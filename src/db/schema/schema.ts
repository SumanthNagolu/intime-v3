import { pgTable, index, foreignKey, unique, pgPolicy, uuid, integer, timestamp, text, jsonb, boolean, check, numeric, date, doublePrecision, type AnyPgColumn, vector, time, bigint, varchar, uniqueIndex, inet, char, interval, primaryKey, pgMaterializedView, pgView, pgSequence, pgEnum } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"

export const activityDirection = pgEnum("activity_direction", ['inbound', 'outbound'])
export const activityOutcome = pgEnum("activity_outcome", ['positive', 'neutral', 'negative'])
export const activityPriority = pgEnum("activity_priority", ['low', 'medium', 'high', 'urgent'])
export const activityStatus = pgEnum("activity_status", ['scheduled', 'open', 'in_progress', 'completed', 'skipped', 'cancelled'])
export const activityTypeEnum = pgEnum("activity_type_enum", ['email', 'call', 'meeting', 'note', 'linkedin_message', 'task', 'follow_up', 'reminder'])
export const approvalStatus = pgEnum("approval_status", ['pending', 'approved', 'rejected', 'delegated', 'escalated'])
export const benchMarketingStatus = pgEnum("bench_marketing_status", ['draft', 'active', 'paused', 'archived'])
export const benchStatus = pgEnum("bench_status", ['onboarding', 'available', 'marketing', 'interviewing', 'placed', 'inactive'])
export const benchType = pgEnum("bench_type", ['w2_internal', 'w2_vendor', '1099', 'c2c'])
export const benefitStatus = pgEnum("benefit_status", ['pending', 'active', 'terminated'])
export const benefitType = pgEnum("benefit_type", ['health', 'dental', 'vision', '401k', 'life', 'disability', 'hsa', 'fsa'])
export const companyCategory = pgEnum("company_category", ['client', 'vendor', 'partner', 'prospect'])
export const companyNoteType = pgEnum("company_note_type", ['general', 'meeting', 'call', 'strategy', 'warning', 'opportunity', 'competitive_intel'])
export const companyRelationshipCategory = pgEnum("company_relationship_category", ['parent_child', 'msp_client', 'prime_sub', 'referral_partner', 'competitor', 'affiliate', 'merger_acquisition'])
export const companyRelationshipType = pgEnum("company_relationship_type", ['direct_client', 'msp_client', 'prime_vendor', 'sub_vendor', 'implementation_partner', 'referral_partner', 'competitor'])
export const companySegment = pgEnum("company_segment", ['enterprise', 'mid_market', 'smb', 'startup'])
export const companyStatus = pgEnum("company_status", ['active', 'inactive', 'on_hold', 'churned', 'do_not_use', 'pending_approval'])
export const companyTeamRole = pgEnum("company_team_role", ['owner', 'account_manager', 'recruiter', 'sales', 'coordinator', 'executive_sponsor', 'viewer'])
export const companyTier = pgEnum("company_tier", ['strategic', 'preferred', 'standard', 'transactional'])
export const companyVendorType = pgEnum("company_vendor_type", ['direct_client', 'prime_vendor', 'sub_vendor', 'msp', 'vms_provider', 'talent_supplier', 'referral_source'])
export const complianceAppliesTo = pgEnum("compliance_applies_to", ['all', 'fte', 'contractor'])
export const complianceFrequency = pgEnum("compliance_frequency", ['once', 'annual', 'quarterly', 'monthly'])
export const complianceItemStatus = pgEnum("compliance_item_status", ['pending', 'received', 'under_review', 'verified', 'expiring', 'expired', 'rejected', 'waived'])
export const compliancePriority = pgEnum("compliance_priority", ['critical', 'high', 'medium', 'low'])
export const complianceStatus = pgEnum("compliance_status", ['pending', 'completed', 'overdue', 'exempt'])
export const complianceType = pgEnum("compliance_type", ['federal', 'state', 'local'])
export const contactDecisionAuthority = pgEnum("contact_decision_authority", ['decision_maker', 'influencer', 'champion', 'gatekeeper', 'end_user', 'budget_holder', 'technical_evaluator', 'procurement'])
export const contractStatus = pgEnum("contract_status", ['draft', 'in_review', 'pending_signature', 'active', 'expired', 'terminated', 'superseded'])
export const contractType = pgEnum("contract_type", ['msa', 'sow', 'nda', 'amendment', 'addendum', 'rate_agreement', 'referral_agreement', 'subcontract', 'other'])
export const coverageLevel = pgEnum("coverage_level", ['employee', 'employee_spouse', 'employee_children', 'family'])
export const documentStatus = pgEnum("document_status", ['pending', 'approved', 'expired', 'rejected'])
export const documentType = pgEnum("document_type", ['offer_letter', 'contract', 'i9', 'w4', 'tax_form', 'nda', 'handbook_ack', 'performance_review', 'termination', 'other'])
export const employmentStatus = pgEnum("employment_status", ['onboarding', 'active', 'on_leave', 'terminated'])
export const employmentType = pgEnum("employment_type", ['fte', 'contractor', 'intern', 'part_time'])
export const enrollmentStatus = pgEnum("enrollment_status", ['pending', 'active', 'completed', 'dropped', 'expired'])
export const eventCategory = pgEnum("event_category", ['security', 'data', 'system', 'integration', 'workflow'])
export const eventSeverity = pgEnum("event_severity", ['debug', 'info', 'warning', 'error', 'critical'])
export const feedbackType = pgEnum("feedback_type", ['strength', 'improvement', 'comment'])
export const goalStatus = pgEnum("goal_status", ['not_started', 'in_progress', 'completed', 'cancelled'])
export const graduateCandidateStatus = pgEnum("graduate_candidate_status", ['pending_review', 'bench_candidate', 'placed', 'opted_out', 'not_qualified'])
export const historyChangeType = pgEnum("history_change_type", ['status_change', 'stage_change', 'owner_change', 'assignment_change', 'score_change', 'priority_change', 'category_change', 'workflow_step', 'custom'])
export const i9Status = pgEnum("i9_status", ['pending', 'section1_complete', 'completed', 'expired'])
export const immigrationCaseStatus = pgEnum("immigration_case_status", ['not_started', 'in_progress', 'rfe', 'approved', 'denied', 'withdrawn'])
export const immigrationCaseType = pgEnum("immigration_case_type", ['h1b_transfer', 'h1b_extension', 'h1b_amendment', 'gc_perm', 'gc_i140', 'gc_i485', 'opt_extension', 'tn_renewal', 'l1_extension'])
export const invoiceStatus = pgEnum("invoice_status", ['draft', 'pending_approval', 'approved', 'sent', 'viewed', 'partially_paid', 'paid', 'overdue', 'disputed', 'void', 'written_off'])
export const invoiceType = pgEnum("invoice_type", ['standard', 'fixed_fee', 'retainer', 'milestone', 'credit_note', 'final'])
export const jobOrderPriority = pgEnum("job_order_priority", ['low', 'medium', 'high', 'urgent'])
export const jobOrderSource = pgEnum("job_order_source", ['email', 'portal', 'call', 'referral'])
export const jobOrderStatus = pgEnum("job_order_status", ['new', 'working', 'filled', 'closed', 'on_hold'])
export const leaderboardScope = pgEnum("leaderboard_scope", ['org', 'department', 'course'])
export const leaderboardType = pgEnum("leaderboard_type", ['weekly', 'monthly', 'all_time'])
export const marketingStatus = pgEnum("marketing_status", ['draft', 'active', 'paused', 'archived'])
export const metricPeriodType = pgEnum("metric_period_type", ['daily', 'weekly', 'monthly', 'quarterly', 'yearly'])
export const noteType = pgEnum("note_type", ['general', 'meeting', 'call', 'strategy', 'warning', 'opportunity', 'competitive_intel', 'internal', 'important', 'reminder'])
export const noteVisibility = pgEnum("note_visibility", ['private', 'team', 'organization'])
export const onboardingStatus = pgEnum("onboarding_status", ['not_started', 'in_progress', 'completed', 'cancelled'])
export const organizationTier = pgEnum("organization_tier", ['starter', 'growth', 'enterprise'])
export const pathStatus = pgEnum("path_status", ['draft', 'published', 'archived'])
export const payPeriodStatus = pgEnum("pay_period_status", ['upcoming', 'active', 'processing', 'completed', 'void'])
export const payRunStatus = pgEnum("pay_run_status", ['draft', 'calculating', 'pending_approval', 'approved', 'submitted', 'processing', 'completed', 'void'])
export const payRunType = pgEnum("pay_run_type", ['regular', 'off_cycle', 'bonus', 'final', 'correction'])
export const payType = pgEnum("pay_type", ['w2', '1099', 'corp_to_corp'])
export const performanceGoalCategory = pgEnum("performance_goal_category", ['business', 'development', 'behavioral'])
export const podMemberRole = pgEnum("pod_member_role", ['senior', 'junior'])
export const rateCardStatus = pgEnum("rate_card_status", ['draft', 'pending_approval', 'active', 'expired', 'superseded'])
export const rateCardType = pgEnum("rate_card_type", ['standard', 'msp', 'vms', 'preferred', 'custom'])
export const rateUnit = pgEnum("rate_unit", ['hourly', 'daily', 'weekly', 'monthly', 'annual', 'fixed', 'retainer', 'project'])
export const relationship = pgEnum("relationship", ['spouse', 'child', 'domestic_partner', 'other'])
export const salaryType = pgEnum("salary_type", ['hourly', 'annual'])
export const signatoryStatus = pgEnum("signatory_status", ['pending', 'viewed', 'signed', 'declined', 'expired'])
export const skillCategory = pgEnum("skill_category", ['programming_language', 'framework', 'library', 'tool', 'platform', 'database', 'cloud', 'methodology', 'soft_skill', 'domain', 'certification_skill'])
export const skillDomain = pgEnum("skill_domain", ['technology', 'business', 'creative', 'healthcare', 'finance', 'legal', 'general'])
export const skillLevel = pgEnum("skill_level", ['beginner', 'intermediate', 'advanced'])
export const streakTypeEnum = pgEnum("streak_type_enum", ['daily_login', 'daily_learning', 'weekly_completion'])
export const taskCategory = pgEnum("task_category", ['paperwork', 'it_setup', 'training', 'orientation', 'other'])
export const taskStatus = pgEnum("task_status", ['pending', 'completed', 'skipped'])
export const timeOffStatus = pgEnum("time_off_status", ['pending', 'approved', 'denied', 'cancelled'])
export const timeOffType = pgEnum("time_off_type", ['pto', 'sick', 'personal', 'bereavement', 'jury_duty', 'parental', 'unpaid'])
export const timesheetPeriodType = pgEnum("timesheet_period_type", ['weekly', 'bi_weekly', 'semi_monthly', 'monthly'])
export const timesheetStatus = pgEnum("timesheet_status", ['draft', 'submitted', 'pending_client_approval', 'client_approved', 'client_rejected', 'pending_internal_approval', 'internal_approved', 'internal_rejected', 'approved', 'processed', 'void'])
export const vendorTier = pgEnum("vendor_tier", ['preferred', 'standard', 'new'])
export const vendorType = pgEnum("vendor_type", ['direct_client', 'prime_vendor', 'sub_vendor', 'msp', 'vms'])
export const verificationMethod = pgEnum("verification_method", ['self_reported', 'assessment', 'endorsement', 'certification', 'interview', 'resume_parsed'])
export const visaAlertLevel = pgEnum("visa_alert_level", ['green', 'yellow', 'orange', 'red', 'black'])
export const visaType = pgEnum("visa_type", ['usc', 'green_card', 'gc_ead', 'h1b', 'h1b_transfer', 'h4_ead', 'l1a', 'l1b', 'l2_ead', 'opt', 'opt_stem', 'cpt', 'tn', 'e3', 'o1', 'canada_citizen', 'canada_pr', 'canada_owp', 'canada_cwp', 'canada_pgwp', 'canada_lmia'])
export const workMode = pgEnum("work_mode", ['on_site', 'remote', 'hybrid'])
export const workerType = pgEnum("worker_type", ['employee', 'consultant', 'contractor'])

export const escalationNumberSeq = pgSequence("escalation_number_seq", {  startWith: "1000", increment: "1", minValue: "1", maxValue: "9223372036854775807", cache: "1", cycle: false })
export const activityNumberSeq = pgSequence("activity_number_seq", {  startWith: "1", increment: "1", minValue: "1", maxValue: "9223372036854775807", cache: "1", cycle: false })
export const auditLogsEventIdSeq = pgSequence("audit_logs_event_id_seq", {  startWith: "1", increment: "1", minValue: "1", maxValue: "9223372036854775807", cache: "1", cycle: false })

export const badgeProgress = pgTable("badge_progress", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	badgeId: uuid("badge_id").notNull(),
	currentValue: integer("current_value").default(0),
	targetValue: integer("target_value").notNull(),
	lastUpdated: timestamp("last_updated", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_badge_progress_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.badgeId],
			foreignColumns: [badges.id],
			name: "badge_progress_badge_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "badge_progress_user_id_fkey"
		}).onDelete("cascade"),
	unique("badge_progress_user_id_badge_id_key").on(table.userId, table.badgeId),
	pgPolicy("badge_progress_insert_system", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`true`  }),
	pgPolicy("badge_progress_select_own", { as: "permissive", for: "select", to: ["public"] }),
]);

export const badgeTriggerEvents = pgTable("badge_trigger_events", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	triggerType: text("trigger_type").notNull(),
	eventData: jsonb("event_data").default({}),
	processed: boolean().default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_badge_trigger_events_processed").using("btree", table.processed.asc().nullsLast().op("bool_ops")).where(sql`(processed = false)`),
	index("idx_badge_trigger_events_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "badge_trigger_events_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("badge_trigger_events_insert_system", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`true`  }),
]);

export const paymentTransactions = pgTable("payment_transactions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	enrollmentId: uuid("enrollment_id"),
	stripePaymentIntentId: text("stripe_payment_intent_id"),
	stripeInvoiceId: text("stripe_invoice_id"),
	stripeCustomerId: text("stripe_customer_id"),
	amount: numeric({ precision: 10, scale:  2 }).notNull(),
	currency: text().default('usd'),
	status: text().notNull(),
	paymentMethodType: text("payment_method_type"),
	metadata: jsonb().default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_payment_transactions_created_at").using("btree", table.createdAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_payment_transactions_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_payment_transactions_stripe_pi").using("btree", table.stripePaymentIntentId.asc().nullsLast().op("text_ops")),
	index("idx_payment_transactions_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.enrollmentId],
			foreignColumns: [studentEnrollments.id],
			name: "payment_transactions_enrollment_id_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "payment_transactions_user_id_fkey"
		}),
	pgPolicy("payment_transactions_admin_read", { as: "permissive", for: "select", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM (user_roles ur
     JOIN roles r ON ((r.id = ur.role_id)))
  WHERE ((ur.user_id = auth.uid()) AND (r.name = ANY (ARRAY['admin'::text, 'super_admin'::text])))))` }),
	pgPolicy("payment_transactions_own_read", { as: "permissive", for: "select", to: ["public"] }),
	check("payment_transactions_status_check", sql`status = ANY (ARRAY['succeeded'::text, 'pending'::text, 'failed'::text, 'refunded'::text])`),
]);

export const commissions = pgTable("commissions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	dealId: uuid("deal_id").notNull(),
	placementId: uuid("placement_id"),
	userId: uuid("user_id").notNull(),
	dealValue: numeric("deal_value", { precision: 12, scale:  2 }).notNull(),
	grossMargin: numeric("gross_margin", { precision: 12, scale:  2 }),
	marginPercentage: numeric("margin_percentage", { precision: 5, scale:  2 }).default('20.00'),
	commissionPercentage: numeric("commission_percentage", { precision: 5, scale:  2 }).default('5.00'),
	projectedCommission: numeric("projected_commission", { precision: 12, scale:  2 }).notNull(),
	actualCommission: numeric("actual_commission", { precision: 12, scale:  2 }),
	commissionType: text("commission_type").default('deal_close').notNull(),
	status: text().default('pending').notNull(),
	paymentSchedule: text("payment_schedule").default('monthly'),
	paymentPeriodStart: date("payment_period_start"),
	paymentPeriodEnd: date("payment_period_end"),
	activatedAt: timestamp("activated_at", { withTimezone: true, mode: 'string' }),
	paidAt: timestamp("paid_at", { withTimezone: true, mode: 'string' }),
	cancelledAt: timestamp("cancelled_at", { withTimezone: true, mode: 'string' }),
	cancelledReason: text("cancelled_reason"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_commissions_deal_id").using("btree", table.dealId.asc().nullsLast().op("uuid_ops")),
	index("idx_commissions_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_commissions_payment_period").using("btree", table.paymentPeriodStart.asc().nullsLast().op("date_ops"), table.paymentPeriodEnd.asc().nullsLast().op("date_ops")),
	index("idx_commissions_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_commissions_type").using("btree", table.commissionType.asc().nullsLast().op("text_ops")),
	index("idx_commissions_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	index("idx_commissions_user_status").using("btree", table.userId.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "commissions_created_by_fkey"
		}),
	foreignKey({
			columns: [table.dealId],
			foreignColumns: [deals.id],
			name: "commissions_deal_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "commissions_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "commissions_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("commissions_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid())))` }),
	pgPolicy("commissions_user_select", { as: "permissive", for: "select", to: ["public"] }),
	check("commissions_commission_type_check", sql`commission_type = ANY (ARRAY['deal_close'::text, 'placement'::text, 'renewal'::text, 'expansion'::text])`),
	check("commissions_payment_schedule_check", sql`payment_schedule = ANY (ARRAY['one_time'::text, 'monthly'::text, 'quarterly'::text])`),
	check("commissions_status_check", sql`status = ANY (ARRAY['pending'::text, 'active'::text, 'paid'::text, 'cancelled'::text, 'clawback'::text])`),
]);

export const commissionPayments = pgTable("commission_payments", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	commissionId: uuid("commission_id").notNull(),
	amount: numeric({ precision: 12, scale:  2 }).notNull(),
	paymentDate: date("payment_date").notNull(),
	paymentMethod: text("payment_method"),
	referenceNumber: text("reference_number"),
	periodStart: date("period_start"),
	periodEnd: date("period_end"),
	periodLabel: text("period_label"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_commission_payments_commission_id").using("btree", table.commissionId.asc().nullsLast().op("uuid_ops")),
	index("idx_commission_payments_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_commission_payments_payment_date").using("btree", table.paymentDate.asc().nullsLast().op("date_ops")),
	foreignKey({
			columns: [table.commissionId],
			foreignColumns: [commissions.id],
			name: "commission_payments_commission_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "commission_payments_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "commission_payments_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("commission_payments_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid())))` }),
]);

export const productivityReports = pgTable("productivity_reports", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	date: date().notNull(),
	summary: text().notNull(),
	productiveHours: doublePrecision("productive_hours").notNull(),
	topActivities: jsonb("top_activities").default([]).notNull(),
	insights: jsonb().default([]).notNull(),
	recommendations: jsonb().default([]).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_productivity_reports_date").using("btree", table.date.desc().nullsFirst().op("date_ops")),
	index("idx_productivity_reports_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	index("idx_productivity_reports_user_date").using("btree", table.userId.asc().nullsLast().op("date_ops"), table.date.desc().nullsFirst().op("date_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "productivity_reports_user_id_fkey"
		}).onDelete("cascade"),
	unique("productivity_reports_user_id_date_key").on(table.userId, table.date),
	pgPolicy("reports_admin_all", { as: "permissive", for: "select", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM (user_roles ur
     JOIN roles r ON ((ur.role_id = r.id)))
  WHERE ((ur.user_id = auth.uid()) AND (r.name = 'admin'::text))))` }),
	pgPolicy("reports_system_insert", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("reports_system_update", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("reports_user_own", { as: "permissive", for: "select", to: ["public"] }),
]);

export const leads = pgTable("leads", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	leadType: text("lead_type").default('company').notNull(),
	companyName: text("company_name"),
	industry: text(),
	companySize: text("company_size"),
	firstName: text("first_name"),
	lastName: text("last_name"),
	title: text(),
	email: text(),
	phone: text(),
	linkedinUrl: text("linkedin_url"),
	status: text().default('new').notNull(),
	estimatedValue: numeric("estimated_value", { precision: 12, scale:  2 }),
	source: text(),
	sourceCampaignId: uuid("source_campaign_id"),
	ownerId: uuid("owner_id"),
	lastContactedAt: timestamp("last_contacted_at", { withTimezone: true, mode: 'string' }),
	lastResponseAt: timestamp("last_response_at", { withTimezone: true, mode: 'string' }),
	engagementScore: integer("engagement_score"),
	convertedToDealId: uuid("converted_to_deal_id"),
	convertedToAccountId: uuid("converted_to_account_id"),
	convertedAt: timestamp("converted_at", { withTimezone: true, mode: 'string' }),
	lostReason: text("lost_reason"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	companyType: text("company_type"),
	website: text(),
	tier: text(),
	companyDescription: text("company_description"),
	decisionAuthority: text("decision_authority"),
	preferredContactMethod: text("preferred_contact_method").default('email'),
	accountId: uuid("account_id"),
	notes: text(),
	// TODO: failed to parse database type 'tsvector'
	searchVector: unknown("search_vector"),
	bantBudget: integer("bant_budget").default(0),
	bantAuthority: integer("bant_authority").default(0),
	bantNeed: integer("bant_need").default(0),
	bantTimeline: integer("bant_timeline").default(0),
	bantBudgetNotes: text("bant_budget_notes"),
	bantAuthorityNotes: text("bant_authority_notes"),
	bantNeedNotes: text("bant_need_notes"),
	bantTimelineNotes: text("bant_timeline_notes"),
	bantTotalScore: integer("bant_total_score").generatedAlwaysAs(sql`(((COALESCE(bant_budget, 0) + COALESCE(bant_authority, 0)) + COALESCE(bant_need, 0)) + COALESCE(bant_timeline, 0))`),
	budgetStatus: text("budget_status"),
	estimatedMonthlySpend: numeric("estimated_monthly_spend", { precision: 12, scale:  2 }),
	authorityLevel: text("authority_level"),
	businessNeed: text("business_need"),
	urgency: text(),
	targetStartDate: date("target_start_date"),
	positionsCount: integer("positions_count").default(1),
	skillsNeeded: text("skills_needed").array(),
	contractTypes: text("contract_types").array(),
	qualificationResult: text("qualification_result"),
	qualificationNotes: text("qualification_notes"),
	qualifiedAt: timestamp("qualified_at", { withTimezone: true, mode: 'string' }),
	qualifiedBy: uuid("qualified_by"),
	campaignId: uuid("campaign_id"),
	campaignProspectId: uuid("campaign_prospect_id"),
	crossPillarType: text("cross_pillar_type"),
	targetPillar: text("target_pillar"),
	handoffNotes: text("handoff_notes"),
	interestLevel: text("interest_level"),
	hiringNeeds: text("hiring_needs"),
	painPoints: text("pain_points"),
	budgetNotes: text("budget_notes"),
	authorityStatus: text("authority_status"),
	authorityNotes: text("authority_notes"),
	needStatus: text("need_status"),
	needNotes: text("need_notes"),
	timelineStatus: text("timeline_status"),
	timelineNotes: text("timeline_notes"),
	nextAction: text("next_action"),
	nextActionDate: date("next_action_date"),
	leadScore: integer("lead_score"),
	contactId: uuid("contact_id"),
	companyId: uuid("company_id"),
	convertedToCompanyId: uuid("converted_to_company_id"),
}, (table) => [
	index("idx_leads_account_id").using("btree", table.accountId.asc().nullsLast().op("uuid_ops")),
	index("idx_leads_bant_status").using("btree", table.bantTotalScore.asc().nullsLast().op("text_ops"), table.status.asc().nullsLast().op("int4_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_leads_bant_total").using("btree", table.bantTotalScore.asc().nullsLast().op("int4_ops")),
	index("idx_leads_campaign").using("btree", table.campaignId.asc().nullsLast().op("uuid_ops")),
	index("idx_leads_campaign_org").using("btree", table.campaignId.asc().nullsLast().op("uuid_ops"), table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_leads_company_id").using("btree", table.companyId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_leads_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_leads_converted_to_company").using("btree", table.convertedToCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`(converted_to_company_id IS NOT NULL)`),
	index("idx_leads_cross_pillar_type").using("btree", table.crossPillarType.asc().nullsLast().op("text_ops")).where(sql`(cross_pillar_type IS NOT NULL)`),
	index("idx_leads_email").using("btree", table.email.asc().nullsLast().op("text_ops")),
	index("idx_leads_interest_level").using("btree", table.interestLevel.asc().nullsLast().op("text_ops")),
	index("idx_leads_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_leads_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_leads_owner").using("btree", table.ownerId.asc().nullsLast().op("uuid_ops")),
	index("idx_leads_owner_id").using("btree", table.ownerId.asc().nullsLast().op("uuid_ops")),
	index("idx_leads_qualification_result").using("btree", table.qualificationResult.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_leads_source").using("btree", table.sourceCampaignId.asc().nullsLast().op("uuid_ops")),
	index("idx_leads_status").using("btree", table.status.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_leads_urgency").using("btree", table.urgency.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.convertedToDealId],
			foreignColumns: [deals.id],
			name: "fk_leads_converted_to_deal"
		}),
	foreignKey({
			columns: [table.campaignId],
			foreignColumns: [campaigns.id],
			name: "leads_campaign_id_fkey"
		}),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "leads_company_id_fkey"
		}),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "leads_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.convertedToCompanyId],
			foreignColumns: [companies.id],
			name: "leads_converted_to_company_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "leads_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "leads_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.ownerId],
			foreignColumns: [userProfiles.id],
			name: "leads_owner_id_fkey"
		}),
	foreignKey({
			columns: [table.qualifiedBy],
			foreignColumns: [userProfiles.id],
			name: "leads_qualified_by_fkey"
		}),
	pgPolicy("leads_employee_insert", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(auth_has_role('employee'::text) OR auth_has_role('admin'::text) OR auth_has_role('ta_specialist'::text))`  }),
	pgPolicy("leads_employee_select", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("leads_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	pgPolicy("leads_owner_update", { as: "permissive", for: "update", to: ["public"] }),
	check("leads_authority_level_check", sql`authority_level = ANY (ARRAY['decision_maker'::text, 'influencer'::text, 'gatekeeper'::text, 'no_authority'::text])`),
	check("leads_bant_authority_check", sql`(bant_authority >= 0) AND (bant_authority <= 25)`),
	check("leads_bant_budget_check", sql`(bant_budget >= 0) AND (bant_budget <= 25)`),
	check("leads_bant_need_check", sql`(bant_need >= 0) AND (bant_need <= 25)`),
	check("leads_bant_timeline_check", sql`(bant_timeline >= 0) AND (bant_timeline <= 25)`),
	check("leads_budget_status_check", sql`budget_status = ANY (ARRAY['confirmed'::text, 'likely'::text, 'unclear'::text, 'no_budget'::text])`),
	check("leads_engagement_score_check", sql`(engagement_score >= 0) AND (engagement_score <= 100)`),
	check("leads_lead_score_check", sql`(lead_score >= 0) AND (lead_score <= 100)`),
	check("leads_positions_count_check", sql`(positions_count >= 1) AND (positions_count <= 100)`),
	check("leads_qualification_result_check", sql`qualification_result = ANY (ARRAY['qualified_convert'::text, 'qualified_nurture'::text, 'not_qualified'::text])`),
	check("leads_urgency_check", sql`urgency = ANY (ARRAY['immediate'::text, 'high'::text, 'medium'::text, 'low'::text])`),
]);

export const generatedResumes = pgTable("generated_resumes", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	userId: uuid("user_id").notNull(),
	targetRole: text("target_role").notNull(),
	resumeText: text("resume_text").notNull(),
	resumePdfPath: text("resume_pdf_path"),
	qualityScore: integer("quality_score"),
	atsKeywords: text("ats_keywords").array(),
	hasQuantifiedAchievements: boolean("has_quantified_achievements").default(false),
	hasActionVerbs: boolean("has_action_verbs").default(false),
	lengthAppropriate: boolean("length_appropriate").default(false),
	noTypos: boolean("no_typos").default(false),
	studentFeedback: text("student_feedback"),
	interviewCount: integer("interview_count").default(0),
	placementAchieved: boolean("placement_achieved").default(false),
	modelUsed: text("model_used"),
	tokensUsed: integer("tokens_used"),
	costUsd: numeric("cost_usd", { precision: 10, scale:  6 }),
	generationLatencyMs: integer("generation_latency_ms"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_resumes_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_resumes_placement").using("btree", table.placementAchieved.asc().nullsLast().op("bool_ops")).where(sql`(placement_achieved = true)`),
	index("idx_resumes_quality").using("btree", table.qualityScore.asc().nullsLast().op("int4_ops")).where(sql`(quality_score IS NOT NULL)`),
	index("idx_resumes_role").using("btree", table.targetRole.asc().nullsLast().op("text_ops")),
	index("idx_resumes_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "generated_resumes_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "generated_resumes_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("resumes_admin_all", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id = auth_user_org_id()) AND user_has_role('org_admin'::text))` }),
	pgPolicy("resumes_trainer_view", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("resumes_user_own", { as: "permissive", for: "all", to: ["public"] }),
	check("generated_resumes_quality_score_check", sql`(quality_score >= 0) AND (quality_score <= 100)`),
]);

export const requisitionEmbeddings = pgTable("requisition_embeddings", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	requisitionId: uuid("requisition_id").notNull(),
	embedding: vector({ dimensions: 1536 }),
	description: text().notNull(),
	requiredSkills: text("required_skills").array(),
	niceToHaveSkills: text("nice_to_have_skills").array(),
	experienceLevel: text("experience_level"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_requisition_embeddings_experience").using("btree", table.experienceLevel.asc().nullsLast().op("text_ops")),
	index("idx_requisition_embeddings_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_requisition_embeddings_skills").using("gin", table.requiredSkills.asc().nullsLast().op("array_ops")),
	index("idx_requisition_embeddings_vector").using("ivfflat", table.embedding.asc().nullsLast().op("vector_cosine_ops")).with({lists: "100"}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "requisition_embeddings_org_id_fkey"
		}).onDelete("cascade"),
	unique("requisition_embeddings_org_id_requisition_id_key").on(table.orgId, table.requisitionId),
	pgPolicy("requisitions_recruiter_all", { as: "permissive", for: "select", to: ["public"], using: sql`((org_id = auth_user_org_id()) AND user_has_role('recruiter'::text))` }),
	pgPolicy("requisitions_service_role", { as: "permissive", for: "all", to: ["public"] }),
	check("requisition_embeddings_experience_level_check", sql`experience_level = ANY (ARRAY['entry'::text, 'mid'::text, 'senior'::text])`),
]);

export const resumeMatches = pgTable("resume_matches", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	requisitionId: uuid("requisition_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	matchScore: integer("match_score"),
	reasoning: text(),
	skillsMatched: text("skills_matched").array(),
	skillsMissing: text("skills_missing").array(),
	skillsScore: integer("skills_score"),
	experienceScore: integer("experience_score"),
	projectScore: integer("project_score"),
	availabilityScore: integer("availability_score"),
	recruiterFeedback: text("recruiter_feedback"),
	isRelevant: boolean("is_relevant"),
	submitted: boolean().default(false),
	interviewScheduled: boolean("interview_scheduled").default(false),
	placementAchieved: boolean("placement_achieved").default(false),
	modelUsed: text("model_used"),
	tokensUsed: integer("tokens_used"),
	costUsd: numeric("cost_usd", { precision: 10, scale:  6 }),
	searchLatencyMs: integer("search_latency_ms"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_matches_candidate").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")),
	index("idx_matches_created").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")),
	index("idx_matches_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_matches_placement").using("btree", table.placementAchieved.asc().nullsLast().op("bool_ops")).where(sql`(placement_achieved = true)`),
	index("idx_matches_relevant").using("btree", table.isRelevant.asc().nullsLast().op("bool_ops")).where(sql`(is_relevant IS NOT NULL)`),
	index("idx_matches_requisition").using("btree", table.requisitionId.asc().nullsLast().op("uuid_ops"), table.matchScore.desc().nullsFirst().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "resume_matches_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("matches_admin_all", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id = auth_user_org_id()) AND user_has_role('org_admin'::text))` }),
	pgPolicy("matches_recruiter_all", { as: "permissive", for: "all", to: ["public"] }),
	check("resume_matches_availability_score_check", sql`(availability_score >= 0) AND (availability_score <= 100)`),
	check("resume_matches_experience_score_check", sql`(experience_score >= 0) AND (experience_score <= 100)`),
	check("resume_matches_match_score_check", sql`(match_score >= 0) AND (match_score <= 100)`),
	check("resume_matches_project_score_check", sql`(project_score >= 0) AND (project_score <= 100)`),
	check("resume_matches_skills_score_check", sql`(skills_score >= 0) AND (skills_score <= 100)`),
]);

export const employeeTwinInteractions = pgTable("employee_twin_interactions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	userId: uuid("user_id").notNull(),
	twinRole: text("twin_role").notNull(),
	interactionType: text("interaction_type").notNull(),
	prompt: text(),
	response: text().notNull(),
	context: jsonb().default({}),
	modelUsed: text("model_used").default('gpt-4o-mini'),
	tokensUsed: integer("tokens_used"),
	costUsd: doublePrecision("cost_usd"),
	latencyMs: integer("latency_ms"),
	wasHelpful: boolean("was_helpful"),
	userFeedback: text("user_feedback"),
	dismissed: boolean().default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_employee_twin_interactions_role").using("btree", table.twinRole.asc().nullsLast().op("text_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_employee_twin_interactions_type").using("btree", table.interactionType.asc().nullsLast().op("text_ops"), table.createdAt.desc().nullsFirst().op("text_ops")),
	index("idx_employee_twin_interactions_user").using("btree", table.userId.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "employee_twin_interactions_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("employee_twin_interactions_user_own", { as: "permissive", for: "all", to: ["public"], using: sql`(user_id = auth.uid())` }),
	check("employee_twin_interactions_interaction_type_check", sql`interaction_type = ANY (ARRAY['morning_briefing'::text, 'suggestion'::text, 'question'::text])`),
	check("employee_twin_interactions_twin_role_check", sql`twin_role = ANY (ARRAY['ceo'::text, 'admin'::text, 'recruiter'::text, 'bench_sales'::text, 'talent_acquisition'::text, 'hr'::text, 'immigration'::text, 'trainer'::text])`),
]);

export const candidateEmbeddings = pgTable("candidate_embeddings", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	embedding: vector({ dimensions: 1536 }),
	resumeText: text("resume_text").notNull(),
	skills: text().array(),
	experienceLevel: text("experience_level"),
	availability: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_candidate_embeddings_availability").using("btree", table.availability.asc().nullsLast().op("text_ops")),
	index("idx_candidate_embeddings_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_candidate_embeddings_experience").using("btree", table.experienceLevel.asc().nullsLast().op("text_ops")),
	index("idx_candidate_embeddings_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_candidate_embeddings_skills").using("gin", table.skills.asc().nullsLast().op("array_ops")),
	index("idx_candidate_embeddings_vector").using("ivfflat", table.embedding.asc().nullsLast().op("vector_cosine_ops")).with({lists: "100"}),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidate_embeddings_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "candidate_embeddings_org_id_fkey"
		}).onDelete("cascade"),
	unique("candidate_embeddings_org_id_candidate_id_key").on(table.orgId, table.candidateId),
	pgPolicy("embeddings_recruiter_all", { as: "permissive", for: "select", to: ["public"], using: sql`((org_id = auth_user_org_id()) AND user_has_role('recruiter'::text))` }),
	pgPolicy("embeddings_service_role", { as: "permissive", for: "all", to: ["public"] }),
	check("candidate_embeddings_availability_check", sql`availability = ANY (ARRAY['immediate'::text, '2-weeks'::text, '1-month'::text])`),
	check("candidate_embeddings_experience_level_check", sql`experience_level = ANY (ARRAY['entry'::text, 'mid'::text, 'senior'::text])`),
]);

export const leadSourcingCredits = pgTable("lead_sourcing_credits", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	leadId: uuid("lead_id").notNull(),
	sourcedBy: uuid("sourced_by").notNull(),
	sourcePillar: text("source_pillar").notNull(),
	targetPillar: text("target_pillar").notNull(),
	assignedTo: uuid("assigned_to"),
	creditPoints: integer("credit_points").default(10),
	bonusPoints: integer("bonus_points").default(0),
	status: text().default('pending'),
	convertedAt: timestamp("converted_at", { withTimezone: true, mode: 'string' }),
	conversionValue: numeric("conversion_value", { precision: 12, scale:  2 }),
	commissionEarned: numeric("commission_earned", { precision: 12, scale:  2 }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_lead_sourcing_credits_lead").using("btree", table.leadId.asc().nullsLast().op("uuid_ops")),
	index("idx_lead_sourcing_credits_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_lead_sourcing_credits_sourced_by").using("btree", table.sourcedBy.asc().nullsLast().op("uuid_ops")),
	index("idx_lead_sourcing_credits_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_lead_sourcing_credits_target").using("btree", table.targetPillar.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.assignedTo],
			foreignColumns: [userProfiles.id],
			name: "lead_sourcing_credits_assigned_to_fkey"
		}),
	foreignKey({
			columns: [table.leadId],
			foreignColumns: [leads.id],
			name: "lead_sourcing_credits_lead_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "lead_sourcing_credits_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.sourcedBy],
			foreignColumns: [userProfiles.id],
			name: "lead_sourcing_credits_sourced_by_fkey"
		}),
	pgPolicy("lead_sourcing_credits_create", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(auth_has_role('employee'::text) OR auth_has_role('admin'::text) OR auth_has_role('recruiter'::text))`  }),
	pgPolicy("lead_sourcing_credits_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	pgPolicy("lead_sourcing_credits_select", { as: "permissive", for: "select", to: ["public"] }),
]);

export const roles = pgTable("roles", {
	id: uuid().default(sql`uuid_generate_v4()`).primaryKey().notNull(),
	name: text().notNull(),
	displayName: text("display_name").notNull(),
	description: text(),
	parentRoleId: uuid("parent_role_id"),
	hierarchyLevel: integer("hierarchy_level").default(0),
	isSystemRole: boolean("is_system_role").default(false),
	isActive: boolean("is_active").default(true),
	colorCode: text("color_code").default('#6366f1'),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	updatedBy: uuid("updated_by"),
	displayOrder: integer("display_order").default(0),
}, (table) => [
	index("idx_roles_name").using("btree", table.name.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_roles_parent").using("btree", table.parentRoleId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_roles_system").using("btree", table.isSystemRole.asc().nullsLast().op("bool_ops")).where(sql`(is_system_role = true)`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "roles_created_by_fkey"
		}),
	foreignKey({
			columns: [table.parentRoleId],
			foreignColumns: [table.id],
			name: "roles_parent_role_id_fkey"
		}).onDelete("set null"),
	unique("roles_name_key").on(table.name),
	pgPolicy("Everyone can view active roles", { as: "permissive", for: "select", to: ["public"], using: sql`((deleted_at IS NULL) AND (is_active = true))` }),
	pgPolicy("Super admins can manage roles", { as: "permissive", for: "all", to: ["public"] }),
	check("valid_role_name", sql`name ~ '^[a-z_]+$'::text`),
]);

export const twinPreferences = pgTable("twin_preferences", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	enableMorningBriefing: boolean("enable_morning_briefing").default(true),
	morningBriefingTime: time("morning_briefing_time").default('09:00:00'),
	enableProactiveSuggestions: boolean("enable_proactive_suggestions").default(true),
	suggestionFrequency: integer("suggestion_frequency").default(3),
	notifyViaUi: boolean("notify_via_ui").default(true),
	notifyViaSlack: boolean("notify_via_slack").default(false),
	notifyViaEmail: boolean("notify_via_email").default(false),
	useProductivityData: boolean("use_productivity_data").default(true),
	useActivityData: boolean("use_activity_data").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_twin_preferences_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "twin_preferences_user_id_fkey"
		}).onDelete("cascade"),
	unique("twin_preferences_user_id_key").on(table.userId),
	pgPolicy("twin_preferences_user_own", { as: "permissive", for: "all", to: ["public"], using: sql`(user_id = auth.uid())` }),
]);

export const contentAssets = pgTable("content_assets", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	filename: text().notNull(),
	storagePath: text("storage_path").notNull(),
	fileType: text("file_type").notNull(),
	mimeType: text("mime_type").notNull(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	fileSizeBytes: bigint("file_size_bytes", { mode: "number" }).notNull(),
	topicId: uuid("topic_id"),
	lessonId: uuid("lesson_id"),
	cdnUrl: text("cdn_url"),
	isPublic: boolean("is_public").default(false),
	replacedBy: uuid("replaced_by"),
	isCurrent: boolean("is_current").default(true),
	uploadedBy: uuid("uploaded_by"),
	uploadedAt: timestamp("uploaded_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	searchableContent: text("searchable_content"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_content_assets_file_type").using("btree", table.fileType.asc().nullsLast().op("text_ops")),
	index("idx_content_assets_is_current").using("btree", table.isCurrent.asc().nullsLast().op("bool_ops")).where(sql`(is_current = true)`),
	index("idx_content_assets_lesson").using("btree", table.lessonId.asc().nullsLast().op("uuid_ops")),
	index("idx_content_assets_search").using("gin", sql`to_tsvector('english'::regconfig, COALESCE(searchable_content, `),
	index("idx_content_assets_storage_path").using("btree", table.storagePath.asc().nullsLast().op("text_ops")),
	index("idx_content_assets_topic").using("btree", table.topicId.asc().nullsLast().op("uuid_ops")),
	index("idx_content_assets_uploaded_by").using("btree", table.uploadedBy.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.lessonId],
			foreignColumns: [topicLessons.id],
			name: "content_assets_lesson_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.replacedBy],
			foreignColumns: [table.id],
			name: "content_assets_replaced_by_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.topicId],
			foreignColumns: [moduleTopics.id],
			name: "content_assets_topic_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.uploadedBy],
			foreignColumns: [userProfiles.id],
			name: "content_assets_uploaded_by_fkey"
		}).onDelete("set null"),
	unique("content_assets_storage_path_key").on(table.storagePath),
	pgPolicy("Enrolled students view course assets", { as: "permissive", for: "select", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM ((student_enrollments se
     JOIN course_modules cm ON ((cm.course_id = se.course_id)))
     JOIN module_topics mt ON ((mt.module_id = cm.id)))
  WHERE ((mt.id = content_assets.topic_id) AND (se.user_id = auth.uid()) AND (se.status = ANY (ARRAY['active'::text, 'completed'::text])))))` }),
	pgPolicy("Public assets viewable by all", { as: "permissive", for: "select", to: ["public"] }),
	check("content_assets_file_size_bytes_check", sql`file_size_bytes > 0`),
	check("content_assets_file_type_check", sql`file_type = ANY (ARRAY['video'::text, 'pdf'::text, 'image'::text, 'document'::text, 'other'::text])`),
]);

export const videoProgress = pgTable("video_progress", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	topicId: uuid("topic_id").notNull(),
	enrollmentId: uuid("enrollment_id").notNull(),
	lastPositionSeconds: integer("last_position_seconds").default(0).notNull(),
	totalWatchTimeSeconds: integer("total_watch_time_seconds").default(0).notNull(),
	videoDurationSeconds: integer("video_duration_seconds"),
	completionPercentage: integer("completion_percentage").generatedAlwaysAs(sql`
CASE
    WHEN (video_duration_seconds > 0) THEN LEAST(100, ((last_position_seconds * 100) / video_duration_seconds))
    ELSE 0
END`),
	videoUrl: text("video_url"),
	videoProvider: text("video_provider"),
	sessionCount: integer("session_count").default(1).notNull(),
	lastWatchedAt: timestamp("last_watched_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_video_progress_enrollment").using("btree", table.enrollmentId.asc().nullsLast().op("uuid_ops")),
	index("idx_video_progress_topic").using("btree", table.topicId.asc().nullsLast().op("uuid_ops")),
	index("idx_video_progress_updated").using("btree", table.updatedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_video_progress_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.enrollmentId],
			foreignColumns: [studentEnrollments.id],
			name: "video_progress_enrollment_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.topicId],
			foreignColumns: [moduleTopics.id],
			name: "video_progress_topic_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "video_progress_user_id_fkey"
		}).onDelete("cascade"),
	unique("video_progress_user_id_topic_id_key").on(table.userId, table.topicId),
	pgPolicy("video_progress_student_policy", { as: "permissive", for: "all", to: ["public"], using: sql`((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid()))))`, withCheck: sql`((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid()))))`  }),
	check("valid_duration", sql`(video_duration_seconds IS NULL) OR (video_duration_seconds > 0)`),
	check("valid_position", sql`last_position_seconds >= 0`),
	check("valid_provider", sql`video_provider = ANY (ARRAY['vimeo'::text, 'youtube'::text, 'direct'::text, 's3'::text])`),
	check("valid_watch_time", sql`total_watch_time_seconds >= 0`),
]);

export const auditLogRetentionPolicy = pgTable("audit_log_retention_policy", {
	id: uuid().default(sql`uuid_generate_v4()`).primaryKey().notNull(),
	tableName: text("table_name").notNull(),
	retentionMonths: integer("retention_months").default(6).notNull(),
	archiveAfterMonths: integer("archive_after_months"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	unique("audit_log_retention_policy_table_name_key").on(table.tableName),
	pgPolicy("Admins can manage retention policies", { as: "permissive", for: "all", to: ["public"], using: sql`user_is_admin()`, withCheck: sql`user_is_admin()`  }),
	pgPolicy("Everyone can view retention policies", { as: "permissive", for: "select", to: ["public"] }),
	check("valid_archive", sql`(archive_after_months IS NULL) OR (archive_after_months < retention_months)`),
	check("valid_retention", sql`retention_months > 0`),
]);

export const projectTimeline = pgTable("project_timeline", {
	id: uuid().default(sql`uuid_generate_v4()`).primaryKey().notNull(),
	sessionId: varchar("session_id", { length: 50 }).notNull(),
	sessionDate: timestamp("session_date", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	agentType: varchar("agent_type", { length: 50 }),
	agentModel: varchar("agent_model", { length: 100 }),
	duration: varchar({ length: 50 }),
	conversationSummary: text("conversation_summary").notNull(),
	userIntent: text("user_intent"),
	actionsTaken: jsonb("actions_taken").default({"blocked":[],"completed":[],"inProgress":[]}),
	filesChanged: jsonb("files_changed").default({"created":[],"deleted":[],"modified":[]}),
	decisions: jsonb().default([]),
	assumptions: jsonb().default([]),
	results: jsonb().default({"status":"success","metrics":{},"summary":"","artifacts":[]}),
	futureNotes: jsonb("future_notes").default([]),
	relatedCommits: text("related_commits").array(),
	relatedPrs: text("related_prs").array(),
	relatedDocs: text("related_docs").array(),
	tags: text().array(),
	aiGeneratedSummary: text("ai_generated_summary"),
	keyLearnings: text("key_learnings").array(),
	// TODO: failed to parse database type 'tsvector'
	searchVector: unknown("search_vector"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	isArchived: boolean("is_archived").default(false),
	orgId: uuid("org_id").notNull(),
}, (table) => [
	index("idx_project_timeline_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_timeline_agent_type").using("btree", table.agentType.asc().nullsLast().op("text_ops")),
	index("idx_timeline_created_at").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_timeline_not_archived").using("btree", table.isArchived.asc().nullsLast().op("bool_ops")).where(sql`(is_archived = false)`),
	index("idx_timeline_search").using("gin", table.searchVector.asc().nullsLast().op("tsvector_ops")),
	index("idx_timeline_session_date").using("btree", table.sessionDate.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_timeline_session_id").using("btree", table.sessionId.asc().nullsLast().op("text_ops")),
	index("idx_timeline_tags").using("gin", table.tags.asc().nullsLast().op("array_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "project_timeline_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("Admins can view timeline", { as: "permissive", for: "select", to: ["public"], using: sql`user_is_admin()` }),
	pgPolicy("Allow all for authenticated users", { as: "permissive", for: "all", to: ["public"] }),
	pgPolicy("System can insert timeline", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("Users can view timeline in their org", { as: "permissive", for: "select", to: ["public"] }),
]);

export const sessionMetadata = pgTable("session_metadata", {
	id: uuid().default(sql`uuid_generate_v4()`).primaryKey().notNull(),
	sessionId: varchar("session_id", { length: 50 }).notNull(),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }).notNull(),
	endedAt: timestamp("ended_at", { withTimezone: true, mode: 'string' }),
	duration: varchar({ length: 50 }),
	branch: varchar({ length: 100 }),
	commitHash: varchar("commit_hash", { length: 40 }),
	environment: varchar({ length: 20 }),
	filesModified: integer("files_modified").default(0),
	linesAdded: integer("lines_added").default(0),
	linesRemoved: integer("lines_removed").default(0),
	commandsExecuted: integer("commands_executed").default(0),
	overallGoal: text("overall_goal"),
	successfullyCompleted: boolean("successfully_completed").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	orgId: uuid("org_id").notNull(),
}, (table) => [
	index("idx_session_branch").using("btree", table.branch.asc().nullsLast().op("text_ops")),
	index("idx_session_environment").using("btree", table.environment.asc().nullsLast().op("text_ops")),
	index("idx_session_metadata_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_session_started_at").using("btree", table.startedAt.desc().nullsFirst().op("timestamptz_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "session_metadata_org_id_fkey"
		}).onDelete("cascade"),
	unique("session_metadata_session_id_key").on(table.sessionId),
	pgPolicy("Admins can view sessions", { as: "permissive", for: "select", to: ["public"], using: sql`user_is_admin()` }),
	pgPolicy("Allow all for authenticated users", { as: "permissive", for: "all", to: ["public"] }),
	pgPolicy("System can insert sessions", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("Users can view sessions in their org", { as: "permissive", for: "select", to: ["public"] }),
]);

export const campaignDocuments = pgTable("campaign_documents", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	campaignId: uuid("campaign_id").notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	description: text(),
	documentType: text("document_type").default('attachment').notNull(),
	category: text(),
	fileUrl: text("file_url"),
	fileName: text("file_name"),
	fileSize: integer("file_size"),
	mimeType: text("mime_type"),
	usageCount: integer("usage_count").default(0),
	lastUsedAt: timestamp("last_used_at", { withTimezone: true, mode: 'string' }),
	templateVariables: jsonb("template_variables"),
	uploadedBy: uuid("uploaded_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_campaign_documents_campaign").using("btree", table.campaignId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_campaign_documents_campaign_org").using("btree", table.campaignId.asc().nullsLast().op("uuid_ops"), table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_campaign_documents_category").using("btree", table.category.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_campaign_documents_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_campaign_documents_type").using("btree", table.documentType.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.campaignId],
			foreignColumns: [campaigns.id],
			name: "campaign_documents_campaign_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "campaign_documents_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.uploadedBy],
			foreignColumns: [userProfiles.id],
			name: "campaign_documents_uploaded_by_fkey"
		}),
	pgPolicy("campaign_documents_delete", { as: "permissive", for: "delete", to: ["public"], using: sql`(auth_has_role('admin'::text) OR (uploaded_by = auth.uid()))` }),
	pgPolicy("campaign_documents_insert", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("campaign_documents_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	pgPolicy("campaign_documents_select", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("campaign_documents_update", { as: "permissive", for: "update", to: ["public"] }),
]);

export const eventDeliveryLog = pgTable("event_delivery_log", {
	id: uuid().default(sql`uuid_generate_v4()`).primaryKey().notNull(),
	eventId: uuid("event_id").notNull(),
	subscriptionId: uuid("subscription_id").notNull(),
	attemptedAt: timestamp("attempted_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	status: text().notNull(),
	responseCode: integer("response_code"),
	responseBody: text("response_body"),
	errorMessage: text("error_message"),
	durationMs: integer("duration_ms"),
	orgId: uuid("org_id").notNull(),
}, (table) => [
	index("idx_event_delivery_attempted").using("btree", table.attemptedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_event_delivery_event").using("btree", table.eventId.asc().nullsLast().op("uuid_ops")),
	index("idx_event_delivery_log_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_event_delivery_subscription").using("btree", table.subscriptionId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.eventId],
			foreignColumns: [events.id],
			name: "event_delivery_log_event_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "event_delivery_log_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.subscriptionId],
			foreignColumns: [eventSubscriptions.id],
			name: "event_delivery_log_subscription_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("Admins can view delivery logs", { as: "permissive", for: "select", to: ["public"], using: sql`user_is_admin()` }),
	pgPolicy("System can insert delivery logs", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("Users can view delivery logs in their org", { as: "permissive", for: "select", to: ["public"] }),
	check("valid_delivery_status", sql`status = ANY (ARRAY['success'::text, 'failure'::text, 'timeout'::text, 'skipped'::text])`),
]);

export const onboardingChecklist = pgTable("onboarding_checklist", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	completedProfile: boolean("completed_profile").default(false),
	completedProfileAt: timestamp("completed_profile_at", { withTimezone: true, mode: 'string' }),
	enrolledFirstCourse: boolean("enrolled_first_course").default(false),
	enrolledFirstCourseAt: timestamp("enrolled_first_course_at", { withTimezone: true, mode: 'string' }),
	watchedFirstVideo: boolean("watched_first_video").default(false),
	watchedFirstVideoAt: timestamp("watched_first_video_at", { withTimezone: true, mode: 'string' }),
	completedFirstQuiz: boolean("completed_first_quiz").default(false),
	completedFirstQuizAt: timestamp("completed_first_quiz_at", { withTimezone: true, mode: 'string' }),
	joinedCommunity: boolean("joined_community").default(false),
	joinedCommunityAt: timestamp("joined_community_at", { withTimezone: true, mode: 'string' }),
	connectedPaymentMethod: boolean("connected_payment_method").default(false),
	connectedPaymentMethodAt: timestamp("connected_payment_method_at", { withTimezone: true, mode: 'string' }),
	setLearningGoals: boolean("set_learning_goals").default(false),
	setLearningGoalsAt: timestamp("set_learning_goals_at", { withTimezone: true, mode: 'string' }),
	completedOrientation: boolean("completed_orientation").default(false),
	completedOrientationAt: timestamp("completed_orientation_at", { withTimezone: true, mode: 'string' }),
	totalSteps: integer("total_steps").generatedAlwaysAs(sql`8`),
	completedSteps: integer("completed_steps").generatedAlwaysAs(sql`(((((((
CASE
    WHEN completed_profile THEN 1
    ELSE 0
END +
CASE
    WHEN enrolled_first_course THEN 1
    ELSE 0
END) +
CASE
    WHEN watched_first_video THEN 1
    ELSE 0
END) +
CASE
    WHEN completed_first_quiz THEN 1
    ELSE 0
END) +
CASE
    WHEN joined_community THEN 1
    ELSE 0
END) +
CASE
    WHEN connected_payment_method THEN 1
    ELSE 0
END) +
CASE
    WHEN set_learning_goals THEN 1
    ELSE 0
END) +
CASE
    WHEN completed_orientation THEN 1
    ELSE 0
END)`),
	completionPercentage: integer("completion_percentage").generatedAlwaysAs(sql`round(((((((((((
CASE
    WHEN completed_profile THEN 1
    ELSE 0
END +
CASE
    WHEN enrolled_first_course THEN 1
    ELSE 0
END) +
CASE
    WHEN watched_first_video THEN 1
    ELSE 0
END) +
CASE
    WHEN completed_first_quiz THEN 1
    ELSE 0
END) +
CASE
    WHEN joined_community THEN 1
    ELSE 0
END) +
CASE
    WHEN connected_payment_method THEN 1
    ELSE 0
END) +
CASE
    WHEN set_learning_goals THEN 1
    ELSE 0
END) +
CASE
    WHEN completed_orientation THEN 1
    ELSE 0
END))::numeric / (8)::numeric) * (100)::numeric))`),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_onboarding_checklist_completion").using("btree", table.completionPercentage.asc().nullsLast().op("int4_ops")),
	index("idx_onboarding_checklist_incomplete").using("btree", table.userId.asc().nullsLast().op("uuid_ops")).where(sql`(completed_at IS NULL)`),
	index("idx_onboarding_checklist_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "onboarding_checklist_user_id_fkey"
		}).onDelete("cascade"),
	unique("unique_checklist_per_user").on(table.userId),
	pgPolicy("Admins can view all onboarding checklists", { as: "permissive", for: "select", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM (user_roles ur
     JOIN roles r ON ((r.id = ur.role_id)))
  WHERE ((ur.user_id = auth.uid()) AND (r.name = ANY (ARRAY['admin'::text, 'super_admin'::text])))))` }),
	pgPolicy("System can insert onboarding checklist", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("Users can update own onboarding checklist", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("Users can view own onboarding checklist", { as: "permissive", for: "select", to: ["public"] }),
]);

export const aiTest = pgTable("ai_test", {
	id: uuid().defaultRandom().primaryKey().notNull(),
});

export const courses = pgTable("courses", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	slug: text().notNull(),
	title: text().notNull(),
	subtitle: text(),
	description: text().notNull(),
	totalModules: integer("total_modules").default(0).notNull(),
	totalTopics: integer("total_topics").default(0).notNull(),
	estimatedDurationWeeks: integer("estimated_duration_weeks").notNull(),
	priceMonthly: numeric("price_monthly", { precision: 10, scale:  2 }),
	priceOneTime: numeric("price_one_time", { precision: 10, scale:  2 }),
	isIncludedInAllAccess: boolean("is_included_in_all_access").default(true),
	prerequisiteCourseIds: uuid("prerequisite_course_ids").array(),
	skillLevel: text("skill_level"),
	thumbnailUrl: text("thumbnail_url"),
	promoVideoUrl: text("promo_video_url"),
	isPublished: boolean("is_published").default(false),
	isFeatured: boolean("is_featured").default(false),
	createdBy: uuid("created_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_courses_featured").using("btree", table.isFeatured.asc().nullsLast().op("bool_ops")).where(sql`(is_featured = true)`),
	index("idx_courses_published").using("btree", table.isPublished.asc().nullsLast().op("bool_ops")).where(sql`(is_published = true)`),
	index("idx_courses_slug").using("btree", table.slug.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "courses_created_by_fkey"
		}),
	unique("courses_slug_key").on(table.slug),
	check("courses_skill_level_check", sql`skill_level = ANY (ARRAY['beginner'::text, 'intermediate'::text, 'advanced'::text])`),
]);

export const courseModules = pgTable("course_modules", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	courseId: uuid("course_id").notNull(),
	slug: text().notNull(),
	title: text().notNull(),
	description: text(),
	moduleNumber: integer("module_number").notNull(),
	estimatedDurationHours: integer("estimated_duration_hours"),
	prerequisiteModuleIds: uuid("prerequisite_module_ids").array(),
	isPublished: boolean("is_published").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_course_modules_course_id").using("btree", table.courseId.asc().nullsLast().op("uuid_ops")),
	index("idx_course_modules_number").using("btree", table.courseId.asc().nullsLast().op("uuid_ops"), table.moduleNumber.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.courseId],
			foreignColumns: [courses.id],
			name: "course_modules_course_id_fkey"
		}).onDelete("cascade"),
	unique("unique_course_module_number").on(table.courseId, table.moduleNumber),
	unique("unique_course_module_slug").on(table.courseId, table.slug),
]);

export const moduleTopics = pgTable("module_topics", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	moduleId: uuid("module_id").notNull(),
	slug: text().notNull(),
	title: text().notNull(),
	description: text(),
	topicNumber: integer("topic_number").notNull(),
	estimatedDurationMinutes: integer("estimated_duration_minutes"),
	contentType: text("content_type").notNull(),
	prerequisiteTopicIds: uuid("prerequisite_topic_ids").array(),
	isPublished: boolean("is_published").default(false),
	isRequired: boolean("is_required").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_module_topics_module_id").using("btree", table.moduleId.asc().nullsLast().op("uuid_ops")),
	index("idx_module_topics_number").using("btree", table.moduleId.asc().nullsLast().op("uuid_ops"), table.topicNumber.asc().nullsLast().op("uuid_ops")),
	index("idx_module_topics_required").using("btree", table.isRequired.asc().nullsLast().op("bool_ops")).where(sql`(is_required = true)`),
	foreignKey({
			columns: [table.moduleId],
			foreignColumns: [courseModules.id],
			name: "module_topics_module_id_fkey"
		}).onDelete("cascade"),
	unique("unique_module_topic_number").on(table.moduleId, table.topicNumber),
	unique("unique_module_topic_slug").on(table.moduleId, table.slug),
	check("module_topics_content_type_check", sql`content_type = ANY (ARRAY['video'::text, 'reading'::text, 'quiz'::text, 'lab'::text, 'project'::text])`),
]);

export const aiConversations = pgTable("ai_conversations", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	agentType: text("agent_type").notNull(),
	messages: jsonb().default([]).notNull(),
	metadata: jsonb().default({}).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_ai_conversations_agent_type").using("btree", table.agentType.asc().nullsLast().op("text_ops")),
	index("idx_ai_conversations_metadata").using("gin", table.metadata.asc().nullsLast().op("jsonb_ops")),
	index("idx_ai_conversations_updated_at").using("btree", table.updatedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_ai_conversations_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "ai_conversations_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("ai_conversations_admin_all", { as: "permissive", for: "all", to: ["public"], using: sql`user_is_admin()` }),
	pgPolicy("ai_conversations_delete_own", { as: "permissive", for: "delete", to: ["public"] }),
	pgPolicy("ai_conversations_insert_own", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("ai_conversations_select_own", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("ai_conversations_update_own", { as: "permissive", for: "update", to: ["public"] }),
]);

export const aiEmbeddings = pgTable("ai_embeddings", {
	id: text().primaryKey().notNull(),
	content: text().notNull(),
	embedding: vector({ dimensions: 1536 }).notNull(),
	metadata: jsonb().default({}).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_ai_embeddings_metadata").using("gin", table.metadata.asc().nullsLast().op("jsonb_ops")),
	index("idx_ai_embeddings_vector").using("ivfflat", table.embedding.asc().nullsLast().op("vector_cosine_ops")).with({lists: "100"}),
	pgPolicy("ai_embeddings_admin_modify", { as: "permissive", for: "all", to: ["public"], using: sql`user_is_admin()` }),
	pgPolicy("ai_embeddings_select_authenticated", { as: "permissive", for: "select", to: ["public"] }),
]);

export const aiPatterns = pgTable("ai_patterns", {
	id: text().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	patternType: text("pattern_type").notNull(),
	description: text().notNull(),
	occurrenceCount: integer("occurrence_count").default(1).notNull(),
	firstSeen: timestamp("first_seen", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	lastSeen: timestamp("last_seen", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	metadata: jsonb().default({}).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_ai_patterns_last_seen").using("btree", table.lastSeen.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_ai_patterns_type").using("btree", table.patternType.asc().nullsLast().op("text_ops")),
	index("idx_ai_patterns_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "ai_patterns_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("ai_patterns_admin_all", { as: "permissive", for: "all", to: ["public"], using: sql`user_is_admin()` }),
	pgPolicy("ai_patterns_insert_own", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("ai_patterns_select_own", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("ai_patterns_update_own", { as: "permissive", for: "update", to: ["public"] }),
]);

export const aiCostTracking = pgTable("ai_cost_tracking", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	userId: uuid("user_id"),
	provider: text().notNull(),
	model: text().notNull(),
	inputTokens: integer("input_tokens").default(0).notNull(),
	outputTokens: integer("output_tokens").default(0).notNull(),
	costUsd: numeric("cost_usd", { precision: 10, scale:  6 }).default('0.00').notNull(),
	latencyMs: integer("latency_ms").default(0).notNull(),
	metadata: jsonb().default({}).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_ai_cost_tracking_date").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_ai_cost_tracking_model").using("btree", table.model.asc().nullsLast().op("text_ops")),
	index("idx_ai_cost_tracking_org_date").using("btree", table.orgId.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_ai_cost_tracking_provider").using("btree", table.provider.asc().nullsLast().op("text_ops")),
	index("idx_ai_cost_tracking_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "ai_cost_tracking_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "ai_cost_tracking_user_id_fkey"
		}).onDelete("set null"),
	pgPolicy("ai_cost_tracking_insert_own", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`((user_id = auth_user_id()) AND (org_id = auth_user_org_id()))`  }),
	pgPolicy("ai_cost_tracking_select_own", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("ai_cost_tracking_select_platform_admin", { as: "permissive", for: "select", to: ["public"] }),
	check("ai_cost_tracking_cost_positive", sql`cost_usd >= (0)::numeric`),
	check("ai_cost_tracking_latency_positive", sql`latency_ms >= 0`),
	check("ai_cost_tracking_provider_check", sql`provider = ANY (ARRAY['openai'::text, 'anthropic'::text])`),
	check("ai_cost_tracking_tokens_positive", sql`(input_tokens >= 0) AND (output_tokens >= 0)`),
]);

export const aiPrompts = pgTable("ai_prompts", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	name: text().notNull(),
	version: integer().default(1).notNull(),
	category: text().notNull(),
	content: text().notNull(),
	description: text(),
	variables: jsonb().default([]).notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	createdBy: uuid("created_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_ai_prompts_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")).where(sql`(is_active = true)`),
	index("idx_ai_prompts_category").using("btree", table.category.asc().nullsLast().op("text_ops")),
	index("idx_ai_prompts_name").using("btree", table.name.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "ai_prompts_created_by_fkey"
		}),
	unique("ai_prompts_name_version_unique").on(table.name, table.version),
	pgPolicy("ai_prompts_admin_all", { as: "permissive", for: "all", to: ["public"], using: sql`user_is_admin()` }),
	pgPolicy("ai_prompts_read_active", { as: "permissive", for: "select", to: ["public"] }),
	check("ai_prompts_name_check", sql`name ~ '^[a-z0-9_]+$'::text`),
	check("ai_prompts_version_positive", sql`version > 0`),
]);

export const studentProgress = pgTable("student_progress", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	studentId: uuid("student_id").notNull(),
	currentModule: text("current_module").notNull(),
	completedModules: text("completed_modules").array().default([""]).notNull(),
	struggleAreas: text("struggle_areas").array().default([""]).notNull(),
	masteryScore: integer("mastery_score").default(0).notNull(),
	totalInteractions: integer("total_interactions").default(0).notNull(),
	helpfulInteractions: integer("helpful_interactions").default(0).notNull(),
	lastActivityAt: timestamp("last_activity_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	lessonProgress: jsonb("lesson_progress").default({}),
	currentLesson: text("current_lesson"),
	streakCount: integer("streak_count").default(0),
	lastActiveDate: text("last_active_date"),
	readinessIndex: integer("readiness_index").default(0),
}, (table) => [
	index("idx_student_progress_mastery").using("btree", table.masteryScore.desc().nullsFirst().op("int4_ops")),
	index("idx_student_progress_module").using("btree", table.currentModule.asc().nullsLast().op("text_ops")),
	index("idx_student_progress_student").using("btree", table.studentId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.studentId],
			foreignColumns: [userProfiles.id],
			name: "student_progress_student_id_fkey"
		}).onDelete("cascade"),
	unique("student_progress_student_id_key").on(table.studentId),
	pgPolicy("System can manage student progress", { as: "permissive", for: "all", to: ["public"], using: sql`true`, withCheck: sql`true`  }),
	pgPolicy("student_progress_select_platform_admin", { as: "permissive", for: "select", to: ["public"] }),
	check("student_progress_mastery_score_check", sql`(mastery_score >= 0) AND (mastery_score <= 100)`),
]);

export const aiAgentInteractions = pgTable("ai_agent_interactions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	userId: uuid("user_id"),
	agentName: text("agent_name").notNull(),
	interactionType: text("interaction_type").notNull(),
	input: text(),
	output: text(),
	modelUsed: text("model_used"),
	tokensUsed: integer("tokens_used").default(0),
	costUsd: numeric("cost_usd", { precision: 10, scale:  6 }).default('0.00'),
	latencyMs: integer("latency_ms").default(0),
	success: boolean().default(true).notNull(),
	errorMessage: text("error_message"),
	metadata: jsonb().default({}).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_ai_agent_interactions_agent").using("btree", table.agentName.asc().nullsLast().op("text_ops")),
	index("idx_ai_agent_interactions_org_date").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")),
	index("idx_ai_agent_interactions_success").using("btree", table.success.asc().nullsLast().op("bool_ops")).where(sql`(success = false)`),
	index("idx_ai_agent_interactions_type").using("btree", table.interactionType.asc().nullsLast().op("text_ops")),
	index("idx_ai_agent_interactions_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "ai_agent_interactions_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "ai_agent_interactions_user_id_fkey"
		}).onDelete("set null"),
	pgPolicy("ai_agent_interactions_insert_own", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`((user_id = auth_user_id()) AND (org_id = auth_user_org_id()))`  }),
	pgPolicy("ai_agent_interactions_select_own", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("ai_agent_interactions_select_platform_admin", { as: "permissive", for: "select", to: ["public"] }),
	check("ai_agent_interactions_cost_positive", sql`cost_usd >= (0)::numeric`),
	check("ai_agent_interactions_latency_positive", sql`latency_ms >= 0`),
	check("ai_agent_interactions_tokens_positive", sql`tokens_used >= 0`),
]);

export const guruInteractions = pgTable("guru_interactions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	studentId: uuid("student_id").notNull(),
	agentType: text("agent_type").notNull(),
	conversationId: text("conversation_id"),
	input: jsonb().notNull(),
	output: jsonb().notNull(),
	wasHelpful: boolean("was_helpful"),
	userFeedback: text("user_feedback"),
	modelUsed: text("model_used").notNull(),
	tokensUsed: integer("tokens_used").default(0).notNull(),
	costUsd: numeric("cost_usd", { precision: 10, scale:  6 }).default('0').notNull(),
	latencyMs: integer("latency_ms").default(0).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_guru_interactions_agent_type").using("btree", table.agentType.asc().nullsLast().op("text_ops"), table.createdAt.desc().nullsFirst().op("text_ops")),
	index("idx_guru_interactions_conversation").using("btree", table.conversationId.asc().nullsLast().op("text_ops")).where(sql`(conversation_id IS NOT NULL)`),
	index("idx_guru_interactions_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")),
	index("idx_guru_interactions_student").using("btree", table.studentId.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "guru_interactions_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.studentId],
			foreignColumns: [userProfiles.id],
			name: "guru_interactions_student_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("Students can update own feedback", { as: "permissive", for: "update", to: ["public"], using: sql`(student_id = auth.uid())`, withCheck: sql`(student_id = auth.uid())`  }),
	pgPolicy("System can insert guru interactions", { as: "permissive", for: "insert", to: ["public"] }),
	check("guru_interactions_agent_type_check", sql`agent_type = ANY (ARRAY['code_mentor'::text, 'resume_builder'::text, 'project_planner'::text, 'interview_coach'::text])`),
	check("guru_interactions_cost_check", sql`cost_usd >= (0)::numeric`),
	check("guru_interactions_tokens_check", sql`tokens_used >= 0`),
]);

export const resumeVersions = pgTable("resume_versions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	studentId: uuid("student_id").notNull(),
	version: integer().default(1).notNull(),
	format: text().notNull(),
	content: jsonb().notNull(),
	atsScore: integer("ats_score").default(0).notNull(),
	keywordMatches: text("keyword_matches").array().default([""]).notNull(),
	targetJobDescription: text("target_job_description"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_resume_versions_ats_score").using("btree", table.atsScore.desc().nullsFirst().op("int4_ops")),
	index("idx_resume_versions_format").using("btree", table.format.asc().nullsLast().op("text_ops")),
	index("idx_resume_versions_student").using("btree", table.studentId.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	foreignKey({
			columns: [table.studentId],
			foreignColumns: [userProfiles.id],
			name: "resume_versions_student_id_fkey"
		}).onDelete("cascade"),
	unique("resume_versions_student_id_version_key").on(table.studentId, table.version),
	pgPolicy("Students can insert own resumes", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(student_id = auth.uid())`  }),
	pgPolicy("Students can update own resumes", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("Students can view own resumes", { as: "permissive", for: "select", to: ["public"] }),
	check("resume_versions_ats_score_check", sql`(ats_score >= 0) AND (ats_score <= 100)`),
	check("resume_versions_format_check", sql`format = ANY (ARRAY['pdf'::text, 'docx'::text, 'linkedin'::text, 'json'::text])`),
]);

export const interviewSessions = pgTable("interview_sessions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	studentId: uuid("student_id").notNull(),
	interviewType: text("interview_type").notNull(),
	guidewireModule: text("guidewire_module"),
	questions: jsonb().default([]).notNull(),
	averageScore: numeric("average_score", { precision: 4, scale:  2 }).default('0').notNull(),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	duration: integer(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_interview_sessions_module").using("btree", table.guidewireModule.asc().nullsLast().op("text_ops")).where(sql`(guidewire_module IS NOT NULL)`),
	index("idx_interview_sessions_score").using("btree", table.averageScore.desc().nullsFirst().op("numeric_ops")),
	index("idx_interview_sessions_student").using("btree", table.studentId.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")),
	index("idx_interview_sessions_type").using("btree", table.interviewType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.studentId],
			foreignColumns: [userProfiles.id],
			name: "interview_sessions_student_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("Students can insert own interview sessions", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(student_id = auth.uid())`  }),
	pgPolicy("Students can update own interview sessions", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("Students can view own interview sessions", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("interview_sessions_select_platform_admin", { as: "permissive", for: "select", to: ["public"] }),
	check("interview_sessions_average_score_check", sql`(average_score >= (0)::numeric) AND (average_score <= (10)::numeric)`),
	check("interview_sessions_interview_type_check", sql`interview_type = ANY (ARRAY['technical'::text, 'behavioral'::text, 'mixed'::text])`),
]);

export const employeeScreenshots = pgTable("employee_screenshots", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	filename: text().notNull(),
	fileSize: integer("file_size").notNull(),
	storageBucket: text("storage_bucket").default('employee-screenshots'),
	capturedAt: timestamp("captured_at", { withTimezone: true, mode: 'string' }).notNull(),
	machineName: text("machine_name"),
	osType: text("os_type"),
	activeWindowTitle: text("active_window_title"),
	analyzed: boolean().default(false),
	activityCategory: text("activity_category"),
	confidence: doublePrecision(),
	analyzedAt: timestamp("analyzed_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_screenshots_analyzed").using("btree", table.analyzed.asc().nullsLast().op("bool_ops")).where(sql`((NOT analyzed) AND (deleted_at IS NULL))`),
	index("idx_screenshots_captured_at").using("btree", table.capturedAt.desc().nullsFirst().op("timestamptz_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_screenshots_category").using("btree", table.activityCategory.asc().nullsLast().op("text_ops")).where(sql`(analyzed = true)`),
	index("idx_screenshots_machine").using("btree", table.machineName.asc().nullsLast().op("text_ops")),
	index("idx_screenshots_user_date").using("btree", table.userId.asc().nullsLast().op("timestamptz_ops"), table.capturedAt.desc().nullsFirst().op("timestamptz_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_screenshots_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "employee_screenshots_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("screenshots_admin_select", { as: "permissive", for: "select", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM (user_roles ur
     JOIN roles r ON ((ur.role_id = r.id)))
  WHERE ((ur.user_id = auth.uid()) AND (r.name = 'admin'::text))))` }),
]);

export const topicLessons = pgTable("topic_lessons", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	topicId: uuid("topic_id").notNull(),
	title: text().notNull(),
	lessonNumber: integer("lesson_number").notNull(),
	contentType: text("content_type").notNull(),
	contentUrl: text("content_url"),
	contentMarkdown: text("content_markdown"),
	durationSeconds: integer("duration_seconds"),
	labEnvironmentTemplate: text("lab_environment_template"),
	labInstructionsUrl: text("lab_instructions_url"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_topic_lessons_topic_id").using("btree", table.topicId.asc().nullsLast().op("uuid_ops")),
	index("idx_topic_lessons_type").using("btree", table.contentType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.topicId],
			foreignColumns: [moduleTopics.id],
			name: "topic_lessons_topic_id_fkey"
		}).onDelete("cascade"),
	unique("unique_topic_lesson_number").on(table.topicId, table.lessonNumber),
	check("topic_lessons_content_type_check", sql`content_type = ANY (ARRAY['video'::text, 'markdown'::text, 'pdf'::text, 'quiz'::text, 'lab'::text, 'external_link'::text])`),
]);

export const topicCompletions = pgTable("topic_completions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	enrollmentId: uuid("enrollment_id").notNull(),
	courseId: uuid("course_id").notNull(),
	moduleId: uuid("module_id").notNull(),
	topicId: uuid("topic_id").notNull(),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	timeSpentSeconds: integer("time_spent_seconds").default(0),
	xpEarned: integer("xp_earned").default(0).notNull(),
	completionSource: text("completion_source").default('manual'),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_topic_completions_completed_at").using("btree", table.completedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_topic_completions_course").using("btree", table.courseId.asc().nullsLast().op("uuid_ops")),
	index("idx_topic_completions_enrollment").using("btree", table.enrollmentId.asc().nullsLast().op("uuid_ops")),
	index("idx_topic_completions_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.courseId],
			foreignColumns: [courses.id],
			name: "topic_completions_course_id_fkey"
		}).onDelete("restrict"),
	foreignKey({
			columns: [table.enrollmentId],
			foreignColumns: [studentEnrollments.id],
			name: "topic_completions_enrollment_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.moduleId],
			foreignColumns: [courseModules.id],
			name: "topic_completions_module_id_fkey"
		}).onDelete("restrict"),
	foreignKey({
			columns: [table.topicId],
			foreignColumns: [moduleTopics.id],
			name: "topic_completions_topic_id_fkey"
		}).onDelete("restrict"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "topic_completions_user_id_fkey"
		}).onDelete("cascade"),
	unique("unique_user_topic_completion").on(table.userId, table.topicId),
	pgPolicy("Users can view their own completions", { as: "permissive", for: "select", to: ["public"], using: sql`(user_id = auth.uid())` }),
	check("topic_completions_completion_source_check", sql`completion_source = ANY (ARRAY['manual'::text, 'auto'::text, 'admin_override'::text])`),
	check("valid_time_spent", sql`time_spent_seconds >= 0`),
	check("valid_xp", sql`xp_earned >= 0`),
]);

export const xpTransactions = pgTable("xp_transactions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	amount: integer().notNull(),
	transactionType: text("transaction_type").notNull(),
	referenceType: text("reference_type"),
	referenceId: uuid("reference_id"),
	description: text(),
	awardedAt: timestamp("awarded_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	awardedBy: uuid("awarded_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_xp_transactions_awarded_at").using("btree", table.awardedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_xp_transactions_created_week").using("btree", table.userId.asc().nullsLast().op("timestamptz_ops"), table.createdAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_xp_transactions_reference").using("btree", table.referenceType.asc().nullsLast().op("uuid_ops"), table.referenceId.asc().nullsLast().op("text_ops")),
	index("idx_xp_transactions_type").using("btree", table.transactionType.asc().nullsLast().op("text_ops")),
	index("idx_xp_transactions_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.awardedBy],
			foreignColumns: [userProfiles.id],
			name: "xp_transactions_awarded_by_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "xp_transactions_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("Users can view their own XP transactions", { as: "permissive", for: "select", to: ["public"], using: sql`(user_id = auth.uid())` }),
	check("xp_transactions_reference_type_check", sql`reference_type = ANY (ARRAY['topic_completion'::text, 'enrollment'::text, 'achievement'::text, 'admin_action'::text])`),
	check("xp_transactions_transaction_type_check", sql`transaction_type = ANY (ARRAY['topic_completion'::text, 'quiz_passed'::text, 'lab_completed'::text, 'project_submitted'::text, 'bonus_achievement'::text, 'penalty'::text, 'adjustment'::text])`),
]);

export const readingProgress = pgTable("reading_progress", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	topicId: uuid("topic_id").notNull(),
	enrollmentId: uuid("enrollment_id").notNull(),
	scrollPercentage: integer("scroll_percentage").default(0).notNull(),
	lastScrollPosition: integer("last_scroll_position").default(0),
	totalReadingTimeSeconds: integer("total_reading_time_seconds").default(0).notNull(),
	currentPage: integer("current_page"),
	totalPages: integer("total_pages"),
	contentType: text("content_type"),
	contentLength: integer("content_length"),
	sessionCount: integer("session_count").default(1).notNull(),
	lastReadAt: timestamp("last_read_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_reading_progress_enrollment").using("btree", table.enrollmentId.asc().nullsLast().op("uuid_ops")),
	index("idx_reading_progress_topic").using("btree", table.topicId.asc().nullsLast().op("uuid_ops")),
	index("idx_reading_progress_updated").using("btree", table.updatedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_reading_progress_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.enrollmentId],
			foreignColumns: [studentEnrollments.id],
			name: "reading_progress_enrollment_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.topicId],
			foreignColumns: [moduleTopics.id],
			name: "reading_progress_topic_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "reading_progress_user_id_fkey"
		}).onDelete("cascade"),
	unique("reading_progress_user_id_topic_id_key").on(table.userId, table.topicId),
	pgPolicy("reading_progress_user_policy", { as: "permissive", for: "all", to: ["public"], using: sql`((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid()))))`, withCheck: sql`((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid()))))`  }),
	check("valid_content_type", sql`content_type = ANY (ARRAY['markdown'::text, 'pdf'::text, 'html'::text])`),
	check("valid_page", sql`(current_page IS NULL) OR (current_page > 0)`),
	check("valid_reading_time", sql`total_reading_time_seconds >= 0`),
	check("valid_scroll_percentage", sql`(scroll_percentage >= 0) AND (scroll_percentage <= 100)`),
	check("valid_scroll_position", sql`last_scroll_position >= 0`),
]);

export const labTemplates = pgTable("lab_templates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	name: text().notNull(),
	description: text(),
	githubTemplateUrl: text("github_template_url").notNull(),
	difficultyLevel: text("difficulty_level"),
	timeLimitMinutes: integer("time_limit_minutes").default(120),
	autoGradingEnabled: boolean("auto_grading_enabled").default(false),
	githubActionsWorkflow: text("github_actions_workflow"),
	requiredSkills: text("required_skills").array(),
	estimatedDurationMinutes: integer("estimated_duration_minutes"),
	createdBy: uuid("created_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	isActive: boolean("is_active").default(true),
}, (table) => [
	index("idx_lab_templates_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")),
	index("idx_lab_templates_difficulty").using("btree", table.difficultyLevel.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "lab_templates_created_by_fkey"
		}),
	unique("lab_templates_github_template_url_key").on(table.githubTemplateUrl),
	pgPolicy("lab_templates_public_read", { as: "permissive", for: "select", to: ["public"], using: sql`(is_active = true)` }),
	check("lab_templates_difficulty_level_check", sql`difficulty_level = ANY (ARRAY['beginner'::text, 'intermediate'::text, 'advanced'::text])`),
]);

export const labInstances = pgTable("lab_instances", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	topicId: uuid("topic_id").notNull(),
	enrollmentId: uuid("enrollment_id").notNull(),
	labTemplateId: uuid("lab_template_id"),
	forkedRepoUrl: text("forked_repo_url").notNull(),
	forkedRepoName: text("forked_repo_name"),
	originalTemplateUrl: text("original_template_url").notNull(),
	status: text().default('active'),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	timeSpentSeconds: integer("time_spent_seconds").default(0),
	lastActivityAt: timestamp("last_activity_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	githubUsername: text("github_username"),
	provisioningMetadata: jsonb("provisioning_metadata"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	uniqueIndex("idx_lab_instances_active_unique").using("btree", table.userId.asc().nullsLast().op("uuid_ops"), table.topicId.asc().nullsLast().op("uuid_ops")).where(sql`(status = 'active'::text)`),
	index("idx_lab_instances_enrollment").using("btree", table.enrollmentId.asc().nullsLast().op("uuid_ops")),
	index("idx_lab_instances_expires").using("btree", table.expiresAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_lab_instances_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_lab_instances_topic").using("btree", table.topicId.asc().nullsLast().op("uuid_ops")),
	index("idx_lab_instances_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.enrollmentId],
			foreignColumns: [studentEnrollments.id],
			name: "lab_instances_enrollment_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.labTemplateId],
			foreignColumns: [labTemplates.id],
			name: "lab_instances_lab_template_id_fkey"
		}),
	foreignKey({
			columns: [table.topicId],
			foreignColumns: [moduleTopics.id],
			name: "lab_instances_topic_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "lab_instances_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("lab_instances_user_policy", { as: "permissive", for: "all", to: ["public"], using: sql`((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid()))))`, withCheck: sql`((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid()))))`  }),
	check("lab_instances_status_check", sql`status = ANY (ARRAY['active'::text, 'submitted'::text, 'expired'::text, 'abandoned'::text, 'completed'::text])`),
	check("valid_time_spent", sql`time_spent_seconds >= 0`),
]);

export const labSubmissions = pgTable("lab_submissions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	topicId: uuid("topic_id").notNull(),
	enrollmentId: uuid("enrollment_id").notNull(),
	labInstanceId: uuid("lab_instance_id").notNull(),
	repositoryUrl: text("repository_url"),
	submissionContent: text("submission_content"),
	submissionFileUrl: text("submission_file_url"),
	commitSha: text("commit_sha"),
	branchName: text("branch_name").default('main'),
	submittedAt: timestamp("submitted_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	status: text().default('pending'),
	autoGradeResult: jsonb("auto_grade_result"),
	autoGradeScore: numeric("auto_grade_score", { precision: 5, scale:  2 }),
	autoGradedAt: timestamp("auto_graded_at", { withTimezone: true, mode: 'string' }),
	manualGradeScore: numeric("manual_grade_score", { precision: 5, scale:  2 }),
	rubricScores: jsonb("rubric_scores"),
	gradedBy: uuid("graded_by"),
	gradedAt: timestamp("graded_at", { withTimezone: true, mode: 'string' }),
	feedback: text(),
	finalScore: numeric("final_score", { precision: 5, scale:  2 }),
	passed: boolean(),
	attemptNumber: integer("attempt_number").default(1),
	previousSubmissionId: uuid("previous_submission_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_lab_submissions_grader").using("btree", table.gradedBy.asc().nullsLast().op("uuid_ops")),
	index("idx_lab_submissions_instance").using("btree", table.labInstanceId.asc().nullsLast().op("uuid_ops")),
	index("idx_lab_submissions_pending").using("btree", table.status.asc().nullsLast().op("text_ops")).where(sql`(status = ANY (ARRAY['pending'::text, 'manual_review'::text]))`),
	index("idx_lab_submissions_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_lab_submissions_topic").using("btree", table.topicId.asc().nullsLast().op("uuid_ops")),
	index("idx_lab_submissions_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.enrollmentId],
			foreignColumns: [studentEnrollments.id],
			name: "lab_submissions_enrollment_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.gradedBy],
			foreignColumns: [userProfiles.id],
			name: "lab_submissions_graded_by_fkey"
		}),
	foreignKey({
			columns: [table.labInstanceId],
			foreignColumns: [labInstances.id],
			name: "lab_submissions_lab_instance_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.previousSubmissionId],
			foreignColumns: [table.id],
			name: "lab_submissions_previous_submission_id_fkey"
		}),
	foreignKey({
			columns: [table.topicId],
			foreignColumns: [moduleTopics.id],
			name: "lab_submissions_topic_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "lab_submissions_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("lab_submissions_user_policy", { as: "permissive", for: "all", to: ["public"], using: sql`((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid()))))`, withCheck: sql`((user_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid()))))`  }),
	check("lab_submissions_status_check", sql`status = ANY (ARRAY['pending'::text, 'grading'::text, 'auto_graded'::text, 'manual_review'::text, 'passed'::text, 'failed'::text])`),
	check("valid_auto_score", sql`(auto_grade_score IS NULL) OR ((auto_grade_score >= (0)::numeric) AND (auto_grade_score <= (100)::numeric))`),
	check("valid_final_score", sql`(final_score IS NULL) OR ((final_score >= (0)::numeric) AND (final_score <= (100)::numeric))`),
	check("valid_manual_score", sql`(manual_grade_score IS NULL) OR ((manual_grade_score >= (0)::numeric) AND (manual_grade_score <= (100)::numeric))`),
]);

export const capstoneSubmissions = pgTable("capstone_submissions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	enrollmentId: uuid("enrollment_id").notNull(),
	courseId: uuid("course_id").notNull(),
	repositoryUrl: text("repository_url").notNull(),
	demoVideoUrl: text("demo_video_url"),
	description: text(),
	submittedAt: timestamp("submitted_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	revisionCount: integer("revision_count").default(0),
	status: text().default('pending'),
	gradedBy: uuid("graded_by"),
	gradedAt: timestamp("graded_at", { withTimezone: true, mode: 'string' }),
	grade: numeric({ precision: 5, scale:  2 }),
	feedback: text(),
	rubricScores: jsonb("rubric_scores"),
	peerReviewCount: integer("peer_review_count").default(0),
	avgPeerRating: numeric("avg_peer_rating", { precision: 3, scale:  2 }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_capstone_submissions_course").using("btree", table.courseId.asc().nullsLast().op("uuid_ops")),
	index("idx_capstone_submissions_enrollment").using("btree", table.enrollmentId.asc().nullsLast().op("uuid_ops")),
	index("idx_capstone_submissions_grader").using("btree", table.gradedBy.asc().nullsLast().op("uuid_ops")),
	index("idx_capstone_submissions_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_capstone_submissions_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.courseId],
			foreignColumns: [courses.id],
			name: "capstone_submissions_course_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.enrollmentId],
			foreignColumns: [studentEnrollments.id],
			name: "capstone_submissions_enrollment_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.gradedBy],
			foreignColumns: [userProfiles.id],
			name: "capstone_submissions_graded_by_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "capstone_submissions_user_id_fkey"
		}).onDelete("cascade"),
	unique("capstone_submissions_enrollment_id_revision_count_key").on(table.enrollmentId, table.revisionCount),
	pgPolicy("capstone_submissions_insert_own", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(user_id = auth.uid())`  }),
	pgPolicy("capstone_submissions_select_own", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("capstone_submissions_select_trainer", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("capstone_submissions_update_own", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("capstone_submissions_update_trainer", { as: "permissive", for: "update", to: ["public"] }),
	check("capstone_submissions_avg_peer_rating_check", sql`(avg_peer_rating >= (0)::numeric) AND (avg_peer_rating <= (5)::numeric)`),
	check("capstone_submissions_grade_check", sql`(grade >= (0)::numeric) AND (grade <= (100)::numeric)`),
	check("capstone_submissions_status_check", sql`status = ANY (ARRAY['pending'::text, 'peer_review'::text, 'trainer_review'::text, 'passed'::text, 'failed'::text, 'revision_requested'::text])`),
]);

export const twinEvents = pgTable("twin_events", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	sourceUserId: uuid("source_user_id").notNull(),
	sourceRole: text("source_role").notNull(),
	targetRole: text("target_role"),
	eventType: text("event_type").notNull(),
	payload: jsonb().default({}).notNull(),
	priority: text().default('medium').notNull(),
	processed: boolean().default(false).notNull(),
	processedAt: timestamp("processed_at", { withTimezone: true, mode: 'string' }),
	processedBy: uuid("processed_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }).default(sql`(now() + '7 days'::interval)`),
}, (table) => [
	index("idx_twin_events_org_role").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.targetRole.asc().nullsLast().op("uuid_ops"), table.processed.asc().nullsLast().op("bool_ops")),
	index("idx_twin_events_source").using("btree", table.sourceUserId.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_twin_events_type").using("btree", table.eventType.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_twin_events_unprocessed").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.processed.asc().nullsLast().op("bool_ops"), table.priority.desc().nullsFirst().op("timestamptz_ops"), table.createdAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(processed = false)`),
	foreignKey({
			columns: [table.processedBy],
			foreignColumns: [userProfiles.id],
			name: "twin_events_processed_by_fkey"
		}),
	foreignKey({
			columns: [table.sourceUserId],
			foreignColumns: [userProfiles.id],
			name: "twin_events_source_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("twin_events_org_access", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())))` }),
	check("twin_events_event_type_check", sql`event_type = ANY (ARRAY['placement_complete'::text, 'bench_ending'::text, 'training_graduate'::text, 'deal_closed'::text, 'escalation'::text, 'approval_needed'::text, 'milestone_reached'::text, 'cross_sell_opportunity'::text, 'custom'::text])`),
	check("twin_events_priority_check", sql`priority = ANY (ARRAY['low'::text, 'medium'::text, 'high'::text, 'critical'::text])`),
	check("twin_events_source_role_check", sql`source_role = ANY (ARRAY['ceo'::text, 'admin'::text, 'recruiter'::text, 'bench_sales'::text, 'talent_acquisition'::text, 'hr'::text, 'immigration'::text, 'trainer'::text])`),
	check("twin_events_target_role_check", sql`(target_role IS NULL) OR (target_role = ANY (ARRAY['ceo'::text, 'admin'::text, 'recruiter'::text, 'bench_sales'::text, 'talent_acquisition'::text, 'hr'::text, 'immigration'::text, 'trainer'::text]))`),
]);

export const twinConversations = pgTable("twin_conversations", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	initiatorUserId: uuid("initiator_user_id"),
	initiatorRole: text("initiator_role").notNull(),
	responderRole: text("responder_role").notNull(),
	question: text().notNull(),
	response: text(),
	tokensUsed: integer("tokens_used"),
	costUsd: numeric("cost_usd", { precision: 10, scale:  6 }),
	latencyMs: integer("latency_ms"),
	modelUsed: text("model_used").default('gpt-4o-mini'),
	context: jsonb().default({}),
	status: text().default('completed'),
	errorMessage: text("error_message"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_twin_conversations_initiator").using("btree", table.initiatorRole.asc().nullsLast().op("text_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_twin_conversations_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")),
	index("idx_twin_conversations_responder").using("btree", table.responderRole.asc().nullsLast().op("text_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	foreignKey({
			columns: [table.initiatorUserId],
			foreignColumns: [userProfiles.id],
			name: "twin_conversations_initiator_user_id_fkey"
		}).onDelete("set null"),
	pgPolicy("twin_conversations_org_access", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())))` }),
	check("twin_conversations_initiator_role_check", sql`initiator_role = ANY (ARRAY['ceo'::text, 'admin'::text, 'recruiter'::text, 'bench_sales'::text, 'talent_acquisition'::text, 'hr'::text, 'immigration'::text, 'trainer'::text, 'organization'::text])`),
	check("twin_conversations_responder_role_check", sql`responder_role = ANY (ARRAY['ceo'::text, 'admin'::text, 'recruiter'::text, 'bench_sales'::text, 'talent_acquisition'::text, 'hr'::text, 'immigration'::text, 'trainer'::text, 'organization'::text])`),
	check("twin_conversations_status_check", sql`status = ANY (ARRAY['pending'::text, 'completed'::text, 'failed'::text])`),
]);

export const quizQuestions = pgTable("quiz_questions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	topicId: uuid("topic_id"),
	createdBy: uuid("created_by").notNull(),
	questionText: text("question_text").notNull(),
	questionType: text("question_type").notNull(),
	options: jsonb().notNull(),
	correctAnswers: jsonb("correct_answers").notNull(),
	explanation: text(),
	difficulty: text().default('medium').notNull(),
	points: integer().default(1).notNull(),
	codeLanguage: text("code_language"),
	isPublic: boolean("is_public").default(false).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_quiz_questions_created_by").using("btree", table.createdBy.asc().nullsLast().op("uuid_ops")),
	index("idx_quiz_questions_difficulty").using("btree", table.difficulty.asc().nullsLast().op("text_ops")),
	index("idx_quiz_questions_public").using("btree", table.isPublic.asc().nullsLast().op("bool_ops")).where(sql`(is_public = true)`),
	index("idx_quiz_questions_text_search").using("gin", sql`to_tsvector('english'::regconfig, question_text)`),
	index("idx_quiz_questions_topic").using("btree", table.topicId.asc().nullsLast().op("uuid_ops")),
	index("idx_quiz_questions_type").using("btree", table.questionType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "quiz_questions_created_by_fkey"
		}),
	foreignKey({
			columns: [table.topicId],
			foreignColumns: [moduleTopics.id],
			name: "quiz_questions_topic_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("quiz_questions_admin_all", { as: "permissive", for: "all", to: ["authenticated"], using: sql`true` }),
	pgPolicy("quiz_questions_student_read", { as: "permissive", for: "select", to: ["authenticated"] }),
	check("quiz_questions_difficulty_check", sql`difficulty = ANY (ARRAY['easy'::text, 'medium'::text, 'hard'::text])`),
	check("quiz_questions_points_check", sql`points > 0`),
	check("quiz_questions_question_text_check", sql`length(question_text) >= 10`),
	check("quiz_questions_question_type_check", sql`question_type = ANY (ARRAY['multiple_choice_single'::text, 'multiple_choice_multiple'::text, 'true_false'::text, 'code'::text])`),
]);

export const quizSettings = pgTable("quiz_settings", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	topicId: uuid("topic_id").notNull(),
	randomizeQuestions: boolean("randomize_questions").default(false).notNull(),
	randomizeOptions: boolean("randomize_options").default(false).notNull(),
	passingThreshold: integer("passing_threshold").default(70).notNull(),
	showCorrectAnswers: boolean("show_correct_answers").default(true).notNull(),
	timeLimitMinutes: integer("time_limit_minutes"),
	maxAttempts: integer("max_attempts"),
	allowReview: boolean("allow_review").default(true).notNull(),
	xpReward: integer("xp_reward").default(10).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_quiz_settings_topic").using("btree", table.topicId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.topicId],
			foreignColumns: [moduleTopics.id],
			name: "quiz_settings_topic_id_fkey"
		}).onDelete("cascade"),
	unique("quiz_settings_topic_id_key").on(table.topicId),
	pgPolicy("quiz_settings_admin_all", { as: "permissive", for: "all", to: ["authenticated"], using: sql`true` }),
	pgPolicy("quiz_settings_student_read", { as: "permissive", for: "select", to: ["authenticated"] }),
	check("quiz_settings_max_attempts_check", sql`max_attempts > 0`),
	check("quiz_settings_passing_threshold_check", sql`(passing_threshold >= 0) AND (passing_threshold <= 100)`),
	check("quiz_settings_time_limit_minutes_check", sql`time_limit_minutes > 0`),
	check("quiz_settings_xp_reward_check", sql`xp_reward >= 0`),
]);

export const orgContextCache = pgTable("org_context_cache", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	contextType: text("context_type").notNull(),
	data: jsonb().notNull(),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }).default(sql`(now() + '24:00:00'::interval)`).notNull(),
	refreshTriggeredAt: timestamp("refresh_triggered_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_org_context_cache_lookup").using("btree", table.orgId.asc().nullsLast().op("timestamptz_ops"), table.contextType.asc().nullsLast().op("uuid_ops"), table.expiresAt.asc().nullsLast().op("uuid_ops")),
	unique("org_context_cache_org_id_context_type_key").on(table.orgId, table.contextType),
	pgPolicy("org_context_cache_read", { as: "permissive", for: "select", to: ["public"], using: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())))` }),
	pgPolicy("org_context_cache_update", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("org_context_cache_write", { as: "permissive", for: "insert", to: ["public"] }),
	check("org_context_cache_context_type_check", sql`context_type = ANY (ARRAY['priorities'::text, 'metrics'::text, 'pillar_health'::text, 'cross_pollination'::text, 'announcements'::text, 'goals'::text])`),
]);

export const orgStandups = pgTable("org_standups", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	standupDate: date("standup_date").default(sql`CURRENT_DATE`).notNull(),
	generatedBy: text("generated_by").default('organization_twin').notNull(),
	report: jsonb().notNull(),
	pillarSummaries: jsonb("pillar_summaries").default({}),
	crossPollinationInsights: jsonb("cross_pollination_insights").default([]),
	escalations: jsonb().default([]),
	blockers: jsonb().default([]),
	organismHealthScore: numeric("organism_health_score", { precision: 5, scale:  2 }),
	tokensUsed: integer("tokens_used"),
	costUsd: numeric("cost_usd", { precision: 10, scale:  6 }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_org_standups_date").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.standupDate.desc().nullsFirst().op("date_ops")),
	unique("org_standups_org_id_standup_date_key").on(table.orgId, table.standupDate),
	pgPolicy("org_standups_org_access", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())))` }),
]);

export const peerReviews = pgTable("peer_reviews", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	submissionId: uuid("submission_id").notNull(),
	reviewerId: uuid("reviewer_id").notNull(),
	rating: integer().notNull(),
	comments: text().notNull(),
	strengths: text(),
	improvements: text(),
	reviewedAt: timestamp("reviewed_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_peer_reviews_reviewer").using("btree", table.reviewerId.asc().nullsLast().op("uuid_ops")),
	index("idx_peer_reviews_submission").using("btree", table.submissionId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.reviewerId],
			foreignColumns: [userProfiles.id],
			name: "peer_reviews_reviewer_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.submissionId],
			foreignColumns: [capstoneSubmissions.id],
			name: "peer_reviews_submission_id_fkey"
		}).onDelete("cascade"),
	unique("peer_reviews_submission_id_reviewer_id_key").on(table.submissionId, table.reviewerId),
	pgPolicy("peer_reviews_insert_student", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`((reviewer_id = auth.uid()) AND (NOT (EXISTS ( SELECT 1
   FROM capstone_submissions
  WHERE ((capstone_submissions.id = peer_reviews.submission_id) AND (capstone_submissions.user_id = auth.uid()))))))`  }),
	pgPolicy("peer_reviews_select_own_reviews", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("peer_reviews_select_own_submission", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("peer_reviews_select_trainer", { as: "permissive", for: "select", to: ["public"] }),
	check("peer_reviews_rating_check", sql`(rating >= 1) AND (rating <= 5)`),
]);

export const aiMentorChats = pgTable("ai_mentor_chats", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	topicId: uuid("topic_id"),
	courseId: uuid("course_id"),
	question: text().notNull(),
	response: text().notNull(),
	conversationContext: jsonb("conversation_context").default([]),
	tokensUsed: integer("tokens_used").default(0).notNull(),
	responseTimeMs: integer("response_time_ms").default(0).notNull(),
	model: text().default('gpt-4o-mini').notNull(),
	costUsd: numeric("cost_usd", { precision: 10, scale:  6 }).default('0'),
	studentRating: integer("student_rating"),
	studentFeedback: text("student_feedback"),
	flaggedForReview: boolean("flagged_for_review").default(false),
	escalatedToTrainer: boolean("escalated_to_trainer").default(false),
	escalationReason: text("escalation_reason"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	ratedAt: timestamp("rated_at", { withTimezone: true, mode: 'string' }),
	escalatedAt: timestamp("escalated_at", { withTimezone: true, mode: 'string' }),
	promptVariantId: uuid("prompt_variant_id"),
	questionHash: text("question_hash").generatedAlwaysAs(sql`md5(lower(TRIM(BOTH FROM question)))`),
}, (table) => [
	index("idx_ai_mentor_chats_course_id").using("btree", table.courseId.asc().nullsLast().op("uuid_ops")),
	index("idx_ai_mentor_chats_created_at").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_ai_mentor_chats_escalated").using("btree", table.escalatedToTrainer.asc().nullsLast().op("bool_ops")).where(sql`(escalated_to_trainer = true)`),
	index("idx_ai_mentor_chats_flagged").using("btree", table.flaggedForReview.asc().nullsLast().op("bool_ops")).where(sql`(flagged_for_review = true)`),
	index("idx_ai_mentor_chats_topic_id").using("btree", table.topicId.asc().nullsLast().op("uuid_ops")),
	index("idx_ai_mentor_chats_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	index("idx_mentor_chats_prompt_variant").using("btree", table.promptVariantId.asc().nullsLast().op("uuid_ops")),
	index("idx_mentor_chats_question_hash").using("btree", table.questionHash.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.courseId],
			foreignColumns: [courses.id],
			name: "ai_mentor_chats_course_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.promptVariantId],
			foreignColumns: [aiPromptVariants.id],
			name: "ai_mentor_chats_prompt_variant_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.topicId],
			foreignColumns: [moduleTopics.id],
			name: "ai_mentor_chats_topic_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "ai_mentor_chats_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("ai_mentor_chats_insert_own", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(user_id = auth.uid())`  }),
	pgPolicy("ai_mentor_chats_select_own", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("ai_mentor_chats_select_staff", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("ai_mentor_chats_update_rating", { as: "permissive", for: "update", to: ["public"] }),
	check("ai_mentor_chats_student_rating_check", sql`(student_rating >= 1) AND (student_rating <= 5)`),
]);

export const sequenceTemplates = pgTable("sequence_templates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	description: text(),
	channel: text().notNull(),
	steps: jsonb().default([]).notNull(),
	settings: jsonb().default({}),
	isActive: boolean("is_active").default(true),
	usageCount: integer("usage_count").default(0),
	createdBy: uuid("created_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_sequence_templates_channel").using("btree", table.channel.asc().nullsLast().op("text_ops")),
	index("idx_sequence_templates_created_by").using("btree", table.createdBy.asc().nullsLast().op("uuid_ops")),
	index("idx_sequence_templates_is_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_sequence_templates_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "sequence_templates_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "sequence_templates_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("sequence_templates_delete_org", { as: "permissive", for: "delete", to: ["public"], using: sql`(org_id = (current_setting('app.current_org_id'::text, true))::uuid)` }),
	pgPolicy("sequence_templates_insert_org", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("sequence_templates_select_org", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("sequence_templates_update_org", { as: "permissive", for: "update", to: ["public"] }),
	check("sequence_templates_channel_check", sql`channel = ANY (ARRAY['email'::text, 'linkedin'::text, 'phone'::text, 'sms'::text])`),
	check("sequence_templates_name_length", sql`char_length(name) <= 255`),
]);

export const aiMentorRateLimits = pgTable("ai_mentor_rate_limits", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	hourlyCount: integer("hourly_count").default(0).notNull(),
	dailyCount: integer("daily_count").default(0).notNull(),
	monthlyCount: integer("monthly_count").default(0).notNull(),
	hourlyResetAt: timestamp("hourly_reset_at", { withTimezone: true, mode: 'string' }).default(sql`(now() + '01:00:00'::interval)`).notNull(),
	dailyResetAt: timestamp("daily_reset_at", { withTimezone: true, mode: 'string' }).default(sql`(now() + '1 day'::interval)`).notNull(),
	monthlyResetAt: timestamp("monthly_reset_at", { withTimezone: true, mode: 'string' }).default(sql`(now() + '1 mon'::interval)`).notNull(),
	monthlyCostUsd: numeric("monthly_cost_usd", { precision: 10, scale:  4 }).default('0'),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_ai_mentor_rate_limits_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "ai_mentor_rate_limits_user_id_fkey"
		}).onDelete("cascade"),
	unique("ai_mentor_rate_limits_user_id_key").on(table.userId),
	pgPolicy("ai_mentor_rate_limits_select_own", { as: "permissive", for: "select", to: ["public"], using: sql`(user_id = auth.uid())` }),
]);

export const aiMentorSessions = pgTable("ai_mentor_sessions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	topicId: uuid("topic_id"),
	courseId: uuid("course_id"),
	title: text(),
	messageCount: integer("message_count").default(0).notNull(),
	totalTokens: integer("total_tokens").default(0).notNull(),
	totalCostUsd: numeric("total_cost_usd", { precision: 10, scale:  6 }).default('0'),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	lastMessageAt: timestamp("last_message_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	endedAt: timestamp("ended_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_ai_mentor_sessions_last_message").using("btree", table.lastMessageAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_ai_mentor_sessions_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.courseId],
			foreignColumns: [courses.id],
			name: "ai_mentor_sessions_course_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.topicId],
			foreignColumns: [moduleTopics.id],
			name: "ai_mentor_sessions_topic_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "ai_mentor_sessions_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("ai_mentor_sessions_select_own", { as: "permissive", for: "select", to: ["public"], using: sql`(user_id = auth.uid())` }),
	pgPolicy("ai_mentor_sessions_select_staff", { as: "permissive", for: "select", to: ["public"] }),
]);

export const permissionOverrides = pgTable("permission_overrides", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	userId: uuid("user_id").notNull(),
	permissionId: uuid("permission_id").notNull(),
	granted: boolean().notNull(),
	scopeOverride: varchar("scope_override", { length: 50 }),
	reason: text().notNull(),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }),
	createdBy: uuid("created_by").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	revokedAt: timestamp("revoked_at", { withTimezone: true, mode: 'string' }),
	revokedBy: uuid("revoked_by"),
}, (table) => [
	index("idx_permission_overrides_active").using("btree", table.userId.asc().nullsLast().op("uuid_ops"), table.permissionId.asc().nullsLast().op("uuid_ops")).where(sql`(revoked_at IS NULL)`),
	index("idx_permission_overrides_expires").using("btree", table.expiresAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(expires_at IS NOT NULL)`),
	index("idx_permission_overrides_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_permission_overrides_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "permission_overrides_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "permission_overrides_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.permissionId],
			foreignColumns: [permissions.id],
			name: "permission_overrides_permission_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.revokedBy],
			foreignColumns: [userProfiles.id],
			name: "permission_overrides_revoked_by_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "permission_overrides_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("permission_overrides_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = COALESCE(( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())), ((auth.jwt() ->> 'org_id'::text))::uuid))` }),
	check("permission_overrides_valid_scope", sql`(scope_override IS NULL) OR ((scope_override)::text = ANY ((ARRAY['own'::character varying, 'own_raci'::character varying, 'own_ra'::character varying, 'team'::character varying, 'region'::character varying, 'org'::character varying, 'draft_only'::character varying])::text[]))`),
]);

export const campaignSequences = pgTable("campaign_sequences", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	campaignId: uuid("campaign_id").notNull(),
	sequenceTemplateId: uuid("sequence_template_id").notNull(),
	orgId: uuid("org_id").notNull(),
	isActive: boolean("is_active").default(true),
	enrolledCount: integer("enrolled_count").default(0),
	completedCount: integer("completed_count").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_campaign_sequences_campaign_id").using("btree", table.campaignId.asc().nullsLast().op("uuid_ops")),
	index("idx_campaign_sequences_sequence_template_id").using("btree", table.sequenceTemplateId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.campaignId],
			foreignColumns: [campaigns.id],
			name: "campaign_sequences_campaign_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "campaign_sequences_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.sequenceTemplateId],
			foreignColumns: [sequenceTemplates.id],
			name: "campaign_sequences_sequence_template_id_fkey"
		}).onDelete("cascade"),
	unique("campaign_sequences_unique").on(table.campaignId, table.sequenceTemplateId),
	pgPolicy("campaign_sequences_delete_org", { as: "permissive", for: "delete", to: ["public"], using: sql`(org_id = (current_setting('app.current_org_id'::text, true))::uuid)` }),
	pgPolicy("campaign_sequences_insert_org", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("campaign_sequences_select_org", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("campaign_sequences_update_org", { as: "permissive", for: "update", to: ["public"] }),
]);

export const apiTokens = pgTable("api_tokens", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: varchar({ length: 100 }).notNull(),
	tokenHash: varchar("token_hash", { length: 255 }).notNull(),
	tokenPrefix: varchar("token_prefix", { length: 10 }).notNull(),
	scopes: text().array().default([""]).notNull(),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }),
	lastUsedAt: timestamp("last_used_at", { withTimezone: true, mode: 'string' }),
	lastUsedIp: inet("last_used_ip"),
	usageCount: integer("usage_count").default(0),
	rateLimitPerHour: integer("rate_limit_per_hour").default(1000),
	createdBy: uuid("created_by").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	revokedAt: timestamp("revoked_at", { withTimezone: true, mode: 'string' }),
	revokedBy: uuid("revoked_by"),
}, (table) => [
	index("idx_api_tokens_active").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(revoked_at IS NULL)`),
	index("idx_api_tokens_hash").using("btree", table.tokenHash.asc().nullsLast().op("text_ops")),
	index("idx_api_tokens_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "api_tokens_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "api_tokens_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.revokedBy],
			foreignColumns: [userProfiles.id],
			name: "api_tokens_revoked_by_fkey"
		}),
	pgPolicy("api_tokens_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = COALESCE(( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())), ((auth.jwt() ->> 'org_id'::text))::uuid))` }),
]);

export const bulkUpdateHistory = pgTable("bulk_update_history", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	updateType: varchar("update_type", { length: 50 }).notNull(),
	affectedUserIds: uuid("affected_user_ids").array().notNull(),
	changes: jsonb().notNull(),
	previousState: jsonb("previous_state").notNull(),
	reason: text().notNull(),
	appliedBy: uuid("applied_by").notNull(),
	appliedAt: timestamp("applied_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	rolledBackAt: timestamp("rolled_back_at", { withTimezone: true, mode: 'string' }),
	rolledBackBy: uuid("rolled_back_by"),
}, (table) => [
	index("idx_bulk_update_history_applied").using("btree", table.appliedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_bulk_update_history_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.appliedBy],
			foreignColumns: [userProfiles.id],
			name: "bulk_update_history_applied_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "bulk_update_history_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.rolledBackBy],
			foreignColumns: [userProfiles.id],
			name: "bulk_update_history_rolled_back_by_fkey"
		}),
	pgPolicy("bulk_update_history_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = COALESCE(( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())), ((auth.jwt() ->> 'org_id'::text))::uuid))` }),
	check("bulk_update_history_valid_type", sql`(update_type)::text = ANY ((ARRAY['enable_feature'::character varying, 'disable_feature'::character varying, 'change_scope'::character varying, 'add_permission'::character varying, 'remove_permission'::character varying])::text[])`),
]);

export const rolePermissions = pgTable("role_permissions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	roleId: uuid("role_id").notNull(),
	permissionId: uuid("permission_id").notNull(),
	scopeCondition: varchar("scope_condition", { length: 50 }).default('own'),
	granted: boolean().default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	grantedBy: uuid("granted_by"),
}, (table) => [
	index("idx_role_permissions_permission_id").using("btree", table.permissionId.asc().nullsLast().op("uuid_ops")),
	index("idx_role_permissions_role_id").using("btree", table.roleId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.grantedBy],
			foreignColumns: [userProfiles.id],
			name: "role_permissions_granted_by_fkey"
		}),
	foreignKey({
			columns: [table.permissionId],
			foreignColumns: [permissions.id],
			name: "role_permissions_permission_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.roleId],
			foreignColumns: [systemRoles.id],
			name: "role_permissions_role_id_fkey"
		}).onDelete("cascade"),
	unique("role_permissions_role_id_permission_id_key").on(table.roleId, table.permissionId),
	pgPolicy("role_permissions_public_read", { as: "permissive", for: "select", to: ["public"], using: sql`true` }),
	check("role_permissions_valid_scope", sql`(scope_condition)::text = ANY ((ARRAY['own'::character varying, 'own_raci'::character varying, 'own_ra'::character varying, 'team'::character varying, 'region'::character varying, 'org'::character varying, 'draft_only'::character varying])::text[])`),
]);

export const permissions = pgTable("permissions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	code: varchar({ length: 100 }).notNull(),
	name: varchar({ length: 100 }).notNull(),
	description: text(),
	objectType: varchar("object_type", { length: 50 }).notNull(),
	action: varchar({ length: 20 }).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_permissions_action").using("btree", table.action.asc().nullsLast().op("text_ops")),
	index("idx_permissions_code").using("btree", table.code.asc().nullsLast().op("text_ops")),
	index("idx_permissions_object_type").using("btree", table.objectType.asc().nullsLast().op("text_ops")),
	unique("permissions_code_key").on(table.code),
	pgPolicy("permissions_public_read", { as: "permissive", for: "select", to: ["public"], using: sql`true` }),
	check("permissions_valid_action", sql`(action)::text = ANY ((ARRAY['create'::character varying, 'read'::character varying, 'update'::character varying, 'delete'::character varying, 'approve'::character varying, 'reject'::character varying, 'export'::character varying, 'import'::character varying, 'manage'::character varying, 'assign'::character varying, 'send'::character varying, 'issue'::character varying, 'view'::character varying, 'use'::character varying, 'access'::character varying])::text[])`),
]);

export const aiQuestionPatterns = pgTable("ai_question_patterns", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	patternHash: text("pattern_hash").notNull(),
	canonicalQuestion: text("canonical_question").notNull(),
	category: text(),
	topicId: uuid("topic_id"),
	occurrenceCount: integer("occurrence_count").default(1),
	uniqueStudents: integer("unique_students").default(1),
	avgResponseQuality: numeric("avg_response_quality", { precision: 3, scale:  2 }),
	escalationRate: numeric("escalation_rate", { precision: 5, scale:  4 }),
	firstSeen: timestamp("first_seen", { withTimezone: true, mode: 'string' }).defaultNow(),
	lastSeen: timestamp("last_seen", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_question_patterns_hash").using("btree", table.patternHash.asc().nullsLast().op("text_ops")),
	index("idx_question_patterns_occurrence").using("btree", table.occurrenceCount.desc().nullsFirst().op("int4_ops")),
	index("idx_question_patterns_topic").using("btree", table.topicId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.topicId],
			foreignColumns: [moduleTopics.id],
			name: "ai_question_patterns_topic_id_fkey"
		}).onDelete("set null"),
	unique("ai_question_patterns_pattern_hash_key").on(table.patternHash),
	pgPolicy("question_patterns_select_admin", { as: "permissive", for: "select", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM (user_roles ur
     JOIN roles r ON ((r.id = ur.role_id)))
  WHERE ((ur.user_id = auth.uid()) AND (r.name = 'admin'::text))))` }),
]);

export const featureFlagRoles = pgTable("feature_flag_roles", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	featureFlagId: uuid("feature_flag_id").notNull(),
	roleId: uuid("role_id").notNull(),
	enabled: boolean().default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_feature_flag_roles_flag").using("btree", table.featureFlagId.asc().nullsLast().op("uuid_ops")),
	index("idx_feature_flag_roles_role").using("btree", table.roleId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.featureFlagId],
			foreignColumns: [featureFlags.id],
			name: "feature_flag_roles_feature_flag_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.roleId],
			foreignColumns: [systemRoles.id],
			name: "feature_flag_roles_role_id_fkey"
		}).onDelete("cascade"),
	unique("feature_flag_roles_feature_flag_id_role_id_key").on(table.featureFlagId, table.roleId),
	pgPolicy("feature_flag_roles_read", { as: "permissive", for: "select", to: ["public"], using: sql`true` }),
]);

export const aiPromptVariants = pgTable("ai_prompt_variants", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	variantName: text("variant_name").notNull(),
	systemPrompt: text("system_prompt").notNull(),
	isActive: boolean("is_active").default(false),
	trafficPercentage: integer("traffic_percentage").default(0),
	totalUses: integer("total_uses").default(0),
	avgRating: numeric("avg_rating", { precision: 3, scale:  2 }),
	avgResponseTimeMs: integer("avg_response_time_ms"),
	avgTokensUsed: integer("avg_tokens_used"),
	escalationCount: integer("escalation_count").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	deactivatedAt: timestamp("deactivated_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	unique("ai_prompt_variants_variant_name_key").on(table.variantName),
	pgPolicy("prompt_variants_all_admin", { as: "permissive", for: "all", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM (user_roles ur
     JOIN roles r ON ((r.id = ur.role_id)))
  WHERE ((ur.user_id = auth.uid()) AND (r.name = 'admin'::text))))` }),
	check("ai_prompt_variants_traffic_percentage_check", sql`(traffic_percentage >= 0) AND (traffic_percentage <= 100)`),
]);

export const badges = pgTable("badges", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	slug: text().notNull(),
	name: text().notNull(),
	description: text().notNull(),
	iconUrl: text("icon_url"),
	xpReward: integer("xp_reward").default(50),
	rarity: text().notNull(),
	displayOrder: integer("display_order").default(0),
	isHidden: boolean("is_hidden").default(false),
	triggerType: text("trigger_type").notNull(),
	triggerThreshold: integer("trigger_threshold").default(1),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_badges_rarity").using("btree", table.rarity.asc().nullsLast().op("text_ops")),
	index("idx_badges_trigger_type").using("btree", table.triggerType.asc().nullsLast().op("text_ops")),
	unique("badges_slug_key").on(table.slug),
	pgPolicy("badges_all_admin", { as: "permissive", for: "all", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM (user_roles ur
     JOIN roles r ON ((r.id = ur.role_id)))
  WHERE ((ur.user_id = auth.uid()) AND (r.name = 'admin'::text))))` }),
	pgPolicy("badges_select_all", { as: "permissive", for: "select", to: ["public"] }),
	check("badges_rarity_check", sql`rarity = ANY (ARRAY['common'::text, 'rare'::text, 'epic'::text, 'legendary'::text])`),
	check("badges_trigger_type_check", sql`trigger_type = ANY (ARRAY['first_video'::text, 'first_quiz'::text, 'first_lab'::text, 'quiz_streak'::text, 'perfect_quiz'::text, 'lab_completion'::text, 'course_completion'::text, 'ai_mentor_usage'::text, 'help_others'::text, 'speed_demon'::text, 'night_owl'::text, 'early_bird'::text, 'consistency'::text, 'achievement_hunter'::text])`),
	check("badges_xp_reward_check", sql`xp_reward >= 0`),
]);

export const userBadges = pgTable("user_badges", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	badgeId: uuid("badge_id").notNull(),
	earnedAt: timestamp("earned_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	progressValue: integer("progress_value").default(0),
	isNew: boolean("is_new").default(true),
	viewedAt: timestamp("viewed_at", { withTimezone: true, mode: 'string' }),
	sharedAt: timestamp("shared_at", { withTimezone: true, mode: 'string' }),
	shareCount: integer("share_count").default(0),
}, (table) => [
	index("idx_user_badges_badge").using("btree", table.badgeId.asc().nullsLast().op("uuid_ops")),
	index("idx_user_badges_earned").using("btree", table.earnedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_user_badges_new").using("btree", table.userId.asc().nullsLast().op("uuid_ops"), table.isNew.asc().nullsLast().op("uuid_ops")).where(sql`(is_new = true)`),
	index("idx_user_badges_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.badgeId],
			foreignColumns: [badges.id],
			name: "user_badges_badge_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "user_badges_user_id_fkey"
		}).onDelete("cascade"),
	unique("user_badges_user_id_badge_id_key").on(table.userId, table.badgeId),
	pgPolicy("user_badges_select_own", { as: "permissive", for: "select", to: ["public"], using: sql`(user_id = auth.uid())` }),
	pgPolicy("user_badges_update_own", { as: "permissive", for: "update", to: ["public"] }),
]);

export const systemSettings = pgTable("system_settings", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	key: varchar({ length: 100 }).notNull(),
	value: jsonb().default({}).notNull(),
	category: varchar({ length: 50 }).notNull(),
	dataType: varchar("data_type", { length: 20 }).default('string').notNull(),
	description: text(),
	defaultValue: jsonb("default_value"),
	constraints: jsonb(),
	isSensitive: boolean("is_sensitive").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedBy: uuid("updated_by"),
}, (table) => [
	index("idx_system_settings_category").using("btree", table.category.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "system_settings_updated_by_fkey"
		}),
	unique("system_settings_key_key").on(table.key),
]);

export const workflowStates = pgTable("workflow_states", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	workflowId: uuid("workflow_id").notNull(),
	name: text().notNull(),
	displayName: text("display_name").notNull(),
	description: text(),
	stateOrder: integer("state_order").notNull(),
	isInitial: boolean("is_initial").default(false).notNull(),
	isTerminal: boolean("is_terminal").default(false).notNull(),
	actions: jsonb().default([]).notNull(),
	metadata: jsonb().default({}).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_workflow_states_terminal").using("btree", table.isTerminal.asc().nullsLast().op("bool_ops")).where(sql`(is_terminal = true)`),
	index("idx_workflow_states_workflow_id").using("btree", table.workflowId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.workflowId],
			foreignColumns: [workflows.id],
			name: "workflow_states_workflow_id_fkey"
		}).onDelete("cascade"),
	unique("unique_state_name_per_workflow").on(table.workflowId, table.name),
	unique("unique_state_order_per_workflow").on(table.workflowId, table.stateOrder),
	pgPolicy("Only admins can modify workflow states", { as: "permissive", for: "all", to: ["public"], using: sql`user_is_admin()` }),
	pgPolicy("Users can view workflow states", { as: "permissive", for: "select", to: ["public"] }),
]);

export const workflowTransitions = pgTable("workflow_transitions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	workflowId: uuid("workflow_id").notNull(),
	fromStateId: uuid("from_state_id").notNull(),
	toStateId: uuid("to_state_id").notNull(),
	action: text().notNull(),
	displayName: text("display_name").notNull(),
	requiredPermission: text("required_permission"),
	conditions: jsonb().default({}).notNull(),
	autoTransition: boolean("auto_transition").default(false).notNull(),
	metadata: jsonb().default({}).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_workflow_transitions_action").using("btree", table.action.asc().nullsLast().op("text_ops")),
	index("idx_workflow_transitions_from_state").using("btree", table.fromStateId.asc().nullsLast().op("uuid_ops")),
	index("idx_workflow_transitions_workflow_id").using("btree", table.workflowId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.fromStateId],
			foreignColumns: [workflowStates.id],
			name: "workflow_transitions_from_state_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.toStateId],
			foreignColumns: [workflowStates.id],
			name: "workflow_transitions_to_state_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.workflowId],
			foreignColumns: [workflows.id],
			name: "workflow_transitions_workflow_id_fkey"
		}).onDelete("cascade"),
	unique("unique_transition_action").on(table.workflowId, table.fromStateId, table.action),
	pgPolicy("Only admins can modify workflow transitions", { as: "permissive", for: "all", to: ["public"], using: sql`user_is_admin()` }),
	pgPolicy("Users can view workflow transitions", { as: "permissive", for: "select", to: ["public"] }),
	check("no_self_transition", sql`from_state_id <> to_state_id`),
]);

export const workflowInstances = pgTable("workflow_instances", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	workflowId: uuid("workflow_id").notNull(),
	entityType: text("entity_type").notNull(),
	entityId: uuid("entity_id").notNull(),
	currentStateId: uuid("current_state_id").notNull(),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	cancelledAt: timestamp("cancelled_at", { withTimezone: true, mode: 'string' }),
	status: text().default('active').notNull(),
	metadata: jsonb().default({}).notNull(),
	version: integer().default(0).notNull(),
	createdBy: uuid("created_by").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_workflow_instances_current_state").using("btree", table.currentStateId.asc().nullsLast().op("uuid_ops")),
	index("idx_workflow_instances_entity").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("uuid_ops")),
	index("idx_workflow_instances_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_workflow_instances_status").using("btree", table.status.asc().nullsLast().op("text_ops")).where(sql`(status = 'active'::text)`),
	index("idx_workflow_instances_workflow_id").using("btree", table.workflowId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "workflow_instances_created_by_fkey"
		}),
	foreignKey({
			columns: [table.currentStateId],
			foreignColumns: [workflowStates.id],
			name: "workflow_instances_current_state_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "workflow_instances_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.workflowId],
			foreignColumns: [workflows.id],
			name: "workflow_instances_workflow_id_fkey"
		}),
	unique("unique_entity_workflow").on(table.orgId, table.workflowId, table.entityType, table.entityId),
	pgPolicy("Service role can update workflow instances", { as: "permissive", for: "update", to: ["public"], using: sql`true` }),
	pgPolicy("Users can create workflow instances in their org", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("Users can view workflow instances in their org", { as: "permissive", for: "select", to: ["public"] }),
	check("valid_status", sql`status = ANY (ARRAY['active'::text, 'completed'::text, 'cancelled'::text, 'failed'::text])`),
]);

export const workflowHistory = pgTable("workflow_history", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	workflowInstanceId: uuid("workflow_instance_id").notNull(),
	fromStateId: uuid("from_state_id"),
	toStateId: uuid("to_state_id").notNull(),
	action: text().notNull(),
	performedBy: uuid("performed_by").notNull(),
	notes: text(),
	metadata: jsonb().default({}).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_workflow_history_created_at").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_workflow_history_instance_id").using("btree", table.workflowInstanceId.asc().nullsLast().op("uuid_ops")),
	index("idx_workflow_history_performed_by").using("btree", table.performedBy.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.fromStateId],
			foreignColumns: [workflowStates.id],
			name: "workflow_history_from_state_id_fkey"
		}),
	foreignKey({
			columns: [table.performedBy],
			foreignColumns: [userProfiles.id],
			name: "workflow_history_performed_by_fkey"
		}),
	foreignKey({
			columns: [table.toStateId],
			foreignColumns: [workflowStates.id],
			name: "workflow_history_to_state_id_fkey"
		}),
	foreignKey({
			columns: [table.workflowInstanceId],
			foreignColumns: [workflowInstances.id],
			name: "workflow_history_workflow_instance_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("Service role can insert workflow history", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`true`  }),
	pgPolicy("Users can view workflow history for their org instances", { as: "permissive", for: "select", to: ["public"] }),
]);

export const fileUploads = pgTable("file_uploads", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	bucket: text().notNull(),
	filePath: text("file_path").notNull(),
	fileName: text("file_name").notNull(),
	fileSize: integer("file_size").notNull(),
	mimeType: text("mime_type").notNull(),
	entityType: text("entity_type"),
	entityId: uuid("entity_id"),
	uploadedBy: uuid("uploaded_by").notNull(),
	uploadedAt: timestamp("uploaded_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	metadata: jsonb().default({}).notNull(),
}, (table) => [
	index("idx_file_uploads_bucket").using("btree", table.bucket.asc().nullsLast().op("text_ops")),
	index("idx_file_uploads_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("text_ops")),
	index("idx_file_uploads_not_deleted").using("btree", table.deletedAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_file_uploads_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_file_uploads_uploaded_by").using("btree", table.uploadedBy.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "file_uploads_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.uploadedBy],
			foreignColumns: [userProfiles.id],
			name: "file_uploads_uploaded_by_fkey"
		}),
	unique("unique_file_path").on(table.bucket, table.filePath),
	pgPolicy("Users can soft-delete their own files", { as: "permissive", for: "update", to: ["public"], using: sql`((org_id = auth_user_org_id()) AND (uploaded_by = auth_user_id()))`, withCheck: sql`((org_id = auth_user_org_id()) AND (uploaded_by = auth_user_id()))`  }),
	pgPolicy("Users can upload files to their org", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("Users can view files in their org", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("file_uploads_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	check("valid_bucket", sql`bucket = ANY (ARRAY['avatars'::text, 'resumes'::text, 'documents'::text, 'attachments'::text, 'course-materials'::text])`),
]);

export const documentTemplates = pgTable("document_templates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	description: text(),
	templateType: text("template_type").notNull(),
	category: text().notNull(),
	templateContent: text("template_content").notNull(),
	variables: jsonb().default({}).notNull(),
	sampleData: jsonb("sample_data").default({}),
	isActive: boolean("is_active").default(true).notNull(),
	createdBy: uuid("created_by").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_document_templates_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")).where(sql`(is_active = true)`),
	index("idx_document_templates_category").using("btree", table.category.asc().nullsLast().op("text_ops")),
	index("idx_document_templates_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_document_templates_type").using("btree", table.templateType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "document_templates_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "document_templates_org_id_fkey"
		}).onDelete("cascade"),
	unique("unique_template_name_per_org").on(table.orgId, table.name),
	pgPolicy("Only admins can create templates", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`user_is_admin()`  }),
	pgPolicy("Only admins can delete templates", { as: "permissive", for: "delete", to: ["public"] }),
	pgPolicy("Only admins can update templates", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("Users can view templates in their org", { as: "permissive", for: "select", to: ["public"] }),
	check("valid_template_type", sql`template_type = ANY (ARRAY['pdf'::text, 'docx'::text, 'html'::text])`),
]);

export const generatedDocuments = pgTable("generated_documents", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	templateId: uuid("template_id").notNull(),
	entityType: text("entity_type").notNull(),
	entityId: uuid("entity_id").notNull(),
	filePath: text("file_path").notNull(),
	fileName: text("file_name").notNull(),
	fileSize: integer("file_size").notNull(),
	mimeType: text("mime_type").notNull(),
	generatedBy: uuid("generated_by").notNull(),
	generatedAt: timestamp("generated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	metadata: jsonb().default({}).notNull(),
}, (table) => [
	index("idx_generated_documents_entity").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("text_ops")),
	index("idx_generated_documents_generated_at").using("btree", table.generatedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_generated_documents_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_generated_documents_template_id").using("btree", table.templateId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.generatedBy],
			foreignColumns: [userProfiles.id],
			name: "generated_documents_generated_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "generated_documents_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.templateId],
			foreignColumns: [documentTemplates.id],
			name: "generated_documents_template_id_fkey"
		}),
	pgPolicy("Users can create generated documents in their org", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(org_id = auth_user_org_id())`  }),
	pgPolicy("Users can view generated documents in their org", { as: "permissive", for: "select", to: ["public"] }),
	check("valid_mime_type", sql`mime_type = ANY (ARRAY['application/pdf'::text, 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'::text])`),
]);

export const workflows = pgTable("workflows", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	description: text(),
	entityType: text("entity_type").notNull(),
	initialStateId: uuid("initial_state_id"),
	version: integer().default(1).notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	createdBy: uuid("created_by").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	definition: jsonb().default({}),
}, (table) => [
	index("idx_workflows_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")).where(sql`(is_active = true)`),
	index("idx_workflows_definition_actions").using("gin", sql`((definition -> 'actions'::text))`),
	index("idx_workflows_definition_triggers").using("gin", sql`((definition -> 'triggers'::text))`),
	index("idx_workflows_entity_type").using("btree", table.entityType.asc().nullsLast().op("text_ops")),
	index("idx_workflows_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "workflows_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "workflows_org_id_fkey"
		}).onDelete("cascade"),
	unique("unique_workflow_name_per_org").on(table.orgId, table.name, table.version),
	pgPolicy("Only admins can create workflows", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`user_is_admin()`  }),
	pgPolicy("Only admins can delete workflows", { as: "permissive", for: "delete", to: ["public"] }),
	pgPolicy("Only admins can update workflows", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("Users can view workflows in their org", { as: "permissive", for: "select", to: ["public"] }),
]);

export const emailLogs = pgTable("email_logs", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	templateId: uuid("template_id"),
	toEmail: text("to_email").notNull(),
	ccEmail: text("cc_email").array(),
	bccEmail: text("bcc_email").array(),
	subject: text().notNull(),
	status: text().default('pending').notNull(),
	resendId: text("resend_id"),
	errorMessage: text("error_message"),
	sentAt: timestamp("sent_at", { withTimezone: true, mode: 'string' }),
	openedAt: timestamp("opened_at", { withTimezone: true, mode: 'string' }),
	clickedAt: timestamp("clicked_at", { withTimezone: true, mode: 'string' }),
	metadata: jsonb().default({}).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_email_logs_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_email_logs_resend_id").using("btree", table.resendId.asc().nullsLast().op("text_ops")).where(sql`(resend_id IS NOT NULL)`),
	index("idx_email_logs_sent_at").using("btree", table.sentAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_email_logs_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_email_logs_template_id").using("btree", table.templateId.asc().nullsLast().op("uuid_ops")),
	index("idx_email_logs_to_email").using("btree", table.toEmail.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "email_logs_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.templateId],
			foreignColumns: [emailTemplates.id],
			name: "email_logs_template_id_fkey"
		}),
	pgPolicy("Service role can insert email logs", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`true`  }),
	pgPolicy("Service role can update email logs", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("Users can view email logs in their org", { as: "permissive", for: "select", to: ["public"] }),
	check("valid_email_status", sql`status = ANY (ARRAY['pending'::text, 'sent'::text, 'failed'::text, 'bounced'::text, 'opened'::text, 'clicked'::text])`),
]);

export const backgroundJobs = pgTable("background_jobs", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	jobType: text("job_type").notNull(),
	payload: jsonb().notNull(),
	status: text().default('pending').notNull(),
	attempts: integer().default(0).notNull(),
	maxAttempts: integer("max_attempts").default(3).notNull(),
	errorMessage: text("error_message"),
	result: jsonb(),
	priority: integer().default(5).notNull(),
	createdBy: uuid("created_by").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_background_jobs_failed").using("btree", table.attempts.asc().nullsLast().op("int4_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")).where(sql`((status = 'failed'::text) AND (attempts < max_attempts))`),
	index("idx_background_jobs_job_type").using("btree", table.jobType.asc().nullsLast().op("text_ops")),
	index("idx_background_jobs_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_background_jobs_pending").using("btree", table.priority.asc().nullsLast().op("int4_ops"), table.createdAt.asc().nullsLast().op("int4_ops")).where(sql`(status = 'pending'::text)`),
	index("idx_background_jobs_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "background_jobs_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "background_jobs_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("Service role can update jobs", { as: "permissive", for: "update", to: ["public"], using: sql`true` }),
	pgPolicy("Users can create jobs in their org", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("Users can view jobs in their org", { as: "permissive", for: "select", to: ["public"] }),
	check("valid_job_status", sql`status = ANY (ARRAY['pending'::text, 'processing'::text, 'completed'::text, 'failed'::text])`),
	check("valid_job_type", sql`job_type = ANY (ARRAY['generate_document'::text, 'send_email'::text, 'send_bulk_email'::text, 'import_data'::text, 'export_data'::text])`),
	check("valid_priority", sql`(priority >= 1) AND (priority <= 10)`),
]);

export const pricingPlans = pgTable("pricing_plans", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	name: text().notNull(),
	description: text(),
	slug: text().notNull(),
	planType: text("plan_type").notNull(),
	priceMonthly: numeric("price_monthly", { precision: 10, scale:  2 }),
	priceAnnual: numeric("price_annual", { precision: 10, scale:  2 }),
	priceOneTime: numeric("price_one_time", { precision: 10, scale:  2 }),
	stripePriceIdMonthly: text("stripe_price_id_monthly"),
	stripePriceIdAnnual: text("stripe_price_id_annual"),
	stripePriceIdOneTime: text("stripe_price_id_one_time"),
	stripeProductId: text("stripe_product_id"),
	features: jsonb().default([]),
	maxCourses: integer("max_courses"),
	maxUsers: integer("max_users"),
	displayOrder: integer("display_order").default(0),
	isFeatured: boolean("is_featured").default(false),
	badgeText: text("badge_text"),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_pricing_plans_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_pricing_plans_plan_type").using("btree", table.planType.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_pricing_plans_slug").using("btree", table.slug.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	unique("pricing_plans_name_key").on(table.name),
	unique("pricing_plans_slug_key").on(table.slug),
	pgPolicy("pricing_plans_admin_all", { as: "permissive", for: "all", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM (user_roles ur
     JOIN roles r ON ((r.id = ur.role_id)))
  WHERE ((ur.user_id = auth.uid()) AND (r.name = ANY (ARRAY['admin'::text, 'super_admin'::text])))))` }),
	pgPolicy("pricing_plans_public_read", { as: "permissive", for: "select", to: ["public"] }),
	check("pricing_plans_plan_type_check", sql`plan_type = ANY (ARRAY['per_course'::text, 'all_access'::text, 'team'::text, 'enterprise'::text])`),
]);

export const discountCodes = pgTable("discount_codes", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	code: text().notNull(),
	name: text().notNull(),
	description: text(),
	discountType: text("discount_type").notNull(),
	discountValue: numeric("discount_value", { precision: 10, scale:  2 }).notNull(),
	maxUses: integer("max_uses"),
	usesCount: integer("uses_count").default(0),
	maxUsesPerUser: integer("max_uses_per_user").default(1),
	validFrom: timestamp("valid_from", { withTimezone: true, mode: 'string' }).defaultNow(),
	validUntil: timestamp("valid_until", { withTimezone: true, mode: 'string' }),
	applicablePlanTypes: text("applicable_plan_types").array(),
	applicableCourseIds: uuid("applicable_course_ids").array(),
	minimumPurchaseAmount: numeric("minimum_purchase_amount", { precision: 10, scale:  2 }),
	stripeCouponId: text("stripe_coupon_id"),
	stripePromotionCodeId: text("stripe_promotion_code_id"),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_discount_codes_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops"), table.validFrom.asc().nullsLast().op("timestamptz_ops"), table.validUntil.asc().nullsLast().op("timestamptz_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_discount_codes_code").using("btree", table.code.asc().nullsLast().op("text_ops")).where(sql`((deleted_at IS NULL) AND (is_active = true))`),
	index("idx_discount_codes_validity").using("btree", table.validFrom.asc().nullsLast().op("timestamptz_ops"), table.validUntil.asc().nullsLast().op("timestamptz_ops")).where(sql`((deleted_at IS NULL) AND (is_active = true))`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "discount_codes_created_by_fkey"
		}),
	unique("discount_codes_code_key").on(table.code),
	pgPolicy("discount_codes_admin_all", { as: "permissive", for: "all", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM (user_roles ur
     JOIN roles r ON ((r.id = ur.role_id)))
  WHERE ((ur.user_id = auth.uid()) AND (r.name = ANY (ARRAY['admin'::text, 'super_admin'::text])))))` }),
	check("discount_codes_discount_type_check", sql`discount_type = ANY (ARRAY['percentage'::text, 'fixed'::text])`),
	check("discount_codes_discount_value_check", sql`discount_value > (0)::numeric`),
	check("discount_codes_uses_count_check", sql`uses_count >= 0`),
]);

export const studentInterventions = pgTable("student_interventions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	studentId: uuid("student_id").notNull(),
	enrollmentId: uuid("enrollment_id").notNull(),
	courseId: uuid("course_id").notNull(),
	riskLevel: text("risk_level").notNull(),
	riskReasons: text("risk_reasons").array().notNull(),
	interventionType: text("intervention_type"),
	assignedTrainerId: uuid("assigned_trainer_id"),
	assignedAt: timestamp("assigned_at", { withTimezone: true, mode: 'string' }),
	status: text().default('pending').notNull(),
	notes: text(),
	trainerNotes: text("trainer_notes"),
	resolutionNotes: text("resolution_notes"),
	outcome: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	resolvedAt: timestamp("resolved_at", { withTimezone: true, mode: 'string' }),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_student_interventions_created").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_student_interventions_enrollment").using("btree", table.enrollmentId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_student_interventions_status").using("btree", table.status.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_student_interventions_student").using("btree", table.studentId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_student_interventions_trainer").using("btree", table.assignedTrainerId.asc().nullsLast().op("uuid_ops")).where(sql`((deleted_at IS NULL) AND (status = ANY (ARRAY['pending'::text, 'in_progress'::text])))`),
	foreignKey({
			columns: [table.assignedTrainerId],
			foreignColumns: [userProfiles.id],
			name: "student_interventions_assigned_trainer_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.courseId],
			foreignColumns: [courses.id],
			name: "student_interventions_course_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.enrollmentId],
			foreignColumns: [studentEnrollments.id],
			name: "student_interventions_enrollment_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.studentId],
			foreignColumns: [userProfiles.id],
			name: "student_interventions_student_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("Only admins can delete interventions", { as: "permissive", for: "update", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM (user_roles ur
     JOIN roles r ON ((r.id = ur.role_id)))
  WHERE ((ur.user_id = auth.uid()) AND (r.name = ANY (ARRAY['admin'::text, 'super_admin'::text])))))` }),
	pgPolicy("Students can view own interventions", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("Trainers and admins can create interventions", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("Trainers and admins can view all interventions", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("Trainers can update assigned interventions", { as: "permissive", for: "update", to: ["public"] }),
	check("student_interventions_intervention_type_check", sql`intervention_type = ANY (ARRAY['automated_email'::text, 'trainer_notification'::text, 'one_on_one_scheduled'::text, 'mentor_assigned'::text, 'resource_recommended'::text, 'deadline_extended'::text, 'other'::text])`),
	check("student_interventions_outcome_check", sql`outcome = ANY (ARRAY['student_improved'::text, 'student_completed'::text, 'student_dropped'::text, 'false_positive'::text, 'needs_escalation'::text])`),
	check("student_interventions_risk_level_check", sql`risk_level = ANY (ARRAY['low'::text, 'medium'::text, 'high'::text])`),
	check("student_interventions_status_check", sql`status = ANY (ARRAY['pending'::text, 'in_progress'::text, 'resolved'::text, 'escalated'::text, 'dismissed'::text])`),
	check("valid_assignment", sql`((assigned_trainer_id IS NULL) AND (assigned_at IS NULL)) OR ((assigned_trainer_id IS NOT NULL) AND (assigned_at IS NOT NULL))`),
	check("valid_resolution", sql`((status <> 'resolved'::text) AND (resolved_at IS NULL)) OR ((status = 'resolved'::text) AND (resolved_at IS NOT NULL))`),
]);

export const studentEnrollments = pgTable("student_enrollments", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	courseId: uuid("course_id").notNull(),
	status: text().default('pending').notNull(),
	enrolledAt: timestamp("enrolled_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	startsAt: timestamp("starts_at", { withTimezone: true, mode: 'string' }),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	droppedAt: timestamp("dropped_at", { withTimezone: true, mode: 'string' }),
	paymentId: text("payment_id"),
	paymentAmount: numeric("payment_amount", { precision: 10, scale:  2 }),
	paymentType: text("payment_type"),
	currentModuleId: uuid("current_module_id"),
	currentTopicId: uuid("current_topic_id"),
	completionPercentage: integer("completion_percentage").default(0),
	enrollmentSource: text("enrollment_source"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	isAtRisk: boolean("is_at_risk").default(false),
	atRiskSince: timestamp("at_risk_since", { withTimezone: true, mode: 'string' }),
	riskLevel: text("risk_level"),
	riskReasons: text("risk_reasons").array(),
}, (table) => [
	index("idx_enrollments_active").using("btree", table.userId.asc().nullsLast().op("text_ops"), table.status.asc().nullsLast().op("uuid_ops")).where(sql`(status = 'active'::text)`),
	index("idx_enrollments_course_id").using("btree", table.courseId.asc().nullsLast().op("uuid_ops")),
	index("idx_enrollments_payment").using("btree", table.paymentId.asc().nullsLast().op("text_ops")).where(sql`(payment_id IS NOT NULL)`),
	index("idx_enrollments_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_enrollments_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	index("idx_student_enrollments_at_risk").using("btree", table.isAtRisk.asc().nullsLast().op("text_ops"), table.riskLevel.asc().nullsLast().op("bool_ops")).where(sql`(is_at_risk = true)`),
	index("idx_student_enrollments_enrolled_month").using("btree", table.courseId.asc().nullsLast().op("timestamptz_ops"), table.enrolledAt.asc().nullsLast().op("timestamptz_ops")),
	foreignKey({
			columns: [table.courseId],
			foreignColumns: [courses.id],
			name: "student_enrollments_course_id_fkey"
		}).onDelete("restrict"),
	foreignKey({
			columns: [table.currentModuleId],
			foreignColumns: [courseModules.id],
			name: "student_enrollments_current_module_id_fkey"
		}),
	foreignKey({
			columns: [table.currentTopicId],
			foreignColumns: [moduleTopics.id],
			name: "student_enrollments_current_topic_id_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "student_enrollments_user_id_fkey"
		}).onDelete("cascade"),
	unique("unique_user_course_enrollment").on(table.userId, table.courseId),
	pgPolicy("Admins create enrollments", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(EXISTS ( SELECT 1
   FROM user_roles
  WHERE ((user_roles.user_id = auth.uid()) AND (user_roles.role_id IN ( SELECT roles.id
           FROM roles
          WHERE (roles.name = ANY (ARRAY['admin'::text, 'course_admin'::text])))))))`  }),
	pgPolicy("Students update own enrollments", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("Students view own enrollments", { as: "permissive", for: "select", to: ["public"] }),
	check("student_enrollments_completion_percentage_check", sql`(completion_percentage >= 0) AND (completion_percentage <= 100)`),
	check("student_enrollments_payment_type_check", sql`payment_type = ANY (ARRAY['subscription'::text, 'one_time'::text, 'free'::text, 'scholarship'::text])`),
	check("student_enrollments_risk_level_check", sql`risk_level = ANY (ARRAY['low'::text, 'medium'::text, 'high'::text])`),
	check("student_enrollments_status_check", sql`status = ANY (ARRAY['pending'::text, 'active'::text, 'completed'::text, 'dropped'::text, 'expired'::text])`),
	check("valid_dates", sql`((completed_at IS NULL) OR (completed_at >= enrolled_at)) AND ((dropped_at IS NULL) OR (dropped_at >= enrolled_at))`),
]);

export const discountCodeUsage = pgTable("discount_code_usage", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	discountCodeId: uuid("discount_code_id").notNull(),
	userId: uuid("user_id").notNull(),
	enrollmentId: uuid("enrollment_id"),
	originalAmount: numeric("original_amount", { precision: 10, scale:  2 }).notNull(),
	discountAmount: numeric("discount_amount", { precision: 10, scale:  2 }).notNull(),
	finalAmount: numeric("final_amount", { precision: 10, scale:  2 }).notNull(),
	stripePaymentIntentId: text("stripe_payment_intent_id"),
	usedAt: timestamp("used_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_discount_usage_code").using("btree", table.discountCodeId.asc().nullsLast().op("uuid_ops")),
	index("idx_discount_usage_enrollment").using("btree", table.enrollmentId.asc().nullsLast().op("uuid_ops")),
	index("idx_discount_usage_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	uniqueIndex("idx_discount_usage_user_code").using("btree", table.userId.asc().nullsLast().op("uuid_ops"), table.discountCodeId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.discountCodeId],
			foreignColumns: [discountCodes.id],
			name: "discount_code_usage_discount_code_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.enrollmentId],
			foreignColumns: [studentEnrollments.id],
			name: "discount_code_usage_enrollment_id_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "discount_code_usage_user_id_fkey"
		}),
	pgPolicy("discount_usage_admin_all", { as: "permissive", for: "all", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM (user_roles ur
     JOIN roles r ON ((r.id = ur.role_id)))
  WHERE ((ur.user_id = auth.uid()) AND (r.name = ANY (ARRAY['admin'::text, 'super_admin'::text])))))` }),
	pgPolicy("discount_usage_own_read", { as: "permissive", for: "select", to: ["public"] }),
]);

export const coursePricing = pgTable("course_pricing", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	courseId: uuid("course_id").notNull(),
	priceMonthly: numeric("price_monthly", { precision: 10, scale:  2 }),
	priceAnnual: numeric("price_annual", { precision: 10, scale:  2 }),
	priceOneTime: numeric("price_one_time", { precision: 10, scale:  2 }),
	stripePriceIdMonthly: text("stripe_price_id_monthly"),
	stripePriceIdAnnual: text("stripe_price_id_annual"),
	stripePriceIdOneTime: text("stripe_price_id_one_time"),
	stripeProductId: text("stripe_product_id"),
	earlyBirdPrice: numeric("early_bird_price", { precision: 10, scale:  2 }),
	earlyBirdValidUntil: timestamp("early_bird_valid_until", { withTimezone: true, mode: 'string' }),
	scholarshipAvailable: boolean("scholarship_available").default(false),
	scholarshipCriteria: text("scholarship_criteria"),
	teamDiscountPercentage: numeric("team_discount_percentage", { precision: 5, scale:  2 }),
	minTeamSize: integer("min_team_size").default(5),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_course_pricing_course").using("btree", table.courseId.asc().nullsLast().op("uuid_ops")),
	index("idx_course_pricing_early_bird").using("btree", table.earlyBirdValidUntil.asc().nullsLast().op("timestamptz_ops")).where(sql`(early_bird_price IS NOT NULL)`),
	foreignKey({
			columns: [table.courseId],
			foreignColumns: [courses.id],
			name: "course_pricing_course_id_fkey"
		}).onDelete("cascade"),
	unique("course_pricing_course_id_key").on(table.courseId),
	pgPolicy("course_pricing_admin_all", { as: "permissive", for: "all", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM (user_roles ur
     JOIN roles r ON ((r.id = ur.role_id)))
  WHERE ((ur.user_id = auth.uid()) AND (r.name = ANY (ARRAY['admin'::text, 'super_admin'::text])))))` }),
	pgPolicy("course_pricing_public_read", { as: "permissive", for: "select", to: ["public"] }),
]);

export const organizationSettings = pgTable("organization_settings", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	key: varchar({ length: 100 }).notNull(),
	value: jsonb().default({}).notNull(),
	category: varchar({ length: 50 }).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedBy: uuid("updated_by"),
}, (table) => [
	index("idx_org_settings_category").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.category.asc().nullsLast().op("uuid_ops")),
	index("idx_org_settings_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "organization_settings_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "organization_settings_updated_by_fkey"
		}),
	unique("organization_settings_org_id_key_key").on(table.orgId, table.key),
	pgPolicy("Users can manage their org settings", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id = auth_user_org_id()) OR user_is_admin())` }),
	pgPolicy("Users can view their org settings", { as: "permissive", for: "select", to: ["public"] }),
]);

export const contactLeadData = pgTable("contact_lead_data", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	contactId: uuid("contact_id").notNull(),
	leadScore: integer("lead_score"),
	leadStatus: text("lead_status").default('new'),
	qualificationStatus: text("qualification_status"),
	budgetConfirmed: boolean("budget_confirmed").default(false),
	authorityConfirmed: boolean("authority_confirmed").default(false),
	needConfirmed: boolean("need_confirmed").default(false),
	timelineConfirmed: boolean("timeline_confirmed").default(false),
	estimatedValue: numeric("estimated_value", { precision: 12, scale:  2 }),
	estimatedCloseDate: date("estimated_close_date"),
	convertedToDealId: uuid("converted_to_deal_id"),
	convertedToAccountId: uuid("converted_to_account_id"),
	convertedAt: timestamp("converted_at", { withTimezone: true, mode: 'string' }),
	lostReason: text("lost_reason"),
	sourceCampaignId: uuid("source_campaign_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_contact_lead_data_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")),
	index("idx_contact_lead_data_status").using("btree", table.leadStatus.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "contact_lead_data_contact_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.sourceCampaignId],
			foreignColumns: [campaigns.id],
			name: "contact_lead_data_source_campaign_id_fkey"
		}),
	unique("contact_lead_data_contact_id_key").on(table.contactId),
	check("contact_lead_data_lead_score_check", sql`(lead_score >= 0) AND (lead_score <= 100)`),
	check("contact_lead_data_lead_status_check", sql`lead_status = ANY (ARRAY['new'::text, 'warm'::text, 'hot'::text, 'cold'::text, 'qualified'::text, 'unqualified'::text, 'converted'::text, 'lost'::text])`),
	check("contact_lead_data_qualification_status_check", sql`qualification_status = ANY (ARRAY['unqualified'::text, 'marketing_qualified'::text, 'sales_qualified'::text, 'opportunity'::text])`),
]);

export const comments = pgTable("comments", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: text("entity_type").notNull(),
	entityId: uuid("entity_id").notNull(),
	content: text().notNull(),
	parentCommentId: uuid("parent_comment_id"),
	replyCount: integer("reply_count").default(0),
	authorId: uuid("author_id").notNull(),
	mentionedUserIds: uuid("mentioned_user_ids").array(),
	reactions: jsonb().default({}),
	isDeleted: boolean("is_deleted").default(false),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	deletedBy: uuid("deleted_by"),
	isEdited: boolean("is_edited").default(false),
	editedAt: timestamp("edited_at", { withTimezone: true, mode: 'string' }),
	originalContent: text("original_content"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_comments_author").using("btree", table.authorId.asc().nullsLast().op("uuid_ops")),
	index("idx_comments_created").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_comments_entity").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("text_ops")).where(sql`(NOT is_deleted)`),
	index("idx_comments_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_comments_parent").using("btree", table.parentCommentId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.authorId],
			foreignColumns: [userProfiles.id],
			name: "comments_author_id_fkey"
		}),
	foreignKey({
			columns: [table.deletedBy],
			foreignColumns: [userProfiles.id],
			name: "comments_deleted_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "comments_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.parentCommentId],
			foreignColumns: [table.id],
			name: "comments_parent_comment_id_fkey"
		}),
	pgPolicy("comments_create_employee", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`((author_id = auth.uid()) AND (auth_has_role('employee'::text) OR auth_has_role('admin'::text)))`  }),
	pgPolicy("comments_delete_own_or_admin", { as: "permissive", for: "delete", to: ["public"] }),
	pgPolicy("comments_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	pgPolicy("comments_read_all", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("comments_update_own", { as: "permissive", for: "update", to: ["public"] }),
]);

export const leadTasks = pgTable("lead_tasks", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	leadId: uuid("lead_id").notNull(),
	title: text().notNull(),
	description: text(),
	dueDate: date("due_date").notNull(),
	priority: text().default('medium').notNull(),
	completed: boolean().default(false).notNull(),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	completedBy: uuid("completed_by"),
	assignedTo: uuid("assigned_to"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_lead_tasks_completed").using("btree", table.completed.asc().nullsLast().op("bool_ops")).where(sql`(NOT completed)`),
	index("idx_lead_tasks_due_date").using("btree", table.dueDate.asc().nullsLast().op("date_ops")),
	index("idx_lead_tasks_lead_id").using("btree", table.leadId.asc().nullsLast().op("uuid_ops")),
	index("idx_lead_tasks_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.assignedTo],
			foreignColumns: [userProfiles.id],
			name: "lead_tasks_assigned_to_fkey"
		}),
	foreignKey({
			columns: [table.completedBy],
			foreignColumns: [userProfiles.id],
			name: "lead_tasks_completed_by_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "lead_tasks_created_by_fkey"
		}),
	foreignKey({
			columns: [table.leadId],
			foreignColumns: [leads.id],
			name: "lead_tasks_lead_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "lead_tasks_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("lead_tasks_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid())))` }),
	check("lead_tasks_priority_check", sql`priority = ANY (ARRAY['low'::text, 'medium'::text, 'high'::text])`),
]);

export const notifications = pgTable("notifications", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	userId: uuid("user_id").notNull(),
	notificationType: text("notification_type").notNull(),
	title: text().notNull(),
	message: text().notNull(),
	entityType: text("entity_type"),
	entityId: uuid("entity_id"),
	channels: text().array().default(["RAY['in_app'::tex"]),
	emailSentAt: timestamp("email_sent_at", { withTimezone: true, mode: 'string' }),
	emailError: text("email_error"),
	slackSentAt: timestamp("slack_sent_at", { withTimezone: true, mode: 'string' }),
	slackError: text("slack_error"),
	isRead: boolean("is_read").default(false),
	readAt: timestamp("read_at", { withTimezone: true, mode: 'string' }),
	isArchived: boolean("is_archived").default(false),
	archivedAt: timestamp("archived_at", { withTimezone: true, mode: 'string' }),
	priority: text().default('normal'),
	actionUrl: text("action_url"),
	actionLabel: text("action_label"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_notifications_created").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_notifications_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("uuid_ops")),
	index("idx_notifications_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_notifications_type").using("btree", table.notificationType.asc().nullsLast().op("text_ops")),
	index("idx_notifications_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	index("idx_notifications_user_unread").using("btree", table.userId.asc().nullsLast().op("uuid_ops"), table.isRead.asc().nullsLast().op("uuid_ops")).where(sql`((NOT is_read) AND (NOT is_archived))`),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "notifications_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "notifications_user_id_fkey"
		}),
	pgPolicy("notifications_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
	pgPolicy("notifications_system_create", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("notifications_user_own", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("notifications_user_update_own", { as: "permissive", for: "update", to: ["public"] }),
]);

export const tasks = pgTable("tasks", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	title: text().notNull(),
	description: text(),
	entityType: text("entity_type"),
	entityId: uuid("entity_id"),
	assignedTo: uuid("assigned_to"),
	createdBy: uuid("created_by").notNull(),
	status: text().default('todo').notNull(),
	priority: text().default('medium'),
	dueDate: date("due_date"),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	completedBy: uuid("completed_by"),
	isRecurring: boolean("is_recurring").default(false),
	recurrencePattern: text("recurrence_pattern"),
	parentTaskId: uuid("parent_task_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_tasks_assigned").using("btree", table.assignedTo.asc().nullsLast().op("text_ops"), table.status.asc().nullsLast().op("text_ops")).where(sql`(status = ANY (ARRAY['todo'::text, 'in_progress'::text]))`),
	index("idx_tasks_assignee").using("btree", table.assignedTo.asc().nullsLast().op("uuid_ops")),
	index("idx_tasks_created_by").using("btree", table.createdBy.asc().nullsLast().op("uuid_ops")),
	index("idx_tasks_due").using("btree", table.dueDate.asc().nullsLast().op("date_ops")).where(sql`(status = ANY (ARRAY['todo'::text, 'in_progress'::text]))`),
	index("idx_tasks_entity").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("text_ops")),
	index("idx_tasks_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_tasks_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.assignedTo],
			foreignColumns: [userProfiles.id],
			name: "tasks_assigned_to_fkey"
		}),
	foreignKey({
			columns: [table.completedBy],
			foreignColumns: [userProfiles.id],
			name: "tasks_completed_by_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "tasks_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "tasks_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.parentTaskId],
			foreignColumns: [table.id],
			name: "tasks_parent_task_id_fkey"
		}),
	pgPolicy("tasks_assigned_or_created", { as: "permissive", for: "select", to: ["public"], using: sql`((assigned_to = auth.uid()) OR (created_by = auth.uid()) OR auth_has_role('admin'::text))` }),
	pgPolicy("tasks_create_own", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("tasks_delete_creator_or_admin", { as: "permissive", for: "delete", to: ["public"] }),
	pgPolicy("tasks_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	pgPolicy("tasks_update_assigned_or_admin", { as: "permissive", for: "update", to: ["public"] }),
]);

export const organizationBranding = pgTable("organization_branding", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	assetType: varchar("asset_type", { length: 50 }).notNull(),
	storagePath: text("storage_path").notNull(),
	fileName: text("file_name").notNull(),
	fileSize: integer("file_size"),
	mimeType: varchar("mime_type", { length: 100 }),
	width: integer(),
	height: integer(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	uploadedBy: uuid("uploaded_by"),
}, (table) => [
	index("idx_org_branding_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "organization_branding_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.uploadedBy],
			foreignColumns: [userProfiles.id],
			name: "organization_branding_uploaded_by_fkey"
		}),
	unique("organization_branding_org_id_asset_type_key").on(table.orgId, table.assetType),
	pgPolicy("Users can manage their org branding", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id = auth_user_org_id()) OR user_is_admin())` }),
	pgPolicy("Users can view their org branding", { as: "permissive", for: "select", to: ["public"] }),
]);

export const companyContracts = pgTable("company_contracts", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	companyId: uuid("company_id").notNull(),
	contractType: contractType("contract_type").notNull(),
	contractNumber: varchar("contract_number", { length: 50 }),
	name: text().notNull(),
	description: text(),
	status: contractStatus().default('draft'),
	effectiveDate: date("effective_date"),
	expirationDate: date("expiration_date"),
	signedDate: date("signed_date"),
	terminatedDate: date("terminated_date"),
	autoRenews: boolean("auto_renews").default(false),
	renewalTermMonths: integer("renewal_term_months"),
	renewalNoticeDays: integer("renewal_notice_days").default(30),
	contractValue: numeric("contract_value", { precision: 15, scale:  2 }),
	currency: varchar({ length: 3 }).default('USD'),
	ourSignatoryId: uuid("our_signatory_id"),
	theirSignatoryName: text("their_signatory_name"),
	theirSignatoryTitle: text("their_signatory_title"),
	theirSignatoryEmail: text("their_signatory_email"),
	documentUrl: text("document_url"),
	documentStorageKey: text("document_storage_key"),
	terms: jsonb().default({}),
	parentContractId: uuid("parent_contract_id"),
	expirationAlertSent: boolean("expiration_alert_sent").default(false),
	expirationAlertDate: date("expiration_alert_date"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_contracts_company").using("btree", table.companyId.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contracts_expiration").using("btree", table.expirationDate.asc().nullsLast().op("date_ops")).where(sql`((status = 'active'::contract_status) AND (deleted_at IS NULL))`),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "company_contracts_company_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "company_contracts_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "company_contracts_org_id_fkey"
		}),
	foreignKey({
			columns: [table.ourSignatoryId],
			foreignColumns: [userProfiles.id],
			name: "company_contracts_our_signatory_id_fkey"
		}),
	foreignKey({
			columns: [table.parentContractId],
			foreignColumns: [table.id],
			name: "company_contracts_parent_contract_id_fkey"
		}),
	pgPolicy("contracts_org", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const companyRateCards = pgTable("company_rate_cards", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	companyId: uuid("company_id").notNull(),
	name: text().notNull(),
	version: integer().default(1),
	effectiveStartDate: date("effective_start_date").notNull(),
	effectiveEndDate: date("effective_end_date"),
	status: rateCardStatus().default('draft'),
	currency: varchar({ length: 3 }).default('USD'),
	applicableRegions: text("applicable_regions").array(),
	mspProgramId: uuid("msp_program_id"),
	mspTier: integer("msp_tier"),
	defaultMarkupPercentage: numeric("default_markup_percentage", { precision: 5, scale:  2 }),
	maxMarkupPercentage: numeric("max_markup_percentage", { precision: 5, scale:  2 }),
	minMarginPercentage: numeric("min_margin_percentage", { precision: 5, scale:  2 }),
	overtimeMultiplier: numeric("overtime_multiplier", { precision: 3, scale:  2 }).default('1.5'),
	doubleTimeMultiplier: numeric("double_time_multiplier", { precision: 3, scale:  2 }).default('2.0'),
	directHireFeePercentage: numeric("direct_hire_fee_percentage", { precision: 5, scale:  2 }).default('20.00'),
	guaranteePeriodDays: integer("guarantee_period_days").default(90),
	cthConversionFeePercentage: numeric("cth_conversion_fee_percentage", { precision: 5, scale:  2 }),
	cthHoursCredit: integer("cth_hours_credit").default(0),
	perDiemRate: numeric("per_diem_rate", { precision: 8, scale:  2 }),
	mileageRate: numeric("mileage_rate", { precision: 5, scale:  3 }),
	expenseMarkupPercentage: numeric("expense_markup_percentage", { precision: 5, scale:  2 }).default('0'),
	notes: text(),
	approvedBy: uuid("approved_by"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_rate_cards_company").using("btree", table.companyId.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.approvedBy],
			foreignColumns: [userProfiles.id],
			name: "company_rate_cards_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "company_rate_cards_company_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "company_rate_cards_created_by_fkey"
		}),
	foreignKey({
			columns: [table.mspProgramId],
			foreignColumns: [companies.id],
			name: "company_rate_cards_msp_program_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "company_rate_cards_org_id_fkey"
		}),
	pgPolicy("rate_cards_org", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const companyRateCardItems = pgTable("company_rate_card_items", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	rateCardId: uuid("rate_card_id").notNull(),
	jobCategory: text("job_category").notNull(),
	jobLevel: text("job_level"),
	jobFamily: text("job_family"),
	minPayRate: numeric("min_pay_rate", { precision: 10, scale:  2 }),
	maxPayRate: numeric("max_pay_rate", { precision: 10, scale:  2 }),
	targetPayRate: numeric("target_pay_rate", { precision: 10, scale:  2 }),
	minBillRate: numeric("min_bill_rate", { precision: 10, scale:  2 }),
	maxBillRate: numeric("max_bill_rate", { precision: 10, scale:  2 }),
	standardBillRate: numeric("standard_bill_rate", { precision: 10, scale:  2 }),
	targetMarginPercentage: numeric("target_margin_percentage", { precision: 5, scale:  2 }),
	minMarginPercentage: numeric("min_margin_percentage", { precision: 5, scale:  2 }),
	rateType: varchar("rate_type", { length: 20 }).default('hourly'),
	overtimeMultiplier: numeric("overtime_multiplier", { precision: 3, scale:  2 }),
	sortOrder: integer("sort_order").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_rate_card_items_card").using("btree", table.rateCardId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.rateCardId],
			foreignColumns: [companyRateCards.id],
			name: "company_rate_card_items_rate_card_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("rate_card_items_org", { as: "permissive", for: "all", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM company_rate_cards rc
  WHERE ((rc.id = company_rate_card_items.rate_card_id) AND (rc.org_id = current_user_org_id()))))` }),
]);

export const companyComplianceRequirements = pgTable("company_compliance_requirements", {
	companyId: uuid("company_id").primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	generalLiabilityRequired: boolean("general_liability_required").default(false),
	generalLiabilityMinimum: text("general_liability_minimum"),
	professionalLiabilityRequired: boolean("professional_liability_required").default(false),
	professionalLiabilityMinimum: text("professional_liability_minimum"),
	workersCompRequired: boolean("workers_comp_required").default(true),
	cyberLiabilityRequired: boolean("cyber_liability_required").default(false),
	cyberLiabilityMinimum: text("cyber_liability_minimum"),
	umbrellaRequired: boolean("umbrella_required").default(false),
	umbrellaMinimum: text("umbrella_minimum"),
	coiOnFile: boolean("coi_on_file").default(false),
	coiExpirationDate: date("coi_expiration_date"),
	coiDocumentUrl: text("coi_document_url"),
	clientNamedOnCoi: boolean("client_named_on_coi").default(false),
	backgroundCheckRequired: boolean("background_check_required").default(false),
	backgroundCheckLevel: varchar("background_check_level", { length: 50 }),
	backgroundCheckVendor: varchar("background_check_vendor", { length: 50 }),
	backgroundCheckMaxAgeDays: integer("background_check_max_age_days").default(365),
	drugTestRequired: boolean("drug_test_required").default(false),
	drugTestType: varchar("drug_test_type", { length: 20 }),
	drugTestFrequency: varchar("drug_test_frequency", { length: 20 }),
	securityClearanceRequired: boolean("security_clearance_required").default(false),
	securityClearanceLevel: varchar("security_clearance_level", { length: 50 }),
	citizenshipRequired: varchar("citizenship_required", { length: 50 }),
	hipaaTrainingRequired: boolean("hipaa_training_required").default(false),
	soxComplianceRequired: boolean("sox_compliance_required").default(false),
	pciComplianceRequired: boolean("pci_compliance_required").default(false),
	fedrampRequired: boolean("fedramp_required").default(false),
	w9Required: boolean("w9_required").default(true),
	ndaRequired: boolean("nda_required").default(false),
	nonCompeteRequired: boolean("non_compete_required").default(false),
	i9VerificationMethod: varchar("i9_verification_method", { length: 20 }).default('standard'),
	workAuthorizationTypes: text("work_authorization_types").array(),
	soc2AttestationRequired: boolean("soc2_attestation_required").default(false),
	gdprComplianceRequired: boolean("gdpr_compliance_required").default(false),
	ccpaComplianceRequired: boolean("ccpa_compliance_required").default(false),
	dataRetentionYears: integer("data_retention_years").default(7),
	dataHandlingInstructions: text("data_handling_instructions"),
	safetyTrainingRequired: boolean("safety_training_required").default(false),
	safetyCertifications: text("safety_certifications").array(),
	ppeRequirements: text("ppe_requirements").array(),
	customRequirements: jsonb("custom_requirements").default({}),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedBy: uuid("updated_by"),
}, (table) => [
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "company_compliance_requirements_company_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "company_compliance_requirements_org_id_fkey"
		}),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "company_compliance_requirements_updated_by_fkey"
		}),
	pgPolicy("compliance_org", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const companyHealthScores = pgTable("company_health_scores", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	companyId: uuid("company_id").notNull(),
	scoreDate: date("score_date").default(sql`CURRENT_DATE`).notNull(),
	overallScore: integer("overall_score"),
	overallGrade: char("overall_grade", { length: 1 }),
	healthStatus: varchar("health_status", { length: 20 }),
	engagementScore: integer("engagement_score"),
	daysSinceLastContact: integer("days_since_last_contact"),
	daysSinceLastJob: integer("days_since_last_job"),
	responseRatePercentage: numeric("response_rate_percentage", { precision: 5, scale:  2 }),
	meetingsLast90D: integer("meetings_last_90d"),
	financialScore: integer("financial_score"),
	revenueTrend: varchar("revenue_trend", { length: 10 }),
	revenueVsTargetPercentage: numeric("revenue_vs_target_percentage", { precision: 5, scale:  2 }),
	paymentTimelinessScore: integer("payment_timeliness_score"),
	outstandingArAmount: numeric("outstanding_ar_amount", { precision: 12, scale:  2 }),
	relationshipScore: integer("relationship_score"),
	npsScore: integer("nps_score"),
	satisfactionScore: numeric("satisfaction_score", { precision: 3, scale:  1 }),
	escalationsLast90D: integer("escalations_last_90d"),
	decisionMakerTurnover: boolean("decision_maker_turnover").default(false),
	opportunityScore: integer("opportunity_score"),
	activeJobsCount: integer("active_jobs_count"),
	pipelineValue: numeric("pipeline_value", { precision: 12, scale:  2 }),
	expansionPotential: varchar("expansion_potential", { length: 20 }),
	riskFactors: jsonb("risk_factors").default([]),
	recommendedActions: jsonb("recommended_actions").default([]),
	calculatedAt: timestamp("calculated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	calculatedBy: varchar("calculated_by", { length: 50 }).default('system'),
}, (table) => [
	index("idx_health_scores_company").using("btree", table.companyId.asc().nullsLast().op("date_ops"), table.scoreDate.desc().nullsFirst().op("date_ops")),
	index("idx_health_scores_date").using("btree", table.orgId.asc().nullsLast().op("date_ops"), table.scoreDate.desc().nullsFirst().op("date_ops")),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "company_health_scores_company_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "company_health_scores_org_id_fkey"
		}),
	pgPolicy("health_scores_org", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
	check("company_health_scores_engagement_score_check", sql`(engagement_score >= 0) AND (engagement_score <= 30)`),
	check("company_health_scores_financial_score_check", sql`(financial_score >= 0) AND (financial_score <= 30)`),
	check("company_health_scores_opportunity_score_check", sql`(opportunity_score >= 0) AND (opportunity_score <= 20)`),
	check("company_health_scores_overall_grade_check", sql`overall_grade = ANY (ARRAY['A'::bpchar, 'B'::bpchar, 'C'::bpchar, 'D'::bpchar, 'F'::bpchar])`),
	check("company_health_scores_overall_score_check", sql`(overall_score >= 0) AND (overall_score <= 100)`),
	check("company_health_scores_relationship_score_check", sql`(relationship_score >= 0) AND (relationship_score <= 20)`),
]);

export const companyMetrics = pgTable("company_metrics", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	companyId: uuid("company_id").notNull(),
	periodType: metricPeriodType("period_type").notNull(),
	periodStart: date("period_start").notNull(),
	periodEnd: date("period_end").notNull(),
	jobsPosted: integer("jobs_posted").default(0),
	jobsFilled: integer("jobs_filled").default(0),
	jobsCancelled: integer("jobs_cancelled").default(0),
	fillRate: numeric("fill_rate", { precision: 5, scale:  2 }),
	avgTimeToFillDays: integer("avg_time_to_fill_days"),
	submissionsSent: integer("submissions_sent").default(0),
	submissionsAccepted: integer("submissions_accepted").default(0),
	submissionsRejected: integer("submissions_rejected").default(0),
	submissionToInterviewRate: numeric("submission_to_interview_rate", { precision: 5, scale:  2 }),
	interviewsScheduled: integer("interviews_scheduled").default(0),
	interviewsCompleted: integer("interviews_completed").default(0),
	interviewsCancelled: integer("interviews_cancelled").default(0),
	interviewToOfferRate: numeric("interview_to_offer_rate", { precision: 5, scale:  2 }),
	placementsStarted: integer("placements_started").default(0),
	placementsEnded: integer("placements_ended").default(0),
	placementsActiveEop: integer("placements_active_eop").default(0),
	avgPlacementDurationDays: integer("avg_placement_duration_days"),
	grossRevenue: numeric("gross_revenue", { precision: 15, scale:  2 }).default('0'),
	netRevenue: numeric("net_revenue", { precision: 15, scale:  2 }).default('0'),
	grossMargin: numeric("gross_margin", { precision: 15, scale:  2 }).default('0'),
	grossMarginPercentage: numeric("gross_margin_percentage", { precision: 5, scale:  2 }),
	revenuePerPlacement: numeric("revenue_per_placement", { precision: 12, scale:  2 }),
	activitiesLogged: integer("activities_logged").default(0),
	emailsSent: integer("emails_sent").default(0),
	callsMade: integer("calls_made").default(0),
	meetingsHeld: integer("meetings_held").default(0),
	engagementScore: integer("engagement_score"),
	performanceScore: integer("performance_score"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_company_metrics_lookup").using("btree", table.companyId.asc().nullsLast().op("date_ops"), table.periodType.asc().nullsLast().op("date_ops"), table.periodStart.desc().nullsFirst().op("date_ops")),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "company_metrics_company_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "company_metrics_org_id_fkey"
		}),
	unique("company_metrics_company_id_period_type_period_start_key").on(table.companyId, table.periodType, table.periodStart),
	pgPolicy("metrics_org", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const companyRevenue = pgTable("company_revenue", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	companyId: uuid("company_id").notNull(),
	revenueType: varchar("revenue_type", { length: 50 }).notNull(),
	placementId: uuid("placement_id"),
	jobId: uuid("job_id"),
	invoiceId: uuid("invoice_id"),
	revenueDate: date("revenue_date").notNull(),
	periodStart: date("period_start"),
	periodEnd: date("period_end"),
	grossRevenue: numeric("gross_revenue", { precision: 12, scale:  2 }).notNull(),
	cost: numeric({ precision: 12, scale:  2 }).default('0'),
	grossMargin: numeric("gross_margin", { precision: 12, scale:  2 }),
	marginPercentage: numeric("margin_percentage", { precision: 5, scale:  2 }),
	currency: varchar({ length: 3 }).default('USD'),
	billingCompanyId: uuid("billing_company_id"),
	endClientCompanyId: uuid("end_client_company_id"),
	jobCategory: text("job_category"),
	jobLevel: text("job_level"),
	workLocationState: text("work_location_state"),
	contractType: varchar("contract_type", { length: 20 }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_company_revenue_company").using("btree", table.companyId.asc().nullsLast().op("date_ops"), table.revenueDate.desc().nullsFirst().op("date_ops")),
	foreignKey({
			columns: [table.billingCompanyId],
			foreignColumns: [companies.id],
			name: "company_revenue_billing_company_id_fkey"
		}),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "company_revenue_company_id_fkey"
		}),
	foreignKey({
			columns: [table.endClientCompanyId],
			foreignColumns: [companies.id],
			name: "company_revenue_end_client_company_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "company_revenue_org_id_fkey"
		}),
	pgPolicy("revenue_org", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const activityLog = pgTable("activity_log", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: text("entity_type").notNull(),
	entityId: uuid("entity_id").notNull(),
	activityType: text("activity_type").notNull(),
	subject: text(),
	body: text(),
	direction: text(),
	performedBy: uuid("performed_by"),
	pocId: uuid("poc_id"),
	activityDate: timestamp("activity_date", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	durationMinutes: integer("duration_minutes"),
	outcome: text(),
	nextAction: text("next_action"),
	nextActionDate: timestamp("next_action_date", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_activity_date").using("btree", table.activityDate.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_activity_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("text_ops")),
	index("idx_activity_log_activity_date").using("btree", table.activityDate.asc().nullsLast().op("timestamptz_ops")),
	index("idx_activity_log_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("uuid_ops")),
	index("idx_activity_log_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_activity_log_performed_by").using("btree", table.performedBy.asc().nullsLast().op("uuid_ops")),
	index("idx_activity_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_activity_owner").using("btree", table.performedBy.asc().nullsLast().op("uuid_ops")),
	index("idx_activity_poc").using("btree", table.pocId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "activity_log_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.performedBy],
			foreignColumns: [userProfiles.id],
			name: "activity_log_performed_by_fkey"
		}),
	pgPolicy("activity_employee_insert", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(auth_has_role('employee'::text) OR auth_has_role('admin'::text) OR auth_has_role('recruiter'::text))`  }),
	pgPolicy("activity_employee_select", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("activity_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
]);

export const engagementTracking = pgTable("engagement_tracking", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	campaignContactId: uuid("campaign_contact_id").notNull(),
	eventType: text("event_type").notNull(),
	eventData: jsonb("event_data"),
	eventTimestamp: timestamp("event_timestamp", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	trackingId: text("tracking_id"),
	userAgent: text("user_agent"),
	ipAddress: inet("ip_address"),
	clickedUrl: text("clicked_url"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_engagement_contact").using("btree", table.campaignContactId.asc().nullsLast().op("uuid_ops")),
	index("idx_engagement_timestamp").using("btree", table.eventTimestamp.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_engagement_type").using("btree", table.eventType.asc().nullsLast().op("text_ops")),
]);

export const employeeMetadata = pgTable("employee_metadata", {
	userId: uuid("user_id").primaryKey().notNull(),
	employmentType: text("employment_type").default('full_time'),
	employeeIdNumber: text("employee_id_number"),
	bonusTarget: numeric("bonus_target", { precision: 12, scale:  2 }),
	commissionPlan: text("commission_plan"),
	equityShares: integer("equity_shares"),
	podId: uuid("pod_id"),
	podRole: text("pod_role"),
	kpiTargets: jsonb("kpi_targets"),
	monthlyPlacementTarget: integer("monthly_placement_target"),
	workSchedule: text("work_schedule").default('standard'),
	weeklyHours: integer("weekly_hours").default(40),
	benefitsEligible: boolean("benefits_eligible").default(true),
	benefitsStartDate: date("benefits_start_date"),
	emergencyContactName: text("emergency_contact_name"),
	emergencyContactPhone: text("emergency_contact_phone"),
	emergencyContactRelationship: text("emergency_contact_relationship"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_employee_id_number").using("btree", table.employeeIdNumber.asc().nullsLast().op("text_ops")).where(sql`(employee_id_number IS NOT NULL)`),
	index("idx_employee_metadata_pod").using("btree", table.podId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "employee_metadata_user_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.podId],
			foreignColumns: [pods.id],
			name: "fk_employee_pod"
		}),
	unique("employee_metadata_employee_id_number_key").on(table.employeeIdNumber),
	pgPolicy("employee_metadata_employee_own", { as: "permissive", for: "select", to: ["public"], using: sql`(user_id = auth.uid())` }),
	pgPolicy("employee_metadata_hr_all", { as: "permissive", for: "all", to: ["public"] }),
]);

export const candidateSkills = pgTable("candidate_skills", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	candidateId: uuid("candidate_id").notNull(),
	skillId: uuid("skill_id").notNull(),
	proficiencyLevel: text("proficiency_level").default('intermediate'),
	yearsOfExperience: numeric("years_of_experience", { precision: 4, scale:  1 }),
	isCertified: boolean("is_certified").default(false),
	certificationName: text("certification_name"),
	lastUsedDate: date("last_used_date"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	skillName: text("skill_name"),
	certificationExpiry: date("certification_expiry"),
	isPrimary: boolean("is_primary").default(false),
	source: text(),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_candidate_skills_candidate").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")),
	index("idx_candidate_skills_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_candidate_skills_primary").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")).where(sql`(is_primary = true)`),
	index("idx_candidate_skills_proficiency").using("btree", table.proficiencyLevel.asc().nullsLast().op("text_ops")),
	index("idx_candidate_skills_skill").using("btree", table.skillId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [candidates.id],
			name: "candidate_skills_candidate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidate_skills_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.skillId],
			foreignColumns: [skills.id],
			name: "candidate_skills_skill_id_fkey"
		}),
	unique("candidate_skills_candidate_id_skill_id_key").on(table.candidateId, table.skillId),
	pgPolicy("candidate_skills_candidate_own", { as: "permissive", for: "all", to: ["public"], using: sql`(candidate_id = auth.uid())` }),
	pgPolicy("candidate_skills_employee_read", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("candidate_skills_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	pgPolicy("candidate_skills_recruiter_write", { as: "permissive", for: "all", to: ["public"] }),
]);

export const pods = pgTable("pods", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	podType: text("pod_type").notNull(),
	seniorMemberId: uuid("senior_member_id"),
	juniorMemberId: uuid("junior_member_id"),
	sprintDurationWeeks: integer("sprint_duration_weeks").default(2),
	placementsPerSprintTarget: integer("placements_per_sprint_target").default(2),
	totalPlacements: integer("total_placements").default(0),
	currentSprintPlacements: integer("current_sprint_placements").default(0),
	currentSprintStartDate: date("current_sprint_start_date"),
	averagePlacementsPerSprint: numeric("average_placements_per_sprint", { precision: 5, scale:  2 }),
	isActive: boolean("is_active").default(true),
	formedDate: date("formed_date"),
	dissolvedDate: date("dissolved_date"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	regionId: uuid("region_id"),
	status: text().default('active'),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	managerId: uuid("manager_id"),
	description: text(),
	sprintStartDay: text("sprint_start_day").default('monday'),
	sendSprintSummary: boolean("send_sprint_summary").default(true),
	sendMidpointCheck: boolean("send_midpoint_check").default(true),
	alertIfBelowTarget: boolean("alert_if_below_target").default(true),
	parentId: uuid("parent_id"),
	hierarchyLevel: integer("hierarchy_level").default(0),
	groupId: uuid("group_id"),
}, (table) => [
	index("idx_pods_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")).where(sql`(is_active = true)`),
	index("idx_pods_group_id").using("btree", table.groupId.asc().nullsLast().op("uuid_ops")),
	index("idx_pods_manager_id").using("btree", table.managerId.asc().nullsLast().op("uuid_ops")),
	index("idx_pods_members").using("btree", table.seniorMemberId.asc().nullsLast().op("uuid_ops"), table.juniorMemberId.asc().nullsLast().op("uuid_ops")),
	index("idx_pods_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_pods_region_id").using("btree", table.regionId.asc().nullsLast().op("uuid_ops")),
	index("idx_pods_type").using("btree", table.podType.asc().nullsLast().op("text_ops")),
	index("pods_hierarchy_level_idx").using("btree", table.hierarchyLevel.asc().nullsLast().op("int4_ops")).where(sql`(deleted_at IS NULL)`),
	index("pods_parent_id_idx").using("btree", table.parentId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "pods_created_by_fkey"
		}),
	foreignKey({
			columns: [table.groupId],
			foreignColumns: [groups.id],
			name: "pods_group_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.juniorMemberId],
			foreignColumns: [userProfiles.id],
			name: "pods_junior_member_id_fkey"
		}),
	foreignKey({
			columns: [table.managerId],
			foreignColumns: [userProfiles.id],
			name: "pods_manager_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "pods_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.parentId],
			foreignColumns: [table.id],
			name: "pods_parent_id_fkey"
		}),
	foreignKey({
			columns: [table.regionId],
			foreignColumns: [regions.id],
			name: "pods_region_id_fkey"
		}),
	foreignKey({
			columns: [table.seniorMemberId],
			foreignColumns: [userProfiles.id],
			name: "pods_senior_member_id_fkey"
		}),
	pgPolicy("pods_admin_write", { as: "permissive", for: "all", to: ["public"], using: sql`(auth_has_role('admin'::text) OR auth_has_role('hr'::text))` }),
	pgPolicy("pods_employee_read", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("pods_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	check("pods_pod_type_check", sql`pod_type = ANY (ARRAY['recruiting'::text, 'bench_sales'::text, 'ta'::text, 'hr'::text, 'mixed'::text])`),
	check("pods_sprint_start_day_check", sql`sprint_start_day = ANY (ARRAY['monday'::text, 'tuesday'::text, 'wednesday'::text, 'thursday'::text, 'friday'::text, 'saturday'::text, 'sunday'::text])`),
]);

export const userSessionContext = pgTable("user_session_context", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	activeRole: text("active_role").notNull(),
	sessionStartedAt: timestamp("session_started_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	sessionEndedAt: timestamp("session_ended_at", { withTimezone: true, mode: 'string' }),
	durationSeconds: integer("duration_seconds").generatedAlwaysAs(sql`
CASE
    WHEN (session_ended_at IS NOT NULL) THEN (EXTRACT(epoch FROM (session_ended_at - session_started_at)))::integer
    ELSE NULL::integer
END`),
}, (table) => [
	index("idx_session_context_role").using("btree", table.activeRole.asc().nullsLast().op("text_ops")),
	index("idx_session_context_started").using("btree", table.sessionStartedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_session_context_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "user_session_context_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("session_context_own", { as: "permissive", for: "all", to: ["public"], using: sql`(user_id = auth.uid())` }),
]);

export const podManagers = pgTable("pod_managers", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	podId: uuid("pod_id").notNull(),
	userId: uuid("user_id").notNull(),
	isPrimary: boolean("is_primary").default(true),
	assignedAt: timestamp("assigned_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	assignedBy: uuid("assigned_by"),
	removedAt: timestamp("removed_at", { withTimezone: true, mode: 'string' }),
	removedBy: uuid("removed_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_pod_managers_active").using("btree", table.podId.asc().nullsLast().op("uuid_ops")).where(sql`(removed_at IS NULL)`),
	index("idx_pod_managers_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_pod_managers_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_pod_managers_pod").using("btree", table.podId.asc().nullsLast().op("uuid_ops")),
	index("idx_pod_managers_pod_id").using("btree", table.podId.asc().nullsLast().op("uuid_ops")),
	uniqueIndex("idx_pod_managers_primary").using("btree", table.podId.asc().nullsLast().op("uuid_ops")).where(sql`((is_primary = true) AND (removed_at IS NULL))`),
	index("idx_pod_managers_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	index("idx_pod_managers_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.assignedBy],
			foreignColumns: [userProfiles.id],
			name: "pod_managers_assigned_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "pod_managers_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.podId],
			foreignColumns: [pods.id],
			name: "pod_managers_pod_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.removedBy],
			foreignColumns: [userProfiles.id],
			name: "pod_managers_removed_by_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "pod_managers_user_id_fkey"
		}),
	pgPolicy("pod_managers_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid())
 LIMIT 1))` }),
	pgPolicy("pod_managers_org_policy", { as: "permissive", for: "all", to: ["public"] }),
]);

export const leadStrategies = pgTable("lead_strategies", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	leadId: uuid("lead_id").notNull(),
	strategyNotes: text("strategy_notes"),
	talkingPoints: jsonb("talking_points").default([]),
	valueProposition: text("value_proposition"),
	differentiators: jsonb().default([]),
	objections: jsonb().default([]),
	stakeholders: jsonb().default([]),
	competitors: jsonb().default([]),
	winThemes: jsonb("win_themes").default([]),
	painPoints: jsonb("pain_points").default([]),
	meetingAgenda: jsonb("meeting_agenda").default([]),
	questionsToAsk: jsonb("questions_to_ask").default([]),
	desiredOutcomes: jsonb("desired_outcomes").default([]),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
}, (table) => [
	index("idx_lead_strategies_lead").using("btree", table.leadId.asc().nullsLast().op("uuid_ops")),
	index("idx_lead_strategies_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "lead_strategies_created_by_fkey"
		}),
	foreignKey({
			columns: [table.leadId],
			foreignColumns: [leads.id],
			name: "lead_strategies_lead_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "lead_strategies_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "lead_strategies_updated_by_fkey"
		}),
	unique("lead_strategies_lead_id_key").on(table.leadId),
	pgPolicy("lead_strategies_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
]);

export const talkingPointTemplates = pgTable("talking_point_templates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	description: text(),
	category: text(),
	talkingPoints: jsonb("talking_points").default([]),
	isDefault: boolean("is_default").default(false),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_talking_point_templates_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "talking_point_templates_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "talking_point_templates_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("talking_point_templates_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
]);

export const payrollItems = pgTable("payroll_items", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	payrollRunId: uuid("payroll_run_id").notNull(),
	employeeId: uuid("employee_id").notNull(),
	baseSalary: numeric("base_salary", { precision: 10, scale:  2 }),
	commission: numeric({ precision: 10, scale:  2 }),
	bonus: numeric({ precision: 10, scale:  2 }),
	overtimeHours: numeric("overtime_hours", { precision: 5, scale:  2 }),
	overtimePay: numeric("overtime_pay", { precision: 10, scale:  2 }),
	otherEarnings: numeric("other_earnings", { precision: 10, scale:  2 }),
	grossPay: numeric("gross_pay", { precision: 10, scale:  2 }).notNull(),
	taxesWithheld: numeric("taxes_withheld", { precision: 10, scale:  2 }),
	benefitsDeductions: numeric("benefits_deductions", { precision: 10, scale:  2 }),
	otherDeductions: numeric("other_deductions", { precision: 10, scale:  2 }),
	netPay: numeric("net_pay", { precision: 10, scale:  2 }).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_payroll_items_employee").using("btree", table.employeeId.asc().nullsLast().op("uuid_ops")),
	index("idx_payroll_items_run").using("btree", table.payrollRunId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.employeeId],
			foreignColumns: [userProfiles.id],
			name: "payroll_items_employee_id_fkey"
		}),
	foreignKey({
			columns: [table.payrollRunId],
			foreignColumns: [payrollRuns.id],
			name: "payroll_items_payroll_run_id_fkey"
		}).onDelete("cascade"),
	unique("payroll_items_payroll_run_id_employee_id_key").on(table.payrollRunId, table.employeeId),
	pgPolicy("payroll_items_employee_own", { as: "permissive", for: "select", to: ["public"], using: sql`(employee_id = auth.uid())` }),
	pgPolicy("payroll_items_hr_admin_only", { as: "permissive", for: "all", to: ["public"] }),
]);

export const timeAttendance = pgTable("time_attendance", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	employeeId: uuid("employee_id").notNull(),
	date: date().notNull(),
	regularHours: numeric("regular_hours", { precision: 5, scale:  2 }).default('0'),
	overtimeHours: numeric("overtime_hours", { precision: 5, scale:  2 }).default('0'),
	ptoHours: numeric("pto_hours", { precision: 5, scale:  2 }).default('0'),
	sickHours: numeric("sick_hours", { precision: 5, scale:  2 }).default('0'),
	holidayHours: numeric("holiday_hours", { precision: 5, scale:  2 }).default('0'),
	totalHours: numeric("total_hours", { precision: 5, scale:  2 }).generatedAlwaysAs(sql`((((regular_hours + overtime_hours) + pto_hours) + sick_hours) + holiday_hours)`),
	status: text().default('draft').notNull(),
	approvedBy: uuid("approved_by"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	rejectionReason: text("rejection_reason"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_time_attendance_date").using("btree", table.date.desc().nullsFirst().op("date_ops")),
	index("idx_time_attendance_employee").using("btree", table.employeeId.asc().nullsLast().op("uuid_ops")),
	index("idx_time_attendance_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.approvedBy],
			foreignColumns: [userProfiles.id],
			name: "time_attendance_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.employeeId],
			foreignColumns: [userProfiles.id],
			name: "time_attendance_employee_id_fkey"
		}),
	unique("time_attendance_employee_id_date_key").on(table.employeeId, table.date),
	pgPolicy("time_attendance_employee_own", { as: "permissive", for: "all", to: ["public"], using: sql`(employee_id = auth.uid())` }),
	pgPolicy("time_attendance_hr_read", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("time_attendance_manager_approve", { as: "permissive", for: "update", to: ["public"] }),
]);

export const payrollRuns = pgTable("payroll_runs", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	periodStartDate: date("period_start_date").notNull(),
	periodEndDate: date("period_end_date").notNull(),
	payDate: date("pay_date").notNull(),
	status: text().default('draft').notNull(),
	employeeCount: integer("employee_count").default(0).notNull(),
	totalGrossPay: numeric("total_gross_pay", { precision: 12, scale:  2 }).default('0'),
	totalTaxes: numeric("total_taxes", { precision: 12, scale:  2 }).default('0'),
	totalNetPay: numeric("total_net_pay", { precision: 12, scale:  2 }).default('0'),
	gustoPayrollId: text("gusto_payroll_id"),
	processedAt: timestamp("processed_at", { withTimezone: true, mode: 'string' }),
	processingError: text("processing_error"),
	approvedBy: uuid("approved_by"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_payroll_runs_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_payroll_runs_pay_date").using("btree", table.payDate.desc().nullsFirst().op("date_ops")),
	index("idx_payroll_runs_period").using("btree", table.periodStartDate.asc().nullsLast().op("date_ops"), table.periodEndDate.asc().nullsLast().op("date_ops")),
	index("idx_payroll_runs_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.approvedBy],
			foreignColumns: [userProfiles.id],
			name: "payroll_runs_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "payroll_runs_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "payroll_runs_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("payroll_runs_hr_admin_only", { as: "permissive", for: "all", to: ["public"], using: sql`(auth_has_role('admin'::text) OR auth_has_role('hr'::text))` }),
	pgPolicy("payroll_runs_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
]);

export const performanceReviews = pgTable("performance_reviews", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	employeeId: uuid("employee_id").notNull(),
	reviewerId: uuid("reviewer_id").notNull(),
	reviewCycle: text("review_cycle").notNull(),
	reviewType: text("review_type").default('annual'),
	periodStartDate: date("period_start_date").notNull(),
	periodEndDate: date("period_end_date").notNull(),
	overallRating: integer("overall_rating"),
	qualityOfWork: integer("quality_of_work"),
	communication: integer(),
	teamwork: integer(),
	initiative: integer(),
	reliability: integer(),
	goalsAchieved: jsonb("goals_achieved"),
	goalsNextPeriod: jsonb("goals_next_period"),
	strengths: text(),
	areasForImprovement: text("areas_for_improvement"),
	managerComments: text("manager_comments"),
	employeeSelfAssessment: text("employee_self_assessment"),
	employeeComments: text("employee_comments"),
	status: text().default('draft').notNull(),
	scheduledDate: date("scheduled_date"),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	employeeAcknowledgedAt: timestamp("employee_acknowledged_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_reviews_cycle").using("btree", table.reviewCycle.asc().nullsLast().op("text_ops")),
	index("idx_reviews_employee").using("btree", table.employeeId.asc().nullsLast().op("uuid_ops")),
	index("idx_reviews_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_reviews_reviewer").using("btree", table.reviewerId.asc().nullsLast().op("uuid_ops")),
	index("idx_reviews_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.employeeId],
			foreignColumns: [userProfiles.id],
			name: "performance_reviews_employee_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "performance_reviews_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.reviewerId],
			foreignColumns: [userProfiles.id],
			name: "performance_reviews_reviewer_id_fkey"
		}),
	pgPolicy("performance_reviews_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
	pgPolicy("reviews_employee_own", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("reviews_hr_all", { as: "permissive", for: "all", to: ["public"] }),
	pgPolicy("reviews_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	check("performance_reviews_communication_check", sql`(communication >= 1) AND (communication <= 5)`),
	check("performance_reviews_initiative_check", sql`(initiative >= 1) AND (initiative <= 5)`),
	check("performance_reviews_overall_rating_check", sql`(overall_rating >= 1) AND (overall_rating <= 5)`),
	check("performance_reviews_quality_of_work_check", sql`(quality_of_work >= 1) AND (quality_of_work <= 5)`),
	check("performance_reviews_reliability_check", sql`(reliability >= 1) AND (reliability <= 5)`),
	check("performance_reviews_teamwork_check", sql`(teamwork >= 1) AND (teamwork <= 5)`),
]);

export const importJobs = pgTable("import_jobs", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	fileName: varchar("file_name", { length: 255 }).notNull(),
	filePath: text("file_path").notNull(),
	fileSizeBytes: integer("file_size_bytes"),
	fieldMapping: jsonb("field_mapping").default({}).notNull(),
	importOptions: jsonb("import_options").default({}).notNull(),
	totalRows: integer("total_rows"),
	processedRows: integer("processed_rows").default(0),
	successRows: integer("success_rows").default(0),
	errorRows: integer("error_rows").default(0),
	warningRows: integer("warning_rows").default(0),
	status: varchar({ length: 20 }).default('pending').notNull(),
	errorMessage: text("error_message"),
	errorLog: jsonb("error_log").default([]),
	warningsLog: jsonb("warnings_log").default([]),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	createdBy: uuid("created_by").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_import_jobs_created_at").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_import_jobs_created_by").using("btree", table.createdBy.asc().nullsLast().op("uuid_ops")),
	index("idx_import_jobs_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_import_jobs_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "import_jobs_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "import_jobs_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("import_jobs_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text))` }),
]);

export const exportJobs = pgTable("export_jobs", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	exportName: varchar("export_name", { length: 255 }),
	filters: jsonb().default({}),
	columns: text().array().notNull(),
	format: varchar({ length: 20 }).default('csv').notNull(),
	includeHeaders: boolean("include_headers").default(true),
	isScheduled: boolean("is_scheduled").default(false),
	scheduleCron: varchar("schedule_cron", { length: 100 }),
	scheduleName: varchar("schedule_name", { length: 255 }),
	lastRunAt: timestamp("last_run_at", { withTimezone: true, mode: 'string' }),
	nextRunAt: timestamp("next_run_at", { withTimezone: true, mode: 'string' }),
	filePath: text("file_path"),
	fileSizeBytes: integer("file_size_bytes"),
	recordCount: integer("record_count"),
	status: varchar({ length: 20 }).default('pending').notNull(),
	errorMessage: text("error_message"),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }),
	createdBy: uuid("created_by").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_export_jobs_created_at").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_export_jobs_next_run").using("btree", table.nextRunAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(is_scheduled = true)`),
	index("idx_export_jobs_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_export_jobs_scheduled").using("btree", table.isScheduled.asc().nullsLast().op("bool_ops")).where(sql`(is_scheduled = true)`),
	index("idx_export_jobs_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "export_jobs_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "export_jobs_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("export_jobs_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text))` }),
]);

export const gdprRequests = pgTable("gdpr_requests", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	requestNumber: varchar("request_number", { length: 50 }).notNull(),
	requestType: varchar("request_type", { length: 30 }).notNull(),
	subjectEmail: varchar("subject_email", { length: 255 }).notNull(),
	subjectName: varchar("subject_name", { length: 255 }),
	subjectPhone: varchar("subject_phone", { length: 50 }),
	verificationMethod: varchar("verification_method", { length: 50 }),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	dataFound: jsonb("data_found").default({}),
	tablesScanned: text("tables_scanned").array(),
	totalRecordsFound: integer("total_records_found").default(0),
	status: varchar({ length: 20 }).default('pending').notNull(),
	actionTaken: varchar("action_taken", { length: 50 }),
	exportFilePath: text("export_file_path"),
	anonymizedFields: jsonb("anonymized_fields").default([]),
	notes: text(),
	dueDate: date("due_date").notNull(),
	complianceNotes: text("compliance_notes"),
	processedBy: uuid("processed_by"),
	processedAt: timestamp("processed_at", { withTimezone: true, mode: 'string' }),
	createdBy: uuid("created_by").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_gdpr_requests_due_date").using("btree", table.dueDate.asc().nullsLast().op("date_ops")),
	index("idx_gdpr_requests_email").using("btree", table.subjectEmail.asc().nullsLast().op("text_ops")),
	index("idx_gdpr_requests_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_gdpr_requests_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_gdpr_requests_type").using("btree", table.requestType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "gdpr_requests_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "gdpr_requests_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.processedBy],
			foreignColumns: [userProfiles.id],
			name: "gdpr_requests_processed_by_fkey"
		}),
	pgPolicy("gdpr_requests_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text))` }),
]);

export const duplicateRecords = pgTable("duplicate_records", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	recordId1: uuid("record_id_1").notNull(),
	recordId2: uuid("record_id_2").notNull(),
	confidenceScore: numeric("confidence_score", { precision: 5, scale:  4 }).notNull(),
	matchFields: text("match_fields").array().notNull(),
	matchDetails: jsonb("match_details").default({}),
	status: varchar({ length: 20 }).default('pending').notNull(),
	mergedIntoId: uuid("merged_into_id"),
	dismissedReason: text("dismissed_reason"),
	detectedAt: timestamp("detected_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	reviewedBy: uuid("reviewed_by"),
	reviewedAt: timestamp("reviewed_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_duplicate_records_confidence").using("btree", table.confidenceScore.desc().nullsFirst().op("numeric_ops")),
	index("idx_duplicate_records_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops")),
	index("idx_duplicate_records_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_duplicate_records_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "duplicate_records_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.reviewedBy],
			foreignColumns: [userProfiles.id],
			name: "duplicate_records_reviewed_by_fkey"
		}),
	unique("unique_duplicate_pair").on(table.orgId, table.entityType, table.recordId1, table.recordId2),
	pgPolicy("duplicate_records_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text))` }),
	check("ordered_record_ids", sql`record_id_1 < record_id_2`),
]);

export const duplicateRules = pgTable("duplicate_rules", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	ruleName: varchar("rule_name", { length: 100 }).notNull(),
	isActive: boolean("is_active").default(true),
	matchFields: text("match_fields").array().notNull(),
	matchType: varchar("match_type", { length: 20 }).default('exact').notNull(),
	fuzzyThreshold: numeric("fuzzy_threshold", { precision: 3, scale:  2 }).default('0.85'),
	autoMergeThreshold: numeric("auto_merge_threshold", { precision: 5, scale:  4 }),
	autoMergeEnabled: boolean("auto_merge_enabled").default(false),
	createdBy: uuid("created_by").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_duplicate_rules_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops")),
	index("idx_duplicate_rules_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "duplicate_rules_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "duplicate_rules_org_id_fkey"
		}).onDelete("cascade"),
	unique("unique_rule_name").on(table.orgId, table.entityType, table.ruleName),
	pgPolicy("duplicate_rules_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text))` }),
]);

export const archivedRecords = pgTable("archived_records", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	originalId: uuid("original_id").notNull(),
	originalData: jsonb("original_data").notNull(),
	archiveReason: varchar("archive_reason", { length: 100 }),
	archivedBy: uuid("archived_by").notNull(),
	archivedAt: timestamp("archived_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	restoredAt: timestamp("restored_at", { withTimezone: true, mode: 'string' }),
	restoredBy: uuid("restored_by"),
	permanentlyDeletedAt: timestamp("permanently_deleted_at", { withTimezone: true, mode: 'string' }),
	deletedBy: uuid("deleted_by"),
}, (table) => [
	index("idx_archived_records_archived_at").using("btree", table.archivedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_archived_records_entity").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.originalId.asc().nullsLast().op("uuid_ops")),
	index("idx_archived_records_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.archivedBy],
			foreignColumns: [userProfiles.id],
			name: "archived_records_archived_by_fkey"
		}),
	foreignKey({
			columns: [table.deletedBy],
			foreignColumns: [userProfiles.id],
			name: "archived_records_deleted_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "archived_records_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.restoredBy],
			foreignColumns: [userProfiles.id],
			name: "archived_records_restored_by_fkey"
		}),
	unique("unique_archived_record").on(table.orgId, table.entityType, table.originalId),
	pgPolicy("archived_records_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text))` }),
]);

export const retentionPolicies = pgTable("retention_policies", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	policyName: varchar("policy_name", { length: 100 }).notNull(),
	isActive: boolean("is_active").default(true),
	retentionDays: integer("retention_days").notNull(),
	archiveAfterDays: integer("archive_after_days"),
	deleteAfterArchiveDays: integer("delete_after_archive_days"),
	statusFilter: text("status_filter").array(),
	additionalConditions: jsonb("additional_conditions").default({}),
	createdBy: uuid("created_by").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_retention_policies_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops")),
	index("idx_retention_policies_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "retention_policies_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "retention_policies_org_id_fkey"
		}).onDelete("cascade"),
	unique("unique_retention_policy").on(table.orgId, table.entityType, table.policyName),
	pgPolicy("retention_policies_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text))` }),
]);

export const candidateResumes = pgTable("candidate_resumes", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	version: integer().default(1).notNull(),
	isLatest: boolean("is_latest").default(true).notNull(),
	previousVersionId: uuid("previous_version_id"),
	bucket: text().default('resumes').notNull(),
	filePath: text("file_path").notNull(),
	fileName: text("file_name").notNull(),
	fileSize: integer("file_size").notNull(),
	mimeType: text("mime_type").notNull(),
	resumeType: text("resume_type").default('master'),
	title: text(),
	notes: text(),
	parsedContent: text("parsed_content"),
	parsedSkills: text("parsed_skills").array(),
	parsedExperience: text("parsed_experience"),
	aiSummary: text("ai_summary"),
	submissionWriteUp: text("submission_write_up"),
	uploadedBy: uuid("uploaded_by").notNull(),
	uploadedAt: timestamp("uploaded_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	isArchived: boolean("is_archived").default(false),
	archivedAt: timestamp("archived_at", { withTimezone: true, mode: 'string' }),
	archivedBy: uuid("archived_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_candidate_resumes_candidate_id").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")),
	index("idx_candidate_resumes_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_candidate_resumes_is_latest").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops"), table.isLatest.asc().nullsLast().op("uuid_ops")).where(sql`(is_latest = true)`),
	index("idx_candidate_resumes_not_archived").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")).where(sql`(is_archived = false)`),
	index("idx_candidate_resumes_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_candidate_resumes_resume_type").using("btree", table.resumeType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.archivedBy],
			foreignColumns: [userProfiles.id],
			name: "candidate_resumes_archived_by_fkey"
		}),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "candidate_resumes_candidate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidate_resumes_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "candidate_resumes_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.previousVersionId],
			foreignColumns: [table.id],
			name: "candidate_resumes_previous_version_id_fkey"
		}),
	foreignKey({
			columns: [table.uploadedBy],
			foreignColumns: [userProfiles.id],
			name: "candidate_resumes_uploaded_by_fkey"
		}),
	pgPolicy("Users can insert resumes in their org", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid())))`  }),
	pgPolicy("Users can update resumes in their org", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("Users can view resumes in their org", { as: "permissive", for: "select", to: ["public"] }),
]);

export const candidateBackgroundChecks = pgTable("candidate_background_checks", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	submissionId: uuid("submission_id"),
	placementId: uuid("placement_id"),
	provider: text(),
	providerReferenceId: text("provider_reference_id"),
	providerOrderId: text("provider_order_id"),
	packageName: text("package_name"),
	packageType: text("package_type"),
	status: text().default('not_started').notNull(),
	overallResult: text("overall_result"),
	requestedAt: timestamp("requested_at", { withTimezone: true, mode: 'string' }),
	requestedBy: uuid("requested_by"),
	initiatedAt: timestamp("initiated_at", { withTimezone: true, mode: 'string' }),
	estimatedCompletion: date("estimated_completion"),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }),
	validForMonths: integer("valid_for_months").default(12),
	checks: jsonb().default({}),
	adjudicationStatus: text("adjudication_status"),
	adjudicationNotes: text("adjudication_notes"),
	adjudicatedBy: uuid("adjudicated_by"),
	adjudicatedAt: timestamp("adjudicated_at", { withTimezone: true, mode: 'string' }),
	adverseActionRequired: boolean("adverse_action_required").default(false),
	preAdverseSentAt: timestamp("pre_adverse_sent_at", { withTimezone: true, mode: 'string' }),
	preAdverseResponseDeadline: date("pre_adverse_response_deadline"),
	finalAdverseSentAt: timestamp("final_adverse_sent_at", { withTimezone: true, mode: 'string' }),
	adverseActionNotes: text("adverse_action_notes"),
	consentFormFileId: uuid("consent_form_file_id"),
	consentSignedAt: timestamp("consent_signed_at", { withTimezone: true, mode: 'string' }),
	consentIpAddress: text("consent_ip_address"),
	consentUserAgent: text("consent_user_agent"),
	authorizationFormFileId: uuid("authorization_form_file_id"),
	reportFileId: uuid("report_file_id"),
	reportReceivedAt: timestamp("report_received_at", { withTimezone: true, mode: 'string' }),
	cost: numeric({ precision: 10, scale:  2 }),
	costCurrency: text("cost_currency").default('USD'),
	billedTo: text("billed_to"),
	notes: text(),
	internalNotes: text("internal_notes"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_bgc_candidate").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")),
	index("idx_bgc_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_candidate_background_checks_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "candidate_background_checks_candidate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidate_background_checks_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "candidate_background_checks_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.placementId],
			foreignColumns: [placements.id],
			name: "candidate_background_checks_placement_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.submissionId],
			foreignColumns: [submissions.id],
			name: "candidate_background_checks_submission_id_fkey"
		}).onDelete("set null"),
	pgPolicy("bgv_service_all", { as: "permissive", for: "all", to: ["service_role"], using: sql`true`, withCheck: sql`true`  }),
]);

export const userProfiles = pgTable("user_profiles", {
	id: uuid().default(sql`uuid_generate_v4()`).primaryKey().notNull(),
	authId: uuid("auth_id"),
	email: text().notNull(),
	fullName: text("full_name").notNull(),
	avatarUrl: text("avatar_url"),
	phone: text(),
	timezone: text().default('America/New_York'),
	locale: text().default('en-US'),
	studentEnrollmentDate: timestamp("student_enrollment_date", { withTimezone: true, mode: 'string' }),
	studentCourseId: uuid("student_course_id"),
	studentCurrentModule: text("student_current_module"),
	studentCourseProgress: jsonb("student_course_progress").default({}),
	studentGraduationDate: timestamp("student_graduation_date", { withTimezone: true, mode: 'string' }),
	studentCertificates: jsonb("student_certificates").default([]),
	employeeHireDate: timestamp("employee_hire_date", { withTimezone: true, mode: 'string' }),
	employeeDepartment: text("employee_department"),
	employeePosition: text("employee_position"),
	employeeSalary: numeric("employee_salary", { precision: 10, scale:  2 }),
	employeeStatus: text("employee_status"),
	employeeManagerId: uuid("employee_manager_id"),
	employeePerformanceRating: numeric("employee_performance_rating", { precision: 3, scale:  2 }),
	candidateStatus: text("candidate_status"),
	candidateResumeUrl: text("candidate_resume_url"),
	candidateSkills: text("candidate_skills").array(),
	candidateExperienceYears: integer("candidate_experience_years"),
	candidateCurrentVisa: text("candidate_current_visa"),
	candidateVisaExpiry: timestamp("candidate_visa_expiry", { withTimezone: true, mode: 'string' }),
	candidateHourlyRate: numeric("candidate_hourly_rate", { precision: 10, scale:  2 }),
	candidateBenchStartDate: timestamp("candidate_bench_start_date", { withTimezone: true, mode: 'string' }),
	candidateAvailability: text("candidate_availability"),
	candidateLocation: text("candidate_location"),
	candidateWillingToRelocate: boolean("candidate_willing_to_relocate").default(false),
	clientCompanyName: text("client_company_name"),
	clientIndustry: text("client_industry"),
	clientTier: text("client_tier"),
	clientContractStartDate: timestamp("client_contract_start_date", { withTimezone: true, mode: 'string' }),
	clientContractEndDate: timestamp("client_contract_end_date", { withTimezone: true, mode: 'string' }),
	clientPaymentTerms: integer("client_payment_terms").default(30),
	clientPreferredMarkupPercentage: numeric("client_preferred_markup_percentage", { precision: 5, scale:  2 }),
	recruiterTerritory: text("recruiter_territory"),
	recruiterSpecialization: text("recruiter_specialization").array(),
	recruiterMonthlyPlacementTarget: integer("recruiter_monthly_placement_target").default(2),
	recruiterPodId: uuid("recruiter_pod_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	isActive: boolean("is_active").default(true),
	// TODO: failed to parse database type 'tsvector'
	searchVector: unknown("search_vector"),
	orgId: uuid("org_id").notNull(),
	leaderboardVisible: boolean("leaderboard_visible").default(true),
	firstName: text("first_name"),
	lastName: text("last_name"),
	middleName: text("middle_name"),
	preferredName: text("preferred_name"),
	dateOfBirth: date("date_of_birth"),
	gender: text(),
	nationality: text(),
	emailSecondary: text("email_secondary"),
	phoneHome: text("phone_home"),
	phoneWork: text("phone_work"),
	preferredContactMethod: text("preferred_contact_method"),
	preferredCallTime: text("preferred_call_time"),
	doNotContact: boolean("do_not_contact").default(false),
	doNotEmail: boolean("do_not_email").default(false),
	doNotText: boolean("do_not_text").default(false),
	linkedinUrl: text("linkedin_url"),
	githubUrl: text("github_url"),
	portfolioUrl: text("portfolio_url"),
	personalWebsite: text("personal_website"),
	emergencyContactName: text("emergency_contact_name"),
	emergencyContactRelationship: text("emergency_contact_relationship"),
	emergencyContactPhone: text("emergency_contact_phone"),
	emergencyContactEmail: text("emergency_contact_email"),
	leadSource: text("lead_source"),
	leadSourceDetail: text("lead_source_detail"),
	marketingStatus: text("marketing_status"),
	isOnHotlist: boolean("is_on_hotlist").default(false),
	hotlistAddedAt: timestamp("hotlist_added_at", { withTimezone: true, mode: 'string' }),
	hotlistAddedBy: uuid("hotlist_added_by"),
	hotlistNotes: text("hotlist_notes"),
	currentEmploymentStatus: text("current_employment_status"),
	noticePeriodDays: integer("notice_period_days"),
	earliestStartDate: date("earliest_start_date"),
	preferredEmploymentType: text("preferred_employment_type").array(),
	preferredLocations: text("preferred_locations").array(),
	relocationAssistanceRequired: boolean("relocation_assistance_required").default(false),
	relocationNotes: text("relocation_notes"),
	desiredSalaryAnnual: numeric("desired_salary_annual", { precision: 12, scale:  2 }),
	desiredSalaryCurrency: text("desired_salary_currency").default('USD'),
	minimumHourlyRate: numeric("minimum_hourly_rate", { precision: 10, scale:  2 }),
	minimumAnnualSalary: numeric("minimum_annual_salary", { precision: 12, scale:  2 }),
	benefitsRequired: text("benefits_required").array(),
	compensationNotes: text("compensation_notes"),
	languages: jsonb().default([]),
	recruiterRating: integer("recruiter_rating"),
	recruiterRatingNotes: text("recruiter_rating_notes"),
	profileCompletenessScore: integer("profile_completeness_score").default(0),
	lastProfileUpdate: timestamp("last_profile_update", { withTimezone: true, mode: 'string' }),
	lastActivityDate: timestamp("last_activity_date", { withTimezone: true, mode: 'string' }),
	lastContactedAt: timestamp("last_contacted_at", { withTimezone: true, mode: 'string' }),
	lastContactedBy: uuid("last_contacted_by"),
	professionalHeadline: text("professional_headline"),
	professionalSummary: text("professional_summary"),
	careerObjectives: text("career_objectives"),
	tags: text().array(),
	categories: text().array(),
	employeeRole: text("employee_role"),
	stripeCustomerId: text("stripe_customer_id"),
	title: text(),
	totalPlacements: integer("total_placements").default(0),
	managerId: uuid("manager_id"),
	twoFactorEnabled: boolean("two_factor_enabled").default(false),
	passwordChangedAt: timestamp("password_changed_at", { withTimezone: true, mode: 'string' }),
	startDate: date("start_date"),
	lastLoginAt: timestamp("last_login_at", { withTimezone: true, mode: 'string' }),
	roleId: uuid("role_id"),
	status: text().default('active'),
	primaryGroupId: uuid("primary_group_id"),
}, (table) => [
	index("idx_user_profiles_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_user_profiles_auth").using("btree", table.authId.asc().nullsLast().op("uuid_ops")),
	index("idx_user_profiles_auth_id").using("btree", table.authId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_user_profiles_auth_lookup").using("btree", table.authId.asc().nullsLast().op("uuid_ops"), table.orgId.asc().nullsLast().op("text_ops"), table.email.asc().nullsLast().op("uuid_ops")).where(sql`((deleted_at IS NULL) AND (is_active = true))`),
	index("idx_user_profiles_candidate_skills").using("gin", table.candidateSkills.asc().nullsLast().op("array_ops")).where(sql`((candidate_skills IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_user_profiles_candidate_status").using("btree", table.candidateStatus.asc().nullsLast().op("text_ops")).where(sql`((candidate_status IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_user_profiles_client_tier").using("btree", table.clientTier.asc().nullsLast().op("text_ops")).where(sql`((client_tier IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_user_profiles_created_at").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_user_profiles_email").using("btree", table.email.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_user_profiles_employee_department").using("btree", table.employeeDepartment.asc().nullsLast().op("text_ops")).where(sql`((employee_department IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_user_profiles_employee_role").using("btree", table.employeeRole.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_user_profiles_last_login").using("btree", table.lastLoginAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_user_profiles_leaderboard_visible").using("btree", table.leaderboardVisible.asc().nullsLast().op("bool_ops")).where(sql`(leaderboard_visible = true)`),
	index("idx_user_profiles_manager").using("btree", table.managerId.asc().nullsLast().op("uuid_ops")),
	index("idx_user_profiles_not_deleted").using("btree", table.id.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_user_profiles_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_user_profiles_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_user_profiles_org_id_active").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_user_profiles_primary_group").using("btree", table.primaryGroupId.asc().nullsLast().op("uuid_ops")),
	index("idx_user_profiles_role").using("btree", table.roleId.asc().nullsLast().op("uuid_ops")),
	index("idx_user_profiles_search").using("gin", table.searchVector.asc().nullsLast().op("tsvector_ops")),
	index("idx_user_profiles_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_user_profiles_stripe_customer").using("btree", table.stripeCustomerId.asc().nullsLast().op("text_ops")).where(sql`(stripe_customer_id IS NOT NULL)`),
	index("idx_user_profiles_updated_at").using("btree", table.updatedAt.desc().nullsFirst().op("timestamptz_ops")),
	foreignKey({
			columns: [table.managerId],
			foreignColumns: [table.id],
			name: "user_profiles_manager_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "user_profiles_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.primaryGroupId],
			foreignColumns: [groups.id],
			name: "user_profiles_primary_group_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.roleId],
			foreignColumns: [systemRoles.id],
			name: "user_profiles_role_id_fkey"
		}),
	unique("user_profiles_auth_id_key").on(table.authId),
	unique("user_profiles_email_key").on(table.email),
	pgPolicy("Admins can insert profiles", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`user_is_admin()`  }),
	pgPolicy("Admins can soft delete profiles", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("Admins can update any profile", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("Admins can view all profiles", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("HR managers can view employees", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("Recruiters can view candidates", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("Trainers can view students", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("Users can update own profile", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("Users can view own profile", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("Users can view profiles in their org", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("candidates_context_read", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("user_profiles_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	check("user_profiles_status_check", sql`status = ANY (ARRAY['pending'::text, 'active'::text, 'suspended'::text, 'deactivated'::text])`),
	check("valid_candidate_availability", sql`(candidate_availability IS NULL) OR (candidate_availability = ANY (ARRAY['immediate'::text, '2_weeks'::text, '1_month'::text]))`),
	check("valid_candidate_status", sql`(candidate_status IS NULL) OR (candidate_status = ANY (ARRAY['active'::text, 'placed'::text, 'bench'::text, 'inactive'::text, 'blacklisted'::text]))`),
	check("valid_client_tier", sql`(client_tier IS NULL) OR (client_tier = ANY (ARRAY['preferred'::text, 'strategic'::text, 'exclusive'::text]))`),
	check("valid_email", sql`email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$'::text`),
	check("valid_employee_status", sql`(employee_status IS NULL) OR (employee_status = ANY (ARRAY['active'::text, 'on_leave'::text, 'terminated'::text]))`),
	check("valid_phone", sql`(phone IS NULL) OR (phone ~* '^\+?[1-9]\d{1,14}$'::text)`),
]);

export const candidateCertifications = pgTable("candidate_certifications", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	certificationType: text("certification_type").notNull(),
	name: text().notNull(),
	acronym: text(),
	issuingOrganization: text("issuing_organization"),
	credentialId: text("credential_id"),
	credentialUrl: text("credential_url"),
	issueDate: date("issue_date"),
	expiryDate: date("expiry_date"),
	isLifetime: boolean("is_lifetime").default(false),
	requiresRenewal: boolean("requires_renewal").default(false),
	renewalPeriodMonths: integer("renewal_period_months"),
	cpeCreditsRequired: integer("cpe_credits_required"),
	licenseType: text("license_type"),
	licenseNumber: text("license_number"),
	licenseState: text("license_state"),
	licenseCountry: text("license_country"),
	licenseJurisdiction: text("license_jurisdiction"),
	clearanceLevel: text("clearance_level"),
	clearanceStatus: text("clearance_status"),
	clearanceGrantedDate: date("clearance_granted_date"),
	investigationType: text("investigation_type"),
	polygraphType: text("polygraph_type"),
	polygraphDate: date("polygraph_date"),
	sapAccess: boolean("sap_access").default(false),
	sciAccess: boolean("sci_access").default(false),
	isVerified: boolean("is_verified").default(false),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	verifiedBy: uuid("verified_by"),
	verificationMethod: text("verification_method"),
	verificationNotes: text("verification_notes"),
	documentFileId: uuid("document_file_id"),
	displayOrder: integer("display_order").default(0),
	isFeatured: boolean("is_featured").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_candidate_certifications_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_certifications_candidate").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")),
	index("idx_certifications_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "candidate_certifications_candidate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidate_certifications_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "candidate_certifications_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("certifications_service_all", { as: "permissive", for: "all", to: ["service_role"], using: sql`true`, withCheck: sql`true`  }),
]);

export const candidateComplianceDocuments = pgTable("candidate_compliance_documents", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	placementId: uuid("placement_id"),
	submissionId: uuid("submission_id"),
	documentType: text("document_type").notNull(),
	documentName: text("document_name").notNull(),
	documentDescription: text("document_description"),
	documentCategory: text("document_category"),
	status: text().default('required').notNull(),
	requiredBy: date("required_by"),
	requestedAt: timestamp("requested_at", { withTimezone: true, mode: 'string' }),
	submittedAt: timestamp("submitted_at", { withTimezone: true, mode: 'string' }),
	reviewedAt: timestamp("reviewed_at", { withTimezone: true, mode: 'string' }),
	reviewedBy: uuid("reviewed_by"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	approvedBy: uuid("approved_by"),
	rejectedAt: timestamp("rejected_at", { withTimezone: true, mode: 'string' }),
	rejectedBy: uuid("rejected_by"),
	rejectionReason: text("rejection_reason"),
	effectiveDate: date("effective_date"),
	expiresAt: date("expires_at"),
	fileId: uuid("file_id"),
	fileUrl: text("file_url"),
	fileName: text("file_name"),
	fileSize: integer("file_size"),
	fileMimeType: text("file_mime_type"),
	requiresSignature: boolean("requires_signature").default(true),
	isSigned: boolean("is_signed").default(false),
	signedAt: timestamp("signed_at", { withTimezone: true, mode: 'string' }),
	signerName: text("signer_name"),
	signerEmail: text("signer_email"),
	signatureIp: text("signature_ip"),
	signatureUserAgent: text("signature_user_agent"),
	signatureMethod: text("signature_method"),
	signatureEnvelopeId: text("signature_envelope_id"),
	version: integer().default(1),
	previousVersionId: uuid("previous_version_id"),
	isCurrentVersion: boolean("is_current_version").default(true),
	clientId: uuid("client_id"),
	clientName: text("client_name"),
	notes: text(),
	internalNotes: text("internal_notes"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_candidate_compliance_documents_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_compliance_docs_candidate").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")),
	index("idx_compliance_docs_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "candidate_compliance_documents_candidate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidate_compliance_documents_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "candidate_compliance_documents_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.placementId],
			foreignColumns: [placements.id],
			name: "candidate_compliance_documents_placement_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.submissionId],
			foreignColumns: [submissions.id],
			name: "candidate_compliance_documents_submission_id_fkey"
		}).onDelete("set null"),
	pgPolicy("compliance_service_all", { as: "permissive", for: "all", to: ["service_role"], using: sql`true`, withCheck: sql`true`  }),
]);

export const objectOwners = pgTable("object_owners", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: text("entity_type").notNull(),
	entityId: uuid("entity_id").notNull(),
	userId: uuid("user_id").notNull(),
	role: text().notNull(),
	permission: text().default('view').notNull(),
	isPrimary: boolean("is_primary").default(false),
	assignedAt: timestamp("assigned_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	assignedBy: uuid("assigned_by"),
	assignmentType: text("assignment_type").default('auto'),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_object_owners_entity").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("uuid_ops")),
	index("idx_object_owners_is_primary").using("btree", table.isPrimary.asc().nullsLast().op("bool_ops")).where(sql`(is_primary = true)`),
	index("idx_object_owners_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_object_owners_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_object_owners_permission").using("btree", table.permission.asc().nullsLast().op("text_ops")),
	index("idx_object_owners_primary").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("text_ops")).where(sql`(is_primary = true)`),
	index("idx_object_owners_role").using("btree", table.role.asc().nullsLast().op("text_ops")),
	index("idx_object_owners_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	index("idx_object_owners_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.assignedBy],
			foreignColumns: [userProfiles.id],
			name: "object_owners_assigned_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "object_owners_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "object_owners_user_id_fkey"
		}).onDelete("cascade"),
	unique("object_owners_entity_type_entity_id_user_id_key").on(table.entityType, table.entityId, table.userId),
	pgPolicy("object_owners_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid())))` }),
	pgPolicy("object_owners_user_read", { as: "permissive", for: "select", to: ["public"] }),
	check("object_owners_assignment_type_check", sql`assignment_type = ANY (ARRAY['auto'::text, 'manual'::text])`),
	check("object_owners_entity_type_check", sql`entity_type = ANY (ARRAY['campaign'::text, 'lead'::text, 'deal'::text, 'account'::text, 'job'::text, 'job_order'::text, 'submission'::text, 'contact'::text, 'external_job'::text])`),
	check("object_owners_permission_check", sql`permission = ANY (ARRAY['edit'::text, 'view'::text])`),
	check("object_owners_role_check", sql`role = ANY (ARRAY['responsible'::text, 'accountable'::text, 'consulted'::text, 'informed'::text])`),
]);

export const candidateEducation = pgTable("candidate_education", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	degreeType: text("degree_type"),
	degreeName: text("degree_name"),
	fieldOfStudy: text("field_of_study"),
	minor: text(),
	concentration: text(),
	institutionName: text("institution_name").notNull(),
	institutionType: text("institution_type"),
	institutionCity: text("institution_city"),
	institutionState: text("institution_state"),
	institutionCountry: text("institution_country"),
	countryCode: text("country_code"),
	startDate: date("start_date"),
	endDate: date("end_date"),
	expectedGraduation: date("expected_graduation"),
	isCurrent: boolean("is_current").default(false),
	gpa: numeric({ precision: 4, scale:  2 }),
	gpaScale: numeric("gpa_scale", { precision: 3, scale:  1 }).default('4.0'),
	classRank: text("class_rank"),
	honors: text(),
	thesisTitle: text("thesis_title"),
	dissertationTitle: text("dissertation_title"),
	isVerified: boolean("is_verified").default(false),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	verifiedBy: uuid("verified_by"),
	verificationMethod: text("verification_method"),
	verificationNotes: text("verification_notes"),
	transcriptFileId: uuid("transcript_file_id"),
	diplomaFileId: uuid("diploma_file_id"),
	displayOrder: integer("display_order").default(0),
	isHighestDegree: boolean("is_highest_degree").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_candidate_education_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_education_candidate").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")),
	index("idx_education_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "candidate_education_candidate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidate_education_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "candidate_education_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("education_service_all", { as: "permissive", for: "all", to: ["service_role"], using: sql`true`, withCheck: sql`true`  }),
]);

export const candidateReferences = pgTable("candidate_references", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	referenceName: text("reference_name").notNull(),
	referenceTitle: text("reference_title"),
	referenceCompany: text("reference_company"),
	relationshipType: text("relationship_type"),
	relationshipDescription: text("relationship_description"),
	yearsKnown: integer("years_known"),
	workedTogetherFrom: date("worked_together_from"),
	workedTogetherTo: date("worked_together_to"),
	email: text(),
	phone: text(),
	linkedinUrl: text("linkedin_url"),
	preferredContactMethod: text("preferred_contact_method"),
	bestTimeToContact: text("best_time_to_contact"),
	status: text().default('pending'),
	contactAttempts: integer("contact_attempts").default(0),
	lastContactAttempt: timestamp("last_contact_attempt", { withTimezone: true, mode: 'string' }),
	contactedAt: timestamp("contacted_at", { withTimezone: true, mode: 'string' }),
	contactedBy: uuid("contacted_by"),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	rating: integer(),
	overallImpression: text("overall_impression"),
	wouldRehire: boolean("would_rehire"),
	wouldWorkWithAgain: boolean("would_work_with_again"),
	feedbackSummary: text("feedback_summary"),
	strengths: text().array(),
	areasForImprovement: text("areas_for_improvement").array(),
	questionnaireResponses: jsonb("questionnaire_responses"),
	verificationNotes: text("verification_notes"),
	internalNotes: text("internal_notes"),
	referenceConsentGiven: boolean("reference_consent_given").default(false),
	consentDate: timestamp("consent_date", { withTimezone: true, mode: 'string' }),
	displayOrder: integer("display_order").default(0),
	isPrimary: boolean("is_primary").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_candidate_references_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_references_candidate").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")),
	index("idx_references_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "candidate_references_candidate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidate_references_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "candidate_references_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("references_service_all", { as: "permissive", for: "all", to: ["service_role"], using: sql`true`, withCheck: sql`true`  }),
]);

export const candidateWorkAuthorizations = pgTable("candidate_work_authorizations", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	authorizationType: text("authorization_type").notNull(),
	visaType: text("visa_type"),
	countryCode: text("country_code").notNull(),
	status: text().default('active').notNull(),
	issueDate: date("issue_date"),
	expiryDate: date("expiry_date"),
	receiptNumber: text("receipt_number"),
	requiresSponsorship: boolean("requires_sponsorship").default(false),
	currentSponsor: text("current_sponsor"),
	isTransferable: boolean("is_transferable").default(true),
	transferInProgress: boolean("transfer_in_progress").default(false),
	capExempt: boolean("cap_exempt").default(false),
	lotterySelected: boolean("lottery_selected"),
	lotteryYear: integer("lottery_year"),
	eadCategory: text("ead_category"),
	eadCardNumber: text("ead_card_number"),
	eadExpiry: date("ead_expiry"),
	i9Completed: boolean("i9_completed").default(false),
	i9CompletedAt: timestamp("i9_completed_at", { withTimezone: true, mode: 'string' }),
	i9ExpiryDate: date("i9_expiry_date"),
	i9Section2Completed: boolean("i9_section_2_completed").default(false),
	i9DocumentList: text("i9_document_list"),
	i9DocumentDetails: jsonb("i9_document_details"),
	eVerifyStatus: text("e_verify_status"),
	eVerifyCaseNumber: text("e_verify_case_number"),
	eVerifyCompletionDate: date("e_verify_completion_date"),
	passportCountry: text("passport_country"),
	passportNumberEncrypted: text("passport_number_encrypted"),
	passportIssueDate: date("passport_issue_date"),
	passportExpiryDate: date("passport_expiry_date"),
	hasValidVisaStamp: boolean("has_valid_visa_stamp").default(false),
	visaStampExpiry: date("visa_stamp_expiry"),
	documents: jsonb().default([]),
	notes: text(),
	isPrimary: boolean("is_primary").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_candidate_work_authorizations_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_work_auth_candidate").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")),
	index("idx_work_auth_country").using("btree", table.countryCode.asc().nullsLast().op("text_ops")),
	index("idx_work_auth_expiry").using("btree", table.expiryDate.asc().nullsLast().op("date_ops")),
	index("idx_work_auth_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_work_auth_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "candidate_work_authorizations_candidate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidate_work_authorizations_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "candidate_work_authorizations_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("work_auth_service_all", { as: "permissive", for: "all", to: ["service_role"], using: sql`true`, withCheck: sql`true`  }),
]);

export const regions = pgTable("regions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	code: text(),
	country: text(),
	timezone: text().default('America/New_York'),
	managerId: uuid("manager_id"),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_regions_is_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")),
	index("idx_regions_manager_id").using("btree", table.managerId.asc().nullsLast().op("uuid_ops")),
	index("idx_regions_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "regions_created_by_fkey"
		}),
	foreignKey({
			columns: [table.managerId],
			foreignColumns: [userProfiles.id],
			name: "regions_manager_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "regions_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("regions_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
]);

export const podMembers = pgTable("pod_members", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	podId: uuid("pod_id").notNull(),
	userId: uuid("user_id").notNull(),
	role: text().notNull(),
	joinedAt: timestamp("joined_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	leftAt: timestamp("left_at", { withTimezone: true, mode: 'string' }),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_pod_members_is_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")),
	index("idx_pod_members_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_pod_members_pod_id").using("btree", table.podId.asc().nullsLast().op("uuid_ops")),
	index("idx_pod_members_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "pod_members_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.podId],
			foreignColumns: [pods.id],
			name: "pod_members_pod_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "pod_members_user_id_fkey"
		}).onDelete("cascade"),
	unique("pod_members_pod_id_user_id_key").on(table.podId, table.userId),
	pgPolicy("pod_members_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
	check("pod_members_role_check", sql`role = ANY (ARRAY['senior'::text, 'junior'::text])`),
]);

export const jobSkills = pgTable("job_skills", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	jobId: uuid("job_id").notNull(),
	skillId: uuid("skill_id").notNull(),
	importance: text().default('required').notNull(),
	minYears: numeric("min_years", { precision: 4, scale:  1 }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_job_skills_job_id").using("btree", table.jobId.asc().nullsLast().op("uuid_ops")),
	index("idx_job_skills_skill_id").using("btree", table.skillId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.jobId],
			foreignColumns: [jobs.id],
			name: "job_skills_job_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "job_skills_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.skillId],
			foreignColumns: [skills.id],
			name: "job_skills_skill_id_fkey"
		}).onDelete("cascade"),
	unique("job_skills_job_id_skill_id_key").on(table.jobId, table.skillId),
]);

export const systemRoles = pgTable("system_roles", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	code: text().notNull(),
	name: text().notNull(),
	displayName: text("display_name").notNull(),
	description: text(),
	category: text().notNull(),
	hierarchyLevel: integer("hierarchy_level").default(0),
	isSystemRole: boolean("is_system_role").default(true),
	isActive: boolean("is_active").default(true),
	colorCode: text("color_code").default('#6366f1'),
	iconName: text("icon_name"),
	podType: text("pod_type"),
	defaultPermissions: text("default_permissions").array(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_system_roles_category").using("btree", table.category.asc().nullsLast().op("text_ops")),
	index("idx_system_roles_code").using("btree", table.code.asc().nullsLast().op("text_ops")),
	index("idx_system_roles_pod_type").using("btree", table.podType.asc().nullsLast().op("text_ops")),
	unique("system_roles_code_key").on(table.code),
	pgPolicy("system_roles_public_read", { as: "permissive", for: "select", to: ["public"], using: sql`true` }),
	check("system_roles_category_check", sql`category = ANY (ARRAY['pod_ic'::text, 'pod_manager'::text, 'leadership'::text, 'executive'::text, 'portal'::text, 'admin'::text])`),
	check("system_roles_pod_type_check", sql`(pod_type IS NULL) OR (pod_type = ANY (ARRAY['recruiting'::text, 'bench_sales'::text, 'ta'::text]))`),
]);

export const jobRequirements = pgTable("job_requirements", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	jobId: uuid("job_id").notNull(),
	requirement: text().notNull(),
	type: text().default('must_have').notNull(),
	sequence: integer().default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_job_requirements_job_id").using("btree", table.jobId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.jobId],
			foreignColumns: [jobs.id],
			name: "job_requirements_job_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "job_requirements_org_id_fkey"
		}).onDelete("cascade"),
]);

export const jobRates = pgTable("job_rates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	jobId: uuid("job_id").notNull(),
	billRateMin: numeric("bill_rate_min", { precision: 10, scale:  2 }),
	billRateMax: numeric("bill_rate_max", { precision: 10, scale:  2 }),
	payRateMin: numeric("pay_rate_min", { precision: 10, scale:  2 }),
	payRateMax: numeric("pay_rate_max", { precision: 10, scale:  2 }),
	currency: text().default('USD'),
	rateType: text("rate_type").default('hourly'),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_job_rates_job_id").using("btree", table.jobId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.jobId],
			foreignColumns: [jobs.id],
			name: "job_rates_job_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "job_rates_org_id_fkey"
		}).onDelete("cascade"),
]);

export const jobAssignments = pgTable("job_assignments", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	jobId: uuid("job_id").notNull(),
	userId: uuid("user_id").notNull(),
	role: text().default('secondary').notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_job_assignments_job_id").using("btree", table.jobId.asc().nullsLast().op("uuid_ops")),
	index("idx_job_assignments_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.jobId],
			foreignColumns: [jobs.id],
			name: "job_assignments_job_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "job_assignments_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "job_assignments_user_id_fkey"
		}).onDelete("cascade"),
	unique("job_assignments_job_id_user_id_key").on(table.jobId, table.userId),
]);

export const jobScreeningQuestions = pgTable("job_screening_questions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	jobId: uuid("job_id").notNull(),
	question: text().notNull(),
	type: text().default('text').notNull(),
	options: jsonb(),
	isRequired: boolean("is_required").default(false),
	sequence: integer().default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_job_screening_questions_job_id").using("btree", table.jobId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.jobId],
			foreignColumns: [jobs.id],
			name: "job_screening_questions_job_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "job_screening_questions_org_id_fkey"
		}).onDelete("cascade"),
]);

export const candidateDocuments = pgTable("candidate_documents", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	type: text().notNull(),
	fileUrl: text("file_url").notNull(),
	fileName: text("file_name").notNull(),
	version: integer().default(1),
	isPrimary: boolean("is_primary").default(false),
	uploadedAt: timestamp("uploaded_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_candidate_documents_candidate_id").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")),
	index("idx_candidate_documents_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "candidate_documents_candidate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidate_documents_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "candidate_documents_org_id_fkey"
		}).onDelete("cascade"),
]);

export const candidateProfiles = pgTable("candidate_profiles", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	summary: text(),
	totalExperienceYears: numeric("total_experience_years", { precision: 4, scale:  1 }),
	highestEducation: text("highest_education"),
	linkedinUrl: text("linkedin_url"),
	githubUrl: text("github_url"),
	portfolioUrl: text("portfolio_url"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_candidate_profiles_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "candidate_profiles_candidate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidate_profiles_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "candidate_profiles_org_id_fkey"
		}).onDelete("cascade"),
	unique("candidate_profiles_candidate_id_key").on(table.candidateId),
]);

export const candidatePreferences = pgTable("candidate_preferences", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	preferredJobTypes: text("preferred_job_types").array(),
	preferredWorkModes: text("preferred_work_modes").array(),
	preferredIndustries: text("preferred_industries").array(),
	minRate: numeric("min_rate", { precision: 10, scale:  2 }),
	maxCommuteMiles: integer("max_commute_miles"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_candidate_preferences_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "candidate_preferences_candidate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidate_preferences_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "candidate_preferences_org_id_fkey"
		}).onDelete("cascade"),
	unique("candidate_preferences_candidate_id_key").on(table.candidateId),
]);

export const candidateAvailability = pgTable("candidate_availability", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	availableFrom: date("available_from"),
	noticePeriodDays: integer("notice_period_days"),
	preferredRateMin: numeric("preferred_rate_min", { precision: 10, scale:  2 }),
	preferredRateMax: numeric("preferred_rate_max", { precision: 10, scale:  2 }),
	currency: text().default('USD'),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_candidate_availability_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "candidate_availability_candidate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidate_availability_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "candidate_availability_org_id_fkey"
		}).onDelete("cascade"),
	unique("candidate_availability_candidate_id_key").on(table.candidateId),
]);

export const submissionRates = pgTable("submission_rates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	submissionId: uuid("submission_id").notNull(),
	billRate: numeric("bill_rate", { precision: 10, scale:  2 }),
	payRate: numeric("pay_rate", { precision: 10, scale:  2 }),
	marginPercent: numeric("margin_percent", { precision: 5, scale:  2 }),
	marginAmount: numeric("margin_amount", { precision: 10, scale:  2 }),
	currency: text().default('USD'),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "submission_rates_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.submissionId],
			foreignColumns: [submissions.id],
			name: "submission_rates_submission_id_fkey"
		}).onDelete("cascade"),
	unique("submission_rates_submission_id_key").on(table.submissionId),
]);

export const submissionScreeningAnswers = pgTable("submission_screening_answers", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	submissionId: uuid("submission_id").notNull(),
	questionId: uuid("question_id").notNull(),
	answer: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_submission_screening_answers_submission_id").using("btree", table.submissionId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "submission_screening_answers_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.questionId],
			foreignColumns: [jobScreeningQuestions.id],
			name: "submission_screening_answers_question_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.submissionId],
			foreignColumns: [submissions.id],
			name: "submission_screening_answers_submission_id_fkey"
		}).onDelete("cascade"),
	unique("submission_screening_answers_submission_id_question_id_key").on(table.submissionId, table.questionId),
]);

export const submissionNotes = pgTable("submission_notes", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	submissionId: uuid("submission_id").notNull(),
	note: text().notNull(),
	isClientVisible: boolean("is_client_visible").default(false),
	createdBy: uuid("created_by").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_submission_notes_submission_id").using("btree", table.submissionId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "submission_notes_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "submission_notes_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.submissionId],
			foreignColumns: [submissions.id],
			name: "submission_notes_submission_id_fkey"
		}).onDelete("cascade"),
]);

export const marketingTemplates = pgTable("marketing_templates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	formatType: text("format_type").notNull(),
	templateContent: text("template_content").notNull(),
	placeholders: jsonb(),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_marketing_templates_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "marketing_templates_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "marketing_templates_org_id_fkey"
		}).onDelete("cascade"),
]);

export const hotlistConsultants = pgTable("hotlist_consultants", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	hotlistId: uuid("hotlist_id").notNull(),
	consultantId: uuid("consultant_id").notNull(),
	positionOrder: integer("position_order"),
	notes: text(),
	addedAt: timestamp("added_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	addedBy: uuid("added_by"),
}, (table) => [
	index("idx_hotlist_consultants_consultant_id").using("btree", table.consultantId.asc().nullsLast().op("uuid_ops")),
	index("idx_hotlist_consultants_hotlist_id").using("btree", table.hotlistId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.addedBy],
			foreignColumns: [userProfiles.id],
			name: "hotlist_consultants_added_by_fkey"
		}),
	foreignKey({
			columns: [table.consultantId],
			foreignColumns: [benchConsultants.id],
			name: "hotlist_consultants_consultant_id_fkey"
		}).onDelete("cascade"),
	unique("hotlist_consultants_hotlist_id_consultant_id_key").on(table.hotlistId, table.consultantId),
]);

export const events = pgTable("events", {
	id: uuid().default(sql`uuid_generate_v4()`).primaryKey().notNull(),
	eventType: text("event_type").notNull(),
	eventCategory: text("event_category").notNull(),
	aggregateId: uuid("aggregate_id"),
	payload: jsonb().default({}).notNull(),
	metadata: jsonb().default({}),
	userId: uuid("user_id"),
	userEmail: text("user_email"),
	status: text().default('pending'),
	retryCount: integer("retry_count").default(0),
	maxRetries: integer("max_retries").default(3),
	nextRetryAt: timestamp("next_retry_at", { withTimezone: true, mode: 'string' }),
	errorMessage: text("error_message"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	processedAt: timestamp("processed_at", { withTimezone: true, mode: 'string' }),
	failedAt: timestamp("failed_at", { withTimezone: true, mode: 'string' }),
	eventVersion: integer("event_version").default(1),
	orgId: uuid("org_id").notNull(),
	severity: text().default('info'),
	entityType: text("entity_type"),
	entityId: uuid("entity_id"),
	actorType: text("actor_type").default('user'),
	actorId: uuid("actor_id"),
	eventData: jsonb("event_data").default({}),
	relatedEntities: jsonb("related_entities").default([]),
	correlationId: text("correlation_id"),
	causationId: text("causation_id"),
	parentEventId: uuid("parent_event_id"),
	occurredAt: timestamp("occurred_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	idempotencyKey: text("idempotency_key"),
}, (table) => [
	index("idx_events_actor_id").using("btree", table.actorId.asc().nullsLast().op("uuid_ops")),
	index("idx_events_aggregate_id").using("btree", table.aggregateId.asc().nullsLast().op("uuid_ops")).where(sql`(aggregate_id IS NOT NULL)`),
	index("idx_events_correlation_id").using("btree", table.correlationId.asc().nullsLast().op("text_ops")),
	index("idx_events_created_at").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_events_entity_type_id").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("uuid_ops")),
	index("idx_events_event_category").using("btree", table.eventCategory.asc().nullsLast().op("text_ops")),
	index("idx_events_event_type").using("btree", table.eventType.asc().nullsLast().op("text_ops")),
	index("idx_events_idempotency_key").using("btree", table.idempotencyKey.asc().nullsLast().op("text_ops")),
	index("idx_events_next_retry").using("btree", table.nextRetryAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(next_retry_at IS NOT NULL)`),
	index("idx_events_occurred_at").using("btree", table.occurredAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_events_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_events_status").using("btree", table.status.asc().nullsLast().op("text_ops")).where(sql`(status = ANY (ARRAY['pending'::text, 'processing'::text, 'failed'::text]))`),
	index("idx_events_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")).where(sql`(user_id IS NOT NULL)`),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "events_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "events_user_id_fkey"
		}),
	pgPolicy("Admins can view all events", { as: "permissive", for: "select", to: ["public"], using: sql`user_is_admin()` }),
	pgPolicy("System can publish events", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("System can update events", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("Users can view events in their org", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("Users can view own events", { as: "permissive", for: "select", to: ["public"] }),
	check("valid_event_status", sql`status = ANY (ARRAY['pending'::text, 'processing'::text, 'completed'::text, 'failed'::text, 'dead_letter'::text])`),
	check("valid_max_retries", sql`max_retries >= 0`),
	check("valid_retry_count", sql`retry_count >= 0`),
]);

export const eventSubscriptions = pgTable("event_subscriptions", {
	id: uuid().default(sql`uuid_generate_v4()`).primaryKey().notNull(),
	subscriberName: text("subscriber_name").notNull(),
	eventPattern: text("event_pattern").notNull(),
	handlerFunction: text("handler_function"),
	webhookUrl: text("webhook_url"),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	lastTriggeredAt: timestamp("last_triggered_at", { withTimezone: true, mode: 'string' }),
	orgId: uuid("org_id").notNull(),
	failureCount: integer("failure_count").default(0),
	consecutiveFailures: integer("consecutive_failures").default(0),
	lastFailureAt: timestamp("last_failure_at", { withTimezone: true, mode: 'string' }),
	lastFailureMessage: text("last_failure_message"),
	autoDisabledAt: timestamp("auto_disabled_at", { withTimezone: true, mode: 'string' }),
	userId: uuid("user_id"),
	channel: text().default('email').notNull(),
	frequency: text().default('immediate'),
	digest: boolean().default(false),
	filterCriteria: jsonb("filter_criteria").default({}),
}, (table) => [
	index("idx_event_subscriptions_channel").using("btree", table.channel.asc().nullsLast().op("text_ops")),
	index("idx_event_subscriptions_failure_count").using("btree", table.failureCount.asc().nullsLast().op("int4_ops")),
	index("idx_event_subscriptions_is_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")),
	index("idx_event_subscriptions_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	uniqueIndex("idx_event_subscriptions_unique").using("btree", table.subscriberName.asc().nullsLast().op("text_ops"), table.eventPattern.asc().nullsLast().op("text_ops")),
	index("idx_event_subscriptions_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "event_subscriptions_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "event_subscriptions_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("Admins can manage subscriptions", { as: "permissive", for: "all", to: ["public"], using: sql`user_is_admin()`, withCheck: sql`user_is_admin()`  }),
	pgPolicy("Everyone can view subscriptions", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("event_subscriptions_insert", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("event_subscriptions_select", { as: "permissive", for: "select", to: ["public"] }),
	check("valid_handler", sql`(handler_function IS NOT NULL) OR (webhook_url IS NOT NULL)`),
]);

export const skillAliases = pgTable("skill_aliases", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	skillId: uuid("skill_id").notNull(),
	alias: text().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_skill_aliases_skill_id").using("btree", table.skillId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "skill_aliases_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.skillId],
			foreignColumns: [skills.id],
			name: "skill_aliases_skill_id_fkey"
		}).onDelete("cascade"),
]);

export const submissionStatusHistory = pgTable("submission_status_history", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	submissionId: uuid("submission_id").notNull(),
	fromStatus: text("from_status"),
	toStatus: text("to_status").notNull(),
	reason: text(),
	changedBy: uuid("changed_by").notNull(),
	changedAt: timestamp("changed_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_submission_status_history_submission_id").using("btree", table.submissionId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.changedBy],
			foreignColumns: [userProfiles.id],
			name: "submission_status_history_changed_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "submission_status_history_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.submissionId],
			foreignColumns: [submissions.id],
			name: "submission_status_history_submission_id_fkey"
		}).onDelete("cascade"),
]);

export const interviewFeedback = pgTable("interview_feedback", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	interviewId: uuid("interview_id").notNull(),
	submittedBy: uuid("submitted_by").notNull(),
	rating: integer(),
	recommendation: text(),
	strengths: text(),
	weaknesses: text(),
	notes: text(),
	submittedAt: timestamp("submitted_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_interview_feedback_interview_id").using("btree", table.interviewId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.interviewId],
			foreignColumns: [interviews.id],
			name: "interview_feedback_interview_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "interview_feedback_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.submittedBy],
			foreignColumns: [userProfiles.id],
			name: "interview_feedback_submitted_by_fkey"
		}),
]);

export const interviewReminders = pgTable("interview_reminders", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	interviewId: uuid("interview_id").notNull(),
	reminderType: text("reminder_type").notNull(),
	sentAt: timestamp("sent_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_interview_reminders_interview_id").using("btree", table.interviewId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.interviewId],
			foreignColumns: [interviews.id],
			name: "interview_reminders_interview_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "interview_reminders_org_id_fkey"
		}).onDelete("cascade"),
]);

export const offerTerms = pgTable("offer_terms", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	offerId: uuid("offer_id").notNull(),
	termType: text("term_type").notNull(),
	value: text(),
	description: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_offer_terms_offer_id").using("btree", table.offerId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.offerId],
			foreignColumns: [offers.id],
			name: "offer_terms_offer_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "offer_terms_org_id_fkey"
		}).onDelete("cascade"),
]);

export const placementTimesheets = pgTable("placement_timesheets", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	placementId: uuid("placement_id").notNull(),
	weekEnding: date("week_ending").notNull(),
	regularHours: numeric("regular_hours", { precision: 5, scale:  2 }).default('0'),
	overtimeHours: numeric("overtime_hours", { precision: 5, scale:  2 }).default('0'),
	status: text().default('draft').notNull(),
	submittedAt: timestamp("submitted_at", { withTimezone: true, mode: 'string' }),
	approvedBy: uuid("approved_by"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_placement_timesheets_placement_id").using("btree", table.placementId.asc().nullsLast().op("uuid_ops")),
	index("idx_placement_timesheets_week_ending").using("btree", table.weekEnding.asc().nullsLast().op("date_ops")),
	foreignKey({
			columns: [table.approvedBy],
			foreignColumns: [userProfiles.id],
			name: "placement_timesheets_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "placement_timesheets_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.placementId],
			foreignColumns: [placements.id],
			name: "placement_timesheets_placement_id_fkey"
		}).onDelete("cascade"),
]);

export const consultantVisaDetails = pgTable("consultant_visa_details", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	consultantId: uuid("consultant_id").notNull(),
	visaType: visaType("visa_type").notNull(),
	visaStartDate: date("visa_start_date"),
	visaExpiryDate: date("visa_expiry_date"),
	lcaStatus: text("lca_status"),
	employerOfRecord: text("employer_of_record"),
	gracePeriodEnds: date("grace_period_ends"),
	alertLevel: visaAlertLevel("alert_level").default('green'),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_consultant_visa_details_alert_level").using("btree", table.alertLevel.asc().nullsLast().op("enum_ops")),
	index("idx_consultant_visa_details_consultant_id").using("btree", table.consultantId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.consultantId],
			foreignColumns: [benchConsultants.id],
			name: "consultant_visa_details_consultant_id_fkey"
		}).onDelete("cascade"),
]);

export const consultantWorkAuthorization = pgTable("consultant_work_authorization", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	consultantId: uuid("consultant_id").notNull(),
	authType: text("auth_type").notNull(),
	startDate: date("start_date"),
	endDate: date("end_date"),
	documentUrl: text("document_url"),
	documentFileId: uuid("document_file_id"),
	verifiedBy: uuid("verified_by"),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_consultant_work_auth_consultant_id").using("btree", table.consultantId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.consultantId],
			foreignColumns: [benchConsultants.id],
			name: "consultant_work_authorization_consultant_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.verifiedBy],
			foreignColumns: [userProfiles.id],
			name: "consultant_work_authorization_verified_by_fkey"
		}),
]);

export const consultantAvailability = pgTable("consultant_availability", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	consultantId: uuid("consultant_id").notNull(),
	availableFrom: date("available_from").notNull(),
	noticePeriodDays: integer("notice_period_days").default(0),
	blackoutDates: jsonb("blackout_dates"),
	travelRestrictions: text("travel_restrictions"),
	relocationAssistanceNeeded: boolean("relocation_assistance_needed").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_consultant_availability_consultant_id").using("btree", table.consultantId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.consultantId],
			foreignColumns: [benchConsultants.id],
			name: "consultant_availability_consultant_id_fkey"
		}).onDelete("cascade"),
]);

export const consultantRates = pgTable("consultant_rates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	consultantId: uuid("consultant_id").notNull(),
	rateType: text("rate_type").default('hourly').notNull(),
	minRate: numeric("min_rate", { precision: 10, scale:  2 }).notNull(),
	targetRate: numeric("target_rate", { precision: 10, scale:  2 }).notNull(),
	maxRate: numeric("max_rate", { precision: 10, scale:  2 }),
	currency: text().default('USD').notNull(),
	effectiveFrom: date("effective_from").notNull(),
	effectiveTo: date("effective_to"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_consultant_rates_consultant_id").using("btree", table.consultantId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.consultantId],
			foreignColumns: [benchConsultants.id],
			name: "consultant_rates_consultant_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "consultant_rates_created_by_fkey"
		}),
]);

export const candidates = pgTable("candidates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	firstName: text("first_name").notNull(),
	lastName: text("last_name").notNull(),
	email: text().notNull(),
	phone: text(),
	linkedinUrl: text("linkedin_url"),
	avatarUrl: text("avatar_url"),
	title: text(),
	professionalSummary: text("professional_summary"),
	yearsExperience: integer("years_experience").default(0),
	visaStatus: text("visa_status").default('us_citizen'),
	visaExpiryDate: timestamp("visa_expiry_date", { withTimezone: true, mode: 'string' }),
	availability: text().default('2_weeks'),
	location: text(),
	willingToRelocate: boolean("willing_to_relocate").default(false),
	isRemoteOk: boolean("is_remote_ok").default(false),
	minimumRate: numeric("minimum_rate", { precision: 10, scale:  2 }),
	desiredRate: numeric("desired_rate", { precision: 10, scale:  2 }),
	rateType: text("rate_type").default('hourly'),
	leadSource: text("lead_source"),
	leadSourceDetail: text("lead_source_detail"),
	tags: text().array().default([""]),
	status: text().default('active').notNull(),
	isOnHotlist: boolean("is_on_hotlist").default(false),
	hotlistNotes: text("hotlist_notes"),
	hotlistAddedAt: timestamp("hotlist_added_at", { withTimezone: true, mode: 'string' }),
	hotlistAddedBy: uuid("hotlist_added_by"),
	sourcedBy: uuid("sourced_by"),
	ownerId: uuid("owner_id"),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_candidates_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_candidates_created_at").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_candidates_email").using("btree", table.email.asc().nullsLast().op("text_ops")),
	index("idx_candidates_hotlist").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.isOnHotlist.asc().nullsLast().op("bool_ops")).where(sql`((deleted_at IS NULL) AND (is_on_hotlist = true))`),
	index("idx_candidates_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_candidates_sourced_by").using("btree", table.sourcedBy.asc().nullsLast().op("uuid_ops")),
	index("idx_candidates_status").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidates_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [users.id],
			name: "candidates_created_by_fkey"
		}),
	foreignKey({
			columns: [table.hotlistAddedBy],
			foreignColumns: [users.id],
			name: "candidates_hotlist_added_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "candidates_org_id_fkey"
		}),
	foreignKey({
			columns: [table.ownerId],
			foreignColumns: [users.id],
			name: "candidates_owner_id_fkey"
		}),
	foreignKey({
			columns: [table.sourcedBy],
			foreignColumns: [users.id],
			name: "candidates_sourced_by_fkey"
		}),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [users.id],
			name: "candidates_updated_by_fkey"
		}),
	unique("candidates_email_unique").on(table.orgId, table.email),
	pgPolicy("candidates_delete_policy", { as: "permissive", for: "delete", to: ["public"], using: sql`(org_id IN ( SELECT candidates.org_id
   FROM user_roles
  WHERE (user_roles.user_id = auth.uid())))` }),
	pgPolicy("candidates_insert_policy", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("candidates_select_policy", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("candidates_update_policy", { as: "permissive", for: "update", to: ["public"] }),
]);

export const marketingProfiles = pgTable("marketing_profiles", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	consultantId: uuid("consultant_id").notNull(),
	headline: text().notNull(),
	summary: text(),
	highlights: text().array(),
	targetRoles: text("target_roles").array(),
	targetIndustries: text("target_industries").array(),
	version: integer().default(1).notNull(),
	status: marketingStatus().default('draft').notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_marketing_profiles_consultant_id").using("btree", table.consultantId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.consultantId],
			foreignColumns: [benchConsultants.id],
			name: "marketing_profiles_consultant_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "marketing_profiles_created_by_fkey"
		}),
]);

export const marketingFormats = pgTable("marketing_formats", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	profileId: uuid("profile_id").notNull(),
	formatType: text("format_type").notNull(),
	content: text(),
	fileUrl: text("file_url"),
	fileId: uuid("file_id"),
	version: integer().default(1).notNull(),
	isDefault: boolean("is_default").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_marketing_formats_profile_id").using("btree", table.profileId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.profileId],
			foreignColumns: [marketingProfiles.id],
			name: "marketing_formats_profile_id_fkey"
		}).onDelete("cascade"),
]);

export const vendorRelationships = pgTable("vendor_relationships", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	vendorId: uuid("vendor_id").notNull(),
	relatedEntityType: text("related_entity_type").notNull(),
	relatedEntityId: uuid("related_entity_id").notNull(),
	relationshipType: text("relationship_type").notNull(),
	strength: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_vendor_relationships_related_entity").using("btree", table.relatedEntityType.asc().nullsLast().op("text_ops"), table.relatedEntityId.asc().nullsLast().op("text_ops")),
	index("idx_vendor_relationships_vendor_id").using("btree", table.vendorId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "vendor_relationships_created_by_fkey"
		}),
]);

export const vendorBlacklist = pgTable("vendor_blacklist", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	vendorId: uuid("vendor_id").notNull(),
	reason: text().notNull(),
	reviewDate: date("review_date"),
	blacklistedAt: timestamp("blacklisted_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	blacklistedBy: uuid("blacklisted_by"),
}, (table) => [
	index("idx_vendor_blacklist_vendor_id").using("btree", table.vendorId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.blacklistedBy],
			foreignColumns: [userProfiles.id],
			name: "vendor_blacklist_blacklisted_by_fkey"
		}),
]);

export const companyTeam = pgTable("company_team", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	companyId: uuid("company_id").notNull(),
	userId: uuid("user_id").notNull(),
	role: companyTeamRole().notNull(),
	isPrimary: boolean("is_primary").default(false),
	region: text(),
	jobCategories: text("job_categories").array(),
	assignedAt: timestamp("assigned_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	assignedBy: uuid("assigned_by"),
	removedAt: timestamp("removed_at", { withTimezone: true, mode: 'string' }),
	removedBy: uuid("removed_by"),
	notifyOnNewJob: boolean("notify_on_new_job").default(true),
	notifyOnPlacement: boolean("notify_on_placement").default(true),
	notifyOnActivity: boolean("notify_on_activity").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_company_team_company").using("btree", table.companyId.asc().nullsLast().op("uuid_ops")).where(sql`(removed_at IS NULL)`),
	uniqueIndex("idx_company_team_unique").using("btree", table.companyId.asc().nullsLast().op("enum_ops"), table.userId.asc().nullsLast().op("enum_ops"), table.role.asc().nullsLast().op("enum_ops")).where(sql`(removed_at IS NULL)`),
	index("idx_company_team_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")).where(sql`(removed_at IS NULL)`),
	foreignKey({
			columns: [table.assignedBy],
			foreignColumns: [userProfiles.id],
			name: "company_team_assigned_by_fkey"
		}),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "company_team_company_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "company_team_org_id_fkey"
		}),
	foreignKey({
			columns: [table.removedBy],
			foreignColumns: [userProfiles.id],
			name: "company_team_removed_by_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "company_team_user_id_fkey"
		}),
	pgPolicy("team_org", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const companyContacts = pgTable("company_contacts", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	companyId: uuid("company_id").notNull(),
	contactId: uuid("contact_id").notNull(),
	jobTitle: text("job_title"),
	department: text(),
	roleDescription: text("role_description"),
	decisionAuthority: contactDecisionAuthority("decision_authority"),
	influenceLevel: integer("influence_level"),
	isPrimary: boolean("is_primary").default(false),
	isActive: boolean("is_active").default(true),
	relationshipStrength: integer("relationship_strength"),
	lastContactDate: date("last_contact_date"),
	preferredContactMethod: varchar("preferred_contact_method", { length: 20 }),
	startedAt: date("started_at"),
	leftAt: date("left_at"),
	leftReason: text("left_reason"),
	vendorCompanyId: uuid("vendor_company_id"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_company_contacts_company").using("btree", table.companyId.asc().nullsLast().op("uuid_ops")).where(sql`(is_active = true)`),
	index("idx_company_contacts_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(is_active = true)`),
	uniqueIndex("idx_company_contacts_unique").using("btree", table.companyId.asc().nullsLast().op("uuid_ops"), table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(is_active = true)`),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "company_contacts_company_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "company_contacts_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "company_contacts_org_id_fkey"
		}),
	foreignKey({
			columns: [table.vendorCompanyId],
			foreignColumns: [companies.id],
			name: "company_contacts_vendor_company_id_fkey"
		}),
	pgPolicy("contacts_org", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
	check("company_contacts_influence_level_check", sql`(influence_level >= 1) AND (influence_level <= 5)`),
	check("company_contacts_relationship_strength_check", sql`(relationship_strength >= 1) AND (relationship_strength <= 5)`),
]);

export const companyRelationships = pgTable("company_relationships", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	companyAId: uuid("company_a_id").notNull(),
	companyBId: uuid("company_b_id").notNull(),
	relationshipCategory: companyRelationshipCategory("relationship_category").notNull(),
	relationshipDirection: varchar("relationship_direction", { length: 10 }).notNull(),
	relationshipLabelAToB: text("relationship_label_a_to_b"),
	relationshipLabelBToA: text("relationship_label_b_to_a"),
	isActive: boolean("is_active").default(true),
	startedDate: date("started_date"),
	endedDate: date("ended_date"),
	details: jsonb().default({}),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_company_relationships_a").using("btree", table.companyAId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_company_relationships_b").using("btree", table.companyBId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	uniqueIndex("idx_company_relationships_unique").using("btree", table.companyAId.asc().nullsLast().op("enum_ops"), table.companyBId.asc().nullsLast().op("uuid_ops"), table.relationshipCategory.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.companyAId],
			foreignColumns: [companies.id],
			name: "company_relationships_company_a_id_fkey"
		}),
	foreignKey({
			columns: [table.companyBId],
			foreignColumns: [companies.id],
			name: "company_relationships_company_b_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "company_relationships_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "company_relationships_org_id_fkey"
		}),
	pgPolicy("relationships_org", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
	check("company_relationships_check", sql`company_a_id <> company_b_id`),
]);

export const immigrationTimelines = pgTable("immigration_timelines", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	caseId: uuid("case_id").notNull(),
	milestone: text().notNull(),
	targetDate: date("target_date"),
	actualDate: date("actual_date"),
	status: text().default('pending').notNull(),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_immigration_timelines_case_id").using("btree", table.caseId.asc().nullsLast().op("uuid_ops")),
]);

export const immigrationAttorneys = pgTable("immigration_attorneys", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	firm: text(),
	email: text(),
	phone: text(),
	specialization: text().array(),
	rating: numeric({ precision: 3, scale:  1 }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_immigration_attorneys_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "immigration_attorneys_org_id_fkey"
		}).onDelete("cascade"),
	check("immigration_attorneys_rating_check", sql`(rating >= 1.0) AND (rating <= 5.0)`),
]);

export const immigrationDocuments = pgTable("immigration_documents", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	caseId: uuid("case_id").notNull(),
	documentType: text("document_type").notNull(),
	fileUrl: text("file_url"),
	fileId: uuid("file_id"),
	fileName: text("file_name"),
	issueDate: date("issue_date"),
	expiryDate: date("expiry_date"),
	verifiedBy: uuid("verified_by"),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_immigration_documents_case_id").using("btree", table.caseId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.verifiedBy],
			foreignColumns: [userProfiles.id],
			name: "immigration_documents_verified_by_fkey"
		}),
]);

export const immigrationAlerts = pgTable("immigration_alerts", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	consultantId: uuid("consultant_id").notNull(),
	alertType: text("alert_type").notNull(),
	entityId: uuid("entity_id"),
	alertDate: date("alert_date").notNull(),
	severity: text().notNull(),
	message: text().notNull(),
	acknowledgedBy: uuid("acknowledged_by"),
	acknowledgedAt: timestamp("acknowledged_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_immigration_alerts_alert_date").using("btree", table.alertDate.asc().nullsLast().op("date_ops")),
	index("idx_immigration_alerts_consultant_id").using("btree", table.consultantId.asc().nullsLast().op("uuid_ops")),
	index("idx_immigration_alerts_severity").using("btree", table.severity.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.acknowledgedBy],
			foreignColumns: [userProfiles.id],
			name: "immigration_alerts_acknowledged_by_fkey"
		}),
	foreignKey({
			columns: [table.consultantId],
			foreignColumns: [benchConsultants.id],
			name: "immigration_alerts_consultant_id_fkey"
		}).onDelete("cascade"),
]);

export const companyAddresses = pgTable("company_addresses", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	companyId: uuid("company_id").notNull(),
	addressId: uuid("address_id").notNull(),
	addressType: varchar("address_type", { length: 30 }).notNull(),
	isPrimary: boolean("is_primary").default(false),
	label: text(),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_company_addresses_company").using("btree", table.companyId.asc().nullsLast().op("uuid_ops")).where(sql`(is_active = true)`),
	uniqueIndex("idx_company_addresses_unique").using("btree", table.companyId.asc().nullsLast().op("uuid_ops"), table.addressId.asc().nullsLast().op("text_ops"), table.addressType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "company_addresses_company_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "company_addresses_org_id_fkey"
		}),
	pgPolicy("addresses_org", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const companyNotes = pgTable("company_notes", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	companyId: uuid("company_id").notNull(),
	noteType: companyNoteType("note_type").default('general'),
	title: text(),
	content: text().notNull(),
	isPinned: boolean("is_pinned").default(false),
	isPrivate: boolean("is_private").default(false),
	relatedContactId: uuid("related_contact_id"),
	relatedJobId: uuid("related_job_id"),
	relatedDealId: uuid("related_deal_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by").notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_company_notes_company").using("btree", table.companyId.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "company_notes_company_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "company_notes_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "company_notes_org_id_fkey"
		}),
	pgPolicy("notes_org", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const externalJobOrderSubmissions = pgTable("external_job_order_submissions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orderId: uuid("order_id").notNull(),
	consultantId: uuid("consultant_id").notNull(),
	status: text().default('submitted').notNull(),
	submittedRate: numeric("submitted_rate", { precision: 10, scale:  2 }),
	submittedAt: timestamp("submitted_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	clientResponseAt: timestamp("client_response_at", { withTimezone: true, mode: 'string' }),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_job_order_submissions_consultant_id").using("btree", table.consultantId.asc().nullsLast().op("uuid_ops")),
	index("idx_job_order_submissions_order_id").using("btree", table.orderId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.consultantId],
			foreignColumns: [benchConsultants.id],
			name: "job_order_submissions_consultant_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "job_order_submissions_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orderId],
			foreignColumns: [externalJobOrders.id],
			name: "job_order_submissions_order_id_fkey"
		}).onDelete("cascade"),
	unique("job_order_submissions_order_id_consultant_id_key").on(table.orderId, table.consultantId),
]);

export const migrationCandidateMapping = pgTable("_migration_candidate_mapping", {
	userProfileId: uuid("user_profile_id").primaryKey().notNull(),
	contactId: uuid("contact_id").notNull(),
	migratedAt: timestamp("migrated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
});

export const companyPreferences = pgTable("company_preferences", {
	companyId: uuid("company_id").primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	preferredSkills: text("preferred_skills").array(),
	excludedSkills: text("excluded_skills").array(),
	requiredCertifications: text("required_certifications").array(),
	minYearsExperience: integer("min_years_experience"),
	maxYearsExperience: integer("max_years_experience"),
	preferredExperienceLevels: text("preferred_experience_levels").array(),
	degreeRequired: boolean("degree_required").default(false),
	preferredDegreeLevels: text("preferred_degree_levels").array(),
	preferredUniversities: text("preferred_universities").array(),
	visaTypesAccepted: text("visa_types_accepted").array(),
	requiresUsCitizen: boolean("requires_us_citizen").default(false),
	workModePreference: varchar("work_mode_preference", { length: 20 }),
	officeLocations: text("office_locations").array(),
	remoteStatesAllowed: text("remote_states_allowed").array(),
	relocationAssistance: boolean("relocation_assistance").default(false),
	rateRangeMin: numeric("rate_range_min", { precision: 10, scale:  2 }),
	rateRangeMax: numeric("rate_range_max", { precision: 10, scale:  2 }),
	rateType: varchar("rate_type", { length: 20 }).default('hourly'),
	typicalStartTimelineDays: integer("typical_start_timeline_days"),
	interviewFormatPreference: text("interview_format_preference").array(),
	decisionTimelineDays: integer("decision_timeline_days"),
	preferredSubmissionFormat: varchar("preferred_submission_format", { length: 50 }),
	submissionLimitPerJob: integer("submission_limit_per_job"),
	feedbackCommitment: varchar("feedback_commitment", { length: 50 }),
	customPreferences: jsonb("custom_preferences").default({}),
	specialInstructions: text("special_instructions"),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedBy: uuid("updated_by"),
}, (table) => [
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "company_preferences_company_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "company_preferences_org_id_fkey"
		}),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "company_preferences_updated_by_fkey"
		}),
	pgPolicy("preferences_org", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const companyTags = pgTable("company_tags", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	companyId: uuid("company_id").notNull(),
	tagName: text("tag_name").notNull(),
	tagCategory: text("tag_category"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_company_tags_company").using("btree", table.companyId.asc().nullsLast().op("uuid_ops")),
	index("idx_company_tags_name").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.tagName.asc().nullsLast().op("uuid_ops")),
	uniqueIndex("idx_company_tags_unique").using("btree", table.companyId.asc().nullsLast().op("uuid_ops"), table.tagName.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "company_tags_company_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "company_tags_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "company_tags_org_id_fkey"
		}),
	pgPolicy("tags_org", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const benefitPlanOptions = pgTable("benefit_plan_options", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	planId: uuid("plan_id").notNull(),
	optionName: text("option_name").notNull(),
	coverageLevel: coverageLevel("coverage_level").notNull(),
	employerContribution: numeric("employer_contribution", { precision: 10, scale:  2 }),
	employeeContribution: numeric("employee_contribution", { precision: 10, scale:  2 }),
	description: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_benefit_plan_options_plan_id").using("btree", table.planId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.planId],
			foreignColumns: [benefitPlans.id],
			name: "benefit_plan_options_plan_id_fkey"
		}).onDelete("cascade"),
]);

export const migrationLeadMapping = pgTable("_migration_lead_mapping", {
	leadId: uuid("lead_id").primaryKey().notNull(),
	contactId: uuid("contact_id").notNull(),
	migratedAt: timestamp("migrated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
});

export const integrations = pgTable("integrations", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	type: varchar({ length: 50 }).notNull(),
	provider: varchar({ length: 50 }).notNull(),
	name: varchar({ length: 100 }).notNull(),
	description: text(),
	config: jsonb().default({}).notNull(),
	status: varchar({ length: 20 }).default('inactive').notNull(),
	isPrimary: boolean("is_primary").default(false),
	lastHealthCheck: timestamp("last_health_check", { withTimezone: true, mode: 'string' }),
	lastSync: timestamp("last_sync", { withTimezone: true, mode: 'string' }),
	healthStatus: varchar("health_status", { length: 20 }).default('unknown'),
	errorMessage: text("error_message"),
	errorCount: integer("error_count").default(0),
	metadata: jsonb().default({}),
	createdBy: uuid("created_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_integrations_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_integrations_org_primary").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.type.asc().nullsLast().op("bool_ops"), table.isPrimary.asc().nullsLast().op("bool_ops")).where(sql`((is_primary = true) AND (deleted_at IS NULL))`),
	index("idx_integrations_org_type").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.type.asc().nullsLast().op("uuid_ops")),
	index("idx_integrations_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_integrations_type").using("btree", table.type.asc().nullsLast().op("text_ops")),
	uniqueIndex("idx_integrations_unique_primary").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.type.asc().nullsLast().op("uuid_ops")).where(sql`((is_primary = true) AND (deleted_at IS NULL))`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "integrations_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "integrations_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("integrations_org_access", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text))` }),
]);

export const integrationHealthLogs = pgTable("integration_health_logs", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	integrationId: uuid("integration_id").notNull(),
	checkType: varchar("check_type", { length: 50 }).default('manual').notNull(),
	status: varchar({ length: 20 }).notNull(),
	responseTimeMs: integer("response_time_ms"),
	errorMessage: text("error_message"),
	errorCode: varchar("error_code", { length: 50 }),
	details: jsonb().default({}),
	checkedBy: uuid("checked_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_health_logs_created").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_health_logs_integration").using("btree", table.integrationId.asc().nullsLast().op("uuid_ops")),
	index("idx_health_logs_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_health_logs_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.checkedBy],
			foreignColumns: [userProfiles.id],
			name: "integration_health_logs_checked_by_fkey"
		}),
	foreignKey({
			columns: [table.integrationId],
			foreignColumns: [integrations.id],
			name: "integration_health_logs_integration_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "integration_health_logs_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("health_logs_org_access", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text))` }),
]);

export const integrationTypes = pgTable("integration_types", {
	id: varchar({ length: 50 }).primaryKey().notNull(),
	name: varchar({ length: 100 }).notNull(),
	description: text(),
	category: varchar({ length: 50 }).notNull(),
	icon: varchar({ length: 50 }),
	configSchema: jsonb("config_schema"),
	providers: jsonb().default([]),
	isActive: boolean("is_active").default(true),
	sortOrder: integer("sort_order").default(0),
}, (table) => [
	pgPolicy("integration_types_read", { as: "permissive", for: "select", to: ["public"], using: sql`true` }),
]);

export const externalJobOrders = pgTable("external_job_orders", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	vendorId: uuid("vendor_id"),
	clientName: text("client_name"),
	title: text().notNull(),
	description: text(),
	location: text(),
	workMode: text("work_mode"),
	rateType: text("rate_type").default('hourly'),
	billRate: numeric("bill_rate", { precision: 10, scale:  2 }),
	durationMonths: integer("duration_months"),
	positions: integer().default(1),
	status: jobOrderStatus().default('new').notNull(),
	priority: jobOrderPriority().default('medium'),
	receivedAt: timestamp("received_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	responseDueAt: timestamp("response_due_at", { withTimezone: true, mode: 'string' }),
	source: jobOrderSource().default('email'),
	originalSourceUrl: text("original_source_url"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	vendorCompanyId: uuid("vendor_company_id"),
}, (table) => [
	index("idx_external_job_orders_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_external_job_orders_status").using("btree", table.orgId.asc().nullsLast().op("enum_ops"), table.status.asc().nullsLast().op("enum_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_external_job_orders_vendor_company").using("btree", table.vendorCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_job_orders_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_job_orders_priority").using("btree", table.priority.asc().nullsLast().op("enum_ops")),
	index("idx_job_orders_status").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	index("idx_job_orders_vendor_id").using("btree", table.vendorId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.vendorCompanyId],
			foreignColumns: [companies.id],
			name: "external_job_orders_vendor_company_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "job_orders_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "job_orders_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("external_job_orders_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const dealStagesHistory = pgTable("deal_stages_history", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	dealId: uuid("deal_id").notNull(),
	stage: text().notNull(),
	previousStage: text("previous_stage"),
	enteredAt: timestamp("entered_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	exitedAt: timestamp("exited_at", { withTimezone: true, mode: 'string' }),
	durationDays: integer("duration_days"),
	notes: text(),
	reason: text(),
	changedBy: uuid("changed_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_deal_stages_history_deal_id").using("btree", table.dealId.asc().nullsLast().op("uuid_ops")),
	index("idx_deal_stages_history_entered_at").using("btree", table.enteredAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_deal_stages_history_stage").using("btree", table.stage.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.changedBy],
			foreignColumns: [userProfiles.id],
			name: "deal_stages_history_changed_by_fkey"
		}),
	foreignKey({
			columns: [table.dealId],
			foreignColumns: [deals.id],
			name: "deal_stages_history_deal_id_fkey"
		}).onDelete("cascade"),
]);

export const dealStakeholders = pgTable("deal_stakeholders", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	dealId: uuid("deal_id").notNull(),
	contactId: uuid("contact_id"),
	name: text(),
	title: text(),
	email: text(),
	role: text().notNull(),
	influenceLevel: text("influence_level"),
	sentiment: text(),
	engagementNotes: text("engagement_notes"),
	isActive: boolean("is_active").default(true),
	isPrimary: boolean("is_primary").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_deal_stakeholders_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")),
	index("idx_deal_stakeholders_deal_id").using("btree", table.dealId.asc().nullsLast().op("uuid_ops")),
	index("idx_deal_stakeholders_role").using("btree", table.role.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "deal_stakeholders_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.dealId],
			foreignColumns: [deals.id],
			name: "deal_stakeholders_deal_id_fkey"
		}).onDelete("cascade"),
]);

export const leadScores = pgTable("lead_scores", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	leadId: uuid("lead_id").notNull(),
	score: integer().default(0).notNull(),
	factors: jsonb(),
	budgetScore: integer("budget_score").default(0),
	authorityScore: integer("authority_score").default(0),
	needScore: integer("need_score").default(0),
	timelineScore: integer("timeline_score").default(0),
	engagementScore: integer("engagement_score").default(0),
	fitScore: integer("fit_score").default(0),
	calculatedAt: timestamp("calculated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	calculatedBy: text("calculated_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_lead_scores_lead_id").using("btree", table.leadId.asc().nullsLast().op("uuid_ops")),
	index("idx_lead_scores_score").using("btree", table.score.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.leadId],
			foreignColumns: [leads.id],
			name: "lead_scores_lead_id_fkey"
		}).onDelete("cascade"),
]);

export const leadQualification = pgTable("lead_qualification", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	leadId: uuid("lead_id").notNull(),
	hasBudget: boolean("has_budget"),
	budgetAmount: numeric("budget_amount", { precision: 12, scale:  2 }),
	budgetTimeframe: text("budget_timeframe"),
	budgetNotes: text("budget_notes"),
	decisionMaker: text("decision_maker"),
	decisionProcess: text("decision_process"),
	otherStakeholders: text("other_stakeholders"),
	authorityNotes: text("authority_notes"),
	needIdentified: boolean("need_identified"),
	needUrgency: text("need_urgency"),
	painPoints: text("pain_points").array(),
	currentSolution: text("current_solution"),
	needNotes: text("need_notes"),
	timeline: text(),
	decisionDate: timestamp("decision_date", { withTimezone: true, mode: 'string' }),
	projectStartDate: timestamp("project_start_date", { withTimezone: true, mode: 'string' }),
	timelineNotes: text("timeline_notes"),
	qualifiedBy: uuid("qualified_by"),
	qualifiedAt: timestamp("qualified_at", { withTimezone: true, mode: 'string' }),
	qualificationStatus: text("qualification_status"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_lead_qualification_lead_id").using("btree", table.leadId.asc().nullsLast().op("uuid_ops")),
	index("idx_lead_qualification_status").using("btree", table.qualificationStatus.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.leadId],
			foreignColumns: [leads.id],
			name: "lead_qualification_lead_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.qualifiedBy],
			foreignColumns: [userProfiles.id],
			name: "lead_qualification_qualified_by_fkey"
		}),
]);

export const candidateWorkHistory = pgTable("candidate_work_history", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	companyName: text("company_name").notNull(),
	companyIndustry: text("company_industry"),
	companySize: text("company_size"),
	jobTitle: text("job_title").notNull(),
	department: text(),
	employmentType: text("employment_type"),
	employmentBasis: text("employment_basis"),
	locationCity: text("location_city"),
	locationState: text("location_state"),
	locationCountry: text("location_country"),
	countryCode: text("country_code"),
	isRemote: boolean("is_remote").default(false),
	remoteType: text("remote_type"),
	startDate: date("start_date").notNull(),
	endDate: date("end_date"),
	isCurrent: boolean("is_current").default(false),
	description: text(),
	responsibilities: text().array(),
	achievements: text().array(),
	skillsUsed: text("skills_used").array(),
	toolsUsed: text("tools_used").array(),
	projects: text().array(),
	salaryAmount: numeric("salary_amount", { precision: 12, scale:  2 }),
	salaryCurrency: text("salary_currency").default('USD'),
	salaryType: text("salary_type"),
	supervisorName: text("supervisor_name"),
	supervisorTitle: text("supervisor_title"),
	supervisorEmail: text("supervisor_email"),
	supervisorPhone: text("supervisor_phone"),
	hrContactName: text("hr_contact_name"),
	hrContactEmail: text("hr_contact_email"),
	hrContactPhone: text("hr_contact_phone"),
	isVerified: boolean("is_verified").default(false),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	verifiedBy: uuid("verified_by"),
	verificationMethod: text("verification_method"),
	verificationNotes: text("verification_notes"),
	reasonForLeaving: text("reason_for_leaving"),
	isRehireEligible: boolean("is_rehire_eligible"),
	rehireNotes: text("rehire_notes"),
	displayOrder: integer("display_order").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_candidate_work_history_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_work_history_candidate").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")),
	index("idx_work_history_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "candidate_work_history_candidate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidate_work_history_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "candidate_work_history_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("work_history_service_all", { as: "permissive", for: "all", to: ["service_role"], using: sql`true`, withCheck: sql`true`  }),
]);

export const leadTouchpoints = pgTable("lead_touchpoints", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	leadId: uuid("lead_id").notNull(),
	touchpointType: text("touchpoint_type").notNull(),
	direction: text().default('outbound').notNull(),
	subject: text(),
	notes: text(),
	outcome: text(),
	nextSteps: text("next_steps"),
	nextFollowUpDate: timestamp("next_follow_up_date", { withTimezone: true, mode: 'string' }),
	durationMinutes: integer("duration_minutes"),
	campaignId: uuid("campaign_id"),
	templateUsed: text("template_used"),
	createdBy: uuid("created_by"),
	touchpointDate: timestamp("touchpoint_date", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_lead_touchpoints_date").using("btree", table.touchpointDate.asc().nullsLast().op("timestamptz_ops")),
	index("idx_lead_touchpoints_lead_id").using("btree", table.leadId.asc().nullsLast().op("uuid_ops")),
	index("idx_lead_touchpoints_type").using("btree", table.touchpointType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "lead_touchpoints_created_by_fkey"
		}),
	foreignKey({
			columns: [table.leadId],
			foreignColumns: [leads.id],
			name: "lead_touchpoints_lead_id_fkey"
		}).onDelete("cascade"),
]);

export const dealCompetitors = pgTable("deal_competitors", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	dealId: uuid("deal_id").notNull(),
	competitorName: text("competitor_name").notNull(),
	competitorWebsite: text("competitor_website"),
	strengths: text(),
	weaknesses: text(),
	ourDifferentiators: text("our_differentiators"),
	pricing: text(),
	status: text().default('active'),
	threatLevel: text("threat_level"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_deal_competitors_deal_id").using("btree", table.dealId.asc().nullsLast().op("uuid_ops")),
	index("idx_deal_competitors_name").using("btree", table.competitorName.asc().nullsLast().op("text_ops")),
	index("idx_deal_competitors_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.dealId],
			foreignColumns: [deals.id],
			name: "deal_competitors_deal_id_fkey"
		}).onDelete("cascade"),
]);

export const dealProducts = pgTable("deal_products", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	dealId: uuid("deal_id").notNull(),
	productType: text("product_type").notNull(),
	productName: text("product_name"),
	description: text(),
	quantity: integer().default(1),
	unitPrice: numeric("unit_price", { precision: 12, scale:  2 }),
	totalValue: numeric("total_value", { precision: 12, scale:  2 }),
	discount: numeric({ precision: 5, scale:  2 }),
	currency: text().default('USD'),
	durationMonths: integer("duration_months"),
	startDate: timestamp("start_date", { withTimezone: true, mode: 'string' }),
	endDate: timestamp("end_date", { withTimezone: true, mode: 'string' }),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_deal_products_deal_id").using("btree", table.dealId.asc().nullsLast().op("uuid_ops")),
	index("idx_deal_products_type").using("btree", table.productType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.dealId],
			foreignColumns: [deals.id],
			name: "deal_products_deal_id_fkey"
		}).onDelete("cascade"),
]);

export const employees = pgTable("employees", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	userId: uuid("user_id").notNull(),
	employeeNumber: text("employee_number"),
	status: employmentStatus().default('onboarding').notNull(),
	employmentType: employmentType("employment_type").default('fte').notNull(),
	hireDate: date("hire_date").notNull(),
	terminationDate: date("termination_date"),
	terminationReason: text("termination_reason"),
	department: text(),
	jobTitle: text("job_title"),
	managerId: uuid("manager_id"),
	location: text(),
	workMode: workMode("work_mode").default('on_site'),
	salaryType: salaryType("salary_type").default('annual').notNull(),
	salaryAmount: numeric("salary_amount", { precision: 12, scale:  2 }),
	currency: text().default('USD'),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_employees_deleted_at").using("btree", table.deletedAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_employees_manager_id").using("btree", table.managerId.asc().nullsLast().op("uuid_ops")),
	index("idx_employees_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_employees_status").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	index("idx_employees_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "employees_created_by_fkey"
		}),
	foreignKey({
			columns: [table.managerId],
			foreignColumns: [table.id],
			name: "employees_manager_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "employees_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "employees_updated_by_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "employees_user_id_fkey"
		}).onDelete("cascade"),
	unique("employees_user_id_key").on(table.userId),
	unique("employees_employee_number_key").on(table.employeeNumber),
]);

export const employeeProfiles = pgTable("employee_profiles", {
	employeeId: uuid("employee_id").primaryKey().notNull(),
	dateOfBirth: date("date_of_birth"),
	ssnEncrypted: text("ssn_encrypted"),
	addressStreet: text("address_street"),
	addressCity: text("address_city"),
	addressState: text("address_state"),
	addressCountry: text("address_country").default('USA'),
	addressPostal: text("address_postal"),
	emergencyContactName: text("emergency_contact_name"),
	emergencyContactPhone: text("emergency_contact_phone"),
	emergencyContactRelationship: text("emergency_contact_relationship"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	foreignKey({
			columns: [table.employeeId],
			foreignColumns: [employees.id],
			name: "employee_profiles_employee_id_fkey"
		}).onDelete("cascade"),
]);

export const employeeDocuments = pgTable("employee_documents", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	employeeId: uuid("employee_id").notNull(),
	documentType: documentType("document_type").notNull(),
	fileName: text("file_name").notNull(),
	fileUrl: text("file_url").notNull(),
	issueDate: date("issue_date"),
	expiryDate: date("expiry_date"),
	status: documentStatus().default('pending').notNull(),
	verifiedBy: uuid("verified_by"),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_employee_documents_employee_id").using("btree", table.employeeId.asc().nullsLast().op("uuid_ops")),
	index("idx_employee_documents_status").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	index("idx_employee_documents_type").using("btree", table.documentType.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "employee_documents_created_by_fkey"
		}),
	foreignKey({
			columns: [table.employeeId],
			foreignColumns: [employees.id],
			name: "employee_documents_employee_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.verifiedBy],
			foreignColumns: [userProfiles.id],
			name: "employee_documents_verified_by_fkey"
		}),
]);

export const employeeTimeOff = pgTable("employee_time_off", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	employeeId: uuid("employee_id").notNull(),
	type: timeOffType().notNull(),
	status: timeOffStatus().default('pending').notNull(),
	startDate: date("start_date").notNull(),
	endDate: date("end_date").notNull(),
	hours: numeric({ precision: 5, scale:  2 }).notNull(),
	reason: text(),
	approvedBy: uuid("approved_by"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	denialReason: text("denial_reason"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_employee_time_off_dates").using("btree", table.startDate.asc().nullsLast().op("date_ops"), table.endDate.asc().nullsLast().op("date_ops")),
	index("idx_employee_time_off_employee_id").using("btree", table.employeeId.asc().nullsLast().op("uuid_ops")),
	index("idx_employee_time_off_status").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.approvedBy],
			foreignColumns: [userProfiles.id],
			name: "employee_time_off_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "employee_time_off_created_by_fkey"
		}),
	foreignKey({
			columns: [table.employeeId],
			foreignColumns: [employees.id],
			name: "employee_time_off_employee_id_fkey"
		}).onDelete("cascade"),
]);

export const benefitPlans = pgTable("benefit_plans", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	type: benefitType().notNull(),
	provider: text(),
	status: text().default('active').notNull(),
	effectiveDate: date("effective_date"),
	terminationDate: date("termination_date"),
	description: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_benefit_plans_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_benefit_plans_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_benefit_plans_type").using("btree", table.type.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "benefit_plans_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "benefit_plans_org_id_fkey"
		}).onDelete("cascade"),
]);

export const employeeBenefits = pgTable("employee_benefits", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	employeeId: uuid("employee_id").notNull(),
	planOptionId: uuid("plan_option_id").notNull(),
	status: benefitStatus().default('pending').notNull(),
	enrollmentDate: date("enrollment_date"),
	coverageStart: date("coverage_start"),
	coverageEnd: date("coverage_end"),
	dependentsCount: integer("dependents_count").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_employee_benefits_employee_id").using("btree", table.employeeId.asc().nullsLast().op("uuid_ops")),
	index("idx_employee_benefits_plan_option_id").using("btree", table.planOptionId.asc().nullsLast().op("uuid_ops")),
	index("idx_employee_benefits_status").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "employee_benefits_created_by_fkey"
		}),
	foreignKey({
			columns: [table.employeeId],
			foreignColumns: [employees.id],
			name: "employee_benefits_employee_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.planOptionId],
			foreignColumns: [benefitPlanOptions.id],
			name: "employee_benefits_plan_option_id_fkey"
		}),
]);

export const benefitDependents = pgTable("benefit_dependents", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	employeeBenefitId: uuid("employee_benefit_id").notNull(),
	name: text().notNull(),
	relationship: relationship().notNull(),
	dateOfBirth: date("date_of_birth"),
	ssnEncrypted: text("ssn_encrypted"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_benefit_dependents_employee_benefit_id").using("btree", table.employeeBenefitId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.employeeBenefitId],
			foreignColumns: [employeeBenefits.id],
			name: "benefit_dependents_employee_benefit_id_fkey"
		}).onDelete("cascade"),
]);

export const raciChangeLog = pgTable("raci_change_log", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	objectOwnerId: uuid("object_owner_id"),
	entityType: text("entity_type").notNull(),
	entityId: uuid("entity_id").notNull(),
	changeType: text("change_type").notNull(),
	previousRole: text("previous_role"),
	newRole: text("new_role"),
	previousUserId: uuid("previous_user_id"),
	newUserId: uuid("new_user_id"),
	previousPermission: text("previous_permission"),
	newPermission: text("new_permission"),
	changedBy: uuid("changed_by"),
	reason: text(),
	changedAt: timestamp("changed_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_raci_change_log_changed_at").using("btree", table.changedAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_raci_change_log_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.changedBy],
			foreignColumns: [userProfiles.id],
			name: "raci_change_log_changed_by_fkey"
		}),
	foreignKey({
			columns: [table.objectOwnerId],
			foreignColumns: [objectOwners.id],
			name: "raci_change_log_object_owner_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "raci_change_log_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("raci_change_log_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = COALESCE((current_setting('app.current_org_id'::text, true))::uuid, ((auth.jwt() ->> 'org_id'::text))::uuid))` }),
	check("raci_change_log_change_type_check", sql`change_type = ANY (ARRAY['assigned'::text, 'role_changed'::text, 'permission_changed'::text, 'removed'::text, 'transferred'::text])`),
]);

export const employeeCompliance = pgTable("employee_compliance", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	employeeId: uuid("employee_id").notNull(),
	requirementId: uuid("requirement_id").notNull(),
	status: complianceStatus().default('pending').notNull(),
	dueDate: date("due_date"),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	documentUrl: text("document_url"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_employee_compliance_employee_id").using("btree", table.employeeId.asc().nullsLast().op("uuid_ops")),
	index("idx_employee_compliance_requirement_id").using("btree", table.requirementId.asc().nullsLast().op("uuid_ops")),
	index("idx_employee_compliance_status").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.employeeId],
			foreignColumns: [employees.id],
			name: "employee_compliance_employee_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.requirementId],
			foreignColumns: [legacyComplianceRequirements.id],
			name: "employee_compliance_requirement_id_fkey"
		}),
]);

export const i9Records = pgTable("i9_records", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	employeeId: uuid("employee_id").notNull(),
	section1CompletedAt: timestamp("section1_completed_at", { withTimezone: true, mode: 'string' }),
	section2CompletedAt: timestamp("section2_completed_at", { withTimezone: true, mode: 'string' }),
	listADocument: text("list_a_document"),
	listBDocument: text("list_b_document"),
	listCDocument: text("list_c_document"),
	authorizedRepName: text("authorized_rep_name"),
	authorizedRepTitle: text("authorized_rep_title"),
	reverificationDate: date("reverification_date"),
	status: i9Status().default('pending').notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_i9_records_employee_id").using("btree", table.employeeId.asc().nullsLast().op("uuid_ops")),
	index("idx_i9_records_status").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "i9_records_created_by_fkey"
		}),
	foreignKey({
			columns: [table.employeeId],
			foreignColumns: [employees.id],
			name: "i9_records_employee_id_fkey"
		}).onDelete("cascade"),
	unique("i9_records_employee_id_key").on(table.employeeId),
]);

export const legacyComplianceRequirements = pgTable("legacy_compliance_requirements", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	type: complianceType().notNull(),
	jurisdiction: text(),
	appliesTo: complianceAppliesTo("applies_to").default('all').notNull(),
	frequency: complianceFrequency().notNull(),
	description: text(),
	documentTemplateUrl: text("document_template_url"),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_compliance_requirements_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")),
	index("idx_compliance_requirements_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_compliance_requirements_type").using("btree", table.type.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "compliance_requirements_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "compliance_requirements_org_id_fkey"
		}).onDelete("cascade"),
]);

export const performanceGoals = pgTable("performance_goals", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	employeeId: uuid("employee_id").notNull(),
	reviewId: uuid("review_id"),
	goal: text().notNull(),
	category: performanceGoalCategory().notNull(),
	weightPercent: integer("weight_percent"),
	status: goalStatus().default('not_started').notNull(),
	rating: integer(),
	comments: text(),
	startDate: date("start_date"),
	targetDate: date("target_date"),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_performance_goals_employee_id").using("btree", table.employeeId.asc().nullsLast().op("uuid_ops")),
	index("idx_performance_goals_review_id").using("btree", table.reviewId.asc().nullsLast().op("uuid_ops")),
	index("idx_performance_goals_status").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "performance_goals_created_by_fkey"
		}),
	foreignKey({
			columns: [table.employeeId],
			foreignColumns: [employees.id],
			name: "performance_goals_employee_id_fkey"
		}).onDelete("cascade"),
	check("performance_goals_rating_check", sql`(rating >= 1) AND (rating <= 5)`),
]);

export const performanceFeedback = pgTable("performance_feedback", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	reviewId: uuid("review_id").notNull(),
	feedbackType: feedbackType("feedback_type").notNull(),
	content: text().notNull(),
	category: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_performance_feedback_review_id").using("btree", table.reviewId.asc().nullsLast().op("uuid_ops")),
	index("idx_performance_feedback_type").using("btree", table.feedbackType.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "performance_feedback_created_by_fkey"
		}),
]);

export const patternChecklistItems = pgTable("pattern_checklist_items", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	patternId: uuid("pattern_id").notNull(),
	itemText: text("item_text").notNull(),
	orderIndex: integer("order_index").default(0),
	isRequired: boolean("is_required").default(false),
	autoCompleteCondition: jsonb("auto_complete_condition"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	foreignKey({
			columns: [table.patternId],
			foreignColumns: [activityPatterns.id],
			name: "pattern_checklist_items_pattern_id_fkey"
		}).onDelete("cascade"),
]);

export const activityPatternSuccessors = pgTable("activity_pattern_successors", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	patternId: uuid("pattern_id").notNull(),
	successorPatternId: uuid("successor_pattern_id").notNull(),
	conditionType: text("condition_type").default('always'),
	conditionField: text("condition_field"),
	conditionValue: text("condition_value"),
	conditionExpression: jsonb("condition_expression"),
	delayDays: integer("delay_days").default(0),
	orderIndex: integer("order_index").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_pattern_successors_pattern").using("btree", table.patternId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.patternId],
			foreignColumns: [activityPatterns.id],
			name: "activity_pattern_successors_pattern_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.successorPatternId],
			foreignColumns: [activityPatterns.id],
			name: "activity_pattern_successors_successor_pattern_id_fkey"
		}).onDelete("cascade"),
	unique("activity_pattern_successors_pattern_id_successor_pattern_id_key").on(table.patternId, table.successorPatternId),
]);

export const workplanTemplates = pgTable("workplan_templates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id"),
	code: text().notNull(),
	name: text().notNull(),
	description: text(),
	entityType: text("entity_type").notNull(),
	triggerEvent: text("trigger_event").default('manual'),
	triggerStatus: text("trigger_status"),
	triggerField: text("trigger_field"),
	triggerCondition: jsonb("trigger_condition"),
	completionCriteria: text("completion_criteria").default('all_required'),
	isSystem: boolean("is_system").default(false),
	isActive: boolean("is_active").default(true),
	version: integer().default(1),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_workplan_templates_entity").using("btree", table.entityType.asc().nullsLast().op("bool_ops"), table.isActive.asc().nullsLast().op("bool_ops")),
	index("idx_workplan_templates_trigger").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.triggerEvent.asc().nullsLast().op("text_ops"), table.triggerStatus.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "workplan_templates_org_id_fkey"
		}).onDelete("cascade"),
	unique("workplan_templates_org_id_code_key").on(table.orgId, table.code),
	pgPolicy("workplan_templates_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id = current_user_org_id()) OR (is_system = true))` }),
]);

export const workplanPhases = pgTable("workplan_phases", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	templateId: uuid("template_id").notNull(),
	phaseName: text("phase_name").notNull(),
	phaseCode: text("phase_code").notNull(),
	description: text(),
	orderIndex: integer("order_index").default(0),
	completionCriteria: text("completion_criteria").default('all_required'),
	autoAdvance: boolean("auto_advance").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	foreignKey({
			columns: [table.templateId],
			foreignColumns: [workplanTemplates.id],
			name: "workplan_phases_template_id_fkey"
		}).onDelete("cascade"),
	unique("workplan_phases_template_id_phase_code_key").on(table.templateId, table.phaseCode),
]);

export const workplanInstances = pgTable("workplan_instances", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	templateId: uuid("template_id"),
	entityType: text("entity_type").notNull(),
	entityId: uuid("entity_id").notNull(),
	templateCode: text("template_code"),
	templateName: text("template_name"),
	status: text().default('active'),
	totalActivities: integer("total_activities").default(0),
	completedActivities: integer("completed_activities").default(0),
	skippedActivities: integer("skipped_activities").default(0),
	currentPhase: text("current_phase"),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	pausedAt: timestamp("paused_at", { withTimezone: true, mode: 'string' }),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	canceledAt: timestamp("canceled_at", { withTimezone: true, mode: 'string' }),
	outcome: text(),
	outcomeNotes: text("outcome_notes"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	progressPercentage: integer("progress_percentage").generatedAlwaysAs(sql`
CASE
    WHEN (total_activities > 0) THEN (((completed_activities + skipped_activities) * 100) / total_activities)
    ELSE 0
END`),
}, (table) => [
	index("idx_workplan_instances_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("uuid_ops")),
	index("idx_workplan_instances_status").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("uuid_ops")),
	index("workplan_instances_entity_idx").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("uuid_ops")),
	index("workplan_instances_status_idx").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "workplan_instances_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "workplan_instances_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.templateId],
			foreignColumns: [workplanTemplates.id],
			name: "workplan_instances_template_id_fkey"
		}),
	pgPolicy("workplan_instances_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const workplanTemplateActivities = pgTable("workplan_template_activities", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	templateId: uuid("template_id").notNull(),
	patternId: uuid("pattern_id").notNull(),
	orderIndex: integer("order_index").default(0).notNull(),
	phase: text(),
	isRequired: boolean("is_required").default(true),
	skipCondition: jsonb("skip_condition"),
	canRunParallel: boolean("can_run_parallel").default(false),
	dependsOnActivityIds: uuid("depends_on_activity_ids").array(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_workplan_activities_template").using("btree", table.templateId.asc().nullsLast().op("int4_ops"), table.orderIndex.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.patternId],
			foreignColumns: [activityPatterns.id],
			name: "workplan_template_activities_pattern_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.templateId],
			foreignColumns: [workplanTemplates.id],
			name: "workplan_template_activities_template_id_fkey"
		}).onDelete("cascade"),
	unique("workplan_template_activities_template_id_pattern_id_key").on(table.templateId, table.patternId),
]);

export const activityParticipants = pgTable("activity_participants", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	activityId: uuid("activity_id").notNull(),
	userId: uuid("user_id").notNull(),
	role: text().notNull(),
	permission: text().default('view'),
	isPrimary: boolean("is_primary").default(false),
	notifyOnUpdate: boolean("notify_on_update").default(true),
	addedAt: timestamp("added_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	addedBy: uuid("added_by"),
}, (table) => [
	index("activity_participants_activity_idx").using("btree", table.activityId.asc().nullsLast().op("uuid_ops")),
	index("activity_participants_user_idx").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.activityId],
			foreignColumns: [activities.id],
			name: "activity_participants_activity_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.addedBy],
			foreignColumns: [userProfiles.id],
			name: "activity_participants_added_by_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "activity_participants_user_id_fkey"
		}),
	unique("activity_participants_activity_id_user_id_key").on(table.activityId, table.userId),
]);

export const activityFieldValues = pgTable("activity_field_values", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	activityId: uuid("activity_id").notNull(),
	fieldId: uuid("field_id").notNull(),
	fieldValue: text("field_value"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	foreignKey({
			columns: [table.activityId],
			foreignColumns: [activities.id],
			name: "activity_field_values_activity_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.fieldId],
			foreignColumns: [patternFields.id],
			name: "activity_field_values_field_id_fkey"
		}).onDelete("cascade"),
	unique("activity_field_values_activity_id_field_id_key").on(table.activityId, table.fieldId),
]);

export const activityChecklistItems = pgTable("activity_checklist_items", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	activityId: uuid("activity_id").notNull(),
	patternChecklistItemId: uuid("pattern_checklist_item_id"),
	itemText: text("item_text").notNull(),
	orderIndex: integer("order_index").default(0),
	isCompleted: boolean("is_completed").default(false),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	completedBy: uuid("completed_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	foreignKey({
			columns: [table.activityId],
			foreignColumns: [activities.id],
			name: "activity_checklist_items_activity_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.completedBy],
			foreignColumns: [userProfiles.id],
			name: "activity_checklist_items_completed_by_fkey"
		}),
	foreignKey({
			columns: [table.patternChecklistItemId],
			foreignColumns: [patternChecklistItems.id],
			name: "activity_checklist_items_pattern_checklist_item_id_fkey"
		}),
]);

export const activityComments = pgTable("activity_comments", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	activityId: uuid("activity_id").notNull(),
	commentText: text("comment_text").notNull(),
	commentType: text("comment_type").default('comment'),
	parentCommentId: uuid("parent_comment_id"),
	mentionedUsers: uuid("mentioned_users").array(),
	isInternal: boolean("is_internal").default(false),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by").notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedBy: uuid("updated_by"),
}, (table) => [
	index("activity_comments_activity_idx").using("btree", table.activityId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.activityId],
			foreignColumns: [activities.id],
			name: "activity_comments_activity_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "activity_comments_created_by_fkey"
		}),
	foreignKey({
			columns: [table.parentCommentId],
			foreignColumns: [table.id],
			name: "activity_comments_parent_comment_id_fkey"
		}),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "activity_comments_updated_by_fkey"
		}),
]);

export const activityAttachments = pgTable("activity_attachments", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	activityId: uuid("activity_id").notNull(),
	fileName: text("file_name").notNull(),
	fileSize: integer("file_size"),
	fileType: text("file_type"),
	fileUrl: text("file_url").notNull(),
	storageKey: text("storage_key"),
	description: text(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	uploadedAt: timestamp("uploaded_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	uploadedBy: uuid("uploaded_by").notNull(),
}, (table) => [
	index("activity_attachments_activity_idx").using("btree", table.activityId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.activityId],
			foreignColumns: [activities.id],
			name: "activity_attachments_activity_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.uploadedBy],
			foreignColumns: [userProfiles.id],
			name: "activity_attachments_uploaded_by_fkey"
		}),
]);

export const activityReminders = pgTable("activity_reminders", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	activityId: uuid("activity_id").notNull(),
	userId: uuid("user_id").notNull(),
	remindAt: timestamp("remind_at", { withTimezone: true, mode: 'string' }).notNull(),
	reminderType: text("reminder_type").default('relative'),
	relativeDays: integer("relative_days"),
	relativeHours: integer("relative_hours"),
	channel: text().default('email'),
	isSent: boolean("is_sent").default(false),
	sentAt: timestamp("sent_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("activity_reminders_activity_idx").using("btree", table.activityId.asc().nullsLast().op("uuid_ops")),
	index("activity_reminders_remind_at_idx").using("btree", table.remindAt.asc().nullsLast().op("timestamptz_ops")),
	foreignKey({
			columns: [table.activityId],
			foreignColumns: [activities.id],
			name: "activity_reminders_activity_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "activity_reminders_user_id_fkey"
		}),
]);

export const podSprintMetrics = pgTable("pod_sprint_metrics", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	podId: uuid("pod_id").notNull(),
	sprintNumber: integer("sprint_number").notNull(),
	sprintStartDate: date("sprint_start_date").notNull(),
	sprintEndDate: date("sprint_end_date").notNull(),
	placementsTarget: integer("placements_target").default(2),
	placementsStretchTarget: integer("placements_stretch_target").default(3),
	submissionsTarget: integer("submissions_target").default(20),
	submissionsStretchTarget: integer("submissions_stretch_target").default(30),
	clientMeetingsTarget: integer("client_meetings_target").default(5),
	newCandidatesTarget: integer("new_candidates_target").default(30),
	placementsActual: integer("placements_actual").default(0),
	submissionsActual: integer("submissions_actual").default(0),
	clientMeetingsActual: integer("client_meetings_actual").default(0),
	newCandidatesActual: integer("new_candidates_actual").default(0),
	targetAchievementPct: numeric("target_achievement_pct", { precision: 5, scale:  2 }).generatedAlwaysAs(sql`
CASE
    WHEN (placements_target > 0) THEN round((((placements_actual)::numeric / (placements_target)::numeric) * (100)::numeric), 2)
    ELSE (0)::numeric
END`),
	status: text().default('active'),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_pod_sprint_metrics_active").using("btree", table.podId.asc().nullsLast().op("uuid_ops")).where(sql`(status = 'active'::text)`),
	index("idx_pod_sprint_metrics_dates").using("btree", table.sprintStartDate.asc().nullsLast().op("date_ops"), table.sprintEndDate.asc().nullsLast().op("date_ops")),
	index("idx_pod_sprint_metrics_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_pod_sprint_metrics_pod_id").using("btree", table.podId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "pod_sprint_metrics_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.podId],
			foreignColumns: [pods.id],
			name: "pod_sprint_metrics_pod_id_fkey"
		}).onDelete("cascade"),
	unique("pod_sprint_metrics_pod_id_sprint_number_key").on(table.podId, table.sprintNumber),
	pgPolicy("pod_sprint_metrics_employee_read", { as: "permissive", for: "select", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid())))` }),
	pgPolicy("pod_sprint_metrics_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	check("pod_sprint_metrics_status_check", sql`status = ANY (ARRAY['active'::text, 'completed'::text, 'cancelled'::text])`),
]);

export const activityTimeEntries = pgTable("activity_time_entries", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	activityId: uuid("activity_id").notNull(),
	userId: uuid("user_id").notNull(),
	startTime: timestamp("start_time", { withTimezone: true, mode: 'string' }).notNull(),
	endTime: timestamp("end_time", { withTimezone: true, mode: 'string' }),
	durationMinutes: integer("duration_minutes"),
	description: text(),
	isBillable: boolean("is_billable").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("activity_time_entries_activity_idx").using("btree", table.activityId.asc().nullsLast().op("uuid_ops")),
	index("activity_time_entries_user_idx").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.activityId],
			foreignColumns: [activities.id],
			name: "activity_time_entries_activity_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "activity_time_entries_user_id_fkey"
		}),
]);

export const activityDependencies = pgTable("activity_dependencies", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	activityId: uuid("activity_id").notNull(),
	dependsOnActivityId: uuid("depends_on_activity_id").notNull(),
	dependencyType: text("dependency_type").default('finish_to_start'),
	lagDays: integer("lag_days").default(0),
	isStrict: boolean("is_strict").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("activity_dependencies_activity_idx").using("btree", table.activityId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.activityId],
			foreignColumns: [activities.id],
			name: "activity_dependencies_activity_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.dependsOnActivityId],
			foreignColumns: [activities.id],
			name: "activity_dependencies_depends_on_activity_id_fkey"
		}).onDelete("cascade"),
	unique("activity_dependencies_activity_id_depends_on_activity_id_key").on(table.activityId, table.dependsOnActivityId),
]);

export const activityAutoRules = pgTable("activity_auto_rules", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id"),
	ruleName: text("rule_name").notNull(),
	ruleCode: text("rule_code").notNull(),
	description: text(),
	eventType: text("event_type").notNull(),
	eventCategory: text("event_category").notNull(),
	entityType: text("entity_type").notNull(),
	condition: jsonb(),
	activityPatternId: uuid("activity_pattern_id").notNull(),
	delayDays: integer("delay_days").default(0),
	delayHours: integer("delay_hours").default(0),
	assignToField: text("assign_to_field"),
	assignToUserId: uuid("assign_to_user_id"),
	assignToGroupId: uuid("assign_to_group_id"),
	isActive: boolean("is_active").default(true),
	priority: integer().default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("activity_auto_rules_event_type_idx").using("btree", table.eventType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.activityPatternId],
			foreignColumns: [activityPatterns.id],
			name: "activity_auto_rules_activity_pattern_id_fkey"
		}),
	foreignKey({
			columns: [table.assignToGroupId],
			foreignColumns: [pods.id],
			name: "activity_auto_rules_assign_to_group_id_fkey"
		}),
	foreignKey({
			columns: [table.assignToUserId],
			foreignColumns: [userProfiles.id],
			name: "activity_auto_rules_assign_to_user_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "activity_auto_rules_org_id_fkey"
		}).onDelete("cascade"),
	unique("activity_auto_rules_org_id_rule_code_key").on(table.orgId, table.ruleCode),
]);

export const activityHistory = pgTable("activity_history", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	activityId: uuid("activity_id").notNull(),
	action: text().notNull(),
	fieldChanged: text("field_changed"),
	oldValue: text("old_value"),
	newValue: text("new_value"),
	changedBy: uuid("changed_by"),
	changedAt: timestamp("changed_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	notes: text(),
}, (table) => [
	index("activity_history_activity_idx").using("btree", table.activityId.asc().nullsLast().op("uuid_ops")),
	index("activity_history_changed_at_idx").using("btree", table.changedAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_activity_history_activity").using("btree", table.activityId.asc().nullsLast().op("timestamptz_ops"), table.changedAt.desc().nullsFirst().op("timestamptz_ops")),
	foreignKey({
			columns: [table.activityId],
			foreignColumns: [activities.id],
			name: "activity_history_activity_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.changedBy],
			foreignColumns: [userProfiles.id],
			name: "activity_history_changed_by_fkey"
		}),
]);

export const addresses = pgTable("addresses", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: text("entity_type").notNull(),
	entityId: uuid("entity_id").notNull(),
	addressType: text("address_type").notNull(),
	addressLine1: text("address_line_1"),
	addressLine2: text("address_line_2"),
	addressLine3: text("address_line_3"),
	city: text(),
	stateProvince: text("state_province"),
	postalCode: text("postal_code"),
	countryCode: text("country_code").default('US').notNull(),
	county: text(),
	latitude: numeric({ precision: 10, scale:  7 }),
	longitude: numeric({ precision: 10, scale:  7 }),
	isVerified: boolean("is_verified").default(false),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	verificationSource: text("verification_source"),
	isPrimary: boolean("is_primary").default(false),
	effectiveFrom: date("effective_from"),
	effectiveTo: date("effective_to"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
}, (table) => [
	index("idx_addresses_country").using("btree", table.countryCode.asc().nullsLast().op("text_ops")),
	index("idx_addresses_entity").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("uuid_ops")),
	index("idx_addresses_entity_lookup").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("text_ops")),
	index("idx_addresses_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_addresses_org_city_state").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.city.asc().nullsLast().op("uuid_ops"), table.stateProvince.asc().nullsLast().op("uuid_ops")),
	index("idx_addresses_primary").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("uuid_ops"), table.isPrimary.asc().nullsLast().op("uuid_ops")).where(sql`(is_primary = true)`),
	index("idx_addresses_type").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.addressType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "addresses_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("addresses_service_all", { as: "permissive", for: "all", to: ["service_role"], using: sql`true`, withCheck: sql`true`  }),
	check("addresses_address_type_check", sql`address_type = ANY (ARRAY['current'::text, 'permanent'::text, 'mailing'::text, 'work'::text, 'billing'::text, 'shipping'::text, 'headquarters'::text, 'office'::text, 'job_location'::text, 'meeting'::text, 'first_day'::text])`),
	check("addresses_entity_type_check", sql`entity_type = ANY (ARRAY['candidate'::text, 'account'::text, 'contact'::text, 'vendor'::text, 'organization'::text, 'lead'::text, 'job'::text, 'interview'::text, 'employee'::text, 'placement'::text])`),
]);

export const queueItems = pgTable("queue_items", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	queueId: uuid("queue_id").notNull(),
	entityType: text("entity_type").notNull(),
	entityId: uuid("entity_id").notNull(),
	priority: integer().default(0),
	orderIndex: integer("order_index").default(0),
	assignedTo: uuid("assigned_to"),
	assignedAt: timestamp("assigned_at", { withTimezone: true, mode: 'string' }),
	status: text().default('queued'),
	enqueuedAt: timestamp("enqueued_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	removedAt: timestamp("removed_at", { withTimezone: true, mode: 'string' }),
	metadata: jsonb(),
}, (table) => [
	index("queue_items_entity_idx").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("text_ops")),
	index("queue_items_queue_idx").using("btree", table.queueId.asc().nullsLast().op("uuid_ops")),
	index("queue_items_status_idx").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.assignedTo],
			foreignColumns: [userProfiles.id],
			name: "queue_items_assigned_to_fkey"
		}),
	foreignKey({
			columns: [table.queueId],
			foreignColumns: [workQueues.id],
			name: "queue_items_queue_id_fkey"
		}).onDelete("cascade"),
	unique("queue_items_queue_id_entity_type_entity_id_key").on(table.queueId, table.entityType, table.entityId),
]);

export const slaInstances = pgTable("sla_instances", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	slaDefinitionId: uuid("sla_definition_id").notNull(),
	activityId: uuid("activity_id").notNull(),
	startTime: timestamp("start_time", { withTimezone: true, mode: 'string' }).notNull(),
	targetTime: timestamp("target_time", { withTimezone: true, mode: 'string' }).notNull(),
	warningTime: timestamp("warning_time", { withTimezone: true, mode: 'string' }),
	criticalTime: timestamp("critical_time", { withTimezone: true, mode: 'string' }),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	status: text().default('active'),
	pausedAt: timestamp("paused_at", { withTimezone: true, mode: 'string' }),
	resumedAt: timestamp("resumed_at", { withTimezone: true, mode: 'string' }),
	breachDuration: integer("breach_duration"),
	isBreached: boolean("is_breached").default(false),
	breachedAt: timestamp("breached_at", { withTimezone: true, mode: 'string' }),
	escalationSent: boolean("escalation_sent").default(false),
	escalationSentAt: timestamp("escalation_sent_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("sla_instances_activity_idx").using("btree", table.activityId.asc().nullsLast().op("uuid_ops")),
	index("sla_instances_status_idx").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("sla_instances_target_time_idx").using("btree", table.targetTime.asc().nullsLast().op("timestamptz_ops")),
	foreignKey({
			columns: [table.activityId],
			foreignColumns: [activities.id],
			name: "sla_instances_activity_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "sla_instances_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.slaDefinitionId],
			foreignColumns: [slaDefinitions.id],
			name: "sla_instances_sla_definition_id_fkey"
		}),
	pgPolicy("sla_instances_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid())))` }),
]);

export const bulkActivityJobs = pgTable("bulk_activity_jobs", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	jobName: text("job_name").notNull(),
	jobType: text("job_type").notNull(),
	activityPatternId: uuid("activity_pattern_id"),
	targetEntityType: text("target_entity_type"),
	targetEntityIds: uuid("target_entity_ids").array(),
	targetCriteria: jsonb("target_criteria"),
	operation: jsonb().notNull(),
	status: text().default('pending'),
	totalItems: integer("total_items").default(0),
	processedItems: integer("processed_items").default(0),
	failedItems: integer("failed_items").default(0),
	errorLog: jsonb("error_log"),
	resultSummary: jsonb("result_summary"),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	canceledAt: timestamp("canceled_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by").notNull(),
}, (table) => [
	index("bulk_activity_jobs_created_by_idx").using("btree", table.createdBy.asc().nullsLast().op("uuid_ops")),
	index("bulk_activity_jobs_status_idx").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.activityPatternId],
			foreignColumns: [activityPatterns.id],
			name: "bulk_activity_jobs_activity_pattern_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "bulk_activity_jobs_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "bulk_activity_jobs_org_id_fkey"
		}).onDelete("cascade"),
]);

export const activityMetrics = pgTable("activity_metrics", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	metricDate: timestamp("metric_date", { withTimezone: true, mode: 'string' }).notNull(),
	entityType: text("entity_type"),
	activityType: text("activity_type"),
	activityCategory: text("activity_category"),
	userId: uuid("user_id"),
	podId: uuid("pod_id"),
	totalActivities: integer("total_activities").default(0),
	createdActivities: integer("created_activities").default(0),
	completedActivities: integer("completed_activities").default(0),
	overdueActivities: integer("overdue_activities").default(0),
	completionRate: numeric("completion_rate", { precision: 5, scale:  2 }),
	avgCompletionTimeHours: numeric("avg_completion_time_hours", { precision: 10, scale:  2 }),
	slaMetCount: integer("sla_met_count").default(0),
	slaBreachedCount: integer("sla_breached_count").default(0),
	slaComplianceRate: numeric("sla_compliance_rate", { precision: 5, scale:  2 }),
	totalTimeMinutes: integer("total_time_minutes").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("activity_metrics_date_idx").using("btree", table.metricDate.asc().nullsLast().op("timestamptz_ops")),
	index("activity_metrics_pod_idx").using("btree", table.podId.asc().nullsLast().op("uuid_ops")),
	index("activity_metrics_user_idx").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "activity_metrics_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.podId],
			foreignColumns: [pods.id],
			name: "activity_metrics_pod_id_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "activity_metrics_user_id_fkey"
		}),
]);

export const teamMetrics = pgTable("team_metrics", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	podId: uuid("pod_id").notNull(),
	metricDate: timestamp("metric_date", { withTimezone: true, mode: 'string' }).notNull(),
	metricPeriod: text("metric_period").default('day'),
	totalActivities: integer("total_activities").default(0),
	completedActivities: integer("completed_activities").default(0),
	avgResponseTimeHours: numeric("avg_response_time_hours", { precision: 10, scale:  2 }),
	avgResolutionTimeHours: numeric("avg_resolution_time_hours", { precision: 10, scale:  2 }),
	totalActiveMembers: integer("total_active_members").default(0),
	avgActivitiesPerMember: numeric("avg_activities_per_member", { precision: 10, scale:  2 }),
	slaComplianceRate: numeric("sla_compliance_rate", { precision: 5, scale:  2 }),
	activitiesCreatedPerDay: numeric("activities_created_per_day", { precision: 10, scale:  2 }),
	activitiesCompletedPerDay: numeric("activities_completed_per_day", { precision: 10, scale:  2 }),
	escalationCount: integer("escalation_count").default(0),
	reassignmentCount: integer("reassignment_count").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("team_metrics_date_idx").using("btree", table.metricDate.asc().nullsLast().op("timestamptz_ops")),
	index("team_metrics_pod_idx").using("btree", table.podId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "team_metrics_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.podId],
			foreignColumns: [pods.id],
			name: "team_metrics_pod_id_fkey"
		}),
	unique("team_metrics_pod_id_metric_date_metric_period_key").on(table.podId, table.metricDate, table.metricPeriod),
]);

export const learningPaths = pgTable("learning_paths", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	slug: text().notNull(),
	title: text().notNull(),
	description: text().notNull(),
	category: text(),
	difficulty: skillLevel().default('beginner').notNull(),
	durationEstimateHours: integer("duration_estimate_hours"),
	status: pathStatus().default('draft').notNull(),
	thumbnailUrl: text("thumbnail_url"),
	createdBy: uuid("created_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_learning_paths_deleted_at").using("btree", table.deletedAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_learning_paths_difficulty").using("btree", table.difficulty.asc().nullsLast().op("enum_ops")),
	index("idx_learning_paths_slug").using("btree", table.slug.asc().nullsLast().op("text_ops")),
	index("idx_learning_paths_status").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "learning_paths_created_by_fkey"
		}),
	unique("learning_paths_slug_key").on(table.slug),
]);

export const learningPathCourses = pgTable("learning_path_courses", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	pathId: uuid("path_id").notNull(),
	courseId: uuid("course_id").notNull(),
	sequence: integer().notNull(),
	isRequired: boolean("is_required").default(true).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_learning_path_courses_course_id").using("btree", table.courseId.asc().nullsLast().op("uuid_ops")),
	index("idx_learning_path_courses_path_id").using("btree", table.pathId.asc().nullsLast().op("uuid_ops")),
	index("idx_learning_path_courses_sequence").using("btree", table.sequence.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.courseId],
			foreignColumns: [courses.id],
			name: "learning_path_courses_course_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.pathId],
			foreignColumns: [learningPaths.id],
			name: "learning_path_courses_path_id_fkey"
		}).onDelete("cascade"),
	unique("learning_path_courses_path_id_course_id_key").on(table.pathId, table.courseId),
]);

export const pathEnrollments = pgTable("path_enrollments", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	pathId: uuid("path_id").notNull(),
	status: enrollmentStatus().default('pending').notNull(),
	enrolledAt: timestamp("enrolled_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	progressPercent: integer("progress_percent").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_path_enrollments_path_id").using("btree", table.pathId.asc().nullsLast().op("uuid_ops")),
	index("idx_path_enrollments_status").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	index("idx_path_enrollments_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.pathId],
			foreignColumns: [learningPaths.id],
			name: "path_enrollments_path_id_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "path_enrollments_user_id_fkey"
		}),
	unique("path_enrollments_user_id_path_id_key").on(table.userId, table.pathId),
	check("path_enrollments_progress_percent_check", sql`(progress_percent >= 0) AND (progress_percent <= 100)`),
]);

export const certificates = pgTable("certificates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	enrollmentId: uuid("enrollment_id").notNull(),
	templateId: uuid("template_id"),
	certificateNumber: text("certificate_number").notNull(),
	issuedAt: timestamp("issued_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	expiryDate: timestamp("expiry_date", { withTimezone: true, mode: 'string' }),
	pdfUrl: text("pdf_url"),
	verificationCode: text("verification_code").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_certificates_certificate_number").using("btree", table.certificateNumber.asc().nullsLast().op("text_ops")),
	index("idx_certificates_enrollment_id").using("btree", table.enrollmentId.asc().nullsLast().op("uuid_ops")),
	index("idx_certificates_verification_code").using("btree", table.verificationCode.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.enrollmentId],
			foreignColumns: [studentEnrollments.id],
			name: "certificates_enrollment_id_fkey"
		}),
	foreignKey({
			columns: [table.templateId],
			foreignColumns: [certificateTemplates.id],
			name: "certificates_template_id_fkey"
		}),
	unique("certificates_certificate_number_key").on(table.certificateNumber),
	unique("certificates_verification_code_key").on(table.verificationCode),
]);

export const certificateTemplates = pgTable("certificate_templates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	name: text().notNull(),
	designTemplate: text("design_template").notNull(),
	fields: jsonb(),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_certificate_templates_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")),
]);

export const userLevels = pgTable("user_levels", {
	userId: uuid("user_id").primaryKey().notNull(),
	currentLevel: integer("current_level").default(1).notNull(),
	currentXp: integer("current_xp").default(0).notNull(),
	xpToNextLevel: integer("xp_to_next_level").default(100).notNull(),
	levelUpAt: timestamp("level_up_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_user_levels_current_level").using("btree", table.currentLevel.asc().nullsLast().op("int4_ops")),
	index("idx_user_levels_current_xp").using("btree", table.currentXp.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "user_levels_user_id_fkey"
		}),
]);

export const userAchievements = pgTable("user_achievements", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	achievementId: uuid("achievement_id").notNull(),
	unlockedAt: timestamp("unlocked_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	progress: jsonb(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_user_achievements_achievement_id").using("btree", table.achievementId.asc().nullsLast().op("uuid_ops")),
	index("idx_user_achievements_unlocked_at").using("btree", table.unlockedAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_user_achievements_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.achievementId],
			foreignColumns: [achievements.id],
			name: "user_achievements_achievement_id_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "user_achievements_user_id_fkey"
		}),
	unique("user_achievements_user_id_achievement_id_key").on(table.userId, table.achievementId),
]);

export const achievements = pgTable("achievements", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	slug: text().notNull(),
	name: text().notNull(),
	description: text().notNull(),
	category: text().notNull(),
	badgeUrl: text("badge_url"),
	xpReward: integer("xp_reward").default(0).notNull(),
	criteria: jsonb().notNull(),
	isSecret: boolean("is_secret").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_achievements_category").using("btree", table.category.asc().nullsLast().op("text_ops")),
	index("idx_achievements_is_secret").using("btree", table.isSecret.asc().nullsLast().op("bool_ops")),
	index("idx_achievements_slug").using("btree", table.slug.asc().nullsLast().op("text_ops")),
	unique("achievements_slug_key").on(table.slug),
]);

export const learningStreaks = pgTable("learning_streaks", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	streakType: streakTypeEnum("streak_type").notNull(),
	currentCount: integer("current_count").default(0).notNull(),
	longestCount: integer("longest_count").default(0).notNull(),
	lastActivityDate: timestamp("last_activity_date", { withTimezone: true, mode: 'string' }),
	streakStartedAt: timestamp("streak_started_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_learning_streaks_current_count").using("btree", table.currentCount.asc().nullsLast().op("int4_ops")),
	index("idx_learning_streaks_last_activity_date").using("btree", table.lastActivityDate.asc().nullsLast().op("timestamptz_ops")),
	index("idx_learning_streaks_streak_type").using("btree", table.streakType.asc().nullsLast().op("enum_ops")),
	index("idx_learning_streaks_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "learning_streaks_user_id_fkey"
		}),
	unique("learning_streaks_user_id_streak_type_key").on(table.userId, table.streakType),
]);

export const leaderboards = pgTable("leaderboards", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	type: leaderboardType().notNull(),
	scope: leaderboardScope().notNull(),
	periodStart: timestamp("period_start", { withTimezone: true, mode: 'string' }).notNull(),
	periodEnd: timestamp("period_end", { withTimezone: true, mode: 'string' }).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_leaderboards_period").using("btree", table.periodStart.asc().nullsLast().op("timestamptz_ops"), table.periodEnd.asc().nullsLast().op("timestamptz_ops")),
	index("idx_leaderboards_scope").using("btree", table.scope.asc().nullsLast().op("enum_ops")),
	index("idx_leaderboards_type").using("btree", table.type.asc().nullsLast().op("enum_ops")),
]);

export const leaderboardEntries = pgTable("leaderboard_entries", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	leaderboardId: uuid("leaderboard_id").notNull(),
	userId: uuid("user_id").notNull(),
	rank: integer().notNull(),
	xpEarned: integer("xp_earned").default(0).notNull(),
	coursesCompleted: integer("courses_completed").default(0).notNull(),
	lessonsCompleted: integer("lessons_completed").default(0).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_leaderboard_entries_leaderboard_id").using("btree", table.leaderboardId.asc().nullsLast().op("uuid_ops")),
	index("idx_leaderboard_entries_rank").using("btree", table.rank.asc().nullsLast().op("int4_ops")),
	index("idx_leaderboard_entries_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	index("idx_leaderboard_entries_xp_earned").using("btree", table.xpEarned.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.leaderboardId],
			foreignColumns: [leaderboards.id],
			name: "leaderboard_entries_leaderboard_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "leaderboard_entries_user_id_fkey"
		}),
	unique("leaderboard_entries_leaderboard_id_user_id_key").on(table.leaderboardId, table.userId),
]);

export const levelDefinitions = pgTable("level_definitions", {
	level: integer().primaryKey().notNull(),
	xpRequired: integer("xp_required").notNull(),
	title: text().notNull(),
	badgeUrl: text("badge_url"),
	perks: jsonb(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_level_definitions_xp_required").using("btree", table.xpRequired.asc().nullsLast().op("int4_ops")),
]);

export const loginHistory = pgTable("login_history", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id"),
	orgId: uuid("org_id").notNull(),
	email: varchar({ length: 255 }).notNull(),
	success: boolean().notNull(),
	ipAddress: inet("ip_address"),
	userAgent: text("user_agent"),
	failureReason: varchar("failure_reason", { length: 100 }),
	deviceInfo: jsonb("device_info").default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_login_history_created").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_login_history_email").using("btree", table.email.asc().nullsLast().op("text_ops")),
	index("idx_login_history_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_login_history_success").using("btree", table.success.asc().nullsLast().op("bool_ops")),
	index("idx_login_history_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "login_history_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "login_history_user_id_fkey"
		}).onDelete("set null"),
	pgPolicy("login_history_org_policy", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id = auth_user_org_id()) OR user_is_admin())` }),
]);

export const userInvitations = pgTable("user_invitations", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	email: varchar({ length: 255 }).notNull(),
	firstName: varchar("first_name", { length: 100 }),
	lastName: varchar("last_name", { length: 100 }),
	roleId: uuid("role_id").notNull(),
	podId: uuid("pod_id"),
	managerId: uuid("manager_id"),
	token: varchar({ length: 255 }).notNull(),
	invitedBy: uuid("invited_by").notNull(),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }).notNull(),
	acceptedAt: timestamp("accepted_at", { withTimezone: true, mode: 'string' }),
	cancelledAt: timestamp("cancelled_at", { withTimezone: true, mode: 'string' }),
	requireTwoFactor: boolean("require_two_factor").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_user_invitations_email").using("btree", table.email.asc().nullsLast().op("text_ops")),
	index("idx_user_invitations_expires").using("btree", table.expiresAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_user_invitations_invited_by").using("btree", table.invitedBy.asc().nullsLast().op("uuid_ops")),
	index("idx_user_invitations_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_user_invitations_status").using("btree", table.acceptedAt.asc().nullsLast().op("timestamptz_ops"), table.cancelledAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_user_invitations_token").using("btree", table.token.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.invitedBy],
			foreignColumns: [userProfiles.id],
			name: "user_invitations_invited_by_fkey"
		}),
	foreignKey({
			columns: [table.managerId],
			foreignColumns: [userProfiles.id],
			name: "user_invitations_manager_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "user_invitations_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.podId],
			foreignColumns: [pods.id],
			name: "user_invitations_pod_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.roleId],
			foreignColumns: [systemRoles.id],
			name: "user_invitations_role_id_fkey"
		}),
	unique("user_invitations_token_key").on(table.token),
	pgPolicy("user_invitations_org_policy", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id = auth_user_org_id()) OR user_is_admin())` }),
]);

export const webhooks = pgTable("webhooks", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: varchar({ length: 100 }).notNull(),
	description: text(),
	url: text().notNull(),
	secret: varchar({ length: 64 }).notNull(),
	events: text().array().default([""]).notNull(),
	headers: jsonb().default({}),
	status: varchar({ length: 20 }).default('active').notNull(),
	consecutiveFailures: integer("consecutive_failures").default(0),
	lastTriggeredAt: timestamp("last_triggered_at", { withTimezone: true, mode: 'string' }),
	lastSuccessAt: timestamp("last_success_at", { withTimezone: true, mode: 'string' }),
	lastFailureAt: timestamp("last_failure_at", { withTimezone: true, mode: 'string' }),
	createdBy: uuid("created_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_webhooks_events").using("gin", table.events.asc().nullsLast().op("array_ops")),
	index("idx_webhooks_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_webhooks_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "webhooks_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "webhooks_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("webhooks_org_access", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text))` }),
]);

export const webhookDeliveries = pgTable("webhook_deliveries", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	webhookId: uuid("webhook_id").notNull(),
	eventType: varchar("event_type", { length: 100 }).notNull(),
	eventId: uuid("event_id"),
	payload: jsonb().notNull(),
	requestUrl: text("request_url").notNull(),
	requestHeaders: jsonb("request_headers").notNull(),
	requestBody: text("request_body").notNull(),
	responseStatus: integer("response_status"),
	responseHeaders: jsonb("response_headers"),
	responseBody: text("response_body"),
	durationMs: integer("duration_ms"),
	attemptNumber: integer("attempt_number").default(1),
	maxAttempts: integer("max_attempts").default(3),
	status: varchar({ length: 20 }).default('pending').notNull(),
	errorMessage: text("error_message"),
	errorCode: varchar("error_code", { length: 50 }),
	nextRetryAt: timestamp("next_retry_at", { withTimezone: true, mode: 'string' }),
	deliveredAt: timestamp("delivered_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_webhook_deliveries_created").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_webhook_deliveries_dlq").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.status.asc().nullsLast().op("uuid_ops")).where(sql`((status)::text = 'dlq'::text)`),
	index("idx_webhook_deliveries_next_retry").using("btree", table.nextRetryAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(((status)::text = 'retrying'::text) AND (next_retry_at IS NOT NULL))`),
	index("idx_webhook_deliveries_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_webhook_deliveries_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_webhook_deliveries_webhook").using("btree", table.webhookId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "webhook_deliveries_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.webhookId],
			foreignColumns: [webhooks.id],
			name: "webhook_deliveries_webhook_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("webhook_deliveries_org_access", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text))` }),
]);

export const integrationRetryConfig = pgTable("integration_retry_config", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	maxRetries: integer("max_retries").default(3).notNull(),
	retryStrategy: varchar("retry_strategy", { length: 20 }).default('exponential').notNull(),
	baseDelaySeconds: integer("base_delay_seconds").default(5).notNull(),
	maxDelaySeconds: integer("max_delay_seconds").default(300).notNull(),
	enableJitter: boolean("enable_jitter").default(true),
	enableDlq: boolean("enable_dlq").default(true),
	dlqRetentionDays: integer("dlq_retention_days").default(30),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "integration_retry_config_org_id_fkey"
		}).onDelete("cascade"),
	unique("integration_retry_config_org_id_key").on(table.orgId),
	pgPolicy("retry_config_org_access", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text))` }),
]);

export const integrationOauthTokens = pgTable("integration_oauth_tokens", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	integrationId: uuid("integration_id").notNull(),
	userId: uuid("user_id"),
	provider: varchar({ length: 50 }).notNull(),
	accessToken: text("access_token").notNull(),
	refreshToken: text("refresh_token"),
	tokenType: varchar("token_type", { length: 20 }).default('Bearer'),
	scope: text(),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }),
	refreshExpiresAt: timestamp("refresh_expires_at", { withTimezone: true, mode: 'string' }),
	accountId: varchar("account_id", { length: 255 }),
	accountEmail: varchar("account_email", { length: 255 }),
	rawTokenResponse: jsonb("raw_token_response"),
	lastRefreshedAt: timestamp("last_refreshed_at", { withTimezone: true, mode: 'string' }),
	lastUsedAt: timestamp("last_used_at", { withTimezone: true, mode: 'string' }),
	status: varchar({ length: 20 }).default('active'),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_oauth_tokens_expires").using("btree", table.expiresAt.asc().nullsLast().op("timestamptz_ops")).where(sql`((status)::text = 'active'::text)`),
	index("idx_oauth_tokens_integration").using("btree", table.integrationId.asc().nullsLast().op("uuid_ops")),
	index("idx_oauth_tokens_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	uniqueIndex("idx_oauth_tokens_unique_integration").using("btree", table.integrationId.asc().nullsLast().op("uuid_ops")).where(sql`((status)::text = 'active'::text)`),
	foreignKey({
			columns: [table.integrationId],
			foreignColumns: [integrations.id],
			name: "integration_oauth_tokens_integration_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "integration_oauth_tokens_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "integration_oauth_tokens_user_id_fkey"
		}),
	pgPolicy("oauth_tokens_org_access", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text))` }),
]);

export const integrationFailoverConfig = pgTable("integration_failover_config", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	integrationType: varchar("integration_type", { length: 50 }).notNull(),
	primaryIntegrationId: uuid("primary_integration_id").notNull(),
	backupIntegrationId: uuid("backup_integration_id"),
	failoverThreshold: integer("failover_threshold").default(3),
	autoFailover: boolean("auto_failover").default(true),
	autoRecovery: boolean("auto_recovery").default(false),
	recoveryCheckIntervalMinutes: integer("recovery_check_interval_minutes").default(30),
	currentActive: varchar("current_active", { length: 20 }).default('primary'),
	lastFailoverAt: timestamp("last_failover_at", { withTimezone: true, mode: 'string' }),
	lastRecoveryAt: timestamp("last_recovery_at", { withTimezone: true, mode: 'string' }),
	failoverCount: integer("failover_count").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_failover_config_backup").using("btree", table.backupIntegrationId.asc().nullsLast().op("uuid_ops")),
	index("idx_failover_config_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_failover_config_primary").using("btree", table.primaryIntegrationId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.backupIntegrationId],
			foreignColumns: [integrations.id],
			name: "integration_failover_config_backup_integration_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "integration_failover_config_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.primaryIntegrationId],
			foreignColumns: [integrations.id],
			name: "integration_failover_config_primary_integration_id_fkey"
		}),
	unique("integration_failover_config_org_id_integration_type_key").on(table.orgId, table.integrationType),
	pgPolicy("failover_config_org_access", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text))` }),
]);

export const externalJobOrderRequirements = pgTable("external_job_order_requirements", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orderId: uuid("order_id").notNull(),
	requirement: text().notNull(),
	type: text().notNull(),
	priority: integer().default(1),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_job_order_requirements_order_id").using("btree", table.orderId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orderId],
			foreignColumns: [externalJobOrders.id],
			name: "job_order_requirements_order_id_fkey"
		}).onDelete("cascade"),
]);

export const externalJobOrderSkills = pgTable("external_job_order_skills", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orderId: uuid("order_id").notNull(),
	skillName: text("skill_name").notNull(),
	yearsRequired: numeric("years_required", { precision: 4, scale:  1 }),
	proficiencyRequired: integer("proficiency_required"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_job_order_skills_order_id").using("btree", table.orderId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orderId],
			foreignColumns: [externalJobOrders.id],
			name: "job_order_skills_order_id_fkey"
		}).onDelete("cascade"),
	check("job_order_skills_proficiency_required_check", sql`(proficiency_required >= 1) AND (proficiency_required <= 5)`),
]);

export const externalJobOrderNotes = pgTable("external_job_order_notes", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orderId: uuid("order_id").notNull(),
	note: text().notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_job_order_notes_order_id").using("btree", table.orderId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "job_order_notes_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orderId],
			foreignColumns: [externalJobOrders.id],
			name: "job_order_notes_order_id_fkey"
		}).onDelete("cascade"),
]);

export const skills = pgTable("skills", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	name: text().notNull(),
	category: text(),
	parentSkillId: uuid("parent_skill_id"),
	description: text(),
	isVerified: boolean("is_verified").default(false),
	usageCount: integer("usage_count").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	canonicalName: varchar("canonical_name", { length: 100 }),
	skillLevel: integer("skill_level").default(2),
	hierarchyPath: text("hierarchy_path"),
	aliases: jsonb().default([]),
	relatedSkills: uuid("related_skills").array(),
	version: varchar({ length: 20 }),
	isLatestVersion: boolean("is_latest_version").default(true),
	demandScore: numeric("demand_score", { precision: 5, scale:  2 }).default('0'),
	trending: boolean().default(false),
	trendingDirection: varchar("trending_direction", { length: 10 }),
	embedding: vector({ dimensions: 1536 }),
	deprecated: boolean().default(false),
	deprecatedSuccessorId: uuid("deprecated_successor_id"),
	orgId: uuid("org_id"),
	// TODO: failed to parse database type 'tsvector'
	searchVector: unknown("search_vector"),
	domain: varchar({ length: 50 }).default('technology'),
}, (table) => [
	uniqueIndex("idx_skills_canonical_unique").using("btree", sql`COALESCE(org_id, '00000000-0000-0000-0000-000000000000'::uuid)`, sql`canonical_name`).where(sql`(canonical_name IS NOT NULL)`),
	index("idx_skills_category").using("btree", table.category.asc().nullsLast().op("text_ops")),
	index("idx_skills_category_domain").using("btree", table.category.asc().nullsLast().op("text_ops"), table.domain.asc().nullsLast().op("text_ops")).where(sql`(is_verified = true)`),
	index("idx_skills_hierarchy").using("btree", table.hierarchyPath.asc().nullsLast().op("text_ops")).where(sql`(hierarchy_path IS NOT NULL)`),
	index("idx_skills_name_lower").using("btree", sql`lower(name)`),
	index("idx_skills_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(org_id IS NOT NULL)`),
	index("idx_skills_parent").using("btree", table.parentSkillId.asc().nullsLast().op("uuid_ops")),
	index("idx_skills_search").using("gin", table.searchVector.asc().nullsLast().op("tsvector_ops")).where(sql`(search_vector IS NOT NULL)`),
	index("idx_skills_trending").using("btree", table.demandScore.desc().nullsFirst().op("numeric_ops")).where(sql`(trending = true)`),
	foreignKey({
			columns: [table.deprecatedSuccessorId],
			foreignColumns: [table.id],
			name: "skills_deprecated_successor_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "skills_org_id_fkey"
		}),
	foreignKey({
			columns: [table.parentSkillId],
			foreignColumns: [table.id],
			name: "skills_parent_skill_id_fkey"
		}),
	unique("skills_name_key").on(table.name),
	pgPolicy("skills_admin_write", { as: "permissive", for: "all", to: ["public"], using: sql`auth_has_role('admin'::text)` }),
	pgPolicy("skills_public_read", { as: "permissive", for: "select", to: ["public"] }),
]);

export const activities = pgTable("activities", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: text("entity_type").notNull(),
	entityId: uuid("entity_id").notNull(),
	activityType: text("activity_type").notNull(),
	status: text().default('open').notNull(),
	priority: text().default('medium').notNull(),
	subject: text(),
	body: text(),
	direction: text(),
	scheduledAt: timestamp("scheduled_at", { withTimezone: true, mode: 'string' }),
	dueDate: timestamp("due_date", { withTimezone: true, mode: 'string' }).defaultNow(),
	escalationDate: timestamp("escalation_date", { withTimezone: true, mode: 'string' }),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	skippedAt: timestamp("skipped_at", { withTimezone: true, mode: 'string' }),
	durationMinutes: integer("duration_minutes"),
	outcome: text(),
	assignedTo: uuid("assigned_to").notNull(),
	performedBy: uuid("performed_by"),
	pocId: uuid("poc_id"),
	parentActivityId: uuid("parent_activity_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	patternCode: text("pattern_code"),
	patternId: uuid("pattern_id"),
	workplanInstanceId: uuid("workplan_instance_id"),
	description: text(),
	category: text(),
	instructions: text(),
	assignedGroup: uuid("assigned_group"),
	assignedAt: timestamp("assigned_at", { withTimezone: true, mode: 'string' }),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }),
	scheduledFor: timestamp("scheduled_for", { withTimezone: true, mode: 'string' }),
	outcomeNotes: text("outcome_notes"),
	autoCreated: boolean("auto_created").default(false),
	autoCompleted: boolean("auto_completed").default(false),
	predecessorActivityId: uuid("predecessor_activity_id"),
	escalationCount: integer("escalation_count").default(0),
	lastEscalatedAt: timestamp("last_escalated_at", { withTimezone: true, mode: 'string' }),
	reminderSentAt: timestamp("reminder_sent_at", { withTimezone: true, mode: 'string' }),
	reminderCount: integer("reminder_count").default(0),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	updatedBy: uuid("updated_by"),
	activityNumber: text("activity_number"),
	secondaryEntityType: text("secondary_entity_type"),
	secondaryEntityId: uuid("secondary_entity_id"),
	followUpRequired: boolean("follow_up_required").default(false),
	followUpDate: timestamp("follow_up_date", { withTimezone: true, mode: 'string' }),
	followUpActivityId: uuid("follow_up_activity_id"),
	tags: text().array(),
	customFields: jsonb("custom_fields").default({}),
	pointsEarned: numeric("points_earned", { precision: 5, scale:  2 }).default('0'),
	relatedContactId: uuid("related_contact_id"),
	relatedDealId: uuid("related_deal_id"),
	relatedCampaignId: uuid("related_campaign_id"),
	nextSteps: text("next_steps"),
	nextFollowUpDate: timestamp("next_follow_up_date", { withTimezone: true, mode: 'string' }),
	queueId: uuid("queue_id"),
	claimedAt: timestamp("claimed_at", { withTimezone: true, mode: 'string' }),
	claimedBy: uuid("claimed_by"),
	isBlocking: boolean("is_blocking").default(false),
	blockingStatuses: text("blocking_statuses").array().default([""]),
	escalatedToUserId: uuid("escalated_to_user_id"),
	originalAssignedTo: uuid("original_assigned_to"),
}, (table) => [
	index("activities_activity_type_idx").using("btree", table.activityType.asc().nullsLast().op("text_ops")),
	index("activities_assigned_to_idx").using("btree", table.assignedTo.asc().nullsLast().op("uuid_ops")),
	index("activities_due_date_idx").using("btree", table.dueDate.asc().nullsLast().op("timestamptz_ops")),
	index("activities_entity_idx").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("text_ops")),
	index("activities_pattern_idx").using("btree", table.patternId.asc().nullsLast().op("uuid_ops")),
	index("activities_status_idx").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("activities_workplan_instance_idx").using("btree", table.workplanInstanceId.asc().nullsLast().op("uuid_ops")),
	index("idx_activities_activity_number").using("btree", table.activityNumber.asc().nullsLast().op("text_ops")),
	index("idx_activities_assigned").using("btree", table.assignedTo.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("text_ops")).where(sql`(status = ANY (ARRAY['open'::text, 'in_progress'::text]))`),
	index("idx_activities_assigned_to").using("btree", table.assignedTo.asc().nullsLast().op("uuid_ops")),
	index("idx_activities_blocking").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("uuid_ops"), table.isBlocking.asc().nullsLast().op("bool_ops")).where(sql`((is_blocking = true) AND (status = ANY (ARRAY['open'::text, 'in_progress'::text, 'scheduled'::text])) AND (deleted_at IS NULL))`),
	index("idx_activities_due").using("btree", table.dueDate.asc().nullsLast().op("timestamptz_ops")).where(sql`(status = ANY (ARRAY['open'::text, 'in_progress'::text]))`),
	index("idx_activities_due_date").using("btree", table.dueDate.asc().nullsLast().op("timestamptz_ops")),
	index("idx_activities_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("uuid_ops")),
	index("idx_activities_entity_timeline").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")),
	index("idx_activities_escalated").using("btree", table.escalatedToUserId.asc().nullsLast().op("uuid_ops")).where(sql`((escalated_to_user_id IS NOT NULL) AND (status = ANY (ARRAY['open'::text, 'in_progress'::text, 'scheduled'::text])) AND (deleted_at IS NULL))`),
	index("idx_activities_escalation").using("btree", table.escalationDate.asc().nullsLast().op("timestamptz_ops")).where(sql`((status = 'open'::text) AND (escalation_date IS NOT NULL))`),
	index("idx_activities_follow_up").using("btree", table.followUpRequired.asc().nullsLast().op("bool_ops"), table.followUpDate.asc().nullsLast().op("bool_ops")).where(sql`((follow_up_required = true) AND (status = ANY (ARRAY['open'::text, 'in_progress'::text])))`),
	index("idx_activities_follow_up_date").using("btree", table.followUpDate.asc().nullsLast().op("timestamptz_ops")).where(sql`(follow_up_required = true)`),
	index("idx_activities_group").using("btree", table.assignedGroup.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("uuid_ops")).where(sql`(status = ANY (ARRAY['open'::text, 'in_progress'::text]))`),
	index("idx_activities_my_tasks").using("btree", table.assignedTo.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("text_ops"), table.dueDate.asc().nullsLast().op("text_ops")).where(sql`(status = ANY (ARRAY['open'::text, 'in_progress'::text]))`),
	index("idx_activities_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_activities_org_entity_composite").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_activities_org_entity_recent").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_activities_org_entity_type").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("text_ops"), table.activityType.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_activities_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_activities_org_status").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("uuid_ops")),
	index("idx_activities_parent").using("btree", table.parentActivityId.asc().nullsLast().op("uuid_ops")),
	index("idx_activities_queue_id").using("btree", table.queueId.asc().nullsLast().op("uuid_ops")).where(sql`(queue_id IS NOT NULL)`),
	index("idx_activities_related_campaign").using("btree", table.relatedCampaignId.asc().nullsLast().op("uuid_ops")).where(sql`(related_campaign_id IS NOT NULL)`),
	index("idx_activities_related_contact").using("btree", table.relatedContactId.asc().nullsLast().op("uuid_ops")).where(sql`(related_contact_id IS NOT NULL)`),
	index("idx_activities_related_deal").using("btree", table.relatedDealId.asc().nullsLast().op("uuid_ops")).where(sql`(related_deal_id IS NOT NULL)`),
	index("idx_activities_secondary_entity").using("btree", table.secondaryEntityType.asc().nullsLast().op("uuid_ops"), table.secondaryEntityId.asc().nullsLast().op("uuid_ops")),
	index("idx_activities_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_activities_tags").using("gin", table.tags.asc().nullsLast().op("array_ops")),
	index("idx_activities_type").using("btree", table.activityType.asc().nullsLast().op("text_ops")),
	index("idx_activities_workplan").using("btree", table.workplanInstanceId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.assignedGroup],
			foreignColumns: [pods.id],
			name: "activities_assigned_group_fkey"
		}),
	foreignKey({
			columns: [table.assignedTo],
			foreignColumns: [userProfiles.id],
			name: "activities_assigned_to_fkey"
		}),
	foreignKey({
			columns: [table.claimedBy],
			foreignColumns: [userProfiles.id],
			name: "activities_claimed_by_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "activities_created_by_fkey"
		}),
	foreignKey({
			columns: [table.escalatedToUserId],
			foreignColumns: [userProfiles.id],
			name: "activities_escalated_to_user_id_fkey"
		}),
	foreignKey({
			columns: [table.followUpActivityId],
			foreignColumns: [table.id],
			name: "activities_follow_up_activity_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "activities_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.originalAssignedTo],
			foreignColumns: [userProfiles.id],
			name: "activities_original_assigned_to_fkey"
		}),
	foreignKey({
			columns: [table.parentActivityId],
			foreignColumns: [table.id],
			name: "activities_parent_activity_id_fkey"
		}),
	foreignKey({
			columns: [table.patternId],
			foreignColumns: [activityPatterns.id],
			name: "activities_pattern_id_fkey"
		}),
	foreignKey({
			columns: [table.performedBy],
			foreignColumns: [userProfiles.id],
			name: "activities_performed_by_fkey"
		}),
	foreignKey({
			columns: [table.predecessorActivityId],
			foreignColumns: [table.id],
			name: "activities_predecessor_activity_id_fkey"
		}),
	foreignKey({
			columns: [table.queueId],
			foreignColumns: [workQueues.id],
			name: "activities_queue_id_fkey"
		}),
	foreignKey({
			columns: [table.relatedCampaignId],
			foreignColumns: [campaigns.id],
			name: "activities_related_campaign_id_fkey"
		}),
	foreignKey({
			columns: [table.relatedContactId],
			foreignColumns: [contacts.id],
			name: "activities_related_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.relatedDealId],
			foreignColumns: [deals.id],
			name: "activities_related_deal_id_fkey"
		}),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "activities_updated_by_fkey"
		}),
	foreignKey({
			columns: [table.workplanInstanceId],
			foreignColumns: [workplanInstances.id],
			name: "activities_workplan_instance_id_fkey"
		}).onDelete("set null"),
	unique("uq_activities_org_activity_number").on(table.orgId, table.activityNumber),
	pgPolicy("activities_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid())))` }),
]);

export const benchConsultants = pgTable("bench_consultants", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	status: benchStatus().default('available').notNull(),
	benchStartDate: date("bench_start_date").notNull(),
	visaType: visaType("visa_type"),
	visaExpiryDate: date("visa_expiry_date"),
	workAuthStatus: text("work_auth_status"),
	minAcceptableRate: numeric("min_acceptable_rate", { precision: 10, scale:  2 }),
	targetRate: numeric("target_rate", { precision: 10, scale:  2 }),
	currency: text().default('USD'),
	willingRelocate: boolean("willing_relocate").default(false),
	preferredLocations: text("preferred_locations").array(),
	marketingStatus: marketingStatus("marketing_status").default('draft'),
	benchSalesRepId: uuid("bench_sales_rep_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_bench_consultants_bench_sales_rep_id").using("btree", table.benchSalesRepId.asc().nullsLast().op("uuid_ops")),
	index("idx_bench_consultants_candidate_id").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")),
	index("idx_bench_consultants_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_bench_consultants_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_bench_consultants_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_bench_consultants_status").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.benchSalesRepId],
			foreignColumns: [userProfiles.id],
			name: "bench_consultants_bench_sales_rep_id_fkey"
		}),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "bench_consultants_candidate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "bench_consultants_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "bench_consultants_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "bench_consultants_org_id_fkey"
		}).onDelete("cascade"),
	unique("bench_consultants_candidate_id_key").on(table.candidateId),
	pgPolicy("bench_consultants_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const approvalWorkflows = pgTable("approval_workflows", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	description: text(),
	entityType: text("entity_type").notNull(),
	approvalLevels: jsonb("approval_levels").default([]).notNull(),
	autoApproveCondition: text("auto_approve_condition"),
	escalationDays: integer("escalation_days").default(3),
	escalationRole: text("escalation_role"),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_approval_workflows_active").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(is_active = true)`),
	index("idx_approval_workflows_entity_type").using("btree", table.entityType.asc().nullsLast().op("text_ops")),
	index("idx_approval_workflows_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "approval_workflows_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "approval_workflows_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("approval_workflows_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const approvalSteps = pgTable("approval_steps", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	instanceId: uuid("instance_id").notNull(),
	level: integer().notNull(),
	approverRole: text("approver_role"),
	approverId: uuid("approver_id"),
	status: text().default('pending').notNull(),
	decidedBy: uuid("decided_by"),
	decidedAt: timestamp("decided_at", { withTimezone: true, mode: 'string' }),
	decision: text(),
	decisionNotes: text("decision_notes"),
	reminderSentAt: timestamp("reminder_sent_at", { withTimezone: true, mode: 'string' }),
	reminderCount: integer("reminder_count").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_approval_steps_approver").using("btree", table.approverId.asc().nullsLast().op("uuid_ops")),
	index("idx_approval_steps_instance").using("btree", table.instanceId.asc().nullsLast().op("uuid_ops")),
	index("idx_approval_steps_pending").using("btree", table.approverId.asc().nullsLast().op("uuid_ops")).where(sql`(status = 'pending'::text)`),
	foreignKey({
			columns: [table.approverId],
			foreignColumns: [userProfiles.id],
			name: "approval_steps_approver_id_fkey"
		}),
	foreignKey({
			columns: [table.decidedBy],
			foreignColumns: [userProfiles.id],
			name: "approval_steps_decided_by_fkey"
		}),
	foreignKey({
			columns: [table.instanceId],
			foreignColumns: [approvalInstances.id],
			name: "approval_steps_instance_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("approval_steps_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(instance_id IN ( SELECT approval_instances.id
   FROM approval_instances
  WHERE (approval_instances.org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)))` }),
]);

export const approvalInstances = pgTable("approval_instances", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	workflowId: uuid("workflow_id").notNull(),
	entityType: text("entity_type").notNull(),
	entityId: uuid("entity_id").notNull(),
	currentLevel: integer("current_level").default(1),
	status: text().default('pending').notNull(),
	requestedBy: uuid("requested_by").notNull(),
	requestedAt: timestamp("requested_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	requestNotes: text("request_notes"),
	requestData: jsonb("request_data").default({}),
	resolvedBy: uuid("resolved_by"),
	resolvedAt: timestamp("resolved_at", { withTimezone: true, mode: 'string' }),
	resolutionNotes: text("resolution_notes"),
	isEscalated: boolean("is_escalated").default(false),
	escalatedAt: timestamp("escalated_at", { withTimezone: true, mode: 'string' }),
	escalatedTo: uuid("escalated_to"),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_approval_instances_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("text_ops")),
	index("idx_approval_instances_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_approval_instances_pending").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(status = 'pending'::text)`),
	index("idx_approval_instances_requestor").using("btree", table.requestedBy.asc().nullsLast().op("uuid_ops")),
	index("idx_approval_instances_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_approval_instances_workflow").using("btree", table.workflowId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.escalatedTo],
			foreignColumns: [userProfiles.id],
			name: "approval_instances_escalated_to_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "approval_instances_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.requestedBy],
			foreignColumns: [userProfiles.id],
			name: "approval_instances_requested_by_fkey"
		}),
	foreignKey({
			columns: [table.resolvedBy],
			foreignColumns: [userProfiles.id],
			name: "approval_instances_resolved_by_fkey"
		}),
	foreignKey({
			columns: [table.workflowId],
			foreignColumns: [approvalWorkflows.id],
			name: "approval_instances_workflow_id_fkey"
		}),
	pgPolicy("approval_instances_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const placementCredits = pgTable("placement_credits", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	podId: uuid("pod_id").notNull(),
	sprintNumber: integer("sprint_number").notNull(),
	sprintStartDate: date("sprint_start_date").notNull(),
	sprintEndDate: date("sprint_end_date").notNull(),
	placementId: uuid("placement_id").notNull(),
	placementDate: date("placement_date").notNull(),
	creditAmount: numeric("credit_amount", { precision: 4, scale:  2 }).default('1.0').notNull(),
	seniorRecId: uuid("senior_rec_id"),
	juniorRecId: uuid("junior_rec_id"),
	billRate: numeric("bill_rate", { precision: 10, scale:  2 }),
	payRate: numeric("pay_rate", { precision: 10, scale:  2 }),
	marginPercentage: numeric("margin_percentage", { precision: 5, scale:  2 }),
	estimatedRevenue: numeric("estimated_revenue", { precision: 14, scale:  2 }),
	sourcePillar: text("source_pillar").default('recruiting').notNull(),
	originalLeadId: uuid("original_lead_id"),
	originalCampaignId: uuid("original_campaign_id"),
	originalGraduateId: uuid("original_graduate_id"),
	isVerified: boolean("is_verified").default(false),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	verifiedBy: uuid("verified_by"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_placement_credits_date").using("btree", table.placementDate.asc().nullsLast().op("date_ops")),
	index("idx_placement_credits_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_placement_credits_pod").using("btree", table.podId.asc().nullsLast().op("uuid_ops")),
	index("idx_placement_credits_source").using("btree", table.sourcePillar.asc().nullsLast().op("text_ops")),
	index("idx_placement_credits_sprint").using("btree", table.podId.asc().nullsLast().op("uuid_ops"), table.sprintNumber.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "placement_credits_created_by_fkey"
		}),
	foreignKey({
			columns: [table.juniorRecId],
			foreignColumns: [userProfiles.id],
			name: "placement_credits_junior_rec_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "placement_credits_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.originalGraduateId],
			foreignColumns: [graduateCandidates.id],
			name: "placement_credits_original_graduate_id_fkey"
		}),
	foreignKey({
			columns: [table.podId],
			foreignColumns: [pods.id],
			name: "placement_credits_pod_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.seniorRecId],
			foreignColumns: [userProfiles.id],
			name: "placement_credits_senior_rec_id_fkey"
		}),
	foreignKey({
			columns: [table.verifiedBy],
			foreignColumns: [userProfiles.id],
			name: "placement_credits_verified_by_fkey"
		}),
	pgPolicy("placement_credits_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const graduateCandidates = pgTable("graduate_candidates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	enrollmentId: uuid("enrollment_id").notNull(),
	graduatedAt: timestamp("graduated_at", { withTimezone: true, mode: 'string' }).notNull(),
	courseId: uuid("course_id"),
	finalGrade: text("final_grade"),
	gpaEquivalent: integer("gpa_equivalent"),
	projectScore: integer("project_score"),
	assessmentScore: integer("assessment_score"),
	jobReadinessScore: integer("job_readiness_score"),
	technicalSkillsScore: integer("technical_skills_score"),
	softSkillsScore: integer("soft_skills_score"),
	status: graduateCandidateStatus().default('pending_review').notNull(),
	statusChangedAt: timestamp("status_changed_at", { withTimezone: true, mode: 'string' }),
	statusChangedBy: uuid("status_changed_by"),
	assignedRecruiterId: uuid("assigned_recruiter_id"),
	assignedAt: timestamp("assigned_at", { withTimezone: true, mode: 'string' }),
	benchCandidateId: uuid("bench_candidate_id"),
	recruiterNotes: text("recruiter_notes"),
	optOutReason: text("opt_out_reason"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_graduate_candidates_enrollment").using("btree", table.enrollmentId.asc().nullsLast().op("uuid_ops")),
	index("idx_graduate_candidates_pending").using("btree", table.assignedRecruiterId.asc().nullsLast().op("uuid_ops")).where(sql`(status = 'pending_review'::graduate_candidate_status)`),
	index("idx_graduate_candidates_recruiter").using("btree", table.assignedRecruiterId.asc().nullsLast().op("uuid_ops")),
	index("idx_graduate_candidates_status").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	index("idx_graduate_candidates_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.assignedRecruiterId],
			foreignColumns: [userProfiles.id],
			name: "graduate_candidates_assigned_recruiter_id_fkey"
		}),
	foreignKey({
			columns: [table.courseId],
			foreignColumns: [courses.id],
			name: "graduate_candidates_course_id_fkey"
		}),
	foreignKey({
			columns: [table.enrollmentId],
			foreignColumns: [studentEnrollments.id],
			name: "graduate_candidates_enrollment_id_fkey"
		}),
	foreignKey({
			columns: [table.statusChangedBy],
			foreignColumns: [userProfiles.id],
			name: "graduate_candidates_status_changed_by_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "graduate_candidates_user_id_fkey"
		}),
	pgPolicy("graduate_candidates_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(user_id IN ( SELECT user_profiles.id
   FROM user_profiles
  WHERE (user_profiles.org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)))` }),
]);

export const quizAttempts = pgTable("quiz_attempts", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	userId: uuid("user_id").notNull(),
	topicId: uuid("topic_id").notNull(),
	enrollmentId: uuid("enrollment_id").notNull(),
	attemptNumber: integer("attempt_number").default(1).notNull(),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	submittedAt: timestamp("submitted_at", { withTimezone: true, mode: 'string' }),
	timeTakenSeconds: integer("time_taken_seconds"),
	answers: jsonb(),
	totalQuestions: integer("total_questions").notNull(),
	correctAnswers: integer("correct_answers"),
	score: numeric({ precision: 5, scale:  2 }),
	passed: boolean(),
	xpEarned: integer("xp_earned").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_quiz_attempts_enrollment").using("btree", table.enrollmentId.asc().nullsLast().op("uuid_ops")),
	index("idx_quiz_attempts_submitted").using("btree", table.submittedAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(submitted_at IS NOT NULL)`),
	index("idx_quiz_attempts_topic").using("btree", table.topicId.asc().nullsLast().op("uuid_ops")),
	uniqueIndex("idx_quiz_attempts_unique").using("btree", table.userId.asc().nullsLast().op("int4_ops"), table.topicId.asc().nullsLast().op("uuid_ops"), table.attemptNumber.asc().nullsLast().op("uuid_ops")),
	index("idx_quiz_attempts_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.enrollmentId],
			foreignColumns: [studentEnrollments.id],
			name: "quiz_attempts_enrollment_id_fkey"
		}),
	foreignKey({
			columns: [table.topicId],
			foreignColumns: [moduleTopics.id],
			name: "quiz_attempts_topic_id_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "quiz_attempts_user_id_fkey"
		}),
	pgPolicy("quiz_attempts_admin_read", { as: "permissive", for: "select", to: ["authenticated"], using: sql`true` }),
	pgPolicy("quiz_attempts_user_insert", { as: "permissive", for: "insert", to: ["authenticated"] }),
	pgPolicy("quiz_attempts_user_read", { as: "permissive", for: "select", to: ["authenticated"] }),
	pgPolicy("quiz_attempts_user_update", { as: "permissive", for: "update", to: ["authenticated"] }),
	check("quiz_attempts_attempt_number_check", sql`attempt_number > 0`),
	check("quiz_attempts_correct_answers_check", sql`correct_answers >= 0`),
	check("quiz_attempts_score_check", sql`(score >= (0)::numeric) AND (score <= (100)::numeric)`),
	check("quiz_attempts_total_questions_check", sql`total_questions > 0`),
]);

export const aiMentorEscalations = pgTable("ai_mentor_escalations", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	chatId: uuid("chat_id").notNull(),
	userId: uuid("user_id").notNull(),
	topicId: uuid("topic_id"),
	reason: text().notNull(),
	confidence: numeric({ precision: 3, scale:  2 }),
	autoDetected: boolean("auto_detected").default(true),
	triggers: jsonb().default({}),
	metadata: jsonb().default({}),
	assignedTo: uuid("assigned_to"),
	assignedAt: timestamp("assigned_at", { withTimezone: true, mode: 'string' }),
	status: text().default('pending'),
	resolvedBy: uuid("resolved_by"),
	resolvedAt: timestamp("resolved_at", { withTimezone: true, mode: 'string' }),
	resolutionNotes: text("resolution_notes"),
	resolutionTimeMinutes: integer("resolution_time_minutes"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_escalations_assigned_to").using("btree", table.assignedTo.asc().nullsLast().op("uuid_ops")).where(sql`(assigned_to IS NOT NULL)`),
	index("idx_escalations_chat_id").using("btree", table.chatId.asc().nullsLast().op("uuid_ops")),
	index("idx_escalations_created_at").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_escalations_status").using("btree", table.status.asc().nullsLast().op("text_ops")).where(sql`(status = ANY (ARRAY['pending'::text, 'in_progress'::text]))`),
	index("idx_escalations_topic_id").using("btree", table.topicId.asc().nullsLast().op("uuid_ops")),
	index("idx_escalations_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.assignedTo],
			foreignColumns: [userProfiles.id],
			name: "ai_mentor_escalations_assigned_to_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.chatId],
			foreignColumns: [aiMentorChats.id],
			name: "ai_mentor_escalations_chat_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.resolvedBy],
			foreignColumns: [userProfiles.id],
			name: "ai_mentor_escalations_resolved_by_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.topicId],
			foreignColumns: [moduleTopics.id],
			name: "ai_mentor_escalations_topic_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "ai_mentor_escalations_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("escalations_select_own", { as: "permissive", for: "select", to: ["public"], using: sql`(user_id = auth.uid())` }),
	pgPolicy("escalations_select_staff", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("escalations_update_assigned", { as: "permissive", for: "update", to: ["public"] }),
	check("ai_mentor_escalations_confidence_check", sql`(confidence >= (0)::numeric) AND (confidence <= (1)::numeric)`),
	check("ai_mentor_escalations_status_check", sql`status = ANY (ARRAY['pending'::text, 'in_progress'::text, 'resolved'::text, 'dismissed'::text])`),
]);

export const trainerResponses = pgTable("trainer_responses", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	escalationId: uuid("escalation_id").notNull(),
	trainerId: uuid("trainer_id").notNull(),
	message: text().notNull(),
	isInternalNote: boolean("is_internal_note").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_trainer_responses_escalation_id").using("btree", table.escalationId.asc().nullsLast().op("uuid_ops")),
	index("idx_trainer_responses_trainer_id").using("btree", table.trainerId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.escalationId],
			foreignColumns: [aiMentorEscalations.id],
			name: "trainer_responses_escalation_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.trainerId],
			foreignColumns: [userProfiles.id],
			name: "trainer_responses_trainer_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("trainer_responses_insert_staff", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`((trainer_id = auth.uid()) AND (EXISTS ( SELECT 1
   FROM (user_roles ur
     JOIN roles r ON ((r.id = ur.role_id)))
  WHERE ((ur.user_id = auth.uid()) AND (r.name = ANY (ARRAY['admin'::text, 'trainer'::text]))))))`  }),
	pgPolicy("trainer_responses_select_staff", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("trainer_responses_select_student", { as: "permissive", for: "select", to: ["public"] }),
]);

export const escalationNotifications = pgTable("escalation_notifications", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	escalationId: uuid("escalation_id").notNull(),
	notificationType: text("notification_type").notNull(),
	recipientId: uuid("recipient_id"),
	recipientEmail: text("recipient_email"),
	recipientSlackId: text("recipient_slack_id"),
	sentAt: timestamp("sent_at", { withTimezone: true, mode: 'string' }),
	deliveredAt: timestamp("delivered_at", { withTimezone: true, mode: 'string' }),
	errorMessage: text("error_message"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_escalation_notifications_escalation_id").using("btree", table.escalationId.asc().nullsLast().op("uuid_ops")),
	index("idx_escalation_notifications_sent_at").using("btree", table.sentAt.asc().nullsLast().op("timestamptz_ops")),
	foreignKey({
			columns: [table.escalationId],
			foreignColumns: [aiMentorEscalations.id],
			name: "escalation_notifications_escalation_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.recipientId],
			foreignColumns: [userProfiles.id],
			name: "escalation_notifications_recipient_id_fkey"
		}).onDelete("set null"),
	check("escalation_notifications_notification_type_check", sql`notification_type = ANY (ARRAY['slack'::text, 'email'::text, 'in_app'::text])`),
]);

export const entitySkills = pgTable("entity_skills", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	skillId: uuid("skill_id").notNull(),
	skillNameOverride: varchar("skill_name_override", { length: 100 }),
	proficiencyLevel: integer("proficiency_level"),
	yearsExperience: numeric("years_experience", { precision: 4, scale:  1 }),
	lastUsedDate: date("last_used_date"),
	isPrimary: boolean("is_primary").default(false),
	isRequired: boolean("is_required"),
	minProficiencyRequired: integer("min_proficiency_required"),
	isVerified: boolean("is_verified").default(false),
	verifiedBy: uuid("verified_by"),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	verificationMethod: varchar("verification_method", { length: 50 }).default('self_reported'),
	confidenceScore: numeric("confidence_score", { precision: 3, scale:  2 }),
	source: varchar({ length: 50 }),
	sourceContext: text("source_context"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_entity_skills_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_entity_skills_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_entity_skills_primary").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("text_ops")).where(sql`((is_primary = true) AND (deleted_at IS NULL))`),
	index("idx_entity_skills_proficiency").using("btree", table.proficiencyLevel.desc().nullsFirst().op("int4_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_entity_skills_skill").using("btree", table.skillId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	uniqueIndex("idx_entity_skills_unique").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("uuid_ops"), table.skillId.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_entity_skills_verified").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("uuid_ops")).where(sql`((is_verified = true) AND (deleted_at IS NULL))`),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "entity_skills_org_id_fkey"
		}),
	foreignKey({
			columns: [table.skillId],
			foreignColumns: [skills.id],
			name: "entity_skills_skill_id_fkey"
		}),
	foreignKey({
			columns: [table.verifiedBy],
			foreignColumns: [userProfiles.id],
			name: "entity_skills_verified_by_fkey"
		}),
	pgPolicy("entity_skills_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("entity_skills_proficiency_level_check", sql`(proficiency_level >= 1) AND (proficiency_level <= 5)`),
]);

export const certifications = pgTable("certifications", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	certificationName: varchar("certification_name", { length: 200 }).notNull(),
	issuingOrganization: varchar("issuing_organization", { length: 200 }),
	credentialId: varchar("credential_id", { length: 100 }),
	verificationUrl: varchar("verification_url", { length: 500 }),
	skillId: uuid("skill_id"),
	issueDate: date("issue_date"),
	expiryDate: date("expiry_date"),
	isActive: boolean("is_active").default(true),
	renewalRequired: boolean("renewal_required").default(false),
	renewalPeriodMonths: integer("renewal_period_months"),
	renewalReminderSentAt: timestamp("renewal_reminder_sent_at", { withTimezone: true, mode: 'string' }),
	isVerified: boolean("is_verified").default(false),
	verifiedBy: uuid("verified_by"),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	certificateDocumentId: uuid("certificate_document_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_certifications_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_certifications_expiry").using("btree", table.expiryDate.asc().nullsLast().op("date_ops")).where(sql`((is_active = true) AND (deleted_at IS NULL))`),
	index("idx_certifications_skill").using("btree", table.skillId.asc().nullsLast().op("uuid_ops")).where(sql`((skill_id IS NOT NULL) AND (deleted_at IS NULL))`),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "certifications_org_id_fkey"
		}),
	foreignKey({
			columns: [table.skillId],
			foreignColumns: [skills.id],
			name: "certifications_skill_id_fkey"
		}),
	foreignKey({
			columns: [table.verifiedBy],
			foreignColumns: [userProfiles.id],
			name: "certifications_verified_by_fkey"
		}),
	pgPolicy("certifications_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const contactBenchData = pgTable("contact_bench_data", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	contactId: uuid("contact_id").notNull(),
	benchStartDate: date("bench_start_date").notNull(),
	benchType: benchType("bench_type"),
	benchStatus: text("bench_status").default('available'),
	visaType: text("visa_type"),
	visaExpiryDate: date("visa_expiry_date"),
	workAuthStatus: text("work_auth_status"),
	visaNotes: text("visa_notes"),
	minAcceptableRate: numeric("min_acceptable_rate", { precision: 10, scale:  2 }),
	targetRate: numeric("target_rate", { precision: 10, scale:  2 }),
	maxRate: numeric("max_rate", { precision: 10, scale:  2 }),
	currency: text().default('USD'),
	billRate: numeric("bill_rate", { precision: 10, scale:  2 }),
	payRate: numeric("pay_rate", { precision: 10, scale:  2 }),
	markupPercentage: numeric("markup_percentage", { precision: 5, scale:  2 }),
	costPerDay: numeric("cost_per_day", { precision: 10, scale:  2 }),
	willingToRelocate: boolean("willing_to_relocate").default(false),
	preferredLocations: text("preferred_locations").array(),
	workPreference: text("work_preference"),
	marketingStatus: benchMarketingStatus("marketing_status").default('draft'),
	marketingStartedAt: timestamp("marketing_started_at", { withTimezone: true, mode: 'string' }),
	marketingNotes: text("marketing_notes"),
	benchSalesRepId: uuid("bench_sales_rep_id"),
	vendorId: uuid("vendor_id"),
	vendorContactId: uuid("vendor_contact_id"),
	vendorTerms: text("vendor_terms"),
	targetEndDate: date("target_end_date"),
	maxBenchDays: integer("max_bench_days"),
	totalPlacements: integer("total_placements").default(0),
	lastPlacementEnd: date("last_placement_end"),
	utilizationRate: numeric("utilization_rate", { precision: 5, scale:  2 }),
	daysOnBench: integer("days_on_bench"),
	primarySkills: text("primary_skills").array(),
	yearsOfExperience: numeric("years_of_experience", { precision: 4, scale:  1 }),
	certifications: text().array(),
	legacyBenchConsultantId: uuid("legacy_bench_consultant_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_contact_bench_data_bench_type").using("btree", table.benchType.asc().nullsLast().op("enum_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contact_bench_data_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contact_bench_data_marketing").using("btree", table.marketingStatus.asc().nullsLast().op("enum_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contact_bench_data_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contact_bench_data_sales_rep").using("btree", table.benchSalesRepId.asc().nullsLast().op("uuid_ops")).where(sql`((bench_sales_rep_id IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_contact_bench_data_status").using("btree", table.benchStatus.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contact_bench_data_vendor").using("btree", table.vendorId.asc().nullsLast().op("uuid_ops")).where(sql`((vendor_id IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_contact_bench_data_visa_expiry").using("btree", table.visaExpiryDate.asc().nullsLast().op("date_ops")).where(sql`((visa_expiry_date IS NOT NULL) AND (deleted_at IS NULL))`),
	foreignKey({
			columns: [table.benchSalesRepId],
			foreignColumns: [userProfiles.id],
			name: "contact_bench_data_bench_sales_rep_id_fkey"
		}),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "contact_bench_data_contact_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "contact_bench_data_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contact_bench_data_org_id_fkey"
		}),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "contact_bench_data_updated_by_fkey"
		}),
	foreignKey({
			columns: [table.vendorContactId],
			foreignColumns: [contacts.id],
			name: "contact_bench_data_vendor_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.vendorId],
			foreignColumns: [companies.id],
			name: "contact_bench_data_vendor_id_fkey"
		}),
	unique("contact_bench_data_contact_id_key").on(table.contactId),
	pgPolicy("contact_bench_data_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	pgPolicy("contact_bench_data_service_role", { as: "permissive", for: "all", to: ["service_role"] }),
	check("contact_bench_data_bench_status_check", sql`bench_status = ANY (ARRAY['onboarding'::text, 'available'::text, 'marketing'::text, 'interviewing'::text, 'placed'::text, 'inactive'::text])`),
	check("contact_bench_data_work_preference_check", sql`work_preference = ANY (ARRAY['remote'::text, 'hybrid'::text, 'onsite'::text, 'flexible'::text])`),
]);

export const submissionFeedback = pgTable("submission_feedback", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	submissionId: uuid("submission_id").notNull(),
	feedbackType: varchar("feedback_type", { length: 50 }).notNull(),
	feedbackSource: varchar("feedback_source", { length: 50 }).notNull(),
	providedByUserId: uuid("provided_by_user_id"),
	providedByContactId: uuid("provided_by_contact_id"),
	overallRating: integer("overall_rating"),
	recommendation: varchar({ length: 50 }),
	feedbackText: text("feedback_text"),
	criteriaScores: jsonb("criteria_scores"),
	interviewId: uuid("interview_id"),
	interviewRound: integer("interview_round"),
	isVisibleToClient: boolean("is_visible_to_client").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_submission_feedback_interview").using("btree", table.interviewId.asc().nullsLast().op("uuid_ops")).where(sql`((interview_id IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_submission_feedback_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_submission_feedback_submission").using("btree", table.submissionId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.interviewId],
			foreignColumns: [interviews.id],
			name: "submission_feedback_interview_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "submission_feedback_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.providedByContactId],
			foreignColumns: [contacts.id],
			name: "submission_feedback_provided_by_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.providedByUserId],
			foreignColumns: [userProfiles.id],
			name: "submission_feedback_provided_by_user_id_fkey"
		}),
	foreignKey({
			columns: [table.submissionId],
			foreignColumns: [submissions.id],
			name: "submission_feedback_submission_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("submission_feedback_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("submission_feedback_feedback_source_check", sql`(feedback_source)::text = ANY ((ARRAY['internal'::character varying, 'client'::character varying, 'vendor'::character varying, 'reference'::character varying])::text[])`),
	check("submission_feedback_feedback_type_check", sql`(feedback_type)::text = ANY ((ARRAY['screening'::character varying, 'technical'::character varying, 'client'::character varying, 'reference'::character varying, 'final'::character varying])::text[])`),
	check("submission_feedback_overall_rating_check", sql`(overall_rating IS NULL) OR ((overall_rating >= 1) AND (overall_rating <= 5))`),
	check("submission_feedback_recommendation_check", sql`(recommendation IS NULL) OR ((recommendation)::text = ANY ((ARRAY['strong_hire'::character varying, 'hire'::character varying, 'neutral'::character varying, 'no_hire'::character varying, 'strong_no_hire'::character varying])::text[]))`),
]);

export const submissionRtr = pgTable("submission_rtr", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	submissionId: uuid("submission_id").notNull(),
	contactId: uuid("contact_id").notNull(),
	rtrType: varchar("rtr_type", { length: 50 }).default('standard'),
	obtainedAt: timestamp("obtained_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }),
	validityHours: integer("validity_hours").default(72),
	documentId: uuid("document_id"),
	status: varchar({ length: 50 }).default('active'),
	revokedAt: timestamp("revoked_at", { withTimezone: true, mode: 'string' }),
	revokedReason: text("revoked_reason"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_submission_rtr_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")),
	index("idx_submission_rtr_expiry").using("btree", table.expiresAt.asc().nullsLast().op("timestamptz_ops")).where(sql`((status)::text = 'active'::text)`),
	index("idx_submission_rtr_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_submission_rtr_submission").using("btree", table.submissionId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "submission_rtr_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "submission_rtr_created_by_fkey"
		}),
	foreignKey({
			columns: [table.documentId],
			foreignColumns: [documents.id],
			name: "submission_rtr_document_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "submission_rtr_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.submissionId],
			foreignColumns: [submissions.id],
			name: "submission_rtr_submission_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("submission_rtr_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("submission_rtr_rtr_type_check", sql`(rtr_type)::text = ANY ((ARRAY['standard'::character varying, 'exclusive'::character varying, 'non_exclusive'::character varying, 'verbal'::character varying, 'written'::character varying])::text[])`),
	check("submission_rtr_status_check", sql`(status)::text = ANY ((ARRAY['active'::character varying, 'expired'::character varying, 'revoked'::character varying, 'renewed'::character varying])::text[])`),
]);

export const entityTypeRegistry = pgTable("entity_type_registry", {
	entityType: varchar("entity_type", { length: 50 }).primaryKey().notNull(),
	tableName: varchar("table_name", { length: 100 }).notNull(),
	idColumn: varchar("id_column", { length: 50 }).default('id'),
	displayNameColumn: varchar("display_name_column", { length: 50 }).default('name'),
	displayName: varchar("display_name", { length: 100 }).notNull(),
	urlPattern: varchar("url_pattern", { length: 200 }),
	iconName: varchar("icon_name", { length: 50 }),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_entity_registry_active").using("btree", table.entityType.asc().nullsLast().op("text_ops")).where(sql`(is_active = true)`),
]);

export const skillEndorsements = pgTable("skill_endorsements", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entitySkillId: uuid("entity_skill_id").notNull(),
	endorserId: uuid("endorser_id").notNull(),
	endorserRelationship: varchar("endorser_relationship", { length: 50 }),
	endorsementLevel: varchar("endorsement_level", { length: 20 }),
	comment: text(),
	isVerified: boolean("is_verified").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_skill_endorsements_endorser").using("btree", table.endorserId.asc().nullsLast().op("uuid_ops")),
	index("idx_skill_endorsements_skill").using("btree", table.entitySkillId.asc().nullsLast().op("uuid_ops")),
	uniqueIndex("idx_skill_endorsements_unique").using("btree", table.entitySkillId.asc().nullsLast().op("uuid_ops"), table.endorserId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.endorserId],
			foreignColumns: [contacts.id],
			name: "skill_endorsements_endorser_id_fkey"
		}),
	foreignKey({
			columns: [table.entitySkillId],
			foreignColumns: [entitySkills.id],
			name: "skill_endorsements_entity_skill_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "skill_endorsements_org_id_fkey"
		}),
	pgPolicy("skill_endorsements_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const auditLogs202511 = pgTable("audit_logs_2025_11", {
	id: uuid().default(sql`uuid_generate_v4()`),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	tableName: text("table_name").notNull(),
	action: text().notNull(),
	recordId: uuid("record_id"),
	userId: uuid("user_id"),
	userEmail: text("user_email"),
	userIpAddress: inet("user_ip_address"),
	userAgent: text("user_agent"),
	oldValues: jsonb("old_values"),
	newValues: jsonb("new_values"),
	changedFields: text("changed_fields"),
	requestId: text("request_id"),
	sessionId: text("session_id"),
	requestPath: text("request_path"),
	requestMethod: text("request_method"),
	metadata: jsonb().default({}),
	severity: text().default('info'),
	orgId: uuid("org_id"),
	entityType: text("entity_type"),
	entityId: uuid("entity_id"),
	actorType: text("actor_type").default('user'),
	actorId: uuid("actor_id"),
	correlationId: text("correlation_id"),
	parentAuditId: uuid("parent_audit_id"),
	isComplianceRelevant: boolean("is_compliance_relevant").default(false),
	retentionCategory: text("retention_category"),
	result: text().default('SUCCESS'),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	eventId: bigint("event_id", { mode: "number" }).default(sql`nextval('audit_logs_event_id_seq'::regclass)`).notNull(),
	ipAddress: inet("ip_address"),
	responseCode: integer("response_code"),
	responseTimeMs: integer("response_time_ms"),
	objectName: text("object_name"),
}, (table) => [
	index("audit_logs_2025_11_action_idx").using("btree", table.action.asc().nullsLast().op("text_ops")),
	index("audit_logs_2025_11_actor_id_idx").using("btree", table.actorId.asc().nullsLast().op("uuid_ops")),
	index("audit_logs_2025_11_correlation_id_idx").using("btree", table.correlationId.asc().nullsLast().op("text_ops")),
	index("audit_logs_2025_11_created_at_idx").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("audit_logs_2025_11_entity_type_entity_id_idx").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("uuid_ops")),
	index("audit_logs_2025_11_event_id_idx").using("btree", table.eventId.asc().nullsLast().op("int8_ops")),
	index("audit_logs_2025_11_ip_address_idx").using("btree", table.ipAddress.asc().nullsLast().op("inet_ops")),
	index("audit_logs_2025_11_org_id_created_at_idx").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("audit_logs_2025_11_org_id_idx").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("audit_logs_2025_11_record_id_idx").using("btree", table.recordId.asc().nullsLast().op("uuid_ops")).where(sql`(record_id IS NOT NULL)`),
	index("audit_logs_2025_11_result_idx").using("btree", table.result.asc().nullsLast().op("text_ops")),
	index("audit_logs_2025_11_session_id_idx").using("btree", table.sessionId.asc().nullsLast().op("text_ops")).where(sql`(session_id IS NOT NULL)`),
	index("audit_logs_2025_11_severity_idx").using("btree", table.severity.asc().nullsLast().op("text_ops")).where(sql`(severity = ANY (ARRAY['error'::text, 'critical'::text]))`),
	index("audit_logs_2025_11_table_name_action_idx").using("btree", table.tableName.asc().nullsLast().op("text_ops"), table.action.asc().nullsLast().op("text_ops")),
	index("audit_logs_2025_11_table_name_idx").using("btree", table.tableName.asc().nullsLast().op("text_ops")),
	index("audit_logs_2025_11_user_id_idx").using("btree", table.userId.asc().nullsLast().op("uuid_ops")).where(sql`(user_id IS NOT NULL)`),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "audit_logs_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "audit_logs_user_id_fkey"
		}),
	check("audit_logs_result_check", sql`result = ANY (ARRAY['SUCCESS'::text, 'FAILURE'::text])`),
	check("valid_action", sql`action = ANY (ARRAY['INSERT'::text, 'UPDATE'::text, 'DELETE'::text, 'LOGIN'::text, 'LOGOUT'::text, 'APPROVE'::text, 'REJECT'::text, 'EXPORT'::text, 'IMPORT'::text, 'CUSTOM'::text])`),
	check("valid_severity", sql`severity = ANY (ARRAY['debug'::text, 'info'::text, 'warning'::text, 'error'::text, 'critical'::text])`),
]);

export const auditLogs202512 = pgTable("audit_logs_2025_12", {
	id: uuid().default(sql`uuid_generate_v4()`),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	tableName: text("table_name").notNull(),
	action: text().notNull(),
	recordId: uuid("record_id"),
	userId: uuid("user_id"),
	userEmail: text("user_email"),
	userIpAddress: inet("user_ip_address"),
	userAgent: text("user_agent"),
	oldValues: jsonb("old_values"),
	newValues: jsonb("new_values"),
	changedFields: text("changed_fields"),
	requestId: text("request_id"),
	sessionId: text("session_id"),
	requestPath: text("request_path"),
	requestMethod: text("request_method"),
	metadata: jsonb().default({}),
	severity: text().default('info'),
	orgId: uuid("org_id"),
	entityType: text("entity_type"),
	entityId: uuid("entity_id"),
	actorType: text("actor_type").default('user'),
	actorId: uuid("actor_id"),
	correlationId: text("correlation_id"),
	parentAuditId: uuid("parent_audit_id"),
	isComplianceRelevant: boolean("is_compliance_relevant").default(false),
	retentionCategory: text("retention_category"),
	result: text().default('SUCCESS'),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	eventId: bigint("event_id", { mode: "number" }).default(sql`nextval('audit_logs_event_id_seq'::regclass)`).notNull(),
	ipAddress: inet("ip_address"),
	responseCode: integer("response_code"),
	responseTimeMs: integer("response_time_ms"),
	objectName: text("object_name"),
}, (table) => [
	index("audit_logs_2025_12_action_idx").using("btree", table.action.asc().nullsLast().op("text_ops")),
	index("audit_logs_2025_12_actor_id_idx").using("btree", table.actorId.asc().nullsLast().op("uuid_ops")),
	index("audit_logs_2025_12_correlation_id_idx").using("btree", table.correlationId.asc().nullsLast().op("text_ops")),
	index("audit_logs_2025_12_created_at_idx").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("audit_logs_2025_12_entity_type_entity_id_idx").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("uuid_ops")),
	index("audit_logs_2025_12_event_id_idx").using("btree", table.eventId.asc().nullsLast().op("int8_ops")),
	index("audit_logs_2025_12_ip_address_idx").using("btree", table.ipAddress.asc().nullsLast().op("inet_ops")),
	index("audit_logs_2025_12_org_id_created_at_idx").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("audit_logs_2025_12_org_id_idx").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("audit_logs_2025_12_record_id_idx").using("btree", table.recordId.asc().nullsLast().op("uuid_ops")).where(sql`(record_id IS NOT NULL)`),
	index("audit_logs_2025_12_result_idx").using("btree", table.result.asc().nullsLast().op("text_ops")),
	index("audit_logs_2025_12_session_id_idx").using("btree", table.sessionId.asc().nullsLast().op("text_ops")).where(sql`(session_id IS NOT NULL)`),
	index("audit_logs_2025_12_severity_idx").using("btree", table.severity.asc().nullsLast().op("text_ops")).where(sql`(severity = ANY (ARRAY['error'::text, 'critical'::text]))`),
	index("audit_logs_2025_12_table_name_action_idx").using("btree", table.tableName.asc().nullsLast().op("text_ops"), table.action.asc().nullsLast().op("text_ops")),
	index("audit_logs_2025_12_table_name_idx").using("btree", table.tableName.asc().nullsLast().op("text_ops")),
	index("audit_logs_2025_12_user_id_idx").using("btree", table.userId.asc().nullsLast().op("uuid_ops")).where(sql`(user_id IS NOT NULL)`),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "audit_logs_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "audit_logs_user_id_fkey"
		}),
	check("audit_logs_result_check", sql`result = ANY (ARRAY['SUCCESS'::text, 'FAILURE'::text])`),
	check("valid_action", sql`action = ANY (ARRAY['INSERT'::text, 'UPDATE'::text, 'DELETE'::text, 'LOGIN'::text, 'LOGOUT'::text, 'APPROVE'::text, 'REJECT'::text, 'EXPORT'::text, 'IMPORT'::text, 'CUSTOM'::text])`),
	check("valid_severity", sql`severity = ANY (ARRAY['debug'::text, 'info'::text, 'warning'::text, 'error'::text, 'critical'::text])`),
]);

export const auditLogs202601 = pgTable("audit_logs_2026_01", {
	id: uuid().default(sql`uuid_generate_v4()`),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	tableName: text("table_name").notNull(),
	action: text().notNull(),
	recordId: uuid("record_id"),
	userId: uuid("user_id"),
	userEmail: text("user_email"),
	userIpAddress: inet("user_ip_address"),
	userAgent: text("user_agent"),
	oldValues: jsonb("old_values"),
	newValues: jsonb("new_values"),
	changedFields: text("changed_fields"),
	requestId: text("request_id"),
	sessionId: text("session_id"),
	requestPath: text("request_path"),
	requestMethod: text("request_method"),
	metadata: jsonb().default({}),
	severity: text().default('info'),
	orgId: uuid("org_id"),
	entityType: text("entity_type"),
	entityId: uuid("entity_id"),
	actorType: text("actor_type").default('user'),
	actorId: uuid("actor_id"),
	correlationId: text("correlation_id"),
	parentAuditId: uuid("parent_audit_id"),
	isComplianceRelevant: boolean("is_compliance_relevant").default(false),
	retentionCategory: text("retention_category"),
	result: text().default('SUCCESS'),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	eventId: bigint("event_id", { mode: "number" }).default(sql`nextval('audit_logs_event_id_seq'::regclass)`).notNull(),
	ipAddress: inet("ip_address"),
	responseCode: integer("response_code"),
	responseTimeMs: integer("response_time_ms"),
	objectName: text("object_name"),
}, (table) => [
	index("audit_logs_2026_01_action_idx").using("btree", table.action.asc().nullsLast().op("text_ops")),
	index("audit_logs_2026_01_actor_id_idx").using("btree", table.actorId.asc().nullsLast().op("uuid_ops")),
	index("audit_logs_2026_01_correlation_id_idx").using("btree", table.correlationId.asc().nullsLast().op("text_ops")),
	index("audit_logs_2026_01_created_at_idx").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("audit_logs_2026_01_entity_type_entity_id_idx").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("uuid_ops")),
	index("audit_logs_2026_01_event_id_idx").using("btree", table.eventId.asc().nullsLast().op("int8_ops")),
	index("audit_logs_2026_01_ip_address_idx").using("btree", table.ipAddress.asc().nullsLast().op("inet_ops")),
	index("audit_logs_2026_01_org_id_created_at_idx").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("audit_logs_2026_01_org_id_idx").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("audit_logs_2026_01_record_id_idx").using("btree", table.recordId.asc().nullsLast().op("uuid_ops")).where(sql`(record_id IS NOT NULL)`),
	index("audit_logs_2026_01_result_idx").using("btree", table.result.asc().nullsLast().op("text_ops")),
	index("audit_logs_2026_01_session_id_idx").using("btree", table.sessionId.asc().nullsLast().op("text_ops")).where(sql`(session_id IS NOT NULL)`),
	index("audit_logs_2026_01_severity_idx").using("btree", table.severity.asc().nullsLast().op("text_ops")).where(sql`(severity = ANY (ARRAY['error'::text, 'critical'::text]))`),
	index("audit_logs_2026_01_table_name_action_idx").using("btree", table.tableName.asc().nullsLast().op("text_ops"), table.action.asc().nullsLast().op("text_ops")),
	index("audit_logs_2026_01_table_name_idx").using("btree", table.tableName.asc().nullsLast().op("text_ops")),
	index("audit_logs_2026_01_user_id_idx").using("btree", table.userId.asc().nullsLast().op("uuid_ops")).where(sql`(user_id IS NOT NULL)`),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "audit_logs_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "audit_logs_user_id_fkey"
		}),
	check("audit_logs_result_check", sql`result = ANY (ARRAY['SUCCESS'::text, 'FAILURE'::text])`),
	check("valid_action", sql`action = ANY (ARRAY['INSERT'::text, 'UPDATE'::text, 'DELETE'::text, 'LOGIN'::text, 'LOGOUT'::text, 'APPROVE'::text, 'REJECT'::text, 'EXPORT'::text, 'IMPORT'::text, 'CUSTOM'::text])`),
	check("valid_severity", sql`severity = ANY (ARRAY['debug'::text, 'info'::text, 'warning'::text, 'error'::text, 'critical'::text])`),
]);

export const auditLogs202602 = pgTable("audit_logs_2026_02", {
	id: uuid().default(sql`uuid_generate_v4()`),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	tableName: text("table_name").notNull(),
	action: text().notNull(),
	recordId: uuid("record_id"),
	userId: uuid("user_id"),
	userEmail: text("user_email"),
	userIpAddress: inet("user_ip_address"),
	userAgent: text("user_agent"),
	oldValues: jsonb("old_values"),
	newValues: jsonb("new_values"),
	changedFields: text("changed_fields"),
	requestId: text("request_id"),
	sessionId: text("session_id"),
	requestPath: text("request_path"),
	requestMethod: text("request_method"),
	metadata: jsonb().default({}),
	severity: text().default('info'),
	orgId: uuid("org_id"),
	entityType: text("entity_type"),
	entityId: uuid("entity_id"),
	actorType: text("actor_type").default('user'),
	actorId: uuid("actor_id"),
	correlationId: text("correlation_id"),
	parentAuditId: uuid("parent_audit_id"),
	isComplianceRelevant: boolean("is_compliance_relevant").default(false),
	retentionCategory: text("retention_category"),
	result: text().default('SUCCESS'),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	eventId: bigint("event_id", { mode: "number" }).default(sql`nextval('audit_logs_event_id_seq'::regclass)`).notNull(),
	ipAddress: inet("ip_address"),
	responseCode: integer("response_code"),
	responseTimeMs: integer("response_time_ms"),
	objectName: text("object_name"),
}, (table) => [
	index("audit_logs_2026_02_action_idx").using("btree", table.action.asc().nullsLast().op("text_ops")),
	index("audit_logs_2026_02_actor_id_idx").using("btree", table.actorId.asc().nullsLast().op("uuid_ops")),
	index("audit_logs_2026_02_correlation_id_idx").using("btree", table.correlationId.asc().nullsLast().op("text_ops")),
	index("audit_logs_2026_02_created_at_idx").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("audit_logs_2026_02_entity_type_entity_id_idx").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("uuid_ops")),
	index("audit_logs_2026_02_event_id_idx").using("btree", table.eventId.asc().nullsLast().op("int8_ops")),
	index("audit_logs_2026_02_ip_address_idx").using("btree", table.ipAddress.asc().nullsLast().op("inet_ops")),
	index("audit_logs_2026_02_org_id_created_at_idx").using("btree", table.orgId.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("audit_logs_2026_02_org_id_idx").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("audit_logs_2026_02_record_id_idx").using("btree", table.recordId.asc().nullsLast().op("uuid_ops")).where(sql`(record_id IS NOT NULL)`),
	index("audit_logs_2026_02_result_idx").using("btree", table.result.asc().nullsLast().op("text_ops")),
	index("audit_logs_2026_02_session_id_idx").using("btree", table.sessionId.asc().nullsLast().op("text_ops")).where(sql`(session_id IS NOT NULL)`),
	index("audit_logs_2026_02_severity_idx").using("btree", table.severity.asc().nullsLast().op("text_ops")).where(sql`(severity = ANY (ARRAY['error'::text, 'critical'::text]))`),
	index("audit_logs_2026_02_table_name_action_idx").using("btree", table.tableName.asc().nullsLast().op("text_ops"), table.action.asc().nullsLast().op("text_ops")),
	index("audit_logs_2026_02_table_name_idx").using("btree", table.tableName.asc().nullsLast().op("text_ops")),
	index("audit_logs_2026_02_user_id_idx").using("btree", table.userId.asc().nullsLast().op("uuid_ops")).where(sql`(user_id IS NOT NULL)`),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "audit_logs_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "audit_logs_user_id_fkey"
		}),
	check("audit_logs_result_check", sql`result = ANY (ARRAY['SUCCESS'::text, 'FAILURE'::text])`),
	check("valid_action", sql`action = ANY (ARRAY['INSERT'::text, 'UPDATE'::text, 'DELETE'::text, 'LOGIN'::text, 'LOGOUT'::text, 'APPROVE'::text, 'REJECT'::text, 'EXPORT'::text, 'IMPORT'::text, 'CUSTOM'::text])`),
	check("valid_severity", sql`severity = ANY (ARRAY['debug'::text, 'info'::text, 'warning'::text, 'error'::text, 'critical'::text])`),
]);

export const securityAlerts = pgTable("security_alerts", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	alertType: text("alert_type").notNull(),
	severity: text().notNull(),
	title: text().notNull(),
	description: text(),
	relatedUserId: uuid("related_user_id"),
	relatedUserEmail: text("related_user_email"),
	relatedEvents: jsonb("related_events").default([]),
	status: text().default('open'),
	assignedTo: uuid("assigned_to"),
	resolvedAt: timestamp("resolved_at", { withTimezone: true, mode: 'string' }),
	resolutionNotes: text("resolution_notes"),
	riskLevel: text("risk_level"),
	riskIndicators: jsonb("risk_indicators").default({}),
	recommendedActions: jsonb("recommended_actions").default([]),
	actionsTaken: jsonb("actions_taken").default([]),
	metadata: jsonb().default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_security_alerts_created").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_security_alerts_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_security_alerts_severity").using("btree", table.severity.asc().nullsLast().op("text_ops")),
	index("idx_security_alerts_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_security_alerts_user").using("btree", table.relatedUserId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.assignedTo],
			foreignColumns: [userProfiles.id],
			name: "security_alerts_assigned_to_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "security_alerts_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.relatedUserId],
			foreignColumns: [userProfiles.id],
			name: "security_alerts_related_user_id_fkey"
		}).onDelete("set null"),
	pgPolicy("Admins can manage security alerts", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())))` }),
	pgPolicy("Users can view security alerts in their org", { as: "permissive", for: "select", to: ["public"] }),
	check("security_alerts_risk_level_check", sql`risk_level = ANY (ARRAY['LOW'::text, 'LOW_MEDIUM'::text, 'MEDIUM'::text, 'MEDIUM_HIGH'::text, 'HIGH'::text])`),
	check("security_alerts_severity_check", sql`severity = ANY (ARRAY['LOW'::text, 'MEDIUM'::text, 'HIGH'::text, 'CRITICAL'::text])`),
	check("security_alerts_status_check", sql`status = ANY (ARRAY['open'::text, 'investigating'::text, 'resolved'::text, 'dismissed'::text])`),
]);

export const alertRules = pgTable("alert_rules", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	description: text(),
	eventType: text("event_type").notNull(),
	resultCondition: text("result_condition").default('ANY'),
	thresholdCount: integer("threshold_count").default(5).notNull(),
	timeWindowMinutes: integer("time_window_minutes").default(10).notNull(),
	objectType: text("object_type"),
	additionalConditions: jsonb("additional_conditions").default({}),
	severity: text().notNull(),
	notificationChannels: jsonb("notification_channels").default({"dashboard":true}),
	autoAction: text("auto_action"),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_alert_rules_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")),
	index("idx_alert_rules_event_type").using("btree", table.eventType.asc().nullsLast().op("text_ops")),
	index("idx_alert_rules_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "alert_rules_created_by_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "alert_rules_org_id_fkey"
		}).onDelete("cascade"),
	unique("unique_alert_rule_name_per_org").on(table.orgId, table.name),
	pgPolicy("Admins can manage alert rules", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())))` }),
	pgPolicy("Users can view alert rules in their org", { as: "permissive", for: "select", to: ["public"] }),
	check("alert_rules_auto_action_check", sql`auto_action = ANY (ARRAY['none'::text, 'lock_account'::text, 'block_ip'::text, 'require_2fa'::text, 'notify_manager'::text])`),
	check("alert_rules_result_condition_check", sql`result_condition = ANY (ARRAY['ANY'::text, 'SUCCESS'::text, 'FAILURE'::text])`),
	check("alert_rules_severity_check", sql`severity = ANY (ARRAY['LOW'::text, 'MEDIUM'::text, 'HIGH'::text, 'CRITICAL'::text])`),
]);

export const emailTemplates = pgTable("email_templates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	subject: text().notNull(),
	bodyHtml: text("body_html").notNull(),
	bodyText: text("body_text"),
	category: text().notNull(),
	variables: jsonb().default({}).notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	createdBy: uuid("created_by").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	slug: text().notNull(),
	previewText: text("preview_text"),
	fromName: text("from_name").default('{{company_name}}').notNull(),
	fromEmail: text("from_email").default('noreply@{{company_domain}}').notNull(),
	replyTo: text("reply_to"),
	variablesUsed: text("variables_used").array().default([""]),
	notes: text(),
	status: text().default('draft').notNull(),
	version: integer().default(1).notNull(),
	updatedBy: uuid("updated_by"),
	archivedAt: timestamp("archived_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_email_templates_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")).where(sql`(is_active = true)`),
	index("idx_email_templates_category").using("btree", table.category.asc().nullsLast().op("text_ops")),
	index("idx_email_templates_org_category").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.category.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_email_templates_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_email_templates_org_slug").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.slug.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_email_templates_org_status").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "email_templates_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "email_templates_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "email_templates_updated_by_fkey"
		}),
	unique("unique_email_template_name").on(table.orgId, table.name),
	unique("email_templates_org_id_slug_version_key").on(table.orgId, table.slug, table.version),
	pgPolicy("Only admins can create email templates", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`user_is_admin()`  }),
	pgPolicy("Only admins can update email templates", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("Users can view email templates in their org", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("email_templates_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	check("email_templates_category_check", sql`category = ANY (ARRAY['user'::text, 'candidate'::text, 'client'::text, 'internal'::text, 'system'::text, 'marketing'::text])`),
	check("email_templates_status_check", sql`status = ANY (ARRAY['draft'::text, 'active'::text, 'disabled'::text, 'archived'::text])`),
]);

export const emailSends = pgTable("email_sends", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	templateId: uuid("template_id"),
	recipientEmail: text("recipient_email").notNull(),
	recipientName: text("recipient_name"),
	subject: text().notNull(),
	fromEmail: text("from_email").notNull(),
	fromName: text("from_name"),
	status: text().default('queued').notNull(),
	resendId: text("resend_id"),
	variablesData: jsonb("variables_data"),
	sentAt: timestamp("sent_at", { withTimezone: true, mode: 'string' }),
	deliveredAt: timestamp("delivered_at", { withTimezone: true, mode: 'string' }),
	openedAt: timestamp("opened_at", { withTimezone: true, mode: 'string' }),
	clickedAt: timestamp("clicked_at", { withTimezone: true, mode: 'string' }),
	bouncedAt: timestamp("bounced_at", { withTimezone: true, mode: 'string' }),
	errorMessage: text("error_message"),
	entityType: text("entity_type"),
	entityId: uuid("entity_id"),
	triggeredBy: text("triggered_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_email_sends_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_email_sends_recipient").using("btree", table.recipientEmail.asc().nullsLast().op("text_ops"), table.createdAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_email_sends_status").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("text_ops"), table.createdAt.asc().nullsLast().op("text_ops")),
	index("idx_email_sends_template").using("btree", table.templateId.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "email_sends_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "email_sends_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.templateId],
			foreignColumns: [emailTemplates.id],
			name: "email_sends_template_id_fkey"
		}).onDelete("set null"),
	pgPolicy("email_sends_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())))` }),
	check("email_sends_status_check", sql`status = ANY (ARRAY['queued'::text, 'sent'::text, 'delivered'::text, 'opened'::text, 'clicked'::text, 'bounced'::text, 'failed'::text, 'spam'::text])`),
	check("email_sends_triggered_by_check", sql`triggered_by = ANY (ARRAY['workflow'::text, 'manual'::text, 'system'::text, 'test'::text])`),
]);

export const emailSenders = pgTable("email_senders", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	email: text().notNull(),
	name: text().notNull(),
	isDefault: boolean("is_default").default(false),
	isVerified: boolean("is_verified").default(false),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_email_senders_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "email_senders_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "email_senders_org_id_fkey"
		}).onDelete("cascade"),
	unique("email_senders_org_id_email_key").on(table.orgId, table.email),
	pgPolicy("email_senders_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())))` }),
]);

export const activityNotes = pgTable("activity_notes", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	activityId: uuid("activity_id").notNull(),
	orgId: uuid("org_id").notNull(),
	content: text().notNull(),
	isInternal: boolean("is_internal").default(false),
	createdBy: uuid("created_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_activity_notes_activity_id").using("btree", table.activityId.asc().nullsLast().op("uuid_ops")),
	index("idx_activity_notes_created_at").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_activity_notes_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.activityId],
			foreignColumns: [activities.id],
			name: "activity_notes_activity_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "activity_notes_created_by_fkey"
		}),
	pgPolicy("activity_notes_delete_policy", { as: "permissive", for: "delete", to: ["public"], using: sql`((org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))) AND (created_by IN ( SELECT user_profiles.id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))))` }),
	pgPolicy("activity_notes_insert_policy", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("activity_notes_select_policy", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("activity_notes_update_policy", { as: "permissive", for: "update", to: ["public"] }),
]);

export const workQueues = pgTable("work_queues", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id"),
	queueName: text("queue_name").notNull(),
	queueCode: text("queue_code").notNull(),
	description: text(),
	queueType: text("queue_type").default('activity'),
	entityType: text("entity_type"),
	assignedToGroupId: uuid("assigned_to_group_id"),
	assignmentStrategy: text("assignment_strategy").default('round_robin'),
	filterCriteria: jsonb("filter_criteria"),
	sortOrder: text("sort_order").default('priority_desc'),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	ownerGroupId: uuid("owner_group_id"),
	assignmentType: text("assignment_type").default('manual'),
	escalationThresholdHours: integer("escalation_threshold_hours").default(24),
	reminderThresholdHours: integer("reminder_threshold_hours").default(4),
	isDefault: boolean("is_default").default(false),
	entityTypes: text("entity_types").array().default([""]),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_work_queues_is_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")).where(sql`(is_active = true)`),
	index("idx_work_queues_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_work_queues_owner_group_id").using("btree", table.ownerGroupId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.assignedToGroupId],
			foreignColumns: [pods.id],
			name: "work_queues_assigned_to_group_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "work_queues_org_id_fkey"
		}).onDelete("cascade"),
	unique("work_queues_org_id_queue_code_key").on(table.orgId, table.queueCode),
	pgPolicy("work_queues_insert_policy", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid())))`  }),
	pgPolicy("work_queues_select_policy", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("work_queues_update_policy", { as: "permissive", for: "update", to: ["public"] }),
]);

export const incidents = pgTable("incidents", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	incidentNumber: text("incident_number").notNull(),
	title: text().notNull(),
	description: text(),
	severity: text().notNull(),
	status: text().default('open').notNull(),
	impact: text(),
	rootCause: text("root_cause"),
	resolution: text(),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }).notNull(),
	detectedAt: timestamp("detected_at", { withTimezone: true, mode: 'string' }),
	resolvedAt: timestamp("resolved_at", { withTimezone: true, mode: 'string' }),
	incidentCommander: uuid("incident_commander"),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	metadata: jsonb().default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_incidents_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_incidents_org_created").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")),
	index("idx_incidents_org_status").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.status.asc().nullsLast().op("text_ops")),
	index("idx_incidents_severity").using("btree", table.severity.asc().nullsLast().op("text_ops")),
	index("idx_incidents_started").using("btree", table.startedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_incidents_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "incidents_created_by_fkey"
		}),
	foreignKey({
			columns: [table.incidentCommander],
			foreignColumns: [userProfiles.id],
			name: "incidents_incident_commander_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "incidents_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "incidents_updated_by_fkey"
		}),
	unique("incidents_org_id_incident_number_key").on(table.orgId, table.incidentNumber),
	pgPolicy("incidents_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())))` }),
	check("incidents_severity_check", sql`severity = ANY (ARRAY['P0'::text, 'P1'::text, 'P2'::text, 'P3'::text])`),
	check("incidents_status_check", sql`status = ANY (ARRAY['open'::text, 'investigating'::text, 'identified'::text, 'monitoring'::text, 'resolved'::text])`),
]);

export const incidentTimeline = pgTable("incident_timeline", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	incidentId: uuid("incident_id").notNull(),
	eventType: text("event_type").notNull(),
	description: text().notNull(),
	performedBy: uuid("performed_by"),
	metadata: jsonb().default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_incident_timeline_created").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_incident_timeline_incident").using("btree", table.incidentId.asc().nullsLast().op("uuid_ops")),
	index("idx_incident_timeline_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.incidentId],
			foreignColumns: [incidents.id],
			name: "incident_timeline_incident_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "incident_timeline_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.performedBy],
			foreignColumns: [userProfiles.id],
			name: "incident_timeline_performed_by_fkey"
		}),
	pgPolicy("incident_timeline_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())))` }),
	check("incident_timeline_event_type_check", sql`event_type = ANY (ARRAY['detection'::text, 'notification'::text, 'escalation'::text, 'action'::text, 'update'::text, 'resolution'::text])`),
]);

export const incidentNotifications = pgTable("incident_notifications", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	incidentId: uuid("incident_id").notNull(),
	notificationType: text("notification_type").notNull(),
	recipient: text().notNull(),
	subject: text(),
	body: text().notNull(),
	status: text().default('pending'),
	sentAt: timestamp("sent_at", { withTimezone: true, mode: 'string' }),
	deliveredAt: timestamp("delivered_at", { withTimezone: true, mode: 'string' }),
	errorMessage: text("error_message"),
	sentBy: uuid("sent_by"),
	metadata: jsonb().default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_incident_notifications_incident").using("btree", table.incidentId.asc().nullsLast().op("uuid_ops")),
	index("idx_incident_notifications_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_incident_notifications_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.incidentId],
			foreignColumns: [incidents.id],
			name: "incident_notifications_incident_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "incident_notifications_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.sentBy],
			foreignColumns: [userProfiles.id],
			name: "incident_notifications_sent_by_fkey"
		}),
	pgPolicy("incident_notifications_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())))` }),
	check("incident_notifications_notification_type_check", sql`notification_type = ANY (ARRAY['email'::text, 'sms'::text, 'slack'::text, 'status_page'::text, 'in_app'::text])`),
	check("incident_notifications_status_check", sql`status = ANY (ARRAY['pending'::text, 'sent'::text, 'delivered'::text, 'failed'::text])`),
]);

export const breakGlassAccess = pgTable("break_glass_access", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	userId: uuid("user_id"),
	accessedBy: text("accessed_by").notNull(),
	reason: text().notNull(),
	incidentId: uuid("incident_id"),
	authorizedBy: text("authorized_by").notNull(),
	actionsTaken: text("actions_taken").array().default([""]),
	accessedAt: timestamp("accessed_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	endedAt: timestamp("ended_at", { withTimezone: true, mode: 'string' }),
	ipAddress: inet("ip_address"),
	userAgent: text("user_agent"),
	metadata: jsonb().default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_break_glass_accessed").using("btree", table.accessedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_break_glass_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_break_glass_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.incidentId],
			foreignColumns: [incidents.id],
			name: "break_glass_access_incident_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "break_glass_access_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "break_glass_access_user_id_fkey"
		}),
	pgPolicy("break_glass_access_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())))` }),
]);

export const emergencyDrills = pgTable("emergency_drills", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	drillType: text("drill_type").notNull(),
	title: text().notNull(),
	scenario: text().notNull(),
	participants: uuid().array().default([""]),
	scheduledAt: timestamp("scheduled_at", { withTimezone: true, mode: 'string' }).notNull(),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	status: text().default('scheduled'),
	findings: text(),
	actionItems: jsonb("action_items").default([]),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	metadata: jsonb().default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_emergency_drills_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_emergency_drills_scheduled").using("btree", table.scheduledAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_emergency_drills_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_emergency_drills_type").using("btree", table.drillType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "emergency_drills_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "emergency_drills_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "emergency_drills_updated_by_fkey"
		}),
	pgPolicy("emergency_drills_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())))` }),
	check("emergency_drills_drill_type_check", sql`drill_type = ANY (ARRAY['tabletop'::text, 'simulated_outage'::text, 'security_breach'::text, 'backup_restore'::text])`),
	check("emergency_drills_status_check", sql`status = ANY (ARRAY['scheduled'::text, 'in_progress'::text, 'completed'::text, 'cancelled'::text])`),
]);

export const slaDefinitions = pgTable("sla_definitions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id"),
	slaName: text("sla_name").notNull(),
	slaCode: text("sla_code").notNull(),
	description: text(),
	entityType: text("entity_type").notNull(),
	activityType: text("activity_type"),
	activityCategory: text("activity_category"),
	priority: text(),
	targetHours: integer("target_hours").notNull(),
	warningHours: integer("warning_hours"),
	criticalHours: integer("critical_hours"),
	useBusinessHours: boolean("use_business_hours").default(false),
	businessHoursStart: text("business_hours_start").default('09:00'),
	businessHoursEnd: text("business_hours_end").default('17:00'),
	escalateOnBreach: boolean("escalate_on_breach").default(false),
	escalateToUserId: uuid("escalate_to_user_id"),
	escalateToGroupId: uuid("escalate_to_group_id"),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	category: text(),
	startEvent: text("start_event"),
	endEvent: text("end_event"),
	targetValue: integer("target_value"),
	targetUnit: text("target_unit").default('business_hours'),
	conditions: jsonb().default([]),
	status: text().default('draft'),
	pauseOnHold: boolean("pause_on_hold").default(false),
	applyRetroactive: boolean("apply_retroactive").default(false),
}, (table) => [
	index("idx_sla_definitions_status").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.escalateToGroupId],
			foreignColumns: [pods.id],
			name: "sla_definitions_escalate_to_group_id_fkey"
		}),
	foreignKey({
			columns: [table.escalateToUserId],
			foreignColumns: [userProfiles.id],
			name: "sla_definitions_escalate_to_user_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "sla_definitions_org_id_fkey"
		}).onDelete("cascade"),
	unique("sla_definitions_org_id_sla_code_key").on(table.orgId, table.slaCode),
	pgPolicy("sla_definitions_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id IS NULL) OR (org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid()))))` }),
	check("sla_definitions_status_check", sql`(status IS NULL) OR (status = ANY (ARRAY['draft'::text, 'active'::text, 'disabled'::text]))`),
	check("sla_definitions_target_unit_check", sql`(target_unit IS NULL) OR (target_unit = ANY (ARRAY['minutes'::text, 'hours'::text, 'business_hours'::text, 'days'::text, 'business_days'::text, 'weeks'::text]))`),
]);

export const workQueueMembers = pgTable("work_queue_members", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	queueId: uuid("queue_id").notNull(),
	userId: uuid("user_id").notNull(),
	role: text().default('member'),
	canClaim: boolean("can_claim").default(true),
	canAssign: boolean("can_assign").default(false),
	maxActiveActivities: integer("max_active_activities").default(10),
	currentLoad: integer("current_load").default(0),
	skills: text().array().default([""]),
	isActive: boolean("is_active").default(true),
	joinedAt: timestamp("joined_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_work_queue_members_queue_id").using("btree", table.queueId.asc().nullsLast().op("uuid_ops")),
	index("idx_work_queue_members_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.queueId],
			foreignColumns: [workQueues.id],
			name: "work_queue_members_queue_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "work_queue_members_user_id_fkey"
		}).onDelete("cascade"),
	unique("work_queue_members_queue_id_user_id_key").on(table.queueId, table.userId),
	pgPolicy("work_queue_members_insert_policy", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(queue_id IN ( SELECT work_queues.id
   FROM work_queues
  WHERE (work_queues.org_id IN ( SELECT user_profiles.org_id
           FROM user_profiles
          WHERE (user_profiles.auth_id = auth.uid())))))`  }),
	pgPolicy("work_queue_members_select_policy", { as: "permissive", for: "select", to: ["public"] }),
	check("work_queue_members_role_check", sql`role = ANY (ARRAY['owner'::text, 'supervisor'::text, 'member'::text])`),
]);

export const slaEscalationLevels = pgTable("sla_escalation_levels", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	slaDefinitionId: uuid("sla_definition_id").notNull(),
	levelNumber: integer("level_number").notNull(),
	levelName: text("level_name").notNull(),
	triggerPercentage: integer("trigger_percentage").notNull(),
	notifyEmail: boolean("notify_email").default(true),
	notifySlack: boolean("notify_slack").default(false),
	notifySms: boolean("notify_sms").default(false),
	emailRecipients: text("email_recipients").array().default([""]),
	slackChannel: text("slack_channel"),
	smsRecipients: text("sms_recipients").array().default([""]),
	showBadge: boolean("show_badge").default(true),
	badgeColor: text("badge_color").default('yellow'),
	addToReport: boolean("add_to_report").default(false),
	addToDashboard: boolean("add_to_dashboard").default(false),
	createTask: boolean("create_task").default(false),
	taskAssignee: text("task_assignee"),
	escalateOwnership: boolean("escalate_ownership").default(false),
	escalateTo: text("escalate_to"),
	blockActions: boolean("block_actions").default(false),
	requireResolutionNotes: boolean("require_resolution_notes").default(false),
	flagForReview: boolean("flag_for_review").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_sla_escalation_levels_definition").using("btree", table.slaDefinitionId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.slaDefinitionId],
			foreignColumns: [slaDefinitions.id],
			name: "sla_escalation_levels_sla_definition_id_fkey"
		}).onDelete("cascade"),
	unique("sla_escalation_levels_sla_definition_id_level_number_key").on(table.slaDefinitionId, table.levelNumber),
	pgPolicy("sla_escalation_levels_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(sla_definition_id IN ( SELECT sla_definitions.id
   FROM sla_definitions
  WHERE (sla_definitions.org_id = COALESCE((current_setting('app.current_org_id'::text, true))::uuid, ((auth.jwt() ->> 'org_id'::text))::uuid))))` }),
	check("sla_escalation_levels_level_number_check", sql`(level_number >= 1) AND (level_number <= 10)`),
	check("sla_escalation_levels_trigger_percentage_check", sql`(trigger_percentage >= 1) AND (trigger_percentage <= 500)`),
]);

export const slaEvents = pgTable("sla_events", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	slaDefinitionId: uuid("sla_definition_id").notNull(),
	entityType: text("entity_type").notNull(),
	entityId: uuid("entity_id").notNull(),
	startTime: timestamp("start_time", { withTimezone: true, mode: 'string' }).notNull(),
	endTime: timestamp("end_time", { withTimezone: true, mode: 'string' }),
	targetDeadline: timestamp("target_deadline", { withTimezone: true, mode: 'string' }).notNull(),
	elapsedMinutes: integer("elapsed_minutes").default(0),
	currentPercentage: numeric("current_percentage", { precision: 6, scale:  2 }).default('0'),
	currentLevel: integer("current_level").default(0),
	status: text().default('pending').notNull(),
	metAt: timestamp("met_at", { withTimezone: true, mode: 'string' }),
	resolutionNotes: text("resolution_notes"),
	resolvedBy: uuid("resolved_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_sla_events_active").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("uuid_ops")).where(sql`(status = ANY (ARRAY['pending'::text, 'warning'::text, 'breach'::text]))`),
	index("idx_sla_events_deadline").using("btree", table.targetDeadline.asc().nullsLast().op("timestamptz_ops")).where(sql`(status = 'pending'::text)`),
	index("idx_sla_events_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("uuid_ops")),
	index("idx_sla_events_org_status").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.status.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "sla_events_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.resolvedBy],
			foreignColumns: [userProfiles.id],
			name: "sla_events_resolved_by_fkey"
		}),
	foreignKey({
			columns: [table.slaDefinitionId],
			foreignColumns: [slaDefinitions.id],
			name: "sla_events_sla_definition_id_fkey"
		}).onDelete("cascade"),
	unique("sla_events_sla_definition_id_entity_type_entity_id_key").on(table.slaDefinitionId, table.entityType, table.entityId),
	pgPolicy("sla_events_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = COALESCE((current_setting('app.current_org_id'::text, true))::uuid, ((auth.jwt() ->> 'org_id'::text))::uuid))` }),
	check("sla_events_status_check", sql`status = ANY (ARRAY['pending'::text, 'warning'::text, 'breach'::text, 'critical'::text, 'met'::text, 'cancelled'::text])`),
]);

export const slaNotifications = pgTable("sla_notifications", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	slaEventId: uuid("sla_event_id").notNull(),
	escalationLevel: integer("escalation_level").notNull(),
	notificationType: text("notification_type").notNull(),
	recipients: text().array().notNull(),
	sentAt: timestamp("sent_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	deliveredAt: timestamp("delivered_at", { withTimezone: true, mode: 'string' }),
	failedAt: timestamp("failed_at", { withTimezone: true, mode: 'string' }),
	errorMessage: text("error_message"),
	externalMessageId: text("external_message_id"),
}, (table) => [
	index("idx_sla_notifications_event_level").using("btree", table.slaEventId.asc().nullsLast().op("int4_ops"), table.escalationLevel.asc().nullsLast().op("uuid_ops"), table.notificationType.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.slaEventId],
			foreignColumns: [slaEvents.id],
			name: "sla_notifications_sla_event_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("sla_notifications_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(sla_event_id IN ( SELECT sla_events.id
   FROM sla_events
  WHERE (sla_events.org_id = COALESCE((current_setting('app.current_org_id'::text, true))::uuid, ((auth.jwt() ->> 'org_id'::text))::uuid))))` }),
	check("sla_notifications_notification_type_check", sql`notification_type = ANY (ARRAY['email'::text, 'slack'::text, 'sms'::text, 'in_app'::text])`),
]);

export const slaScheduledRuns = pgTable("sla_scheduled_runs", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	lastRunAt: timestamp("last_run_at", { withTimezone: true, mode: 'string' }).notNull(),
	rulesChecked: integer("rules_checked").default(0),
	eventsUpdated: integer("events_updated").default(0),
	notificationsSent: integer("notifications_sent").default(0),
	errors: text().array(),
	runDurationMs: integer("run_duration_ms"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
});

export const activityEscalations = pgTable("activity_escalations", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	activityId: uuid("activity_id").notNull(),
	orgId: uuid("org_id").notNull(),
	escalationLevel: integer("escalation_level").default(1).notNull(),
	escalatedFromUser: uuid("escalated_from_user"),
	escalatedToUser: uuid("escalated_to_user"),
	escalatedToQueue: uuid("escalated_to_queue"),
	reason: text(),
	escalationType: text("escalation_type").default('automatic'),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_activity_escalations_activity_id").using("btree", table.activityId.asc().nullsLast().op("uuid_ops")),
	index("idx_activity_escalations_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.activityId],
			foreignColumns: [activities.id],
			name: "activity_escalations_activity_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.escalatedFromUser],
			foreignColumns: [userProfiles.id],
			name: "activity_escalations_escalated_from_user_fkey"
		}),
	foreignKey({
			columns: [table.escalatedToQueue],
			foreignColumns: [workQueues.id],
			name: "activity_escalations_escalated_to_queue_fkey"
		}),
	foreignKey({
			columns: [table.escalatedToUser],
			foreignColumns: [userProfiles.id],
			name: "activity_escalations_escalated_to_user_fkey"
		}),
	pgPolicy("activity_escalations_insert_policy", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid())))`  }),
	pgPolicy("activity_escalations_select_policy", { as: "permissive", for: "select", to: ["public"] }),
	check("activity_escalations_escalation_type_check", sql`escalation_type = ANY (ARRAY['automatic'::text, 'manual'::text])`),
]);

export const contacts = pgTable("contacts", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	firstName: text("first_name"),
	lastName: text("last_name"),
	email: text(),
	phone: text(),
	mobile: text(),
	linkedinUrl: text("linkedin_url"),
	avatarUrl: text("avatar_url"),
	title: text(),
	companyName: text("company_name"),
	companyId: uuid("company_id"),
	department: text(),
	timezone: text().default('America/New_York'),
	preferredContactMethod: text("preferred_contact_method").default('email'),
	bestTimeToContact: text("best_time_to_contact"),
	doNotCallBefore: text("do_not_call_before"),
	doNotCallAfter: text("do_not_call_after"),
	status: text().default('active').notNull(),
	source: text(),
	sourceDetail: text("source_detail"),
	sourceCampaignId: uuid("source_campaign_id"),
	userProfileId: uuid("user_profile_id"),
	lastContactedAt: timestamp("last_contacted_at", { withTimezone: true, mode: 'string' }),
	lastResponseAt: timestamp("last_response_at", { withTimezone: true, mode: 'string' }),
	totalInteractions: integer("total_interactions").default(0),
	engagementScore: integer("engagement_score").default(0),
	twitterUrl: text("twitter_url"),
	githubUrl: text("github_url"),
	decisionAuthority: text("decision_authority"),
	buyingRole: text("buying_role"),
	influenceLevel: text("influence_level"),
	tags: text().array(),
	notes: text(),
	internalNotes: text("internal_notes"),
	ownerId: uuid("owner_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	// TODO: failed to parse database type 'tsvector'
	searchVector: unknown("search_vector"),
	relationshipNotes: text("relationship_notes"),
	isPrimary: boolean("is_primary").default(false),
	marketingEmailsOptIn: boolean("marketing_emails_opt_in").default(true),
	newsletterOptIn: boolean("newsletter_opt_in").default(true),
	productUpdatesOptIn: boolean("product_updates_opt_in").default(true),
	doNotCall: boolean("do_not_call").default(false),
	preferredMeetingPlatform: text("preferred_meeting_platform"),
	meetingDuration: integer("meeting_duration").default(30),
	communicationFrequency: text("communication_frequency"),
	types: text().array().default([""]),
	subtype: text().default('general'),
	candidateStatus: text("candidate_status"),
	candidateResumeUrl: text("candidate_resume_url"),
	candidateSkills: text("candidate_skills").array(),
	candidateExperienceYears: integer("candidate_experience_years"),
	candidateCurrentVisa: text("candidate_current_visa"),
	candidateVisaExpiry: timestamp("candidate_visa_expiry", { withTimezone: true, mode: 'string' }),
	candidateHourlyRate: numeric("candidate_hourly_rate", { precision: 10, scale:  2 }),
	candidateBenchStartDate: timestamp("candidate_bench_start_date", { withTimezone: true, mode: 'string' }),
	candidateAvailability: text("candidate_availability"),
	candidateWillingToRelocate: boolean("candidate_willing_to_relocate").default(false),
	candidatePreferredLocations: text("candidate_preferred_locations").array(),
	candidateCurrentEmploymentStatus: text("candidate_current_employment_status"),
	candidateNoticePeriodDays: integer("candidate_notice_period_days"),
	candidateEarliestStartDate: date("candidate_earliest_start_date"),
	candidatePreferredEmploymentType: text("candidate_preferred_employment_type").array(),
	candidateDesiredSalaryAnnual: numeric("candidate_desired_salary_annual", { precision: 12, scale:  2 }),
	candidateDesiredSalaryCurrency: text("candidate_desired_salary_currency").default('USD'),
	candidateMinimumHourlyRate: numeric("candidate_minimum_hourly_rate", { precision: 10, scale:  2 }),
	candidateMinimumAnnualSalary: numeric("candidate_minimum_annual_salary", { precision: 12, scale:  2 }),
	candidateBenefitsRequired: text("candidate_benefits_required").array(),
	candidateCompensationNotes: text("candidate_compensation_notes"),
	candidateProfessionalHeadline: text("candidate_professional_headline"),
	candidateProfessionalSummary: text("candidate_professional_summary"),
	candidateCareerObjectives: text("candidate_career_objectives"),
	candidateRecruiterRating: integer("candidate_recruiter_rating"),
	candidateRecruiterRatingNotes: text("candidate_recruiter_rating_notes"),
	candidateProfileCompletenessScore: integer("candidate_profile_completeness_score").default(0),
	candidateIsOnHotlist: boolean("candidate_is_on_hotlist").default(false),
	candidateHotlistAddedAt: timestamp("candidate_hotlist_added_at", { withTimezone: true, mode: 'string' }),
	candidateHotlistNotes: text("candidate_hotlist_notes"),
	employeeId: uuid("employee_id"),
	employeeDepartment: text("employee_department"),
	employeeHireDate: date("employee_hire_date"),
	employeePosition: text("employee_position"),
	employeeStatus: text("employee_status"),
	leadStatus: text("lead_status"),
	leadScore: integer("lead_score"),
	leadSource: text("lead_source"),
	leadEstimatedValue: numeric("lead_estimated_value", { precision: 12, scale:  2 }),
	leadConvertedToDealId: uuid("lead_converted_to_deal_id"),
	leadConvertedToAccountId: uuid("lead_converted_to_account_id"),
	leadConvertedAt: timestamp("lead_converted_at", { withTimezone: true, mode: 'string' }),
	leadLostReason: text("lead_lost_reason"),
	leadBantBudget: integer("lead_bant_budget").default(0),
	leadBantAuthority: integer("lead_bant_authority").default(0),
	leadBantNeed: integer("lead_bant_need").default(0),
	leadBantTimeline: integer("lead_bant_timeline").default(0),
	leadBantBudgetNotes: text("lead_bant_budget_notes"),
	leadBantAuthorityNotes: text("lead_bant_authority_notes"),
	leadBantNeedNotes: text("lead_bant_need_notes"),
	leadBantTimelineNotes: text("lead_bant_timeline_notes"),
	leadBantTotalScore: integer("lead_bant_total_score").generatedAlwaysAs(sql`(((COALESCE(lead_bant_budget, 0) + COALESCE(lead_bant_authority, 0)) + COALESCE(lead_bant_need, 0)) + COALESCE(lead_bant_timeline, 0))`),
	leadBudgetStatus: text("lead_budget_status"),
	leadEstimatedMonthlySpend: numeric("lead_estimated_monthly_spend", { precision: 12, scale:  2 }),
	leadAuthorityLevel: text("lead_authority_level"),
	leadBusinessNeed: text("lead_business_need"),
	leadUrgency: text("lead_urgency"),
	leadTargetStartDate: date("lead_target_start_date"),
	leadPositionsCount: integer("lead_positions_count").default(1),
	leadSkillsNeeded: text("lead_skills_needed").array(),
	leadContractTypes: text("lead_contract_types").array(),
	leadQualificationResult: text("lead_qualification_result"),
	leadQualificationNotes: text("lead_qualification_notes"),
	leadQualifiedAt: timestamp("lead_qualified_at", { withTimezone: true, mode: 'string' }),
	leadQualifiedBy: uuid("lead_qualified_by"),
	leadInterestLevel: text("lead_interest_level"),
	leadHiringNeeds: text("lead_hiring_needs"),
	leadPainPoints: text("lead_pain_points"),
	leadNextAction: text("lead_next_action"),
	leadNextActionDate: date("lead_next_action_date"),
	prospectPrimaryCampaignId: uuid("prospect_primary_campaign_id"),
	prospectCurrentSequenceStep: integer("prospect_current_sequence_step"),
	prospectSequenceStatus: text("prospect_sequence_status"),
	prospectConvertedToLeadAt: timestamp("prospect_converted_to_lead_at", { withTimezone: true, mode: 'string' }),
	prospectFirstContactedAt: timestamp("prospect_first_contacted_at", { withTimezone: true, mode: 'string' }),
	prospectRespondedAt: timestamp("prospect_responded_at", { withTimezone: true, mode: 'string' }),
	prospectResponseType: text("prospect_response_type"),
	authId: uuid("auth_id"),
	dateOfBirth: date("date_of_birth"),
	gender: text(),
	nationality: text(),
	languages: jsonb().default([]),
	middleName: text("middle_name"),
	preferredName: text("preferred_name"),
	phoneHome: text("phone_home"),
	phoneWork: text("phone_work"),
	emailSecondary: text("email_secondary"),
	emergencyContactName: text("emergency_contact_name"),
	emergencyContactRelationship: text("emergency_contact_relationship"),
	emergencyContactPhone: text("emergency_contact_phone"),
	emergencyContactEmail: text("emergency_contact_email"),
	portfolioUrl: text("portfolio_url"),
	personalWebsite: text("personal_website"),
	doNotEmail: boolean("do_not_email").default(false),
	doNotText: boolean("do_not_text").default(false),
	lastActivityDate: timestamp("last_activity_date", { withTimezone: true, mode: 'string' }),
	lastContactedBy: uuid("last_contacted_by"),
	category: text().notNull(),
	contactStatus: text("contact_status").default('active'),
	primaryAddressId: uuid("primary_address_id"),
	suffix: text(),
	pronouns: text(),
	photoUrl: text("photo_url"),
	secondaryEmail: text("secondary_email"),
	workEmail: text("work_email"),
	workPhone: text("work_phone"),
	homePhone: text("home_phone"),
	currentCompanyId: uuid("current_company_id"),
	currentTitle: text("current_title"),
	currentDepartment: text("current_department"),
	language: text().default('en'),
	benchType: text("bench_type"),
	benchStatus: text("bench_status"),
	benchVendorId: uuid("bench_vendor_id"),
	benchVendorContactId: uuid("bench_vendor_contact_id"),
	benchStartDate: date("bench_start_date"),
	benchTargetEndDate: date("bench_target_end_date"),
	benchMaxBenchDays: integer("bench_max_bench_days"),
	benchBillRate: numeric("bench_bill_rate", { precision: 10, scale:  2 }),
	benchPayRate: numeric("bench_pay_rate", { precision: 10, scale:  2 }),
	benchMarkupPercentage: numeric("bench_markup_percentage", { precision: 5, scale:  2 }),
	benchCostPerDay: numeric("bench_cost_per_day", { precision: 10, scale:  2 }),
	benchTotalPlacements: integer("bench_total_placements").default(0),
	benchLastPlacementEnd: date("bench_last_placement_end"),
	benchUtilizationRate: numeric("bench_utilization_rate", { precision: 5, scale:  2 }),
	placedStatus: text("placed_status"),
	placedClientId: uuid("placed_client_id"),
	placedJobId: uuid("placed_job_id"),
	placedStartDate: date("placed_start_date"),
	placedEndDate: date("placed_end_date"),
	placedExtensionCount: integer("placed_extension_count").default(0),
	clientContactCompanyId: uuid("client_contact_company_id"),
	clientContactRole: text("client_contact_role"),
	clientContactDecisionAuthority: boolean("client_contact_decision_authority").default(false),
	clientContactBudgetAuthority: boolean("client_contact_budget_authority").default(false),
	clientContactContractSigner: boolean("client_contact_contract_signer").default(false),
	clientContactRelationshipStrength: integer("client_contact_relationship_strength"),
	clientContactRelationshipOwnerId: uuid("client_contact_relationship_owner_id"),
	clientContactFirstMeetingDate: date("client_contact_first_meeting_date"),
	clientContactLastMeetingDate: date("client_contact_last_meeting_date"),
	clientContactMeetingCadence: text("client_contact_meeting_cadence"),
	clientContactPreferredVendors: text("client_contact_preferred_vendors").array(),
	clientContactHiringStyle: text("client_contact_hiring_style"),
	clientContactInterviewStyle: text("client_contact_interview_style"),
	vendorContactCompanyId: uuid("vendor_contact_company_id"),
	vendorContactRole: text("vendor_contact_role"),
	vendorContactSpecialtyAreas: text("vendor_contact_specialty_areas").array(),
	vendorContactResponseRating: integer("vendor_contact_response_rating"),
	vendorContactQualityRating: integer("vendor_contact_quality_rating"),
	referralSourceType: text("referral_source_type"),
	referralTotalReferrals: integer("referral_total_referrals").default(0),
	referralSuccessfulPlacements: integer("referral_successful_placements").default(0),
	referralSuccessRate: numeric("referral_success_rate", { precision: 5, scale:  2 }),
	referralFeePercentage: numeric("referral_fee_percentage", { precision: 5, scale:  2 }),
	referralLastReferralDate: date("referral_last_referral_date"),
	alumniFormerEmployeeId: uuid("alumni_former_employee_id"),
	alumniDepartureDate: date("alumni_departure_date"),
	alumniDepartureReason: text("alumni_departure_reason"),
	alumniRehireEligible: boolean("alumni_rehire_eligible").default(true),
	alumniCurrentEmployer: text("alumni_current_employer"),
	alumniLastContactDate: date("alumni_last_contact_date"),
	candidateHotlistAddedBy: uuid("candidate_hotlist_added_by"),
	candidateHotlistReason: text("candidate_hotlist_reason"),
	candidatePriority: integer("candidate_priority").default(0),
	candidateDoNotSubmitTo: uuid("candidate_do_not_submit_to").array(),
	candidateRemotePreference: text("candidate_remote_preference"),
	candidateYearsExperience: numeric("candidate_years_experience", { precision: 4, scale:  1 }),
	candidateCoverLetterUrl: text("candidate_cover_letter_url"),
	candidateResumeUpdatedAt: timestamp("candidate_resume_updated_at", { withTimezone: true, mode: 'string' }),
	leadConvertedToType: text("lead_converted_to_type"),
	leadConvertedToId: uuid("lead_converted_to_id"),
	companyNameLegal: text("company_name_legal"),
	companyDbaName: text("company_dba_name"),
	companyTradeNames: text("company_trade_names").array(),
	companyType: text("company_type"),
	companyStructure: text("company_structure"),
	industryId: uuid("industry_id"),
	industrySecondaryId: uuid("industry_secondary_id"),
	naicsCode: text("naics_code"),
	sicCode: text("sic_code"),
	employeeCount: integer("employee_count"),
	employeeCountRange: text("employee_count_range"),
	annualRevenue: numeric("annual_revenue", { precision: 15, scale:  2 }),
	annualRevenueRange: text("annual_revenue_range"),
	foundedYear: integer("founded_year"),
	websiteUrl: text("website_url"),
	companyLinkedinUrl: text("company_linkedin_url"),
	companyTwitterUrl: text("company_twitter_url"),
	logoUrl: text("logo_url"),
	companyDescription: text("company_description"),
	parentCompanyId: uuid("parent_company_id"),
	ultimateParentId: uuid("ultimate_parent_id"),
	subsidiaryCount: integer("subsidiary_count").default(0),
	einTaxIdEncrypted: text("ein_tax_id_encrypted"),
	dunsNumber: text("duns_number"),
	registrationState: text("registration_state"),
	registrationCountry: text("registration_country").default('US'),
	companyLeadEstimatedAnnualValue: numeric("company_lead_estimated_annual_value", { precision: 12, scale:  2 }),
	companyLeadEstimatedPositionsPerYear: integer("company_lead_estimated_positions_per_year"),
	companyLeadPrimaryHiringNeeds: text("company_lead_primary_hiring_needs").array(),
	clientStatus: text("client_status"),
	clientTier: text("client_tier"),
	clientSegment: text("client_segment"),
	clientProspectDate: date("client_prospect_date"),
	clientConvertedDate: date("client_converted_date"),
	clientFirstPlacementDate: date("client_first_placement_date"),
	clientLastActiveDate: date("client_last_active_date"),
	clientDormantSince: date("client_dormant_since"),
	clientChurnedDate: date("client_churned_date"),
	clientChurnReason: text("client_churn_reason"),
	clientContractType: text("client_contract_type"),
	clientContractStartDate: date("client_contract_start_date"),
	clientContractEndDate: date("client_contract_end_date"),
	clientContractAutoRenew: boolean("client_contract_auto_renew").default(false),
	clientContractUrl: text("client_contract_url"),
	clientPaymentTerms: integer("client_payment_terms").default(30),
	clientCreditLimit: numeric("client_credit_limit", { precision: 12, scale:  2 }),
	clientCreditStatus: text("client_credit_status"),
	clientDefaultMarkup: numeric("client_default_markup", { precision: 5, scale:  2 }),
	clientDefaultBillRate: numeric("client_default_bill_rate", { precision: 10, scale:  2 }),
	clientUsesVms: boolean("client_uses_vms").default(false),
	clientVmsSystem: text("client_vms_system"),
	clientVmsSupplierId: text("client_vms_supplier_id"),
	clientMspId: uuid("client_msp_id"),
	clientTeamLeadId: uuid("client_team_lead_id"),
	clientRecruiterIds: uuid("client_recruiter_ids").array(),
	clientOpenPositionsCount: integer("client_open_positions_count").default(0),
	clientActivePlacementsCount: integer("client_active_placements_count").default(0),
	clientTotalPlacementsCount: integer("client_total_placements_count").default(0),
	clientLifetimeRevenue: numeric("client_lifetime_revenue", { precision: 15, scale:  2 }).default('0'),
	vendorStatus: text("vendor_status"),
	vendorTier: text("vendor_tier"),
	vendorType: text("vendor_type"),
	vendorSpecialtyAreas: text("vendor_specialty_areas").array(),
	vendorGeographicCoverage: text("vendor_geographic_coverage").array(),
	vendorResourceTypes: text("vendor_resource_types").array(),
	vendorPaymentTerms: integer("vendor_payment_terms").default(30),
	vendorDefaultMarkup: numeric("vendor_default_markup", { precision: 5, scale:  2 }),
	vendorReferralFeePercentage: numeric("vendor_referral_fee_percentage", { precision: 5, scale:  2 }),
	vendorApprovedDate: date("vendor_approved_date"),
	vendorApprovedBy: uuid("vendor_approved_by"),
	vendorLastReviewDate: date("vendor_last_review_date"),
	vendorNextReviewDate: date("vendor_next_review_date"),
	vendorInsuranceVerified: boolean("vendor_insurance_verified").default(false),
	vendorInsuranceExpiryDate: date("vendor_insurance_expiry_date"),
	vendorW9OnFile: boolean("vendor_w9_on_file").default(false),
	vendorW9ReceivedDate: date("vendor_w9_received_date"),
	vendorComplianceStatus: text("vendor_compliance_status"),
	vendorBackgroundCheckCompliant: boolean("vendor_background_check_compliant").default(false),
	vendorDrugTestCompliant: boolean("vendor_drug_test_compliant").default(false),
	vendorQualityRating: numeric("vendor_quality_rating", { precision: 3, scale:  2 }),
	vendorResponseRating: numeric("vendor_response_rating", { precision: 3, scale:  2 }),
	vendorFillRate: numeric("vendor_fill_rate", { precision: 5, scale:  2 }),
	vendorSubmissionsCount: integer("vendor_submissions_count").default(0),
	vendorPlacementsCount: integer("vendor_placements_count").default(0),
	vendorActiveResourcesCount: integer("vendor_active_resources_count").default(0),
	mspProgramName: text("msp_program_name"),
	mspManagedClients: uuid("msp_managed_clients").array(),
	mspOurTierStatus: text("msp_our_tier_status"),
	mspContractStartDate: date("msp_contract_start_date"),
	mspContractEndDate: date("msp_contract_end_date"),
	mspFeePercentage: numeric("msp_fee_percentage", { precision: 5, scale:  2 }),
	vmsPlatformName: text("vms_platform_name"),
	vmsIntegrationStatus: text("vms_integration_status"),
	agencyRelationship: text("agency_relationship"),
	agencyPartnershipType: text("agency_partnership_type"),
	agencyPartnershipAgreement: text("agency_partnership_agreement"),
	agencyDoNotRecruitFrom: boolean("agency_do_not_recruit_from").default(false),
	agencySpecialtyAreas: text("agency_specialty_areas").array(),
	agencyGeographicFocus: text("agency_geographic_focus").array(),
	linkedCompanyId: uuid("linked_company_id"),
	vendorCompanyId: uuid("vendor_company_id"),
	sourceCompanyId: uuid("source_company_id"),
	employerCompanyId: uuid("employer_company_id"),
}, (table) => [
	index("idx_contacts_alumni_employee").using("btree", table.alumniFormerEmployeeId.asc().nullsLast().op("uuid_ops")).where(sql`((subtype = 'person_alumni'::text) AND (deleted_at IS NULL))`),
	index("idx_contacts_auth_id").using("btree", table.authId.asc().nullsLast().op("uuid_ops")).where(sql`(auth_id IS NOT NULL)`),
	index("idx_contacts_bench_status").using("btree", table.benchStatus.asc().nullsLast().op("text_ops")).where(sql`((category = 'person'::text) AND (subtype ~~ 'person_bench_%'::text) AND (deleted_at IS NULL))`),
	index("idx_contacts_candidate_hotlist").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.candidateHotlistAddedAt.desc().nullsFirst().op("uuid_ops")).where(sql`((subtype = 'candidate'::text) AND (candidate_is_on_hotlist = true) AND (deleted_at IS NULL))`),
	index("idx_contacts_candidate_skills").using("gin", table.candidateSkills.asc().nullsLast().op("array_ops")).where(sql`((subtype = 'candidate'::text) AND (deleted_at IS NULL))`),
	index("idx_contacts_candidates").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.candidateStatus.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")).where(sql`((subtype = 'candidate'::text) AND (deleted_at IS NULL))`),
	index("idx_contacts_category").using("btree", table.category.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contacts_category_subtype").using("btree", table.category.asc().nullsLast().op("text_ops"), table.subtype.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contacts_client_contact_company").using("btree", table.clientContactCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`((category = 'person'::text) AND (subtype ~~ 'person_%_contact'::text) AND (deleted_at IS NULL))`),
	index("idx_contacts_client_msp").using("btree", table.clientMspId.asc().nullsLast().op("uuid_ops")).where(sql`((client_msp_id IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_contacts_client_tier").using("btree", table.clientTier.asc().nullsLast().op("text_ops"), table.clientStatus.asc().nullsLast().op("text_ops")).where(sql`((category = 'company'::text) AND (subtype = 'company_client'::text) AND (deleted_at IS NULL))`),
	index("idx_contacts_company_id").using("btree", table.companyId.asc().nullsLast().op("uuid_ops")),
	index("idx_contacts_company_org").using("btree", table.companyId.asc().nullsLast().op("uuid_ops"), table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contacts_company_subtypes").using("btree", table.subtype.asc().nullsLast().op("text_ops")).where(sql`((category = 'company'::text) AND (deleted_at IS NULL))`),
	index("idx_contacts_contact_status").using("btree", table.contactStatus.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contacts_current_company").using("btree", table.currentCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`((current_company_id IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_contacts_email").using("btree", table.email.asc().nullsLast().op("text_ops")),
	index("idx_contacts_employees").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.employeeStatus.asc().nullsLast().op("uuid_ops")).where(sql`((subtype = 'employee'::text) AND (deleted_at IS NULL))`),
	index("idx_contacts_employer_company").using("btree", table.employerCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contacts_engagement").using("btree", table.engagementScore.asc().nullsLast().op("int4_ops")),
	index("idx_contacts_lead_skills_needed").using("gin", table.leadSkillsNeeded.asc().nullsLast().op("array_ops")).where(sql`((subtype = 'lead'::text) AND (deleted_at IS NULL))`),
	index("idx_contacts_leads").using("btree", table.orgId.asc().nullsLast().op("int4_ops"), table.leadStatus.asc().nullsLast().op("uuid_ops"), table.leadScore.desc().nullsFirst().op("text_ops")).where(sql`((subtype = 'lead'::text) AND (deleted_at IS NULL))`),
	index("idx_contacts_linked_company").using("btree", table.linkedCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contacts_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_contacts_owner_id").using("btree", table.ownerId.asc().nullsLast().op("uuid_ops")),
	index("idx_contacts_parent_company").using("btree", table.parentCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`((parent_company_id IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_contacts_placed_client").using("btree", table.placedClientId.asc().nullsLast().op("uuid_ops"), table.placedStatus.asc().nullsLast().op("text_ops")).where(sql`((category = 'person'::text) AND (subtype = 'person_placed'::text) AND (deleted_at IS NULL))`),
	index("idx_contacts_primary_address").using("btree", table.primaryAddressId.asc().nullsLast().op("uuid_ops")).where(sql`(primary_address_id IS NOT NULL)`),
	index("idx_contacts_primary_company").using("btree", table.companyId.asc().nullsLast().op("bool_ops"), table.isPrimary.asc().nullsLast().op("uuid_ops")).where(sql`((is_primary = true) AND (deleted_at IS NULL))`),
	index("idx_contacts_prospects").using("btree", table.orgId.asc().nullsLast().op("int4_ops"), table.prospectSequenceStatus.asc().nullsLast().op("int4_ops"), table.engagementScore.desc().nullsFirst().op("uuid_ops")).where(sql`((subtype = 'prospect'::text) AND (deleted_at IS NULL))`),
	index("idx_contacts_search").using("gin", table.searchVector.asc().nullsLast().op("tsvector_ops")),
	index("idx_contacts_source_company").using("btree", table.sourceCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contacts_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_contacts_subtype").using("btree", table.subtype.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contacts_types").using("gin", table.types.asc().nullsLast().op("array_ops")),
	index("idx_contacts_user_profile_id").using("btree", table.userProfileId.asc().nullsLast().op("uuid_ops")).where(sql`(user_profile_id IS NOT NULL)`),
	index("idx_contacts_vendor_company").using("btree", table.vendorCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contacts_vendor_contact_company").using("btree", table.vendorContactCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`((category = 'person'::text) AND (subtype = 'person_vendor_contact'::text) AND (deleted_at IS NULL))`),
	index("idx_contacts_vendor_status").using("btree", table.vendorStatus.asc().nullsLast().op("text_ops"), table.vendorTier.asc().nullsLast().op("text_ops")).where(sql`((category = 'company'::text) AND (subtype = 'company_vendor'::text) AND (deleted_at IS NULL))`),
	foreignKey({
			columns: [table.alumniFormerEmployeeId],
			foreignColumns: [employees.id],
			name: "contacts_alumni_former_employee_id_fkey"
		}),
	foreignKey({
			columns: [table.benchVendorContactId],
			foreignColumns: [table.id],
			name: "contacts_bench_vendor_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.candidateHotlistAddedBy],
			foreignColumns: [userProfiles.id],
			name: "contacts_candidate_hotlist_added_by_fkey"
		}),
	foreignKey({
			columns: [table.clientContactRelationshipOwnerId],
			foreignColumns: [userProfiles.id],
			name: "contacts_client_contact_relationship_owner_id_fkey"
		}),
	foreignKey({
			columns: [table.clientMspId],
			foreignColumns: [table.id],
			name: "contacts_client_msp_id_fkey"
		}),
	foreignKey({
			columns: [table.clientTeamLeadId],
			foreignColumns: [userProfiles.id],
			name: "contacts_client_team_lead_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "contacts_created_by_fkey"
		}),
	foreignKey({
			columns: [table.currentCompanyId],
			foreignColumns: [table.id],
			name: "contacts_current_company_id_fkey"
		}),
	foreignKey({
			columns: [table.employeeId],
			foreignColumns: [employees.id],
			name: "contacts_employee_id_fkey"
		}),
	foreignKey({
			columns: [table.employerCompanyId],
			foreignColumns: [companies.id],
			name: "contacts_employer_company_id_fkey"
		}),
	foreignKey({
			columns: [table.leadConvertedToDealId],
			foreignColumns: [deals.id],
			name: "contacts_lead_converted_to_deal_id_fkey"
		}),
	foreignKey({
			columns: [table.linkedCompanyId],
			foreignColumns: [companies.id],
			name: "contacts_linked_company_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contacts_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.ownerId],
			foreignColumns: [userProfiles.id],
			name: "contacts_owner_id_fkey"
		}),
	foreignKey({
			columns: [table.parentCompanyId],
			foreignColumns: [table.id],
			name: "contacts_parent_company_id_fkey"
		}),
	foreignKey({
			columns: [table.primaryAddressId],
			foreignColumns: [addresses.id],
			name: "contacts_primary_address_id_fkey"
		}),
	foreignKey({
			columns: [table.prospectPrimaryCampaignId],
			foreignColumns: [campaigns.id],
			name: "contacts_prospect_primary_campaign_id_fkey"
		}),
	foreignKey({
			columns: [table.sourceCompanyId],
			foreignColumns: [companies.id],
			name: "contacts_source_company_id_fkey"
		}),
	foreignKey({
			columns: [table.ultimateParentId],
			foreignColumns: [table.id],
			name: "contacts_ultimate_parent_id_fkey"
		}),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "contacts_updated_by_fkey"
		}),
	foreignKey({
			columns: [table.userProfileId],
			foreignColumns: [userProfiles.id],
			name: "contacts_user_profile_id_fkey"
		}),
	foreignKey({
			columns: [table.vendorApprovedBy],
			foreignColumns: [userProfiles.id],
			name: "contacts_vendor_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.vendorCompanyId],
			foreignColumns: [companies.id],
			name: "contacts_vendor_company_id_fkey"
		}),
	pgPolicy("contacts_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
	check("contacts_agency_relationship_check", sql`(agency_relationship IS NULL) OR (agency_relationship = ANY (ARRAY['partner'::text, 'competitor'::text, 'both'::text]))`),
	check("contacts_bench_type_check", sql`(bench_type IS NULL) OR (bench_type = ANY (ARRAY['w2_internal'::text, 'w2_vendor'::text, '1099'::text, 'c2c'::text]))`),
	check("contacts_candidate_availability_check", sql`(candidate_availability IS NULL) OR (candidate_availability = ANY (ARRAY['immediate'::text, '2_weeks'::text, '1_month'::text, '2_months'::text, '3_months'::text, 'not_available'::text]))`),
	check("contacts_candidate_remote_preference_check", sql`(candidate_remote_preference IS NULL) OR (candidate_remote_preference = ANY (ARRAY['remote'::text, 'hybrid'::text, 'onsite'::text, 'flexible'::text]))`),
	check("contacts_candidate_status_check", sql`(candidate_status IS NULL) OR (candidate_status = ANY (ARRAY['active'::text, 'passive'::text, 'placed'::text, 'bench'::text, 'inactive'::text, 'blacklisted'::text]))`),
	check("contacts_category_check", sql`category = ANY (ARRAY['person'::text, 'company'::text])`),
	check("contacts_category_subtype_consistency", sql`((category = 'person'::text) AND (subtype ~~ 'person_%'::text)) OR ((category = 'company'::text) AND (subtype ~~ 'company_%'::text))`),
	check("contacts_client_relationship_strength_check", sql`(client_contact_relationship_strength IS NULL) OR ((client_contact_relationship_strength >= 1) AND (client_contact_relationship_strength <= 10))`),
	check("contacts_client_status_check", sql`(client_status IS NULL) OR (client_status = ANY (ARRAY['active'::text, 'dormant'::text, 'former'::text, 'blacklisted'::text]))`),
	check("contacts_client_tier_check", sql`(client_tier IS NULL) OR (client_tier = ANY (ARRAY['enterprise'::text, 'strategic'::text, 'growth'::text, 'standard'::text, 'startup'::text]))`),
	check("contacts_company_status_check", sql`(category <> 'company'::text) OR (contact_status = ANY (ARRAY['active'::text, 'inactive'::text, 'pending'::text, 'dormant'::text, 'former'::text, 'blacklisted'::text, 'suspended'::text]))`),
	check("contacts_company_structure_check", sql`(company_structure IS NULL) OR (company_structure = ANY (ARRAY['public'::text, 'private'::text, 'subsidiary'::text, 'franchise'::text]))`),
	check("contacts_company_type_check", sql`(company_type IS NULL) OR (company_type = ANY (ARRAY['corporation'::text, 'llc'::text, 'partnership'::text, 'sole_prop'::text, 'nonprofit'::text]))`),
	check("contacts_employee_status_check", sql`(employee_status IS NULL) OR (employee_status = ANY (ARRAY['active'::text, 'on_leave'::text, 'terminated'::text]))`),
	check("contacts_lead_authority_level_check", sql`(lead_authority_level IS NULL) OR (lead_authority_level = ANY (ARRAY['decision_maker'::text, 'influencer'::text, 'gatekeeper'::text, 'no_authority'::text]))`),
	check("contacts_lead_bant_authority_check", sql`(lead_bant_authority IS NULL) OR ((lead_bant_authority >= 0) AND (lead_bant_authority <= 25))`),
	check("contacts_lead_bant_budget_check", sql`(lead_bant_budget IS NULL) OR ((lead_bant_budget >= 0) AND (lead_bant_budget <= 25))`),
	check("contacts_lead_bant_need_check", sql`(lead_bant_need IS NULL) OR ((lead_bant_need >= 0) AND (lead_bant_need <= 25))`),
	check("contacts_lead_bant_timeline_check", sql`(lead_bant_timeline IS NULL) OR ((lead_bant_timeline >= 0) AND (lead_bant_timeline <= 25))`),
	check("contacts_lead_qualification_result_check", sql`(lead_qualification_result IS NULL) OR (lead_qualification_result = ANY (ARRAY['qualified_convert'::text, 'qualified_nurture'::text, 'not_qualified'::text]))`),
	check("contacts_lead_score_check", sql`(lead_score IS NULL) OR ((lead_score >= 0) AND (lead_score <= 100))`),
	check("contacts_lead_status_check", sql`(lead_status IS NULL) OR (lead_status = ANY (ARRAY['new'::text, 'contacted'::text, 'warm'::text, 'hot'::text, 'cold'::text, 'qualified'::text, 'unqualified'::text, 'converted'::text, 'lost'::text, 'nurture'::text]))`),
	check("contacts_placed_status_check", sql`(placed_status IS NULL) OR (placed_status = ANY (ARRAY['active'::text, 'ending_soon'::text, 'extended'::text, 'completed'::text]))`),
	check("contacts_prospect_response_type_check", sql`(prospect_response_type IS NULL) OR (prospect_response_type = ANY (ARRAY['positive'::text, 'neutral'::text, 'negative'::text, 'auto_reply'::text, 'out_of_office'::text]))`),
	check("contacts_prospect_sequence_status_check", sql`(prospect_sequence_status IS NULL) OR (prospect_sequence_status = ANY (ARRAY['pending'::text, 'in_progress'::text, 'paused'::text, 'completed'::text, 'stopped'::text]))`),
	check("contacts_subtype_check", sql`subtype = ANY (ARRAY['person_prospect'::text, 'person_lead'::text, 'person_candidate'::text, 'person_bench_internal'::text, 'person_bench_vendor'::text, 'person_placed'::text, 'person_client_contact'::text, 'person_hiring_manager'::text, 'person_hr_contact'::text, 'person_vendor_contact'::text, 'person_employee'::text, 'person_referral_source'::text, 'person_alumni'::text, 'company_prospect'::text, 'company_lead'::text, 'company_client'::text, 'company_vendor'::text, 'company_msp'::text, 'company_vms'::text, 'company_end_client'::text, 'company_agency'::text, 'company_institution'::text])`),
	check("contacts_vendor_quality_rating_check", sql`(vendor_contact_quality_rating IS NULL) OR ((vendor_contact_quality_rating >= 1) AND (vendor_contact_quality_rating <= 5))`),
	check("contacts_vendor_response_rating_check", sql`(vendor_contact_response_rating IS NULL) OR ((vendor_contact_response_rating >= 1) AND (vendor_contact_response_rating <= 5))`),
	check("contacts_vendor_status_check", sql`(vendor_status IS NULL) OR (vendor_status = ANY (ARRAY['pending'::text, 'approved'::text, 'preferred'::text, 'suspended'::text, 'blacklisted'::text]))`),
	check("contacts_vendor_tier_check", sql`(vendor_tier IS NULL) OR (vendor_tier = ANY (ARRAY['preferred'::text, 'approved'::text, 'probationary'::text, 'new'::text]))`),
	check("contacts_vms_integration_status_check", sql`(vms_integration_status IS NULL) OR (vms_integration_status = ANY (ARRAY['not_integrated'::text, 'pending'::text, 'active'::text, 'suspended'::text]))`),
]);

export const activityStatsDaily = pgTable("activity_stats_daily", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	userId: uuid("user_id").notNull(),
	date: date().notNull(),
	patternId: uuid("pattern_id"),
	count: integer().default(0),
	totalDurationMinutes: integer("total_duration_minutes").default(0),
	totalPoints: numeric("total_points", { precision: 10, scale:  2 }).default('0'),
	outcomes: jsonb().default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_activity_stats_user_date").using("btree", table.userId.asc().nullsLast().op("date_ops"), table.date.desc().nullsFirst().op("date_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "activity_stats_daily_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.patternId],
			foreignColumns: [activityPatterns.id],
			name: "activity_stats_daily_pattern_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "activity_stats_daily_user_id_fkey"
		}).onDelete("cascade"),
	unique("activity_stats_daily_org_id_user_id_date_pattern_id_key").on(table.orgId, table.userId, table.date, table.patternId),
	pgPolicy("activity_stats_daily_insert_policy", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`true`  }),
	pgPolicy("activity_stats_daily_select_policy", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("activity_stats_daily_update_policy", { as: "permissive", for: "update", to: ["public"] }),
]);

export const notes = pgTable("notes", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	title: varchar({ length: 200 }),
	content: text().notNull(),
	contentHtml: text("content_html"),
	contentPlain: text("content_plain"),
	noteType: noteType("note_type").default('general'),
	parentNoteId: uuid("parent_note_id"),
	threadRootId: uuid("thread_root_id"),
	replyCount: integer("reply_count").default(0),
	visibility: noteVisibility().default('team'),
	isPinned: boolean("is_pinned").default(false),
	isStarred: boolean("is_starred").default(false),
	pinOrder: integer("pin_order"),
	mentionedUserIds: uuid("mentioned_user_ids").array(),
	mentionedContactIds: uuid("mentioned_contact_ids").array(),
	tags: text().array(),
	attachmentCount: integer("attachment_count").default(0),
	// TODO: failed to parse database type 'tsvector'
	searchVector: unknown("search_vector"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by").notNull(),
	updatedBy: uuid("updated_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_notes_creator").using("btree", table.createdBy.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_notes_entity").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_notes_mentions_users").using("gin", table.mentionedUserIds.asc().nullsLast().op("array_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_notes_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_notes_parent").using("btree", table.parentNoteId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_notes_pinned").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("text_ops"), table.pinOrder.asc().nullsLast().op("text_ops")).where(sql`((is_pinned = true) AND (deleted_at IS NULL))`),
	index("idx_notes_search").using("gin", table.searchVector.asc().nullsLast().op("tsvector_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_notes_thread").using("btree", table.threadRootId.asc().nullsLast().op("uuid_ops"), table.createdAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "notes_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "notes_org_id_fkey"
		}),
	foreignKey({
			columns: [table.parentNoteId],
			foreignColumns: [table.id],
			name: "notes_parent_note_id_fkey"
		}),
	foreignKey({
			columns: [table.threadRootId],
			foreignColumns: [table.id],
			name: "notes_thread_root_id_fkey"
		}),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "notes_updated_by_fkey"
		}),
	pgPolicy("notes_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	pgPolicy("notes_select_visibility", { as: "permissive", for: "select", to: ["public"] }),
	check("notes_content_not_empty", sql`(content IS NOT NULL) AND (content <> ''::text)`),
]);

export const patternFields = pgTable("pattern_fields", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	patternId: uuid("pattern_id").notNull(),
	fieldName: text("field_name").notNull(),
	fieldLabel: text("field_label").notNull(),
	fieldType: text("field_type").notNull(),
	isRequired: boolean("is_required").default(false),
	defaultValue: text("default_value"),
	validationRules: jsonb("validation_rules"),
	orderIndex: integer("order_index").default(0),
	placeholder: text(),
	helpText: text("help_text"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	options: jsonb().default([]),
}, (table) => [
	foreignKey({
			columns: [table.patternId],
			foreignColumns: [activityPatterns.id],
			name: "pattern_fields_pattern_id_fkey"
		}).onDelete("cascade"),
	unique("pattern_fields_pattern_id_field_name_key").on(table.patternId, table.fieldName),
]);

export const activityPatterns = pgTable("activity_patterns", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id"),
	code: text().notNull(),
	name: text().notNull(),
	description: text(),
	targetDays: integer("target_days").default(1).notNull(),
	escalationDays: integer("escalation_days").default(3).notNull(),
	defaultAssignee: text("default_assignee").default('owner'),
	assigneeGroupId: uuid("assignee_group_id"),
	assigneeUserId: uuid("assignee_user_id"),
	priority: text().default('normal'),
	autoComplete: boolean("auto_complete").default(false),
	autoCompleteCondition: jsonb("auto_complete_condition"),
	autoAction: text("auto_action"),
	autoActionConfig: jsonb("auto_action_config"),
	category: text(),
	entityType: text("entity_type").notNull(),
	instructions: text(),
	isSystem: boolean("is_system").default(false),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	icon: text().default(''),
	color: text().default('blue'),
	displayOrder: integer("display_order").default(100),
	showInTimeline: boolean("show_in_timeline").default(true),
	outcomes: jsonb().default([]),
	points: numeric({ precision: 5, scale:  2 }).default('0'),
	pointMultipliers: jsonb("point_multipliers").default([]),
	autoLogIntegrations: text("auto_log_integrations").array().default([""]),
	followupRules: jsonb("followup_rules").default([]),
	fieldDependencies: jsonb("field_dependencies").default([]),
	createdBy: uuid("created_by"),
	isBlocking: boolean("is_blocking").default(false),
	blockingStatuses: jsonb("blocking_statuses").default([]),
}, (table) => [
	index("activity_patterns_entity_type_idx").using("btree", table.entityType.asc().nullsLast().op("text_ops")),
	index("idx_activity_patterns_category").using("btree", table.orgId.asc().nullsLast().op("bool_ops"), table.category.asc().nullsLast().op("text_ops"), table.isActive.asc().nullsLast().op("uuid_ops")),
	index("idx_activity_patterns_display").using("btree", table.orgId.asc().nullsLast().op("int4_ops"), table.category.asc().nullsLast().op("text_ops"), table.displayOrder.asc().nullsLast().op("text_ops")),
	index("idx_activity_patterns_entity").using("btree", table.entityType.asc().nullsLast().op("bool_ops"), table.isActive.asc().nullsLast().op("text_ops")),
	index("idx_activity_patterns_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(org_id IS NOT NULL)`),
	foreignKey({
			columns: [table.assigneeGroupId],
			foreignColumns: [pods.id],
			name: "activity_patterns_assignee_group_id_fkey"
		}),
	foreignKey({
			columns: [table.assigneeUserId],
			foreignColumns: [userProfiles.id],
			name: "activity_patterns_assignee_user_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "activity_patterns_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "activity_patterns_org_id_fkey"
		}).onDelete("cascade"),
	unique("activity_patterns_org_id_code_key").on(table.orgId, table.code),
]);

export const featureFlagUsage = pgTable("feature_flag_usage", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	featureFlagId: uuid("feature_flag_id").notNull(),
	userId: uuid("user_id").notNull(),
	sessionId: text("session_id"),
	checkedAt: timestamp("checked_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	wasEnabled: boolean("was_enabled").notNull(),
	context: jsonb().default({}),
}, (table) => [
	index("idx_feature_flag_usage_flag").using("btree", table.featureFlagId.asc().nullsLast().op("timestamptz_ops"), table.checkedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_feature_flag_usage_org").using("btree", table.orgId.asc().nullsLast().op("timestamptz_ops"), table.checkedAt.desc().nullsFirst().op("uuid_ops")),
	index("idx_feature_flag_usage_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops"), table.checkedAt.desc().nullsFirst().op("timestamptz_ops")),
	foreignKey({
			columns: [table.featureFlagId],
			foreignColumns: [featureFlags.id],
			name: "feature_flag_usage_feature_flag_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "feature_flag_usage_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "feature_flag_usage_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("feature_flag_usage_insert", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(user_id = auth.uid())`  }),
	pgPolicy("feature_flag_usage_select", { as: "permissive", for: "select", to: ["public"] }),
]);

export const featureFlagFeedback = pgTable("feature_flag_feedback", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	featureFlagId: uuid("feature_flag_id").notNull(),
	userId: uuid("user_id").notNull(),
	rating: integer(),
	feedbackText: text("feedback_text"),
	submittedAt: timestamp("submitted_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_feature_flag_feedback_flag").using("btree", table.featureFlagId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.featureFlagId],
			foreignColumns: [featureFlags.id],
			name: "feature_flag_feedback_feature_flag_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "feature_flag_feedback_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "feature_flag_feedback_user_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("feature_flag_feedback_insert", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(user_id = auth.uid())`  }),
	pgPolicy("feature_flag_feedback_select", { as: "permissive", for: "select", to: ["public"] }),
	check("feature_flag_feedback_rating_check", sql`(rating >= 1) AND (rating <= 5)`),
]);

export const featureFlagCategories = pgTable("feature_flag_categories", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id"),
	name: text().notNull(),
	displayOrder: integer("display_order").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "feature_flag_categories_org_id_fkey"
		}).onDelete("cascade"),
	unique("feature_flag_categories_org_id_name_key").on(table.orgId, table.name),
	pgPolicy("feature_flag_categories_select", { as: "permissive", for: "select", to: ["public"], using: sql`((org_id IS NULL) OR (org_id = COALESCE(( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())), ((auth.jwt() ->> 'org_id'::text))::uuid)))` }),
]);

export const featureFlags = pgTable("feature_flags", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id"),
	key: varchar({ length: 100 }).notNull(),
	name: varchar({ length: 100 }).notNull(),
	description: text(),
	defaultEnabled: boolean("default_enabled").default(false),
	isGlobal: boolean("is_global").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	state: text().default('disabled').notNull(),
	rolloutStrategy: text("rollout_strategy").default('none').notNull(),
	rolloutPercentage: integer("rollout_percentage").default(0),
	enabledUsers: uuid("enabled_users").array().default([""]),
	enabledPods: uuid("enabled_pods").array().default([""]),
	enabledRoles: uuid("enabled_roles").array().default([""]),
	category: text(),
	showInNav: boolean("show_in_nav").default(true),
	showNewBadge: boolean("show_new_badge").default(false),
	showBetaBadge: boolean("show_beta_badge").default(false),
	logUsage: boolean("log_usage").default(true),
	showFeedbackPrompt: boolean("show_feedback_prompt").default(false),
	rolloutSchedule: jsonb("rollout_schedule").default([]),
	safeguards: jsonb().default({}),
	metadata: jsonb().default({}),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
}, (table) => [
	index("idx_feature_flags_code").using("btree", table.key.asc().nullsLast().op("text_ops")),
	index("idx_feature_flags_enabled_pods").using("gin", table.enabledPods.asc().nullsLast().op("array_ops")),
	index("idx_feature_flags_enabled_roles").using("gin", table.enabledRoles.asc().nullsLast().op("array_ops")),
	index("idx_feature_flags_enabled_users").using("gin", table.enabledUsers.asc().nullsLast().op("array_ops")),
	index("idx_feature_flags_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_feature_flags_org_key").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.key.asc().nullsLast().op("uuid_ops")),
	index("idx_feature_flags_org_state").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.state.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "feature_flags_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "feature_flags_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "feature_flags_updated_by_fkey"
		}),
	unique("feature_flags_org_id_code_key").on(table.orgId, table.key),
	pgPolicy("feature_flags_access", { as: "permissive", for: "select", to: ["public"], using: sql`((is_global = true) OR (org_id IS NULL) OR (org_id = COALESCE(( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())), ((auth.jwt() ->> 'org_id'::text))::uuid)))` }),
	pgPolicy("feature_flags_org_delete", { as: "permissive", for: "delete", to: ["public"] }),
	pgPolicy("feature_flags_org_update", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("feature_flags_org_write", { as: "permissive", for: "insert", to: ["public"] }),
	check("feature_flags_rollout_percentage_check", sql`(rollout_percentage >= 0) AND (rollout_percentage <= 100)`),
	check("feature_flags_rollout_strategy_check", sql`rollout_strategy = ANY (ARRAY['all'::text, 'roles'::text, 'users'::text, 'percentage'::text, 'pods'::text, 'none'::text])`),
	check("feature_flags_state_check", sql`state = ANY (ARRAY['enabled'::text, 'disabled'::text, 'beta'::text, 'internal'::text, 'percentage'::text, 'coming_soon'::text])`),
]);

export const jobStatusHistory = pgTable("job_status_history", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	jobId: uuid("job_id").notNull(),
	previousStatus: text("previous_status"),
	newStatus: text("new_status").notNull(),
	changedBy: uuid("changed_by").notNull(),
	changedAt: timestamp("changed_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	reason: text(),
	notes: text(),
	isSystemTriggered: boolean("is_system_triggered").default(false),
	expectedReactivationDate: date("expected_reactivation_date"),
	actualReactivationDate: date("actual_reactivation_date"),
	holdDurationDays: integer("hold_duration_days"),
	daysToFill: integer("days_to_fill"),
	positionsFilledCount: integer("positions_filled_count"),
	candidatesAffectedCount: integer("candidates_affected_count"),
	interviewsCancelledCount: integer("interviews_cancelled_count"),
	offersWithdrawnCount: integer("offers_withdrawn_count"),
	reopenApprovedBy: uuid("reopen_approved_by"),
	reopenApprovalDate: timestamp("reopen_approval_date", { withTimezone: true, mode: 'string' }),
	metadata: jsonb().default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_job_status_history_job_id").using("btree", table.jobId.asc().nullsLast().op("uuid_ops")),
	index("idx_job_status_history_new_status").using("btree", table.newStatus.asc().nullsLast().op("text_ops")),
	index("idx_job_status_history_org_changed_at").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.changedAt.desc().nullsFirst().op("timestamptz_ops")),
	foreignKey({
			columns: [table.changedBy],
			foreignColumns: [userProfiles.id],
			name: "job_status_history_changed_by_fkey"
		}),
	foreignKey({
			columns: [table.jobId],
			foreignColumns: [jobs.id],
			name: "job_status_history_job_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "job_status_history_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.reopenApprovedBy],
			foreignColumns: [userProfiles.id],
			name: "job_status_history_reopen_approved_by_fkey"
		}),
	pgPolicy("Users can insert job status history in their org", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(org_id = ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())))`  }),
	pgPolicy("Users can view job status history in their org", { as: "permissive", for: "select", to: ["public"] }),
]);

export const organizations = pgTable("organizations", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	name: text().notNull(),
	slug: text().notNull(),
	legalName: text("legal_name"),
	email: text(),
	phone: text(),
	website: text(),
	billingEmail: text("billing_email"),
	taxId: text("tax_id"),
	subscriptionTier: text("subscription_tier").default('free').notNull(),
	subscriptionStatus: text("subscription_status").default('active').notNull(),
	maxUsers: integer("max_users").default(5),
	maxCandidates: integer("max_candidates").default(100),
	maxStorageGb: integer("max_storage_gb").default(10),
	features: jsonb().default({}),
	settings: jsonb().default({}),
	status: text().default('active').notNull(),
	onboardingCompleted: boolean("onboarding_completed").default(false),
	onboardingStep: text("onboarding_step"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	timezone: text().default('America/New_York'),
	locale: text().default('en-US'),
	logoUrl: text("logo_url"),
	faviconUrl: text("favicon_url"),
	plan: text().default('free'),
	metadata: jsonb().default({}),
	stripeCouponId: text("stripe_coupon_id"),
	stripeCustomerId: text("stripe_customer_id"),
	tier: text().default('starter'),
	industry: text(),
	healthScore: integer("health_score"),
	businessHoursStart: time("business_hours_start").default('09:00:00'),
	businessHoursEnd: time("business_hours_end").default('17:00:00'),
	businessTimezone: text("business_timezone").default('America/New_York'),
	holidayCalendar: jsonb("holiday_calendar").default([]),
	companySize: text("company_size"),
	foundedYear: integer("founded_year"),
	primaryColor: text("primary_color").default('#000000'),
	secondaryColor: text("secondary_color").default('#B76E79'),
	backgroundColor: text("background_color").default('#FDFBF7'),
	textColor: text("text_color").default('#171717'),
	dateFormat: text("date_format").default('MM/DD/YYYY'),
	timeFormat: text("time_format").default('12h'),
	weekStart: text("week_start").default('sunday'),
	currency: text().default('USD'),
	numberFormat: text("number_format").default('1,234.56'),
	fiscalYearStart: integer("fiscal_year_start").default(1),
	reportingPeriod: text("reporting_period").default('quarterly'),
	sprintAlignment: boolean("sprint_alignment").default(true),
	businessHours: jsonb("business_hours").default({"friday":{"end":"17:00","open":true,"start":"09:00","break_minutes":60},"monday":{"end":"17:00","open":true,"start":"09:00","break_minutes":60},"sunday":{"open":false},"tuesday":{"end":"17:00","open":true,"start":"09:00","break_minutes":60},"saturday":{"open":false},"thursday":{"end":"17:00","open":true,"start":"09:00","break_minutes":60},"wednesday":{"end":"17:00","open":true,"start":"09:00","break_minutes":60}}),
	customHolidays: jsonb("custom_holidays").default([]),
	defaultValues: jsonb("default_values").default({"job_type":"contract","job_status":"draft","work_location":"hybrid","follow_up_days":3,"candidate_source":"direct_application","auto_parse_resume":true,"submission_status":"pending_review","auto_create_followup":true,"auto_send_client_email":false,"candidate_availability":"2_weeks","email_signature_location":"below","include_company_disclaimer":true}),
	contactInfo: jsonb("contact_info").default({"fax":null,"hr_email":null,"main_phone":null,"linkedin_url":null,"billing_email":null,"general_email":null,"support_email":null,"twitter_handle":null}),
}, (table) => [
	index("idx_organizations_deleted_at").using("btree", table.deletedAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_organizations_email").using("btree", table.email.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_organizations_industry").using("btree", table.industry.asc().nullsLast().op("text_ops")),
	index("idx_organizations_slug").using("btree", table.slug.asc().nullsLast().op("text_ops")),
	index("idx_organizations_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_organizations_stripe_customer").using("btree", table.stripeCustomerId.asc().nullsLast().op("text_ops")).where(sql`(stripe_customer_id IS NOT NULL)`),
	index("idx_organizations_subscription_tier").using("btree", table.subscriptionTier.asc().nullsLast().op("text_ops")),
	index("idx_organizations_timezone").using("btree", table.timezone.asc().nullsLast().op("text_ops")),
	unique("organizations_slug_key").on(table.slug),
	pgPolicy("Authenticated users can view active organizations", { as: "permissive", for: "select", to: ["public"], using: sql`((status = 'active'::text) AND (deleted_at IS NULL) AND ((id = auth_user_org_id()) OR user_is_admin()))` }),
	pgPolicy("Only admins can create organizations", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("Only admins can delete organizations", { as: "permissive", for: "delete", to: ["public"] }),
	pgPolicy("Only admins can update organizations", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("Service role can create organizations", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("Users can view their own organization", { as: "permissive", for: "select", to: ["public"] }),
	check("chk_background_color", sql`(background_color IS NULL) OR (background_color ~ '^#[0-9A-Fa-f]{6}$'::text)`),
	check("chk_fiscal_year_start", sql`(fiscal_year_start >= 1) AND (fiscal_year_start <= 12)`),
	check("chk_primary_color", sql`(primary_color IS NULL) OR (primary_color ~ '^#[0-9A-Fa-f]{6}$'::text)`),
	check("chk_secondary_color", sql`(secondary_color IS NULL) OR (secondary_color ~ '^#[0-9A-Fa-f]{6}$'::text)`),
	check("chk_text_color", sql`(text_color IS NULL) OR (text_color ~ '^#[0-9A-Fa-f]{6}$'::text)`),
]);

export const savedSearches = pgTable("saved_searches", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	userId: uuid("user_id").notNull(),
	entityType: text("entity_type").default('candidate').notNull(),
	name: text().notNull(),
	description: text(),
	filters: jsonb().default({}).notNull(),
	isDefault: boolean("is_default").default(false),
	isShared: boolean("is_shared").default(false),
	emailAlerts: boolean("email_alerts").default(false),
	alertFrequency: text("alert_frequency").default('daily'),
	resultCount: integer("result_count"),
	lastExecutedAt: timestamp("last_executed_at", { withTimezone: true, mode: 'string' }),
	executionCount: integer("execution_count").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_saved_searches_default").using("btree", table.userId.asc().nullsLast().op("text_ops"), table.entityType.asc().nullsLast().op("uuid_ops"), table.isDefault.asc().nullsLast().op("uuid_ops")).where(sql`((is_default = true) AND (deleted_at IS NULL))`),
	index("idx_saved_searches_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_saved_searches_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_saved_searches_shared").using("btree", table.orgId.asc().nullsLast().op("bool_ops"), table.entityType.asc().nullsLast().op("uuid_ops"), table.isShared.asc().nullsLast().op("uuid_ops")).where(sql`((is_shared = true) AND (deleted_at IS NULL))`),
	index("idx_saved_searches_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "saved_searches_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "saved_searches_user_id_fkey"
		}).onDelete("cascade"),
	unique("saved_searches_unique_name").on(table.orgId, table.userId, table.entityType, table.name),
	pgPolicy("saved_searches_delete_policy", { as: "permissive", for: "delete", to: ["public"], using: sql`((org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid()))) AND (user_id = auth.uid()))` }),
	pgPolicy("saved_searches_insert_policy", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("saved_searches_select_policy", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("saved_searches_update_policy", { as: "permissive", for: "update", to: ["public"] }),
]);

export const candidatePreparedProfiles = pgTable("candidate_prepared_profiles", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	jobId: uuid("job_id"),
	templateType: text("template_type").default('standard').notNull(),
	summary: text(),
	keyHighlights: text("key_highlights").array(),
	skillsMatrix: jsonb("skills_matrix"),
	experienceSummary: jsonb("experience_summary"),
	whyThisCandidate: text("why_this_candidate"),
	education: jsonb(),
	status: text().default('draft').notNull(),
	finalizedAt: timestamp("finalized_at", { withTimezone: true, mode: 'string' }),
	finalizedBy: uuid("finalized_by"),
	pdfUrl: text("pdf_url"),
	docxUrl: text("docx_url"),
	lastExportedAt: timestamp("last_exported_at", { withTimezone: true, mode: 'string' }),
	createdBy: uuid("created_by").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_candidate_prepared_profiles_candidate").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_candidate_prepared_profiles_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_candidate_prepared_profiles_job").using("btree", table.jobId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "candidate_prepared_profiles_candidate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidate_prepared_profiles_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "candidate_prepared_profiles_created_by_fkey"
		}),
	foreignKey({
			columns: [table.finalizedBy],
			foreignColumns: [userProfiles.id],
			name: "candidate_prepared_profiles_finalized_by_fkey"
		}),
	foreignKey({
			columns: [table.jobId],
			foreignColumns: [jobs.id],
			name: "candidate_prepared_profiles_job_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "candidate_prepared_profiles_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("candidate_prepared_profiles_org_access", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())))` }),
]);

export const candidateScreenings = pgTable("candidate_screenings", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	jobId: uuid("job_id"),
	submissionId: uuid("submission_id"),
	screenerId: uuid("screener_id").notNull(),
	status: text().default('in_progress').notNull(),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	durationMinutes: integer("duration_minutes"),
	knockoutPassed: boolean("knockout_passed"),
	knockoutAnswers: jsonb("knockout_answers").default([]),
	technicalScores: jsonb("technical_scores").default({}),
	technicalOverall: numeric("technical_overall", { precision: 3, scale:  2 }),
	projectDiscussion: jsonb("project_discussion"),
	softSkillsScores: jsonb("soft_skills_scores").default({}),
	softSkillsOverall: numeric("soft_skills_overall", { precision: 3, scale:  2 }),
	cultureFitScore: numeric("culture_fit_score", { precision: 3, scale:  2 }),
	interestLevel: text("interest_level"),
	motivationNotes: jsonb("motivation_notes"),
	overallScore: numeric("overall_score", { precision: 3, scale:  2 }),
	recommendation: text().default('hold').notNull(),
	strengths: text().array(),
	concerns: text().array(),
	interviewPrepNotes: text("interview_prep_notes"),
	compensationDiscussion: jsonb("compensation_discussion"),
	nextSteps: jsonb("next_steps").default([]),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_candidate_screenings_candidate").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_candidate_screenings_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_candidate_screenings_job").using("btree", table.jobId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_candidate_screenings_recommendation").using("btree", table.recommendation.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_candidate_screenings_screener").using("btree", table.screenerId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_candidate_screenings_status").using("btree", table.status.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "candidate_screenings_candidate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "candidate_screenings_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.jobId],
			foreignColumns: [jobs.id],
			name: "candidate_screenings_job_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "candidate_screenings_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.screenerId],
			foreignColumns: [userProfiles.id],
			name: "candidate_screenings_screener_id_fkey"
		}),
	foreignKey({
			columns: [table.submissionId],
			foreignColumns: [submissions.id],
			name: "candidate_screenings_submission_id_fkey"
		}).onDelete("set null"),
	pgPolicy("candidate_screenings_org_access", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.id = auth.uid())))` }),
]);

export const contactRelationships = pgTable("contact_relationships", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	sourceContactId: uuid("source_contact_id").notNull(),
	targetContactId: uuid("target_contact_id").notNull(),
	relationshipType: text("relationship_type").notNull(),
	titleAtCompany: text("title_at_company"),
	departmentAtCompany: text("department_at_company"),
	startDate: date("start_date"),
	endDate: date("end_date"),
	isCurrent: boolean("is_current").default(false),
	relationshipStrength: integer("relationship_strength"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_contact_relationships_current").using("btree", table.sourceContactId.asc().nullsLast().op("uuid_ops"), table.isCurrent.asc().nullsLast().op("uuid_ops")).where(sql`((is_current = true) AND (deleted_at IS NULL))`),
	index("idx_contact_relationships_source").using("btree", table.sourceContactId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contact_relationships_target").using("btree", table.targetContactId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contact_relationships_type").using("btree", table.relationshipType.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "contact_relationships_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contact_relationships_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.sourceContactId],
			foreignColumns: [contacts.id],
			name: "contact_relationships_source_contact_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.targetContactId],
			foreignColumns: [contacts.id],
			name: "contact_relationships_target_contact_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "contact_relationships_updated_by_fkey"
		}),
	unique("contact_relationships_unique").on(table.sourceContactId, table.targetContactId, table.relationshipType),
	pgPolicy("contact_relationships_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
	check("contact_relationships_strength_check", sql`(relationship_strength IS NULL) OR ((relationship_strength >= 1) AND (relationship_strength <= 10))`),
	check("contact_relationships_type_check", sql`relationship_type = ANY (ARRAY['works_at'::text, 'worked_at'::text, 'owns'::text, 'founded'::text, 'board_member'::text, 'reports_to'::text, 'manages'::text, 'referred_by'::text, 'knows'::text, 'mentors'::text, 'spouse_of'::text])`),
]);

export const contactRoles = pgTable("contact_roles", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	contactId: uuid("contact_id").notNull(),
	roleType: text("role_type").notNull(),
	roleStatus: text("role_status").default('active').notNull(),
	contextCompanyId: uuid("context_company_id"),
	contextDetails: jsonb("context_details").default({}),
	roleStartedAt: timestamp("role_started_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	roleEndedAt: timestamp("role_ended_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_contact_roles_active").using("btree", table.contactId.asc().nullsLast().op("text_ops"), table.roleType.asc().nullsLast().op("uuid_ops")).where(sql`((role_status = 'active'::text) AND (role_ended_at IS NULL) AND (deleted_at IS NULL))`),
	index("idx_contact_roles_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contact_roles_type").using("btree", table.roleType.asc().nullsLast().op("text_ops"), table.roleStatus.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "contact_roles_contact_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contextCompanyId],
			foreignColumns: [contacts.id],
			name: "contact_roles_context_company_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "contact_roles_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contact_roles_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("contact_roles_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
	check("contact_roles_status_check", sql`role_status = ANY (ARRAY['active'::text, 'inactive'::text, 'pending'::text, 'suspended'::text])`),
	check("contact_roles_type_check", sql`role_type = ANY (ARRAY['candidate'::text, 'employee'::text, 'client_contact'::text, 'hiring_manager'::text, 'hr_contact'::text, 'vendor_contact'::text, 'bench_internal'::text, 'bench_vendor'::text, 'placed'::text, 'referral_source'::text, 'alumni'::text])`),
]);

export const offers = pgTable("offers", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	submissionId: uuid("submission_id").notNull(),
	jobId: uuid("job_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	offerType: text("offer_type").default('contract'),
	rate: numeric({ precision: 10, scale:  2 }).notNull(),
	rateType: text("rate_type").default('hourly'),
	startDate: date("start_date"),
	endDate: date("end_date"),
	bonus: numeric({ precision: 10, scale:  2 }),
	benefits: text(),
	relocationAssistance: boolean("relocation_assistance").default(false),
	signOnBonus: numeric("sign_on_bonus", { precision: 10, scale:  2 }),
	status: text().default('draft').notNull(),
	sentAt: timestamp("sent_at", { withTimezone: true, mode: 'string' }),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }),
	candidateCounterOffer: numeric("candidate_counter_offer", { precision: 10, scale:  2 }),
	negotiationNotes: text("negotiation_notes"),
	acceptedAt: timestamp("accepted_at", { withTimezone: true, mode: 'string' }),
	declinedAt: timestamp("declined_at", { withTimezone: true, mode: 'string' }),
	declineReason: text("decline_reason"),
	offerLetterFileId: uuid("offer_letter_file_id"),
	signedOfferFileId: uuid("signed_offer_file_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	orgId: uuid("org_id").notNull(),
	payRate: numeric("pay_rate", { precision: 10, scale:  2 }),
	billRate: numeric("bill_rate", { precision: 10, scale:  2 }),
	overtimeRate: numeric("overtime_rate", { precision: 10, scale:  2 }),
	durationMonths: integer("duration_months"),
	employmentType: varchar("employment_type", { length: 20 }).default('w2'),
	ptoDays: integer("pto_days"),
	sickDays: integer("sick_days"),
	healthInsurance: boolean("health_insurance").default(false),
	has401K: boolean("has_401k").default(false),
	workLocation: varchar("work_location", { length: 20 }).default('remote'),
	standardHoursPerWeek: integer("standard_hours_per_week").default(40),
	internalNotes: text("internal_notes"),
	sentBy: uuid("sent_by"),
	acceptedBy: uuid("accepted_by"),
	withdrawnAt: timestamp("withdrawn_at", { withTimezone: true, mode: 'string' }),
	withdrawalReason: text("withdrawal_reason"),
}, (table) => [
	index("idx_offers_bill_rate").using("btree", table.billRate.asc().nullsLast().op("numeric_ops")),
	index("idx_offers_candidate").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")),
	index("idx_offers_employment_type").using("btree", table.employmentType.asc().nullsLast().op("text_ops")),
	index("idx_offers_expires").using("btree", table.expiresAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_offers_job").using("btree", table.jobId.asc().nullsLast().op("uuid_ops")),
	index("idx_offers_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_offers_pay_rate").using("btree", table.payRate.asc().nullsLast().op("numeric_ops")),
	index("idx_offers_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_offers_submission").using("btree", table.submissionId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.acceptedBy],
			foreignColumns: [userProfiles.id],
			name: "offers_accepted_by_fkey"
		}),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "offers_candidate_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "offers_created_by_fkey"
		}),
	foreignKey({
			columns: [table.jobId],
			foreignColumns: [jobs.id],
			name: "offers_job_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "offers_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.sentBy],
			foreignColumns: [userProfiles.id],
			name: "offers_sent_by_fkey"
		}),
	foreignKey({
			columns: [table.submissionId],
			foreignColumns: [submissions.id],
			name: "offers_submission_id_fkey"
		}),
	pgPolicy("Users can manage offers in their organization", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid())))` }),
	pgPolicy("Users can view offers in their organization", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("offers_candidate_own", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("offers_employee_all", { as: "permissive", for: "all", to: ["public"] }),
	check("offers_employment_type_check", sql`(employment_type)::text = ANY ((ARRAY['w2'::character varying, 'c2c'::character varying, '1099'::character varying])::text[])`),
	check("offers_work_location_check", sql`(work_location)::text = ANY ((ARRAY['remote'::character varying, 'onsite'::character varying, 'hybrid'::character varying])::text[])`),
]);

export const offerNegotiations = pgTable("offer_negotiations", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	offerId: uuid("offer_id").notNull(),
	requestedBy: text("requested_by").notNull(),
	requestedChanges: text("requested_changes"),
	status: text().default('pending').notNull(),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	initiatedBy: varchar("initiated_by", { length: 20 }),
	originalTerms: jsonb("original_terms"),
	proposedTerms: jsonb("proposed_terms"),
	counterMessage: text("counter_message"),
}, (table) => [
	index("idx_offer_negotiations_offer_id").using("btree", table.offerId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.offerId],
			foreignColumns: [offers.id],
			name: "offer_negotiations_offer_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "offer_negotiations_org_id_fkey"
		}).onDelete("cascade"),
	check("offer_negotiations_initiated_by_check", sql`(initiated_by)::text = ANY ((ARRAY['candidate'::character varying, 'client'::character varying, 'recruiter'::character varying])::text[])`),
]);

export const offerApprovals = pgTable("offer_approvals", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	offerId: uuid("offer_id").notNull(),
	approverId: uuid("approver_id").notNull(),
	status: text().default('pending').notNull(),
	notes: text(),
	decidedAt: timestamp("decided_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	approvalType: varchar("approval_type", { length: 30 }),
	requestedBy: uuid("requested_by"),
	requestNotes: text("request_notes"),
	proposedChanges: jsonb("proposed_changes"),
	respondedAt: timestamp("responded_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_offer_approvals_approver_id").using("btree", table.approverId.asc().nullsLast().op("uuid_ops")),
	index("idx_offer_approvals_offer_id").using("btree", table.offerId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.approverId],
			foreignColumns: [userProfiles.id],
			name: "offer_approvals_approver_id_fkey"
		}),
	foreignKey({
			columns: [table.offerId],
			foreignColumns: [offers.id],
			name: "offer_approvals_offer_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "offer_approvals_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.requestedBy],
			foreignColumns: [userProfiles.id],
			name: "offer_approvals_requested_by_fkey"
		}),
	check("offer_approvals_approval_type_check", sql`(approval_type)::text = ANY ((ARRAY['rate_change'::character varying, 'terms_change'::character varying, 'low_margin'::character varying, 'extension'::character varying])::text[])`),
]);

export const contactSkills = pgTable("contact_skills", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	contactId: uuid("contact_id").notNull(),
	skillId: uuid("skill_id"),
	skillName: text("skill_name").notNull(),
	skillCategory: text("skill_category"),
	proficiencyLevel: integer("proficiency_level").default(3),
	yearsExperience: numeric("years_experience", { precision: 4, scale:  1 }),
	lastUsedDate: date("last_used_date"),
	isPrimary: boolean("is_primary").default(false),
	isVerified: boolean("is_verified").default(false),
	verifiedBy: uuid("verified_by"),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	verificationMethod: text("verification_method"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_contact_skills_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contact_skills_name").using("btree", table.skillName.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contact_skills_primary").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`((is_primary = true) AND (deleted_at IS NULL))`),
	index("idx_contact_skills_skill").using("btree", table.skillId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "contact_skills_contact_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contact_skills_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.skillId],
			foreignColumns: [skills.id],
			name: "contact_skills_skill_id_fkey"
		}),
	foreignKey({
			columns: [table.verifiedBy],
			foreignColumns: [userProfiles.id],
			name: "contact_skills_verified_by_fkey"
		}),
	pgPolicy("contact_skills_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
	check("contact_skills_proficiency_check", sql`(proficiency_level >= 1) AND (proficiency_level <= 5)`),
]);

export const contactWorkHistory = pgTable("contact_work_history", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	contactId: uuid("contact_id").notNull(),
	companyName: text("company_name").notNull(),
	companyContactId: uuid("company_contact_id"),
	title: text().notNull(),
	department: text(),
	employmentType: text("employment_type"),
	startDate: date("start_date").notNull(),
	endDate: date("end_date"),
	isCurrent: boolean("is_current").default(false),
	description: text(),
	achievements: text().array(),
	reasonForLeaving: text("reason_for_leaving"),
	managerName: text("manager_name"),
	managerContact: text("manager_contact"),
	location: text(),
	isRemote: boolean("is_remote").default(false),
	isVerified: boolean("is_verified").default(false),
	verifiedBy: uuid("verified_by"),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	displayOrder: integer("display_order").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_contact_work_history_company").using("btree", table.companyContactId.asc().nullsLast().op("uuid_ops")).where(sql`((company_contact_id IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_contact_work_history_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contact_work_history_current").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`((is_current = true) AND (deleted_at IS NULL))`),
	foreignKey({
			columns: [table.companyContactId],
			foreignColumns: [contacts.id],
			name: "contact_work_history_company_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "contact_work_history_contact_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contact_work_history_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.verifiedBy],
			foreignColumns: [userProfiles.id],
			name: "contact_work_history_verified_by_fkey"
		}),
	pgPolicy("contact_work_history_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
]);

export const contactEducation = pgTable("contact_education", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	contactId: uuid("contact_id").notNull(),
	institutionName: text("institution_name").notNull(),
	institutionType: text("institution_type"),
	degreeType: text("degree_type"),
	fieldOfStudy: text("field_of_study"),
	major: text(),
	minor: text(),
	startDate: date("start_date"),
	endDate: date("end_date"),
	graduationDate: date("graduation_date"),
	isCompleted: boolean("is_completed").default(false),
	gpa: numeric({ precision: 4, scale:  2 }),
	gpaScale: numeric("gpa_scale", { precision: 3, scale:  1 }).default('4.0'),
	honors: text(),
	activities: text(),
	achievements: text().array(),
	isVerified: boolean("is_verified").default(false),
	verifiedBy: uuid("verified_by"),
	displayOrder: integer("display_order").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_contact_education_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "contact_education_contact_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contact_education_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.verifiedBy],
			foreignColumns: [userProfiles.id],
			name: "contact_education_verified_by_fkey"
		}),
	pgPolicy("contact_education_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
]);

export const contactCertifications = pgTable("contact_certifications", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	contactId: uuid("contact_id").notNull(),
	certificationName: text("certification_name").notNull(),
	issuingOrganization: text("issuing_organization"),
	issueDate: date("issue_date"),
	expiryDate: date("expiry_date"),
	isActive: boolean("is_active").default(true),
	credentialId: text("credential_id"),
	verificationUrl: text("verification_url"),
	renewalRequired: boolean("renewal_required").default(false),
	renewalReminderSentAt: timestamp("renewal_reminder_sent_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_contact_certifications_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contact_certifications_expiry").using("btree", table.expiryDate.asc().nullsLast().op("date_ops")).where(sql`((is_active = true) AND (deleted_at IS NULL))`),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "contact_certifications_contact_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contact_certifications_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("contact_certifications_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
]);

export const placementMilestones = pgTable("placement_milestones", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	placementId: uuid("placement_id").notNull(),
	milestoneType: text("milestone_type").notNull(),
	dueDate: date("due_date"),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	status: varchar({ length: 20 }).default('pending'),
	completedDate: date("completed_date"),
}, (table) => [
	index("idx_placement_milestones_due_date").using("btree", table.dueDate.asc().nullsLast().op("date_ops")),
	index("idx_placement_milestones_placement_id").using("btree", table.placementId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "placement_milestones_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.placementId],
			foreignColumns: [placements.id],
			name: "placement_milestones_placement_id_fkey"
		}).onDelete("cascade"),
	check("placement_milestones_status_check", sql`(status)::text = ANY ((ARRAY['pending'::character varying, 'completed'::character varying, 'skipped'::character varying])::text[])`),
]);

export const contactRateCards = pgTable("contact_rate_cards", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	contactId: uuid("contact_id").notNull(),
	clientId: uuid("client_id"),
	skillId: uuid("skill_id"),
	jobId: uuid("job_id"),
	billRateHourly: numeric("bill_rate_hourly", { precision: 10, scale:  2 }),
	payRateHourly: numeric("pay_rate_hourly", { precision: 10, scale:  2 }),
	markupPercentage: numeric("markup_percentage", { precision: 5, scale:  2 }),
	overtimeMultiplier: numeric("overtime_multiplier", { precision: 3, scale:  2 }).default('1.5'),
	effectiveDate: date("effective_date").notNull(),
	expiryDate: date("expiry_date"),
	isActive: boolean("is_active").default(true),
	approvedBy: uuid("approved_by"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_contact_rate_cards_active").using("btree", table.contactId.asc().nullsLast().op("bool_ops"), table.isActive.asc().nullsLast().op("uuid_ops")).where(sql`((is_active = true) AND (deleted_at IS NULL))`),
	index("idx_contact_rate_cards_client").using("btree", table.clientId.asc().nullsLast().op("uuid_ops")).where(sql`((client_id IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_contact_rate_cards_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.approvedBy],
			foreignColumns: [userProfiles.id],
			name: "contact_rate_cards_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.clientId],
			foreignColumns: [contacts.id],
			name: "contact_rate_cards_client_id_fkey"
		}),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "contact_rate_cards_contact_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contact_rate_cards_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.skillId],
			foreignColumns: [skills.id],
			name: "contact_rate_cards_skill_id_fkey"
		}),
	pgPolicy("contact_rate_cards_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
]);

export const groups = pgTable("groups", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	code: text(),
	description: text(),
	groupType: text("group_type").default('team').notNull(),
	parentGroupId: uuid("parent_group_id"),
	hierarchyLevel: integer("hierarchy_level").default(0),
	hierarchyPath: text("hierarchy_path"),
	supervisorId: uuid("supervisor_id"),
	managerId: uuid("manager_id"),
	securityZone: text("security_zone").default('default'),
	phone: text(),
	fax: text(),
	email: text(),
	addressLine1: text("address_line1"),
	addressLine2: text("address_line2"),
	city: text(),
	state: text(),
	postalCode: text("postal_code"),
	country: text().default('USA'),
	loadFactor: integer("load_factor").default(100),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_groups_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_groups_hierarchy_path").using("btree", table.hierarchyPath.asc().nullsLast().op("text_ops")),
	index("idx_groups_manager").using("btree", table.managerId.asc().nullsLast().op("uuid_ops")),
	index("idx_groups_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_groups_parent_id").using("btree", table.parentGroupId.asc().nullsLast().op("uuid_ops")),
	index("idx_groups_supervisor").using("btree", table.supervisorId.asc().nullsLast().op("uuid_ops")),
	index("idx_groups_type").using("btree", table.groupType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "groups_created_by_fkey"
		}),
	foreignKey({
			columns: [table.managerId],
			foreignColumns: [userProfiles.id],
			name: "groups_manager_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "groups_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.parentGroupId],
			foreignColumns: [table.id],
			name: "groups_parent_group_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.supervisorId],
			foreignColumns: [userProfiles.id],
			name: "groups_supervisor_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "groups_updated_by_fkey"
		}),
	unique("groups_unique_name_per_org").on(table.orgId, table.name, table.deletedAt),
	unique("groups_unique_code_per_org").on(table.orgId, table.code, table.deletedAt),
	pgPolicy("groups_delete_policy", { as: "permissive", for: "delete", to: ["public"], using: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid())))` }),
	pgPolicy("groups_insert_policy", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("groups_select_policy", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("groups_update_policy", { as: "permissive", for: "update", to: ["public"] }),
	check("groups_root_no_parent", sql`((group_type = 'root'::text) AND (parent_group_id IS NULL)) OR (group_type <> 'root'::text)`),
	check("groups_type_check", sql`group_type = ANY (ARRAY['root'::text, 'division'::text, 'branch'::text, 'team'::text, 'satellite_office'::text, 'producer'::text])`),
]);

export const placementExtensions = pgTable("placement_extensions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	placementId: uuid("placement_id").notNull(),
	previousEndDate: date("previous_end_date").notNull(),
	newEndDate: date("new_end_date").notNull(),
	reason: text(),
	approvedBy: uuid("approved_by"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	originalEndDate: date("original_end_date"),
	extensionMonths: integer("extension_months"),
	newPayRate: numeric("new_pay_rate", { precision: 10, scale:  2 }),
	newBillRate: numeric("new_bill_rate", { precision: 10, scale:  2 }),
	notes: text(),
}, (table) => [
	index("idx_placement_extensions_placement_id").using("btree", table.placementId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.approvedBy],
			foreignColumns: [userProfiles.id],
			name: "placement_extensions_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "placement_extensions_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.placementId],
			foreignColumns: [placements.id],
			name: "placement_extensions_placement_id_fkey"
		}).onDelete("cascade"),
]);

export const placementRates = pgTable("placement_rates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	placementId: uuid("placement_id").notNull(),
	billRate: numeric("bill_rate", { precision: 10, scale:  2 }).notNull(),
	payRate: numeric("pay_rate", { precision: 10, scale:  2 }).notNull(),
	marginPercent: numeric("margin_percent", { precision: 5, scale:  2 }),
	effectiveFrom: date("effective_from").notNull(),
	effectiveTo: date("effective_to"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	rateType: varchar("rate_type", { length: 20 }).default('regular'),
	effectiveDate: date("effective_date"),
}, (table) => [
	index("idx_placement_rates_placement_id").using("btree", table.placementId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "placement_rates_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.placementId],
			foreignColumns: [placements.id],
			name: "placement_rates_placement_id_fkey"
		}).onDelete("cascade"),
	check("placement_rates_rate_type_check", sql`(rate_type)::text = ANY ((ARRAY['regular'::character varying, 'overtime'::character varying, 'holiday'::character varying])::text[])`),
]);

export const contactAgreements = pgTable("contact_agreements", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	contactId: uuid("contact_id").notNull(),
	agreementType: text("agreement_type").notNull(),
	agreementName: text("agreement_name"),
	effectiveDate: date("effective_date"),
	expiryDate: date("expiry_date"),
	autoRenew: boolean("auto_renew").default(false),
	renewalNoticeDays: integer("renewal_notice_days").default(30),
	status: text().default('draft').notNull(),
	documentUrl: text("document_url"),
	signedDocumentUrl: text("signed_document_url"),
	ourSignerId: uuid("our_signer_id"),
	ourSignedAt: timestamp("our_signed_at", { withTimezone: true, mode: 'string' }),
	theirSignerName: text("their_signer_name"),
	theirSignedAt: timestamp("their_signed_at", { withTimezone: true, mode: 'string' }),
	terms: jsonb().default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_contact_agreements_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contact_agreements_expiry").using("btree", table.expiryDate.asc().nullsLast().op("date_ops")).where(sql`((status = 'active'::text) AND (deleted_at IS NULL))`),
	index("idx_contact_agreements_status").using("btree", table.status.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "contact_agreements_contact_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contact_agreements_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.ourSignerId],
			foreignColumns: [userProfiles.id],
			name: "contact_agreements_our_signer_id_fkey"
		}),
	pgPolicy("contact_agreements_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
	check("contact_agreements_status_check", sql`status = ANY (ARRAY['draft'::text, 'pending'::text, 'active'::text, 'expired'::text, 'terminated'::text])`),
	check("contact_agreements_type_check", sql`agreement_type = ANY (ARRAY['msa'::text, 'nda'::text, 'sow'::text, 'rate_card'::text, 'sla'::text, 'vendor_agreement'::text, 'other'::text])`),
]);

export const contactCompliance = pgTable("contact_compliance", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	contactId: uuid("contact_id").notNull(),
	complianceType: text("compliance_type").notNull(),
	status: text().default('pending').notNull(),
	documentUrl: text("document_url"),
	documentReceivedAt: timestamp("document_received_at", { withTimezone: true, mode: 'string' }),
	effectiveDate: date("effective_date"),
	expiryDate: date("expiry_date"),
	verifiedBy: uuid("verified_by"),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	verificationNotes: text("verification_notes"),
	policyNumber: text("policy_number"),
	coverageAmount: numeric("coverage_amount", { precision: 15, scale:  2 }),
	insuranceCarrier: text("insurance_carrier"),
	expiryAlertSentAt: timestamp("expiry_alert_sent_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_contact_compliance_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contact_compliance_expiry").using("btree", table.expiryDate.asc().nullsLast().op("date_ops")).where(sql`((status = ANY (ARRAY['verified'::text, 'expiring'::text])) AND (deleted_at IS NULL))`),
	index("idx_contact_compliance_type").using("btree", table.complianceType.asc().nullsLast().op("text_ops"), table.status.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "contact_compliance_contact_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contact_compliance_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.verifiedBy],
			foreignColumns: [userProfiles.id],
			name: "contact_compliance_verified_by_fkey"
		}),
	pgPolicy("contact_compliance_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
	check("contact_compliance_status_check", sql`status = ANY (ARRAY['pending'::text, 'received'::text, 'verified'::text, 'expiring'::text, 'expired'::text, 'rejected'::text])`),
	check("contact_compliance_type_check", sql`compliance_type = ANY (ARRAY['general_liability'::text, 'workers_comp'::text, 'e_o'::text, 'cyber'::text, 'w9'::text, 'coi'::text, 'background_check'::text, 'drug_test'::text, 'i9'::text, 'w4'::text, 'direct_deposit'::text])`),
]);

export const groupMembers = pgTable("group_members", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	groupId: uuid("group_id").notNull(),
	userId: uuid("user_id").notNull(),
	isManager: boolean("is_manager").default(false),
	isActive: boolean("is_active").default(true),
	loadFactor: integer("load_factor").default(100),
	loadPermission: text("load_permission").default('normal'),
	vacationStatus: text("vacation_status").default('available'),
	backupUserId: uuid("backup_user_id"),
	joinedAt: timestamp("joined_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	leftAt: timestamp("left_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_group_members_active").using("btree", table.isActive.asc().nullsLast().op("bool_ops")).where(sql`(left_at IS NULL)`),
	index("idx_group_members_group_id").using("btree", table.groupId.asc().nullsLast().op("uuid_ops")),
	index("idx_group_members_manager").using("btree", table.groupId.asc().nullsLast().op("uuid_ops")).where(sql`(is_manager = true)`),
	index("idx_group_members_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_group_members_user_id").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.backupUserId],
			foreignColumns: [userProfiles.id],
			name: "group_members_backup_user_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "group_members_created_by_fkey"
		}),
	foreignKey({
			columns: [table.groupId],
			foreignColumns: [groups.id],
			name: "group_members_group_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "group_members_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "group_members_user_id_fkey"
		}).onDelete("cascade"),
	unique("group_members_unique").on(table.groupId, table.userId),
	pgPolicy("group_members_delete_policy", { as: "permissive", for: "delete", to: ["public"], using: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid())))` }),
	pgPolicy("group_members_insert_policy", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("group_members_select_policy", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("group_members_update_policy", { as: "permissive", for: "update", to: ["public"] }),
	check("group_members_load_permission_check", sql`load_permission = ANY (ARRAY['normal'::text, 'reduced'::text, 'exempt'::text])`),
	check("group_members_vacation_check", sql`vacation_status = ANY (ARRAY['available'::text, 'vacation'::text, 'sick'::text, 'leave'::text])`),
]);

export const contactCommunicationPreferences = pgTable("contact_communication_preferences", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	contactId: uuid("contact_id").notNull(),
	channel: text().notNull(),
	isOptedIn: boolean("is_opted_in").default(true),
	optedInAt: timestamp("opted_in_at", { withTimezone: true, mode: 'string' }),
	optedOutAt: timestamp("opted_out_at", { withTimezone: true, mode: 'string' }),
	consentSource: text("consent_source"),
	frequencyPreference: text("frequency_preference"),
	contentPreferences: text("content_preferences").array(),
	bounceCount: integer("bounce_count").default(0),
	lastBounceAt: timestamp("last_bounce_at", { withTimezone: true, mode: 'string' }),
	complaintCount: integer("complaint_count").default(0),
	lastComplaintAt: timestamp("last_complaint_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_contact_comm_prefs_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")),
	index("idx_contact_comm_prefs_opted_out").using("btree", table.channel.asc().nullsLast().op("text_ops")).where(sql`(is_opted_in = false)`),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "contact_communication_preferences_contact_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contact_communication_preferences_org_id_fkey"
		}).onDelete("cascade"),
	unique("contact_comm_prefs_unique").on(table.contactId, table.channel),
	pgPolicy("contact_comm_prefs_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
	check("contact_comm_prefs_channel_check", sql`channel = ANY (ARRAY['email'::text, 'phone'::text, 'sms'::text, 'linkedin'::text, 'whatsapp'::text, 'mail'::text])`),
]);

export const contactMergeHistory = pgTable("contact_merge_history", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	survivorContactId: uuid("survivor_contact_id").notNull(),
	mergedContactId: uuid("merged_contact_id").notNull(),
	mergedAt: timestamp("merged_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	mergedBy: uuid("merged_by"),
	fieldSelections: jsonb("field_selections").default({}),
	mergedContactSnapshot: jsonb("merged_contact_snapshot").notNull(),
	notes: text(),
}, (table) => [
	index("idx_contact_merge_history_merged").using("btree", table.mergedContactId.asc().nullsLast().op("uuid_ops")),
	index("idx_contact_merge_history_survivor").using("btree", table.survivorContactId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.mergedBy],
			foreignColumns: [userProfiles.id],
			name: "contact_merge_history_merged_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contact_merge_history_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.survivorContactId],
			foreignColumns: [contacts.id],
			name: "contact_merge_history_survivor_contact_id_fkey"
		}),
	pgPolicy("contact_merge_history_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
]);

export const noteReactions = pgTable("note_reactions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	noteId: uuid("note_id").notNull(),
	userId: uuid("user_id").notNull(),
	reaction: varchar({ length: 20 }).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_note_reactions_note").using("btree", table.noteId.asc().nullsLast().op("uuid_ops")),
	index("idx_note_reactions_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.noteId],
			foreignColumns: [notes.id],
			name: "note_reactions_note_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "note_reactions_user_id_fkey"
		}),
	unique("note_reactions_unique").on(table.noteId, table.userId, table.reaction),
	pgPolicy("note_reactions_access", { as: "permissive", for: "all", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM notes n
  WHERE ((n.id = note_reactions.note_id) AND (n.org_id = (current_setting('app.org_id'::text, true))::uuid))))` }),
]);

export const companies = pgTable("companies", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	companyNumber: varchar("company_number", { length: 50 }),
	category: companyCategory().notNull(),
	relationshipType: companyRelationshipType("relationship_type").default('direct_client').notNull(),
	segment: companySegment(),
	tier: companyTier().default('standard'),
	status: companyStatus().default('active').notNull(),
	name: text().notNull(),
	legalName: text("legal_name"),
	dbaName: text("dba_name"),
	industry: text(),
	subIndustry: text("sub_industry"),
	sicCode: varchar("sic_code", { length: 10 }),
	naicsCode: varchar("naics_code", { length: 10 }),
	employeeCount: integer("employee_count"),
	employeeRange: varchar("employee_range", { length: 20 }),
	annualRevenue: numeric("annual_revenue", { precision: 15, scale:  2 }),
	revenueRange: varchar("revenue_range", { length: 20 }),
	foundedYear: integer("founded_year"),
	ownershipType: varchar("ownership_type", { length: 50 }),
	parentCompanyId: uuid("parent_company_id"),
	hierarchyLevel: integer("hierarchy_level").default(0),
	hierarchyPath: text("hierarchy_path"),
	isHeadquarters: boolean("is_headquarters").default(true),
	website: text(),
	phone: text(),
	linkedinUrl: text("linkedin_url"),
	headquartersCity: text("headquarters_city"),
	headquartersState: text("headquarters_state"),
	headquartersCountry: text("headquarters_country").default('USA'),
	timezone: text().default('America/New_York'),
	ownerId: uuid("owner_id"),
	accountManagerId: uuid("account_manager_id"),
	podId: uuid("pod_id"),
	primaryContactId: uuid("primary_contact_id"),
	isMspProgram: boolean("is_msp_program").default(false),
	mspProviderId: uuid("msp_provider_id"),
	ourMspTier: integer("our_msp_tier"),
	vmsPlatform: varchar("vms_platform", { length: 50 }),
	vmsVendorId: varchar("vms_vendor_id", { length: 100 }),
	vmsApiEnabled: boolean("vms_api_enabled").default(false),
	msaStatus: varchar("msa_status", { length: 20 }).default('none'),
	msaEffectiveDate: date("msa_effective_date"),
	msaExpirationDate: date("msa_expiration_date"),
	msaAutoRenews: boolean("msa_auto_renews").default(false),
	defaultPaymentTerms: varchar("default_payment_terms", { length: 20 }).default('Net 30'),
	defaultCurrency: varchar("default_currency", { length: 3 }).default('USD'),
	defaultMarkupPercentage: numeric("default_markup_percentage", { precision: 5, scale:  2 }),
	defaultFeePercentage: numeric("default_fee_percentage", { precision: 5, scale:  2 }),
	creditLimit: numeric("credit_limit", { precision: 12, scale:  2 }),
	creditStatus: varchar("credit_status", { length: 20 }).default('approved'),
	accountScore: integer("account_score"),
	accountGrade: char("account_grade", { length: 1 }),
	healthScore: integer("health_score"),
	healthStatus: varchar("health_status", { length: 20 }).default('healthy'),
	churnRisk: integer("churn_risk"),
	npsScore: integer("nps_score"),
	lifetimeRevenue: numeric("lifetime_revenue", { precision: 15, scale:  2 }).default('0'),
	lifetimePlacements: integer("lifetime_placements").default(0),
	revenueYtd: numeric("revenue_ytd", { precision: 15, scale:  2 }).default('0'),
	placementsYtd: integer("placements_ytd").default(0),
	revenueLast12M: numeric("revenue_last_12m", { precision: 15, scale:  2 }).default('0'),
	avgMarginPercentage: numeric("avg_margin_percentage", { precision: 5, scale:  2 }),
	firstEngagementDate: date("first_engagement_date"),
	lastJobDate: date("last_job_date"),
	lastPlacementDate: date("last_placement_date"),
	lastActivityDate: timestamp("last_activity_date", { withTimezone: true, mode: 'string' }),
	lastContactedDate: timestamp("last_contacted_date", { withTimezone: true, mode: 'string' }),
	nextScheduledContact: date("next_scheduled_contact"),
	activeJobsCount: integer("active_jobs_count").default(0),
	activePlacementsCount: integer("active_placements_count").default(0),
	totalContactsCount: integer("total_contacts_count").default(0),
	source: varchar({ length: 50 }),
	sourceDetail: text("source_detail"),
	sourceCampaignId: uuid("source_campaign_id"),
	referringCompanyId: uuid("referring_company_id"),
	referringContactId: uuid("referring_contact_id"),
	convertedFromLeadId: uuid("converted_from_lead_id"),
	preferredContactMethod: varchar("preferred_contact_method", { length: 20 }).default('email'),
	submissionMethod: varchar("submission_method", { length: 20 }).default('email'),
	invoiceDeliveryMethod: varchar("invoice_delivery_method", { length: 20 }).default('email'),
	meetingCadence: varchar("meeting_cadence", { length: 20 }),
	isStrategic: boolean("is_strategic").default(false),
	requiresPo: boolean("requires_po").default(false),
	requiresApprovalForSubmission: boolean("requires_approval_for_submission").default(false),
	allowsRemoteWork: boolean("allows_remote_work").default(true),
	onboardingStatus: text("onboarding_status").default('pending'),
	onboardingCompletedAt: timestamp("onboarding_completed_at", { withTimezone: true, mode: 'string' }),
	onboardingCompletedBy: uuid("onboarding_completed_by"),
	onboardingData: jsonb("onboarding_data").default({}),
	tags: text().array(),
	customFields: jsonb("custom_fields").default({}),
	preferences: jsonb().default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	// TODO: failed to parse database type 'tsvector'
	searchVector: unknown("search_vector"),
	description: text(),
	industries: text().array(),
}, (table) => [
	index("idx_companies_account_manager").using("btree", table.accountManagerId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_companies_category").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.category.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_companies_health").using("btree", table.orgId.asc().nullsLast().op("int4_ops"), table.healthStatus.asc().nullsLast().op("uuid_ops"), table.healthScore.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_companies_hierarchy").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.hierarchyPath.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_companies_name_trgm").using("gin", table.name.asc().nullsLast().op("gin_trgm_ops")),
	index("idx_companies_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_companies_owner").using("btree", table.ownerId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_companies_parent").using("btree", table.parentCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_companies_search").using("gin", table.searchVector.asc().nullsLast().op("tsvector_ops")),
	index("idx_companies_status").using("btree", table.orgId.asc().nullsLast().op("enum_ops"), table.status.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_companies_tier").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.tier.asc().nullsLast().op("enum_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.accountManagerId],
			foreignColumns: [userProfiles.id],
			name: "companies_account_manager_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "companies_created_by_fkey"
		}),
	foreignKey({
			columns: [table.mspProviderId],
			foreignColumns: [table.id],
			name: "companies_msp_provider_id_fkey"
		}),
	foreignKey({
			columns: [table.onboardingCompletedBy],
			foreignColumns: [userProfiles.id],
			name: "companies_onboarding_completed_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "companies_org_id_fkey"
		}),
	foreignKey({
			columns: [table.ownerId],
			foreignColumns: [userProfiles.id],
			name: "companies_owner_id_fkey"
		}),
	foreignKey({
			columns: [table.parentCompanyId],
			foreignColumns: [table.id],
			name: "companies_parent_company_id_fkey"
		}),
	foreignKey({
			columns: [table.podId],
			foreignColumns: [pods.id],
			name: "companies_pod_id_fkey"
		}),
	foreignKey({
			columns: [table.referringCompanyId],
			foreignColumns: [table.id],
			name: "companies_referring_company_id_fkey"
		}),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "companies_updated_by_fkey"
		}),
	pgPolicy("companies_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
	check("companies_account_grade_check", sql`account_grade = ANY (ARRAY['A'::bpchar, 'B'::bpchar, 'C'::bpchar, 'D'::bpchar])`),
	check("companies_account_score_check", sql`(account_score >= 0) AND (account_score <= 100)`),
	check("companies_churn_risk_check", sql`(churn_risk >= 0) AND (churn_risk <= 100)`),
	check("companies_health_score_check", sql`(health_score >= 0) AND (health_score <= 100)`),
	check("companies_nps_score_check", sql`(nps_score >= '-100'::integer) AND (nps_score <= 100)`),
	check("companies_our_msp_tier_check", sql`(our_msp_tier >= 1) AND (our_msp_tier <= 5)`),
	check("valid_hierarchy", sql`(parent_company_id IS NULL) OR (parent_company_id <> id)`),
	check("valid_msp_reference", sql`(msp_provider_id IS NULL) OR (msp_provider_id <> id)`),
]);

export const groupRegions = pgTable("group_regions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	groupId: uuid("group_id").notNull(),
	regionId: uuid("region_id").notNull(),
	isPrimary: boolean("is_primary").default(false),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_group_regions_group_id").using("btree", table.groupId.asc().nullsLast().op("uuid_ops")),
	index("idx_group_regions_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_group_regions_region_id").using("btree", table.regionId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "group_regions_created_by_fkey"
		}),
	foreignKey({
			columns: [table.groupId],
			foreignColumns: [groups.id],
			name: "group_regions_group_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "group_regions_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.regionId],
			foreignColumns: [regions.id],
			name: "group_regions_region_id_fkey"
		}).onDelete("cascade"),
	unique("group_regions_unique").on(table.groupId, table.regionId),
	pgPolicy("group_regions_delete_policy", { as: "permissive", for: "delete", to: ["public"], using: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid())))` }),
	pgPolicy("group_regions_insert_policy", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("group_regions_select_policy", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("group_regions_update_policy", { as: "permissive", for: "update", to: ["public"] }),
]);

export const documents = pgTable("documents", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	fileName: varchar("file_name", { length: 255 }).notNull(),
	fileType: varchar("file_type", { length: 20 }),
	mimeType: varchar("mime_type", { length: 100 }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	fileSizeBytes: bigint("file_size_bytes", { mode: "number" }),
	storageProvider: varchar("storage_provider", { length: 20 }).default('supabase'),
	storageBucket: varchar("storage_bucket", { length: 100 }),
	storagePath: varchar("storage_path", { length: 500 }).notNull(),
	publicUrl: varchar("public_url", { length: 1000 }),
	documentType: varchar("document_type", { length: 50 }).default('other').notNull(),
	documentCategory: varchar("document_category", { length: 50 }).default('general'),
	description: text(),
	version: integer().default(1),
	isLatestVersion: boolean("is_latest_version").default(true),
	previousVersionId: uuid("previous_version_id"),
	versionNotes: text("version_notes"),
	processingStatus: varchar("processing_status", { length: 20 }).default('pending'),
	processedAt: timestamp("processed_at", { withTimezone: true, mode: 'string' }),
	ocrText: text("ocr_text"),
	extractedMetadata: jsonb("extracted_metadata"),
	contentHash: varchar("content_hash", { length: 64 }),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }),
	expiryAlertSentAt: timestamp("expiry_alert_sent_at", { withTimezone: true, mode: 'string' }),
	expiryAlertDaysBefore: integer("expiry_alert_days_before").default(30),
	isConfidential: boolean("is_confidential").default(false),
	accessLevel: varchar("access_level", { length: 20 }).default('standard'),
	accessibleByRoles: text("accessible_by_roles").array(),
	tags: text().array(),
	uploadedBy: uuid("uploaded_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_documents_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_documents_expiry").using("btree", table.expiresAt.asc().nullsLast().op("timestamptz_ops")).where(sql`((expires_at IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_documents_hash").using("btree", table.contentHash.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_documents_latest").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("uuid_ops"), table.documentType.asc().nullsLast().op("text_ops")).where(sql`((is_latest_version = true) AND (deleted_at IS NULL))`),
	index("idx_documents_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_documents_processing").using("btree", table.processingStatus.asc().nullsLast().op("text_ops")).where(sql`(((processing_status)::text <> 'completed'::text) AND (deleted_at IS NULL))`),
	index("idx_documents_type").using("btree", table.documentType.asc().nullsLast().op("text_ops"), table.entityType.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "documents_org_id_fkey"
		}),
	foreignKey({
			columns: [table.previousVersionId],
			foreignColumns: [table.id],
			name: "documents_previous_version_id_fkey"
		}),
	foreignKey({
			columns: [table.uploadedBy],
			foreignColumns: [userProfiles.id],
			name: "documents_uploaded_by_fkey"
		}),
	pgPolicy("documents_access_level", { as: "permissive", for: "select", to: ["public"], using: sql`(((access_level)::text = ANY ((ARRAY['public'::character varying, 'standard'::character varying])::text[])) OR (((access_level)::text = 'confidential'::text) AND (EXISTS ( SELECT 1
   FROM user_roles ur
  WHERE ((ur.user_id = (current_setting('app.user_id'::text, true))::uuid) AND (ur.role_id IN ( SELECT roles.id
           FROM roles
          WHERE (roles.name = ANY (ARRAY['admin'::text, 'manager'::text])))))))) OR (uploaded_by = (current_setting('app.user_id'::text, true))::uuid))` }),
	pgPolicy("documents_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	check("documents_access_level_check", sql`(access_level)::text = ANY ((ARRAY['public'::character varying, 'standard'::character varying, 'confidential'::character varying, 'restricted'::character varying])::text[])`),
	check("documents_document_category_check", sql`(document_category)::text = ANY ((ARRAY['compliance'::character varying, 'legal'::character varying, 'marketing'::character varying, 'hr'::character varying, 'operational'::character varying, 'general'::character varying])::text[])`),
	check("documents_document_type_check", sql`(document_type)::text = ANY ((ARRAY['resume'::character varying, 'cover_letter'::character varying, 'id_document'::character varying, 'certification'::character varying, 'reference_letter'::character varying, 'background_check'::character varying, 'drug_test'::character varying, 'i9'::character varying, 'w4'::character varying, 'direct_deposit'::character varying, 'msa'::character varying, 'nda'::character varying, 'sow'::character varying, 'w9'::character varying, 'coi'::character varying, 'insurance'::character varying, 'contract'::character varying, 'job_description'::character varying, 'requirements'::character varying, 'scorecard'::character varying, 'other'::character varying, 'note_attachment'::character varying, 'email_attachment'::character varying])::text[])`),
	check("documents_processing_status_check", sql`(processing_status)::text = ANY ((ARRAY['pending'::character varying, 'processing'::character varying, 'completed'::character varying, 'failed'::character varying])::text[])`),
]);

export const meetingNotes = pgTable("meeting_notes", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	accountId: uuid("account_id").notNull(),
	contactIds: uuid("contact_ids").array(),
	meetingType: text("meeting_type").default('check_in').notNull(),
	title: text().notNull(),
	description: text(),
	scheduledAt: timestamp("scheduled_at", { withTimezone: true, mode: 'string' }),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }),
	endedAt: timestamp("ended_at", { withTimezone: true, mode: 'string' }),
	durationMinutes: integer("duration_minutes"),
	locationType: text("location_type").default('video'),
	locationDetails: text("location_details"),
	status: text().default('scheduled').notNull(),
	agenda: text(),
	discussionNotes: text("discussion_notes"),
	keyTakeaways: text("key_takeaways").array(),
	actionItems: jsonb("action_items").default([]),
	nextMeetingScheduled: timestamp("next_meeting_scheduled", { withTimezone: true, mode: 'string' }),
	followUpNotes: text("follow_up_notes"),
	clientSatisfaction: text("client_satisfaction"),
	clientFeedback: text("client_feedback"),
	relatedJobIds: uuid("related_job_ids").array(),
	relatedCandidateIds: uuid("related_candidate_ids").array(),
	relatedEscalationId: uuid("related_escalation_id"),
	createdBy: uuid("created_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedBy: uuid("updated_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_meeting_notes_account").using("btree", table.accountId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_meeting_notes_created_by").using("btree", table.createdBy.asc().nullsLast().op("uuid_ops")),
	index("idx_meeting_notes_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_meeting_notes_scheduled").using("btree", table.scheduledAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_meeting_notes_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_meeting_notes_type").using("btree", table.meetingType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "meeting_notes_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "meeting_notes_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "meeting_notes_updated_by_fkey"
		}),
	pgPolicy("meeting_notes_employee_access", { as: "permissive", for: "all", to: ["public"], using: sql`(auth_has_role('employee'::text) OR auth_has_role('admin'::text) OR auth_has_role('recruiter'::text))` }),
	pgPolicy("meeting_notes_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
]);

export const escalations = pgTable("escalations", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	escalationNumber: text("escalation_number").notNull(),
	accountId: uuid("account_id").notNull(),
	escalationType: text("escalation_type").notNull(),
	severity: text().default('medium').notNull(),
	issueSummary: text("issue_summary").notNull(),
	detailedDescription: text("detailed_description").notNull(),
	relatedEntities: jsonb("related_entities").default([]),
	clientImpact: text("client_impact").array(),
	rootCause: text("root_cause"),
	immediateActions: text("immediate_actions"),
	resolutionPlan: text("resolution_plan"),
	status: text().default('open').notNull(),
	slaResponseDue: timestamp("sla_response_due", { withTimezone: true, mode: 'string' }),
	slaResolutionDue: timestamp("sla_resolution_due", { withTimezone: true, mode: 'string' }),
	slaResponseMet: boolean("sla_response_met"),
	slaResolutionMet: boolean("sla_resolution_met"),
	createdBy: uuid("created_by").notNull(),
	assignedTo: uuid("assigned_to"),
	escalatedTo: uuid("escalated_to"),
	resolvedBy: uuid("resolved_by"),
	resolvedAt: timestamp("resolved_at", { withTimezone: true, mode: 'string' }),
	resolutionSummary: text("resolution_summary"),
	resolutionActions: text("resolution_actions"),
	timeToResolve: interval("time_to_resolve"),
	clientSatisfaction: text("client_satisfaction"),
	lessonsLearned: text("lessons_learned"),
	preventiveMeasures: text("preventive_measures"),
	managerNotificationType: text("manager_notification_type"),
	managerNotifiedAt: timestamp("manager_notified_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_client_escalations_account").using("btree", table.accountId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_client_escalations_assigned").using("btree", table.assignedTo.asc().nullsLast().op("uuid_ops")),
	index("idx_client_escalations_created_by").using("btree", table.createdBy.asc().nullsLast().op("uuid_ops")),
	index("idx_client_escalations_number").using("btree", table.escalationNumber.asc().nullsLast().op("text_ops")),
	index("idx_client_escalations_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_client_escalations_severity").using("btree", table.severity.asc().nullsLast().op("text_ops")),
	index("idx_client_escalations_sla_response").using("btree", table.slaResponseDue.asc().nullsLast().op("timestamptz_ops")).where(sql`(status = ANY (ARRAY['open'::text, 'in_progress'::text]))`),
	index("idx_client_escalations_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_client_escalations_type").using("btree", table.escalationType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.assignedTo],
			foreignColumns: [userProfiles.id],
			name: "escalations_assigned_to_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "escalations_created_by_fkey"
		}),
	foreignKey({
			columns: [table.escalatedTo],
			foreignColumns: [userProfiles.id],
			name: "escalations_escalated_to_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "escalations_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.resolvedBy],
			foreignColumns: [userProfiles.id],
			name: "escalations_resolved_by_fkey"
		}),
	unique("escalations_escalation_number_key").on(table.escalationNumber),
	pgPolicy("escalations_employee_access", { as: "permissive", for: "all", to: ["public"], using: sql`(auth_has_role('employee'::text) OR auth_has_role('admin'::text) OR auth_has_role('recruiter'::text))` }),
	pgPolicy("escalations_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
]);

export const escalationUpdates = pgTable("escalation_updates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	escalationId: uuid("escalation_id").notNull(),
	updateType: text("update_type").notNull(),
	content: text().notNull(),
	oldStatus: text("old_status"),
	newStatus: text("new_status"),
	oldAssigneeId: uuid("old_assignee_id"),
	newAssigneeId: uuid("new_assignee_id"),
	createdBy: uuid("created_by").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	isInternal: boolean("is_internal").default(true),
}, (table) => [
	index("idx_escalation_updates_created_at").using("btree", table.createdAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_escalation_updates_escalation").using("btree", table.escalationId.asc().nullsLast().op("uuid_ops")),
	index("idx_escalation_updates_type").using("btree", table.updateType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "escalation_updates_created_by_fkey"
		}),
	foreignKey({
			columns: [table.escalationId],
			foreignColumns: [escalations.id],
			name: "escalation_updates_escalation_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.newAssigneeId],
			foreignColumns: [userProfiles.id],
			name: "escalation_updates_new_assignee_id_fkey"
		}),
	foreignKey({
			columns: [table.oldAssigneeId],
			foreignColumns: [userProfiles.id],
			name: "escalation_updates_old_assignee_id_fkey"
		}),
	pgPolicy("escalation_updates_access", { as: "permissive", for: "all", to: ["public"], using: sql`(escalation_id IN ( SELECT escalations.id
   FROM escalations
  WHERE (escalations.org_id = auth_org_id())))` }),
]);

export const documentAccessLog = pgTable("document_access_log", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	documentId: uuid("document_id").notNull(),
	userId: uuid("user_id").notNull(),
	action: varchar({ length: 20 }).notNull(),
	ipAddress: inet("ip_address"),
	userAgent: text("user_agent"),
	accessedAt: timestamp("accessed_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_document_access_document").using("btree", table.documentId.asc().nullsLast().op("timestamptz_ops"), table.accessedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_document_access_user").using("btree", table.userId.asc().nullsLast().op("timestamptz_ops"), table.accessedAt.desc().nullsFirst().op("timestamptz_ops")),
	foreignKey({
			columns: [table.documentId],
			foreignColumns: [documents.id],
			name: "document_access_log_document_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "document_access_log_user_id_fkey"
		}),
	pgPolicy("document_access_log_policy", { as: "permissive", for: "all", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM documents d
  WHERE ((d.id = document_access_log.document_id) AND (d.org_id = (current_setting('app.org_id'::text, true))::uuid))))` }),
]);

export const companyClientDetails = pgTable("company_client_details", {
	companyId: uuid("company_id").primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	billingEntityName: text("billing_entity_name"),
	billingEmail: text("billing_email"),
	billingPhone: text("billing_phone"),
	billingContactId: uuid("billing_contact_id"),
	poRequired: boolean("po_required").default(false),
	currentPoNumber: text("current_po_number"),
	poExpirationDate: date("po_expiration_date"),
	invoiceFormat: varchar("invoice_format", { length: 20 }).default('standard'),
	invoiceConsolidation: varchar("invoice_consolidation", { length: 20 }).default('per_placement'),
	invoiceDueReminderDays: integer("invoice_due_reminder_days").default(7),
	billingAddressLine1: text("billing_address_line_1"),
	billingAddressLine2: text("billing_address_line_2"),
	billingCity: text("billing_city"),
	billingState: text("billing_state"),
	billingPostalCode: text("billing_postal_code"),
	billingCountry: text("billing_country").default('USA'),
	preferredWorkArrangements: text("preferred_work_arrangements").array(),
	preferredContractTypes: text("preferred_contract_types").array(),
	allowsContractToHire: boolean("allows_contract_to_hire").default(true),
	cthConversionFeePercentage: numeric("cth_conversion_fee_percentage", { precision: 5, scale:  2 }),
	cthConversionCreditDays: integer("cth_conversion_credit_days").default(90),
	responsivenessRating: varchar("responsiveness_rating", { length: 20 }),
	feedbackQualityRating: varchar("feedback_quality_rating", { length: 20 }),
	hiringSpeedRating: varchar("hiring_speed_rating", { length: 20 }),
	preferredExperienceLevels: text("preferred_experience_levels").array(),
	typicalInterviewRounds: integer("typical_interview_rounds"),
	avgTimeToDecisionDays: integer("avg_time_to_decision_days"),
	interviewProcessNotes: text("interview_process_notes"),
	exclusiveSupplier: boolean("exclusive_supplier").default(false),
	exclusiveStartDate: date("exclusive_start_date"),
	exclusiveEndDate: date("exclusive_end_date"),
	knownCompetitors: text("known_competitors").array(),
	walletSharePercentage: numeric("wallet_share_percentage", { precision: 5, scale:  2 }),
	qbrFrequency: varchar("qbr_frequency", { length: 20 }),
	lastQbrDate: date("last_qbr_date"),
	nextQbrDate: date("next_qbr_date"),
	executiveSponsorId: uuid("executive_sponsor_id"),
	legacyBillingData: jsonb("legacy_billing_data").default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	billingFrequency: varchar("billing_frequency", { length: 20 }).default('monthly'),
}, (table) => [
	index("idx_company_client_details_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "company_client_details_company_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.executiveSponsorId],
			foreignColumns: [userProfiles.id],
			name: "company_client_details_executive_sponsor_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "company_client_details_org_id_fkey"
		}),
	pgPolicy("company_client_details_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
	check("company_client_details_billing_frequency_check", sql`(billing_frequency)::text = ANY ((ARRAY['weekly'::character varying, 'biweekly'::character varying, 'monthly'::character varying])::text[])`),
]);

export const entityDrafts = pgTable("entity_drafts", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	userId: uuid("user_id").notNull(),
	entityType: text("entity_type").notNull(),
	displayName: text("display_name").notNull(),
	formData: jsonb("form_data").default({}).notNull(),
	currentStep: integer("current_step").default(1),
	totalSteps: integer("total_steps").default(1),
	wizardRoute: text("wizard_route").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_entity_drafts_entity_type").using("btree", table.entityType.asc().nullsLast().op("text_ops")),
	index("idx_entity_drafts_org").using("btree", table.orgId.asc().nullsLast().op("timestamptz_ops"), table.deletedAt.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_entity_drafts_user_active").using("btree", table.userId.asc().nullsLast().op("uuid_ops"), table.deletedAt.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "entity_drafts_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("entity_drafts_delete_own", { as: "permissive", for: "delete", to: ["public"], using: sql`(user_id = auth.uid())` }),
	pgPolicy("entity_drafts_insert_own", { as: "permissive", for: "insert", to: ["public"] }),
	pgPolicy("entity_drafts_select_own", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("entity_drafts_update_own", { as: "permissive", for: "update", to: ["public"] }),
	check("entity_drafts_entity_type_check", sql`entity_type = ANY (ARRAY['account'::text, 'job'::text, 'contact'::text, 'candidate'::text, 'submission'::text, 'placement'::text, 'vendor'::text, 'contract'::text])`),
]);

export const companyVendorDetails = pgTable("company_vendor_details", {
	companyId: uuid("company_id").primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	vendorType: companyVendorType("vendor_type").default('prime_vendor').notNull(),
	industryFocus: text("industry_focus").array(),
	geographicFocus: text("geographic_focus").array(),
	skillFocus: text("skill_focus").array(),
	vendorManagerId: uuid("vendor_manager_id"),
	onboardedDate: date("onboarded_date"),
	lastJobOrderDate: date("last_job_order_date"),
	paymentTermsToUs: varchar("payment_terms_to_us", { length: 20 }).default('Net 60'),
	typicalMarkupToClient: numeric("typical_markup_to_client", { precision: 5, scale:  2 }),
	ourTypicalMargin: numeric("our_typical_margin", { precision: 5, scale:  2 }),
	preferredJobCategories: text("preferred_job_categories").array(),
	excludedJobCategories: text("excluded_job_categories").array(),
	minRateHourly: numeric("min_rate_hourly", { precision: 10, scale:  2 }),
	maxRateHourly: numeric("max_rate_hourly", { precision: 10, scale:  2 }),
	acceptsCorpToCorp: boolean("accepts_corp_to_corp").default(true),
	accepts1099: boolean("accepts_1099").default(true),
	totalJobOrders: integer("total_job_orders").default(0),
	filledJobOrders: integer("filled_job_orders").default(0),
	fillRate: numeric("fill_rate", { precision: 5, scale:  2 }),
	avgTimeToFillDays: integer("avg_time_to_fill_days"),
	totalRevenueFromVendor: numeric("total_revenue_from_vendor", { precision: 15, scale:  2 }).default('0'),
	jobOrderDeliveryMethod: varchar("job_order_delivery_method", { length: 20 }).default('email'),
	submissionFormat: varchar("submission_format", { length: 20 }).default('email'),
	requiresRightToRepresent: boolean("requires_right_to_represent").default(true),
	rtrValidityHours: integer("rtr_validity_hours").default(24),
	isBlacklisted: boolean("is_blacklisted").default(false),
	blacklistReason: text("blacklist_reason"),
	blacklistDate: date("blacklist_date"),
	hasPaymentIssues: boolean("has_payment_issues").default(false),
	paymentIssueNotes: text("payment_issue_notes"),
	suppliesTalent: boolean("supplies_talent").default(false),
	talentCategories: text("talent_categories").array(),
	talentSpecializations: text("talent_specializations").array(),
	benchConsultantsCount: integer("bench_consultants_count").default(0),
	candidatesSuppliedCount: integer("candidates_supplied_count").default(0),
	candidatesPlacedCount: integer("candidates_placed_count").default(0),
	talentPlacementRate: numeric("talent_placement_rate", { precision: 5, scale:  2 }),
	avgTalentQualityScore: numeric("avg_talent_quality_score", { precision: 3, scale:  1 }),
	legacyTermsData: jsonb("legacy_terms_data").default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_company_vendor_details_blacklist").using("btree", table.companyId.asc().nullsLast().op("uuid_ops")).where(sql`(is_blacklisted = true)`),
	index("idx_company_vendor_details_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_company_vendor_details_type").using("btree", table.vendorType.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "company_vendor_details_company_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "company_vendor_details_org_id_fkey"
		}),
	foreignKey({
			columns: [table.vendorManagerId],
			foreignColumns: [userProfiles.id],
			name: "company_vendor_details_vendor_manager_id_fkey"
		}),
	pgPolicy("company_vendor_details_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const companyPartnerDetails = pgTable("company_partner_details", {
	companyId: uuid("company_id").primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	partnershipType: varchar("partnership_type", { length: 50 }),
	partnershipTier: varchar("partnership_tier", { length: 20 }),
	partnershipStartDate: date("partnership_start_date"),
	partnershipRenewalDate: date("partnership_renewal_date"),
	referralFeePercentage: numeric("referral_fee_percentage", { precision: 5, scale:  2 }),
	referralFeeFlat: numeric("referral_fee_flat", { precision: 10, scale:  2 }),
	referralTrackingPeriodDays: integer("referral_tracking_period_days").default(365),
	totalReferrals: integer("total_referrals").default(0),
	successfulReferrals: integer("successful_referrals").default(0),
	referralConversionRate: numeric("referral_conversion_rate", { precision: 5, scale:  2 }),
	totalReferralRevenue: numeric("total_referral_revenue", { precision: 15, scale:  2 }).default('0'),
	coMarketingFund: numeric("co_marketing_fund", { precision: 10, scale:  2 }),
	coMarketingActivities: text("co_marketing_activities").array(),
	jointCaseStudies: text("joint_case_studies").array(),
	apiIntegrationEnabled: boolean("api_integration_enabled").default(false),
	integrationType: varchar("integration_type", { length: 50 }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_company_partner_details_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "company_partner_details_company_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "company_partner_details_org_id_fkey"
		}),
	pgPolicy("company_partner_details_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = current_user_org_id())` }),
]);

export const deals = pgTable("deals", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	leadId: uuid("lead_id"),
	accountId: uuid("account_id"),
	title: text().notNull(),
	description: text(),
	value: numeric({ precision: 12, scale:  2 }).notNull(),
	stage: text().default('discovery').notNull(),
	probability: integer(),
	expectedCloseDate: date("expected_close_date"),
	actualCloseDate: date("actual_close_date"),
	ownerId: uuid("owner_id").notNull(),
	closeReason: text("close_reason"),
	linkedJobIds: uuid("linked_job_ids").array(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	name: text(),
	dealType: text("deal_type"),
	currency: text().default('USD'),
	lossReason: text("loss_reason"),
	competitorWon: text("competitor_won"),
	notes: text(),
	valueBasis: text("value_basis").default('one_time'),
	weightedValue: numeric("weighted_value", { precision: 12, scale:  2 }).generatedAlwaysAs(sql`((value * (probability)::numeric) / 100.0)`),
	estimatedPlacements: integer("estimated_placements"),
	avgBillRate: numeric("avg_bill_rate", { precision: 10, scale:  2 }),
	contractLengthMonths: integer("contract_length_months"),
	hiringNeeds: text("hiring_needs"),
	rolesBreakdown: jsonb("roles_breakdown"),
	servicesRequired: text("services_required").array(),
	competitors: text().array(),
	competitiveAdvantage: text("competitive_advantage"),
	podManagerId: uuid("pod_manager_id"),
	secondaryOwnerId: uuid("secondary_owner_id"),
	nextAction: text("next_action"),
	nextActionDate: date("next_action_date"),
	healthStatus: text("health_status").default('on_track'),
	lastActivityAt: timestamp("last_activity_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	contractSignedDate: date("contract_signed_date"),
	contractStartDate: date("contract_start_date"),
	contractDurationMonths: integer("contract_duration_months"),
	contractType: text("contract_type"),
	paymentTerms: text("payment_terms"),
	billingFrequency: text("billing_frequency"),
	billingContact: jsonb("billing_contact"),
	confirmedRoles: jsonb("confirmed_roles"),
	winReason: text("win_reason"),
	winDetails: text("win_details"),
	competitorsBeat: text("competitors_beat").array(),
	lossReasonCategory: text("loss_reason_category"),
	lossDetails: text("loss_details"),
	competitorPrice: numeric("competitor_price", { precision: 10, scale:  2 }),
	futurePotential: text("future_potential"),
	reengagementDate: date("reengagement_date"),
	lessonsLearned: text("lessons_learned"),
	createdAccountId: uuid("created_account_id"),
	companyId: uuid("company_id"),
	leadContactId: uuid("lead_contact_id"),
}, (table) => [
	index("idx_deals_account").using("btree", table.accountId.asc().nullsLast().op("uuid_ops")),
	index("idx_deals_account_id").using("btree", table.accountId.asc().nullsLast().op("uuid_ops")),
	index("idx_deals_company_id").using("btree", table.companyId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_deals_expected_close").using("btree", table.expectedCloseDate.asc().nullsLast().op("date_ops")),
	index("idx_deals_expected_close_active").using("btree", table.expectedCloseDate.asc().nullsLast().op("date_ops")).where(sql`((deleted_at IS NULL) AND (stage <> ALL (ARRAY['closed_won'::text, 'closed_lost'::text])))`),
	index("idx_deals_health_status").using("btree", table.healthStatus.asc().nullsLast().op("text_ops")).where(sql`((deleted_at IS NULL) AND (stage <> ALL (ARRAY['closed_won'::text, 'closed_lost'::text])))`),
	index("idx_deals_last_activity").using("btree", table.lastActivityAt.asc().nullsLast().op("timestamptz_ops")).where(sql`((deleted_at IS NULL) AND (stage <> ALL (ARRAY['closed_won'::text, 'closed_lost'::text])))`),
	index("idx_deals_lead").using("btree", table.leadId.asc().nullsLast().op("uuid_ops")),
	index("idx_deals_lead_contact").using("btree", table.leadContactId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_deals_lead_id").using("btree", table.leadId.asc().nullsLast().op("uuid_ops")),
	index("idx_deals_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_deals_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_deals_owner").using("btree", table.ownerId.asc().nullsLast().op("uuid_ops")),
	index("idx_deals_owner_id").using("btree", table.ownerId.asc().nullsLast().op("uuid_ops")),
	index("idx_deals_stage").using("btree", table.stage.asc().nullsLast().op("text_ops")),
	index("idx_deals_stage_owner").using("btree", table.stage.asc().nullsLast().op("text_ops"), table.ownerId.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "deals_company_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "deals_created_by_fkey"
		}),
	foreignKey({
			columns: [table.leadContactId],
			foreignColumns: [contacts.id],
			name: "deals_lead_contact_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.leadId],
			foreignColumns: [leads.id],
			name: "deals_lead_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "deals_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.ownerId],
			foreignColumns: [userProfiles.id],
			name: "deals_owner_id_fkey"
		}),
	foreignKey({
			columns: [table.podManagerId],
			foreignColumns: [userProfiles.id],
			name: "deals_pod_manager_id_fkey"
		}),
	foreignKey({
			columns: [table.secondaryOwnerId],
			foreignColumns: [userProfiles.id],
			name: "deals_secondary_owner_id_fkey"
		}),
	pgPolicy("deals_employee_insert", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(auth_has_role('employee'::text) OR auth_has_role('admin'::text) OR auth_has_role('recruiter'::text))`  }),
	pgPolicy("deals_employee_select", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("deals_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	pgPolicy("deals_owner_update", { as: "permissive", for: "update", to: ["public"] }),
	check("deals_billing_frequency_check", sql`billing_frequency = ANY (ARRAY['weekly'::text, 'biweekly'::text, 'monthly'::text])`),
	check("deals_contract_type_check", sql`contract_type = ANY (ARRAY['msa'::text, 'sow'::text, 'po'::text, 'email'::text])`),
	check("deals_future_potential_check", sql`future_potential = ANY (ARRAY['yes'::text, 'maybe'::text, 'no'::text])`),
	check("deals_health_status_check", sql`health_status = ANY (ARRAY['on_track'::text, 'slow'::text, 'stale'::text, 'urgent'::text, 'at_risk'::text])`),
	check("deals_loss_reason_category_check", sql`loss_reason_category = ANY (ARRAY['competitor'::text, 'no_budget'::text, 'project_cancelled'::text, 'hired_internally'::text, 'went_dark'::text, 'price_too_high'::text, 'requirements_changed'::text, 'other'::text])`),
	check("deals_payment_terms_check", sql`payment_terms = ANY (ARRAY['net_15'::text, 'net_30'::text, 'net_45'::text, 'net_60'::text])`),
	check("deals_probability_check", sql`(probability >= 0) AND (probability <= 100)`),
	check("deals_value_basis_check", sql`value_basis = ANY (ARRAY['one_time'::text, 'annual'::text, 'monthly'::text])`),
	check("deals_win_reason_check", sql`win_reason = ANY (ARRAY['price_value'::text, 'expertise_speed'::text, 'relationship_trust'::text, 'candidate_quality'::text, 'response_time'::text, 'other'::text])`),
]);

export const dataRetentionPolicies = pgTable("data_retention_policies", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	tableName: varchar("table_name", { length: 100 }).notNull(),
	entityType: varchar("entity_type", { length: 50 }),
	retentionDays: integer("retention_days").notNull(),
	archiveAfterDays: integer("archive_after_days"),
	maskPiiAfterDays: integer("mask_pii_after_days"),
	actionOnExpiry: varchar("action_on_expiry", { length: 20 }).default('archive'),
	lastProcessedAt: timestamp("last_processed_at", { withTimezone: true, mode: 'string' }),
	processingFrequency: varchar("processing_frequency", { length: 20 }).default('daily'),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_retention_policies_active").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(is_active = true)`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "data_retention_policies_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "data_retention_policies_org_id_fkey"
		}),
	unique("retention_policies_unique").on(table.orgId, table.tableName, table.entityType),
	pgPolicy("retention_policies_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("retention_policies_action_check", sql`(action_on_expiry)::text = ANY ((ARRAY['archive'::character varying, 'delete'::character varying, 'anonymize'::character varying])::text[])`),
]);

export const complianceRequirements = pgTable("compliance_requirements", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	requirementCode: varchar("requirement_code", { length: 50 }).notNull(),
	requirementName: varchar("requirement_name", { length: 200 }).notNull(),
	description: text(),
	category: varchar({ length: 50 }).notNull(),
	subcategory: varchar({ length: 50 }),
	appliesToEntityTypes: text("applies_to_entity_types").array().default(["RAY['contact'::tex"]),
	validityPeriodDays: integer("validity_period_days"),
	renewalLeadDays: integer("renewal_lead_days").default(30),
	priority: compliancePriority().default('medium'),
	isBlocking: boolean("is_blocking").default(false),
	requiresDocument: boolean("requires_document").default(true),
	acceptedDocumentTypes: text("accepted_document_types").array(),
	jurisdiction: varchar({ length: 50 }),
	jurisdictionRegion: varchar("jurisdiction_region", { length: 100 }),
	isActive: boolean("is_active").default(true),
	effectiveFrom: date("effective_from"),
	effectiveUntil: date("effective_until"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_compliance_req_blocking").using("btree", table.isBlocking.asc().nullsLast().op("bool_ops")).where(sql`((is_blocking = true) AND (deleted_at IS NULL))`),
	index("idx_compliance_req_category").using("btree", table.category.asc().nullsLast().op("bool_ops"), table.isActive.asc().nullsLast().op("bool_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_compliance_req_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "compliance_requirements_created_by_fkey1"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "compliance_requirements_org_id_fkey1"
		}),
	unique("compliance_requirements_code_unique").on(table.orgId, table.requirementCode),
	pgPolicy("compliance_requirements_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("compliance_requirements_category_check", sql`(category)::text = ANY ((ARRAY['background'::character varying, 'drug_test'::character varying, 'tax'::character varying, 'insurance'::character varying, 'certification'::character varying, 'legal'::character varying, 'immigration'::character varying, 'health'::character varying, 'training'::character varying, 'other'::character varying])::text[])`),
]);

export const complianceItems = pgTable("compliance_items", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	requirementId: uuid("requirement_id"),
	complianceType: varchar("compliance_type", { length: 100 }),
	complianceName: varchar("compliance_name", { length: 200 }),
	status: complianceItemStatus().default('pending'),
	documentId: uuid("document_id"),
	documentUrl: varchar("document_url", { length: 500 }),
	documentReceivedAt: timestamp("document_received_at", { withTimezone: true, mode: 'string' }),
	effectiveDate: date("effective_date"),
	expiryDate: date("expiry_date"),
	verifiedBy: uuid("verified_by"),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	verificationMethod: varchar("verification_method", { length: 50 }),
	verificationNotes: text("verification_notes"),
	rejectionReason: text("rejection_reason"),
	waivedBy: uuid("waived_by"),
	waivedAt: timestamp("waived_at", { withTimezone: true, mode: 'string' }),
	waiverReason: text("waiver_reason"),
	waiverExpiresAt: date("waiver_expires_at"),
	policyNumber: varchar("policy_number", { length: 100 }),
	coverageAmount: numeric("coverage_amount", { precision: 12, scale:  2 }),
	insuranceCarrier: varchar("insurance_carrier", { length: 200 }),
	contextPlacementId: uuid("context_placement_id"),
	contextClientId: uuid("context_client_id"),
	expiryAlertSentAt: timestamp("expiry_alert_sent_at", { withTimezone: true, mode: 'string' }),
	expiryAlertDaysBefore: integer("expiry_alert_days_before").default(30),
	inheritedFromEntityType: varchar("inherited_from_entity_type", { length: 50 }),
	inheritedFromEntityId: uuid("inherited_from_entity_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_compliance_items_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_compliance_items_expiring").using("btree", table.expiryDate.asc().nullsLast().op("date_ops"), table.status.asc().nullsLast().op("enum_ops")).where(sql`((status <> ALL (ARRAY['expired'::compliance_item_status, 'rejected'::compliance_item_status, 'waived'::compliance_item_status])) AND (expiry_date IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_compliance_items_expiry").using("btree", table.expiryDate.asc().nullsLast().op("date_ops")).where(sql`((expiry_date IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_compliance_items_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_compliance_items_requirement").using("btree", table.requirementId.asc().nullsLast().op("uuid_ops")).where(sql`((requirement_id IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_compliance_items_status").using("btree", table.status.asc().nullsLast().op("enum_ops"), table.entityType.asc().nullsLast().op("enum_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "compliance_items_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "compliance_items_org_id_fkey"
		}),
	foreignKey({
			columns: [table.requirementId],
			foreignColumns: [complianceRequirements.id],
			name: "compliance_items_requirement_id_fkey"
		}),
	foreignKey({
			columns: [table.verifiedBy],
			foreignColumns: [userProfiles.id],
			name: "compliance_items_verified_by_fkey"
		}),
	foreignKey({
			columns: [table.waivedBy],
			foreignColumns: [userProfiles.id],
			name: "compliance_items_waived_by_fkey"
		}),
	pgPolicy("compliance_items_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const entityComplianceRequirements = pgTable("entity_compliance_requirements", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	requirementId: uuid("requirement_id").notNull(),
	isRequired: boolean("is_required").default(true),
	customValidityDays: integer("custom_validity_days"),
	customLeadDays: integer("custom_lead_days"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_entity_compliance_req_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "entity_compliance_requirements_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "entity_compliance_requirements_org_id_fkey"
		}),
	foreignKey({
			columns: [table.requirementId],
			foreignColumns: [complianceRequirements.id],
			name: "entity_compliance_requirements_requirement_id_fkey"
		}),
	unique("entity_compliance_req_unique").on(table.entityType, table.entityId, table.requirementId),
	pgPolicy("entity_compliance_requirements_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const contracts = pgTable("contracts", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	secondaryEntityType: varchar("secondary_entity_type", { length: 50 }),
	secondaryEntityId: uuid("secondary_entity_id"),
	contractNumber: varchar("contract_number", { length: 50 }),
	contractName: varchar("contract_name", { length: 300 }).notNull(),
	contractType: contractType("contract_type").notNull(),
	category: varchar({ length: 50 }),
	parentContractId: uuid("parent_contract_id"),
	status: contractStatus().default('draft'),
	effectiveDate: date("effective_date"),
	expiryDate: date("expiry_date"),
	terminationDate: date("termination_date"),
	autoRenew: boolean("auto_renew").default(false),
	renewalTermMonths: integer("renewal_term_months"),
	renewalNoticeDays: integer("renewal_notice_days").default(30),
	maxRenewals: integer("max_renewals"),
	renewalsCount: integer("renewals_count").default(0),
	contractValue: numeric("contract_value", { precision: 14, scale:  2 }),
	currency: varchar({ length: 3 }).default('USD'),
	terms: jsonb().default({}),
	documentId: uuid("document_id"),
	documentUrl: varchar("document_url", { length: 500 }),
	signedDocumentId: uuid("signed_document_id"),
	signedDocumentUrl: varchar("signed_document_url", { length: 500 }),
	templateId: uuid("template_id"),
	version: integer().default(1),
	isLatestVersion: boolean("is_latest_version").default(true),
	previousVersionId: uuid("previous_version_id"),
	esignProvider: varchar("esign_provider", { length: 50 }),
	esignEnvelopeId: varchar("esign_envelope_id", { length: 200 }),
	esignStatus: varchar("esign_status", { length: 50 }),
	terminationReason: text("termination_reason"),
	terminatedBy: uuid("terminated_by"),
	contextJobId: uuid("context_job_id"),
	contextPlacementId: uuid("context_placement_id"),
	ownerId: uuid("owner_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_contracts_entity").using("btree", table.entityType.asc().nullsLast().op("timestamptz_ops"), table.entityId.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contracts_expiry").using("btree", table.expiryDate.asc().nullsLast().op("date_ops")).where(sql`((expiry_date IS NOT NULL) AND (status = 'active'::contract_status) AND (deleted_at IS NULL))`),
	index("idx_contracts_latest").using("btree", table.entityType.asc().nullsLast().op("enum_ops"), table.entityId.asc().nullsLast().op("enum_ops"), table.contractType.asc().nullsLast().op("enum_ops")).where(sql`((is_latest_version = true) AND (deleted_at IS NULL))`),
	index("idx_contracts_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contracts_parent").using("btree", table.parentContractId.asc().nullsLast().op("uuid_ops")).where(sql`((parent_contract_id IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_contracts_status").using("btree", table.status.asc().nullsLast().op("enum_ops"), table.contractType.asc().nullsLast().op("enum_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "contracts_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contracts_org_id_fkey"
		}),
	foreignKey({
			columns: [table.ownerId],
			foreignColumns: [userProfiles.id],
			name: "contracts_owner_id_fkey"
		}),
	foreignKey({
			columns: [table.parentContractId],
			foreignColumns: [table.id],
			name: "contracts_parent_contract_id_fkey"
		}),
	foreignKey({
			columns: [table.previousVersionId],
			foreignColumns: [table.id],
			name: "contracts_previous_version_id_fkey"
		}),
	foreignKey({
			columns: [table.terminatedBy],
			foreignColumns: [userProfiles.id],
			name: "contracts_terminated_by_fkey"
		}),
	unique("contracts_number_unique").on(table.orgId, table.contractNumber),
	pgPolicy("contracts_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const contractVersions = pgTable("contract_versions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	contractId: uuid("contract_id").notNull(),
	versionNumber: integer("version_number").notNull(),
	versionType: varchar("version_type", { length: 50 }).notNull(),
	versionName: varchar("version_name", { length: 200 }),
	changeSummary: text("change_summary"),
	changesJson: jsonb("changes_json"),
	effectiveDate: date("effective_date"),
	expiryDate: date("expiry_date"),
	contractValue: numeric("contract_value", { precision: 14, scale:  2 }),
	termsSnapshot: jsonb("terms_snapshot"),
	documentId: uuid("document_id"),
	documentUrl: varchar("document_url", { length: 500 }),
	approvedBy: uuid("approved_by"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_contract_versions_contract").using("btree", table.contractId.asc().nullsLast().op("int4_ops"), table.versionNumber.desc().nullsFirst().op("int4_ops")),
	foreignKey({
			columns: [table.approvedBy],
			foreignColumns: [userProfiles.id],
			name: "contract_versions_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.contractId],
			foreignColumns: [contracts.id],
			name: "contract_versions_contract_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "contract_versions_created_by_fkey"
		}),
	unique("contract_versions_unique").on(table.contractId, table.versionNumber),
	pgPolicy("contract_versions_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM contracts c
  WHERE ((c.id = contract_versions.contract_id) AND (c.org_id = (current_setting('app.org_id'::text, true))::uuid))))` }),
]);

export const contractParties = pgTable("contract_parties", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	contractId: uuid("contract_id").notNull(),
	partyType: varchar("party_type", { length: 50 }).notNull(),
	partyRole: varchar("party_role", { length: 50 }).notNull(),
	userId: uuid("user_id"),
	contactId: uuid("contact_id"),
	companyId: uuid("company_id"),
	partyName: varchar("party_name", { length: 200 }),
	partyEmail: varchar("party_email", { length: 200 }),
	partyTitle: varchar("party_title", { length: 100 }),
	partyCompany: varchar("party_company", { length: 200 }),
	signatoryStatus: signatoryStatus("signatory_status").default('pending'),
	signatureRequestedAt: timestamp("signature_requested_at", { withTimezone: true, mode: 'string' }),
	signedAt: timestamp("signed_at", { withTimezone: true, mode: 'string' }),
	signatureIp: varchar("signature_ip", { length: 45 }),
	declinedReason: text("declined_reason"),
	esignRecipientId: varchar("esign_recipient_id", { length: 200 }),
	signingOrder: integer("signing_order").default(1),
	isRequired: boolean("is_required").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_contract_parties_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_contract_parties_contract").using("btree", table.contractId.asc().nullsLast().op("uuid_ops")),
	index("idx_contract_parties_pending").using("btree", table.contractId.asc().nullsLast().op("uuid_ops"), table.signatoryStatus.asc().nullsLast().op("enum_ops")).where(sql`(signatory_status = 'pending'::signatory_status)`),
	index("idx_contract_parties_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")).where(sql`(user_id IS NOT NULL)`),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "contract_parties_company_id_fkey"
		}),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "contract_parties_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.contractId],
			foreignColumns: [contracts.id],
			name: "contract_parties_contract_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contract_parties_org_id_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "contract_parties_user_id_fkey"
		}),
	pgPolicy("contract_parties_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const contractTemplates = pgTable("contract_templates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	templateName: varchar("template_name", { length: 200 }).notNull(),
	templateCode: varchar("template_code", { length: 50 }),
	contractType: contractType("contract_type").notNull(),
	description: text(),
	templateContent: text("template_content"),
	templateDocumentId: uuid("template_document_id"),
	availableVariables: jsonb("available_variables"),
	defaultClauses: uuid("default_clauses").array(),
	defaultTerms: jsonb("default_terms"),
	defaultRenewalMonths: integer("default_renewal_months"),
	defaultNoticeDays: integer("default_notice_days"),
	isActive: boolean("is_active").default(true),
	usageCount: integer("usage_count").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_contract_templates_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contract_templates_type").using("btree", table.contractType.asc().nullsLast().op("bool_ops"), table.isActive.asc().nullsLast().op("bool_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "contract_templates_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contract_templates_org_id_fkey"
		}),
	unique("contract_templates_code_unique").on(table.orgId, table.templateCode),
	pgPolicy("contract_templates_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const contractClauses = pgTable("contract_clauses", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	clauseName: varchar("clause_name", { length: 200 }).notNull(),
	clauseCode: varchar("clause_code", { length: 50 }),
	category: varchar({ length: 50 }),
	clauseText: text("clause_text").notNull(),
	clauseVersion: integer("clause_version").default(1),
	legalApproved: boolean("legal_approved").default(false),
	legalApprovedBy: uuid("legal_approved_by"),
	legalApprovedAt: timestamp("legal_approved_at", { withTimezone: true, mode: 'string' }),
	isStandard: boolean("is_standard").default(false),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_contract_clauses_category").using("btree", table.category.asc().nullsLast().op("text_ops"), table.isActive.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_contract_clauses_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "contract_clauses_created_by_fkey"
		}),
	foreignKey({
			columns: [table.legalApprovedBy],
			foreignColumns: [userProfiles.id],
			name: "contract_clauses_legal_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "contract_clauses_org_id_fkey"
		}),
	pgPolicy("contract_clauses_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const rateApprovals = pgTable("rate_approvals", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityRateId: uuid("entity_rate_id").notNull(),
	approvalType: varchar("approval_type", { length: 50 }).notNull(),
	requestedBy: uuid("requested_by"),
	requestedAt: timestamp("requested_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	justification: text(),
	proposedBillRate: numeric("proposed_bill_rate", { precision: 10, scale:  2 }),
	proposedPayRate: numeric("proposed_pay_rate", { precision: 10, scale:  2 }),
	proposedMarginPercentage: numeric("proposed_margin_percentage", { precision: 5, scale:  2 }),
	status: varchar({ length: 20 }).default('pending'),
	decidedBy: uuid("decided_by"),
	decidedAt: timestamp("decided_at", { withTimezone: true, mode: 'string' }),
	decisionReason: text("decision_reason"),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_rate_approvals_pending").using("btree", table.status.asc().nullsLast().op("text_ops")).where(sql`((status)::text = 'pending'::text)`),
	index("idx_rate_approvals_rate").using("btree", table.entityRateId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.decidedBy],
			foreignColumns: [userProfiles.id],
			name: "rate_approvals_decided_by_fkey"
		}),
	foreignKey({
			columns: [table.entityRateId],
			foreignColumns: [entityRates.id],
			name: "rate_approvals_entity_rate_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "rate_approvals_org_id_fkey"
		}),
	foreignKey({
			columns: [table.requestedBy],
			foreignColumns: [userProfiles.id],
			name: "rate_approvals_requested_by_fkey"
		}),
	pgPolicy("rate_approvals_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("rate_approvals_status_check", sql`(status)::text = ANY ((ARRAY['pending'::character varying, 'approved'::character varying, 'rejected'::character varying, 'expired'::character varying])::text[])`),
]);

export const rateCards = pgTable("rate_cards", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	rateCardName: varchar("rate_card_name", { length: 200 }).notNull(),
	rateCardCode: varchar("rate_card_code", { length: 50 }),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	rateCardType: rateCardType("rate_card_type").default('standard'),
	currency: varchar({ length: 3 }).default('USD'),
	version: integer().default(1),
	isActive: boolean("is_active").default(true),
	isLatestVersion: boolean("is_latest_version").default(true),
	previousVersionId: uuid("previous_version_id"),
	effectiveStartDate: date("effective_start_date").notNull(),
	effectiveEndDate: date("effective_end_date"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	approvedBy: uuid("approved_by"),
	overtimeMultiplier: numeric("overtime_multiplier", { precision: 4, scale:  2 }).default('1.5'),
	doubleTimeMultiplier: numeric("double_time_multiplier", { precision: 4, scale:  2 }).default('2.0'),
	holidayMultiplier: numeric("holiday_multiplier", { precision: 4, scale:  2 }).default('1.5'),
	defaultMarkupPercentage: numeric("default_markup_percentage", { precision: 5, scale:  2 }),
	minMarginPercentage: numeric("min_margin_percentage", { precision: 5, scale:  2 }).default('10.0'),
	targetMarginPercentage: numeric("target_margin_percentage", { precision: 5, scale:  2 }).default('20.0'),
	mspProgramName: varchar("msp_program_name", { length: 200 }),
	mspTier: varchar("msp_tier", { length: 50 }),
	vmsPlatform: varchar("vms_platform", { length: 100 }),
	vmsFeePercentage: numeric("vms_fee_percentage", { precision: 5, scale:  2 }),
	directHireFeePercentage: numeric("direct_hire_fee_percentage", { precision: 5, scale:  2 }),
	directHireFeeFlat: numeric("direct_hire_fee_flat", { precision: 10, scale:  2 }),
	applicableRegions: text("applicable_regions").array(),
	applicableJobCategories: text("applicable_job_categories").array(),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_rate_cards_active").using("btree", table.entityType.asc().nullsLast().op("bool_ops"), table.entityId.asc().nullsLast().op("text_ops"), table.isActive.asc().nullsLast().op("uuid_ops")).where(sql`((is_active = true) AND (deleted_at IS NULL))`),
	index("idx_rate_cards_effective").using("btree", table.effectiveStartDate.asc().nullsLast().op("date_ops"), table.effectiveEndDate.asc().nullsLast().op("date_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_rate_cards_entity").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_rate_cards_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	uniqueIndex("idx_rate_cards_unique_active").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("uuid_ops")).where(sql`((is_active = true) AND (is_latest_version = true) AND (deleted_at IS NULL))`),
	foreignKey({
			columns: [table.approvedBy],
			foreignColumns: [userProfiles.id],
			name: "rate_cards_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "rate_cards_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "rate_cards_org_id_fkey"
		}),
	foreignKey({
			columns: [table.previousVersionId],
			foreignColumns: [table.id],
			name: "rate_cards_previous_version_id_fkey"
		}),
	unique("rate_cards_code_unique").on(table.orgId, table.rateCardCode),
	pgPolicy("rate_cards_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const rateCardItems = pgTable("rate_card_items", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	rateCardId: uuid("rate_card_id").notNull(),
	jobCategory: varchar("job_category", { length: 100 }),
	jobLevel: varchar("job_level", { length: 50 }),
	jobFamily: varchar("job_family", { length: 100 }),
	skillId: uuid("skill_id"),
	rateUnit: rateUnit("rate_unit").default('hourly'),
	minPayRate: numeric("min_pay_rate", { precision: 10, scale:  2 }),
	maxPayRate: numeric("max_pay_rate", { precision: 10, scale:  2 }),
	targetPayRate: numeric("target_pay_rate", { precision: 10, scale:  2 }),
	minBillRate: numeric("min_bill_rate", { precision: 10, scale:  2 }),
	maxBillRate: numeric("max_bill_rate", { precision: 10, scale:  2 }),
	standardBillRate: numeric("standard_bill_rate", { precision: 10, scale:  2 }),
	calculatedMarkup: numeric("calculated_markup", { precision: 5, scale:  2 }).generatedAlwaysAs(sql`
CASE
    WHEN ((target_pay_rate > (0)::numeric) AND (target_pay_rate IS NOT NULL)) THEN round((((standard_bill_rate - target_pay_rate) / target_pay_rate) * (100)::numeric), 2)
    ELSE NULL::numeric
END`),
	calculatedMargin: numeric("calculated_margin", { precision: 5, scale:  2 }).generatedAlwaysAs(sql`
CASE
    WHEN ((standard_bill_rate > (0)::numeric) AND (standard_bill_rate IS NOT NULL)) THEN round((((standard_bill_rate - target_pay_rate) / standard_bill_rate) * (100)::numeric), 2)
    ELSE NULL::numeric
END`),
	targetMarginPercentage: numeric("target_margin_percentage", { precision: 5, scale:  2 }),
	minMarginPercentage: numeric("min_margin_percentage", { precision: 5, scale:  2 }),
	requiresCertification: boolean("requires_certification").default(false),
	requiresClearance: boolean("requires_clearance").default(false),
	clearanceLevel: varchar("clearance_level", { length: 50 }),
	minYearsExperience: integer("min_years_experience"),
	notes: text(),
	displayOrder: integer("display_order").default(0),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_rate_card_items_category").using("btree", table.jobCategory.asc().nullsLast().op("text_ops"), table.jobLevel.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_rate_card_items_skill").using("btree", table.skillId.asc().nullsLast().op("uuid_ops")).where(sql`((skill_id IS NOT NULL) AND (deleted_at IS NULL))`),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "rate_card_items_org_id_fkey"
		}),
	foreignKey({
			columns: [table.rateCardId],
			foreignColumns: [rateCards.id],
			name: "rate_card_items_rate_card_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("rate_card_items_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const entityRates = pgTable("entity_rates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	rateCardId: uuid("rate_card_id"),
	rateCardItemId: uuid("rate_card_item_id"),
	rateUnit: rateUnit("rate_unit").default('hourly'),
	currency: varchar({ length: 3 }).default('USD'),
	billRate: numeric("bill_rate", { precision: 10, scale:  2 }).notNull(),
	payRate: numeric("pay_rate", { precision: 10, scale:  2 }).notNull(),
	grossMargin: numeric("gross_margin", { precision: 10, scale:  2 }).generatedAlwaysAs(sql`(bill_rate - pay_rate)`),
	marginPercentage: numeric("margin_percentage", { precision: 5, scale:  2 }).generatedAlwaysAs(sql`
CASE
    WHEN (bill_rate > (0)::numeric) THEN round((((bill_rate - pay_rate) / bill_rate) * (100)::numeric), 2)
    ELSE (0)::numeric
END`),
	markupPercentage: numeric("markup_percentage", { precision: 5, scale:  2 }).generatedAlwaysAs(sql`
CASE
    WHEN (pay_rate > (0)::numeric) THEN round((((bill_rate - pay_rate) / pay_rate) * (100)::numeric), 2)
    ELSE (0)::numeric
END`),
	otBillRate: numeric("ot_bill_rate", { precision: 10, scale:  2 }),
	otPayRate: numeric("ot_pay_rate", { precision: 10, scale:  2 }),
	dtBillRate: numeric("dt_bill_rate", { precision: 10, scale:  2 }),
	dtPayRate: numeric("dt_pay_rate", { precision: 10, scale:  2 }),
	effectiveDate: date("effective_date").notNull(),
	endDate: date("end_date"),
	isCurrent: boolean("is_current").default(true),
	originalBillRate: numeric("original_bill_rate", { precision: 10, scale:  2 }),
	originalPayRate: numeric("original_pay_rate", { precision: 10, scale:  2 }),
	negotiatedBy: uuid("negotiated_by"),
	negotiationNotes: text("negotiation_notes"),
	requiresApproval: boolean("requires_approval").default(false),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	approvedBy: uuid("approved_by"),
	approvalNotes: text("approval_notes"),
	contextJobId: uuid("context_job_id"),
	contextClientId: uuid("context_client_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_entity_rates_card").using("btree", table.rateCardId.asc().nullsLast().op("uuid_ops")).where(sql`((rate_card_id IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_entity_rates_current").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.entityId.asc().nullsLast().op("uuid_ops")).where(sql`((is_current = true) AND (deleted_at IS NULL))`),
	index("idx_entity_rates_entity").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_entity_rates_margin").using("btree", table.marginPercentage.asc().nullsLast().op("numeric_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_entity_rates_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.approvedBy],
			foreignColumns: [userProfiles.id],
			name: "entity_rates_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "entity_rates_created_by_fkey"
		}),
	foreignKey({
			columns: [table.negotiatedBy],
			foreignColumns: [userProfiles.id],
			name: "entity_rates_negotiated_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "entity_rates_org_id_fkey"
		}),
	foreignKey({
			columns: [table.rateCardId],
			foreignColumns: [rateCards.id],
			name: "entity_rates_rate_card_id_fkey"
		}),
	foreignKey({
			columns: [table.rateCardItemId],
			foreignColumns: [rateCardItems.id],
			name: "entity_rates_rate_card_item_id_fkey"
		}),
	pgPolicy("entity_rates_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const rateChangeHistory = pgTable("rate_change_history", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	entityRateId: uuid("entity_rate_id").notNull(),
	changeType: varchar("change_type", { length: 50 }).notNull(),
	oldBillRate: numeric("old_bill_rate", { precision: 10, scale:  2 }),
	newBillRate: numeric("new_bill_rate", { precision: 10, scale:  2 }),
	oldPayRate: numeric("old_pay_rate", { precision: 10, scale:  2 }),
	newPayRate: numeric("new_pay_rate", { precision: 10, scale:  2 }),
	reason: text(),
	changedBy: uuid("changed_by"),
	changedAt: timestamp("changed_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_rate_change_history_rate").using("btree", table.entityRateId.asc().nullsLast().op("timestamptz_ops"), table.changedAt.desc().nullsFirst().op("timestamptz_ops")),
	foreignKey({
			columns: [table.changedBy],
			foreignColumns: [userProfiles.id],
			name: "rate_change_history_changed_by_fkey"
		}),
	foreignKey({
			columns: [table.entityRateId],
			foreignColumns: [entityRates.id],
			name: "rate_change_history_entity_rate_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("rate_change_history_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM entity_rates e
  WHERE ((e.id = rate_change_history.entity_rate_id) AND (e.org_id = (current_setting('app.org_id'::text, true))::uuid))))` }),
	check("rate_change_history_type_check", sql`(change_type)::text = ANY ((ARRAY['created'::character varying, 'updated'::character varying, 'approved'::character varying, 'rejected'::character varying, 'expired'::character varying, 'negotiated'::character varying])::text[])`),
]);

export const jobs = pgTable("jobs", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	dealId: uuid("deal_id"),
	title: text().notNull(),
	description: text(),
	jobType: text("job_type").default('contract'),
	location: text(),
	isRemote: boolean("is_remote").default(false),
	hybridDays: integer("hybrid_days"),
	rateMin: numeric("rate_min", { precision: 10, scale:  2 }),
	rateMax: numeric("rate_max", { precision: 10, scale:  2 }),
	rateType: text("rate_type").default('hourly'),
	currency: text().default('USD'),
	status: text().default('draft').notNull(),
	urgency: text().default('medium'),
	positionsCount: integer("positions_count").default(1),
	positionsFilled: integer("positions_filled").default(0),
	requiredSkills: text("required_skills").array(),
	niceToHaveSkills: text("nice_to_have_skills").array(),
	minExperienceYears: integer("min_experience_years"),
	maxExperienceYears: integer("max_experience_years"),
	visaRequirements: text("visa_requirements").array(),
	ownerId: uuid("owner_id").notNull(),
	recruiterIds: uuid("recruiter_ids").array(),
	postedDate: date("posted_date"),
	targetFillDate: date("target_fill_date"),
	filledDate: date("filled_date"),
	clientSubmissionInstructions: text("client_submission_instructions"),
	clientInterviewProcess: text("client_interview_process"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	// TODO: failed to parse database type 'tsvector'
	searchVector: unknown("search_vector"),
	priority: text().default('medium'),
	targetStartDate: timestamp("target_start_date", { withTimezone: true, mode: 'string' }),
	closedAt: timestamp("closed_at", { withTimezone: true, mode: 'string' }),
	closedBy: uuid("closed_by"),
	closureReason: text("closure_reason"),
	closureNote: text("closure_note"),
	onHoldReason: text("on_hold_reason"),
	expectedReactivationDate: date("expected_reactivation_date"),
	publishedAt: timestamp("published_at", { withTimezone: true, mode: 'string' }),
	publishedBy: uuid("published_by"),
	daysToFill: integer("days_to_fill"),
	companyId: uuid("company_id"),
	clientCompanyId: uuid("client_company_id"),
	endClientCompanyId: uuid("end_client_company_id"),
	vendorCompanyId: uuid("vendor_company_id"),
	hiringManagerContactId: uuid("hiring_manager_contact_id"),
	hrContactId: uuid("hr_contact_id"),
	externalJobId: varchar("external_job_id", { length: 100 }),
	priorityRank: integer("priority_rank").default(0),
	slaDays: integer("sla_days").default(30),
	intakeCompletedAt: timestamp("intake_completed_at", { withTimezone: true, mode: 'string' }),
	intakeCompletedBy: uuid("intake_completed_by"),
	feeType: varchar("fee_type", { length: 50 }).default('percentage'),
	feePercentage: numeric("fee_percentage", { precision: 5, scale:  2 }),
	feeFlatAmount: numeric("fee_flat_amount", { precision: 10, scale:  2 }),
	intakeData: jsonb("intake_data").default({}),
	targetEndDate: date("target_end_date"),
	wizardState: jsonb("wizard_state"),
}, (table) => [
	index("idx_jobs_client_company").using("btree", table.clientCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_jobs_company_id").using("btree", table.companyId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_jobs_company_org").using("btree", table.companyId.asc().nullsLast().op("uuid_ops"), table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_jobs_deal").using("btree", table.dealId.asc().nullsLast().op("uuid_ops")),
	index("idx_jobs_end_client").using("btree", table.endClientCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_jobs_external_id").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.externalJobId.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_jobs_hiring_manager").using("btree", table.hiringManagerContactId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_jobs_intake_data").using("gin", table.intakeData.asc().nullsLast().op("jsonb_ops")),
	index("idx_jobs_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_jobs_org_status").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_jobs_owner").using("btree", table.ownerId.asc().nullsLast().op("uuid_ops")),
	index("idx_jobs_posted_date").using("btree", table.postedDate.desc().nullsFirst().op("date_ops")),
	index("idx_jobs_priority_rank").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.priorityRank.desc().nullsFirst().op("uuid_ops")).where(sql`((status = ANY (ARRAY['open'::text, 'active'::text])) AND (deleted_at IS NULL))`),
	index("idx_jobs_search").using("gin", table.searchVector.asc().nullsLast().op("tsvector_ops")),
	index("idx_jobs_sla").using("btree", table.orgId.asc().nullsLast().op("int4_ops"), table.slaDays.asc().nullsLast().op("uuid_ops")).where(sql`((status = ANY (ARRAY['open'::text, 'active'::text])) AND (deleted_at IS NULL))`),
	index("idx_jobs_status").using("btree", table.status.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_jobs_vendor").using("btree", table.vendorCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.clientCompanyId],
			foreignColumns: [companies.id],
			name: "jobs_client_company_id_fkey"
		}),
	foreignKey({
			columns: [table.closedBy],
			foreignColumns: [userProfiles.id],
			name: "jobs_closed_by_fkey"
		}),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "jobs_company_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "jobs_created_by_fkey"
		}),
	foreignKey({
			columns: [table.dealId],
			foreignColumns: [deals.id],
			name: "jobs_deal_id_fkey"
		}),
	foreignKey({
			columns: [table.endClientCompanyId],
			foreignColumns: [companies.id],
			name: "jobs_end_client_company_id_fkey"
		}),
	foreignKey({
			columns: [table.hiringManagerContactId],
			foreignColumns: [contacts.id],
			name: "jobs_hiring_manager_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.hrContactId],
			foreignColumns: [contacts.id],
			name: "jobs_hr_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.intakeCompletedBy],
			foreignColumns: [userProfiles.id],
			name: "jobs_intake_completed_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "jobs_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.ownerId],
			foreignColumns: [userProfiles.id],
			name: "jobs_owner_id_fkey"
		}),
	foreignKey({
			columns: [table.publishedBy],
			foreignColumns: [userProfiles.id],
			name: "jobs_published_by_fkey"
		}),
	foreignKey({
			columns: [table.vendorCompanyId],
			foreignColumns: [companies.id],
			name: "jobs_vendor_company_id_fkey"
		}),
	pgPolicy("jobs_employee_read", { as: "permissive", for: "select", to: ["public"], using: sql`((auth_has_active_role('recruiter'::text) AND ((owner_id = auth.uid()) OR (auth.uid() = ANY (recruiter_ids)))) OR auth_has_active_role('bench_sales'::text) OR auth_has_active_role('ta_specialist'::text) OR auth_has_active_role('admin'::text))` }),
	pgPolicy("jobs_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	pgPolicy("jobs_recruiter_write", { as: "permissive", for: "all", to: ["public"] }),
	check("jobs_fee_type_check", sql`(fee_type IS NULL) OR ((fee_type)::text = ANY ((ARRAY['percentage'::character varying, 'flat'::character varying, 'hourly_spread'::character varying])::text[]))`),
]);

export const submissions = pgTable("submissions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	jobId: uuid("job_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	accountId: uuid("account_id"),
	status: text().default('sourced').notNull(),
	aiMatchScore: integer("ai_match_score"),
	recruiterMatchScore: integer("recruiter_match_score"),
	matchExplanation: text("match_explanation"),
	submittedRate: numeric("submitted_rate", { precision: 10, scale:  2 }),
	submittedRateType: text("submitted_rate_type").default('hourly'),
	submissionNotes: text("submission_notes"),
	submittedToClientAt: timestamp("submitted_to_client_at", { withTimezone: true, mode: 'string' }),
	submittedToClientBy: uuid("submitted_to_client_by"),
	clientResumeFileId: uuid("client_resume_file_id"),
	clientProfileUrl: text("client_profile_url"),
	interviewCount: integer("interview_count").default(0),
	lastInterviewDate: timestamp("last_interview_date", { withTimezone: true, mode: 'string' }),
	interviewFeedback: text("interview_feedback"),
	offerExtendedAt: timestamp("offer_extended_at", { withTimezone: true, mode: 'string' }),
	offerAcceptedAt: timestamp("offer_accepted_at", { withTimezone: true, mode: 'string' }),
	offerDeclinedAt: timestamp("offer_declined_at", { withTimezone: true, mode: 'string' }),
	offerDeclineReason: text("offer_decline_reason"),
	rejectedAt: timestamp("rejected_at", { withTimezone: true, mode: 'string' }),
	rejectionReason: text("rejection_reason"),
	rejectionSource: text("rejection_source"),
	ownerId: uuid("owner_id").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	vendorSubmittedAt: timestamp("vendor_submitted_at", { withTimezone: true, mode: 'string' }),
	vendorSubmittedBy: uuid("vendor_submitted_by"),
	vendorDecision: text("vendor_decision"),
	vendorDecisionAt: timestamp("vendor_decision_at", { withTimezone: true, mode: 'string' }),
	vendorDecisionBy: uuid("vendor_decision_by"),
	vendorNotes: text("vendor_notes"),
	vendorScreeningNotes: text("vendor_screening_notes"),
	vendorScreeningCompletedAt: timestamp("vendor_screening_completed_at", { withTimezone: true, mode: 'string' }),
	clientDecision: text("client_decision"),
	clientDecisionAt: timestamp("client_decision_at", { withTimezone: true, mode: 'string' }),
	clientDecisionNotes: text("client_decision_notes"),
	offerId: uuid("offer_id"),
	placementId: uuid("placement_id"),
	contactId: uuid("contact_id"),
	companyId: uuid("company_id"),
	submittedByCompanyId: uuid("submitted_by_company_id"),
	submittedByContactId: uuid("submitted_by_contact_id"),
	isVendorSubmission: boolean("is_vendor_submission").default(false),
	rtrObtained: boolean("rtr_obtained").default(false),
	rtrObtainedAt: timestamp("rtr_obtained_at", { withTimezone: true, mode: 'string' }),
	rtrExpiresAt: timestamp("rtr_expires_at", { withTimezone: true, mode: 'string' }),
	rtrDocumentId: uuid("rtr_document_id"),
	rateCardId: uuid("rate_card_id"),
	rateCardItemId: uuid("rate_card_item_id"),
	negotiatedBillRate: numeric("negotiated_bill_rate", { precision: 10, scale:  2 }),
	negotiatedPayRate: numeric("negotiated_pay_rate", { precision: 10, scale:  2 }),
	rateNegotiationNotes: text("rate_negotiation_notes"),
	statusEnteredAt: timestamp("status_entered_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	expectedDecisionDate: date("expected_decision_date"),
	submissionScore: integer("submission_score"),
	scoreBreakdown: jsonb("score_breakdown"),
	rankAmongSubmissions: integer("rank_among_submissions"),
	isDuplicate: boolean("is_duplicate").default(false),
	duplicateOfSubmissionId: uuid("duplicate_of_submission_id"),
}, (table) => [
	index("idx_submissions_account").using("btree", table.accountId.asc().nullsLast().op("uuid_ops")),
	index("idx_submissions_candidate").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")),
	index("idx_submissions_candidate_org").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops"), table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_submissions_client_decision").using("btree", table.clientDecision.asc().nullsLast().op("text_ops")).where(sql`(client_decision IS NOT NULL)`),
	index("idx_submissions_company_id").using("btree", table.companyId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_submissions_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_submissions_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_submissions_created").using("btree", table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_submissions_job").using("btree", table.jobId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_submissions_job_org").using("btree", table.jobId.asc().nullsLast().op("uuid_ops"), table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_submissions_offer_id").using("btree", table.offerId.asc().nullsLast().op("uuid_ops")),
	index("idx_submissions_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_submissions_owner").using("btree", table.ownerId.asc().nullsLast().op("uuid_ops")),
	index("idx_submissions_placement_id").using("btree", table.placementId.asc().nullsLast().op("uuid_ops")),
	index("idx_submissions_rtr").using("btree", table.rtrExpiresAt.asc().nullsLast().op("timestamptz_ops")).where(sql`((rtr_obtained = true) AND (deleted_at IS NULL))`),
	index("idx_submissions_score").using("btree", table.orgId.asc().nullsLast().op("int4_ops"), table.submissionScore.desc().nullsFirst().op("int4_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_submissions_status").using("btree", table.status.asc().nullsLast().op("text_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_submissions_status_entered").using("btree", table.statusEnteredAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(deleted_at IS NULL)`),
	uniqueIndex("idx_submissions_unique").using("btree", table.jobId.asc().nullsLast().op("uuid_ops"), table.candidateId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_submissions_vendor").using("btree", table.submittedByCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`((is_vendor_submission = true) AND (deleted_at IS NULL))`),
	index("idx_submissions_vendor_decision").using("btree", table.vendorDecision.asc().nullsLast().op("text_ops")).where(sql`(vendor_decision IS NOT NULL)`),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "submissions_candidate_id_fkey"
		}),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "submissions_company_id_fkey"
		}),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "submissions_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "submissions_created_by_fkey"
		}),
	foreignKey({
			columns: [table.duplicateOfSubmissionId],
			foreignColumns: [table.id],
			name: "submissions_duplicate_of_submission_id_fkey"
		}),
	foreignKey({
			columns: [table.jobId],
			foreignColumns: [jobs.id],
			name: "submissions_job_id_fkey"
		}),
	foreignKey({
			columns: [table.offerId],
			foreignColumns: [offers.id],
			name: "submissions_offer_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "submissions_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.ownerId],
			foreignColumns: [userProfiles.id],
			name: "submissions_owner_id_fkey"
		}),
	foreignKey({
			columns: [table.placementId],
			foreignColumns: [placements.id],
			name: "submissions_placement_id_fkey"
		}),
	foreignKey({
			columns: [table.rateCardId],
			foreignColumns: [rateCards.id],
			name: "submissions_rate_card_id_fkey"
		}),
	foreignKey({
			columns: [table.rateCardItemId],
			foreignColumns: [rateCardItems.id],
			name: "submissions_rate_card_item_id_fkey"
		}),
	foreignKey({
			columns: [table.rtrDocumentId],
			foreignColumns: [documents.id],
			name: "submissions_rtr_document_id_fkey"
		}),
	foreignKey({
			columns: [table.submittedByCompanyId],
			foreignColumns: [companies.id],
			name: "submissions_submitted_by_company_id_fkey"
		}),
	foreignKey({
			columns: [table.submittedByContactId],
			foreignColumns: [contacts.id],
			name: "submissions_submitted_by_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.submittedToClientBy],
			foreignColumns: [userProfiles.id],
			name: "submissions_submitted_to_client_by_fkey"
		}),
	foreignKey({
			columns: [table.vendorDecisionBy],
			foreignColumns: [userProfiles.id],
			name: "submissions_vendor_decision_by_fkey"
		}),
	foreignKey({
			columns: [table.vendorSubmittedBy],
			foreignColumns: [userProfiles.id],
			name: "submissions_vendor_submitted_by_fkey"
		}),
	pgPolicy("submissions_candidate_own_read", { as: "permissive", for: "select", to: ["public"], using: sql`(auth_has_role('candidate'::text) AND (candidate_id = auth.uid()))` }),
	pgPolicy("submissions_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	pgPolicy("submissions_recruiter_write", { as: "permissive", for: "all", to: ["public"] }),
	check("submissions_ai_match_score_check", sql`(ai_match_score >= 0) AND (ai_match_score <= 100)`),
	check("submissions_recruiter_match_score_check", sql`(recruiter_match_score >= 0) AND (recruiter_match_score <= 100)`),
	check("submissions_submission_score_check", sql`(submission_score IS NULL) OR ((submission_score >= 0) AND (submission_score <= 100))`),
]);

export const interviews = pgTable("interviews", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	submissionId: uuid("submission_id").notNull(),
	jobId: uuid("job_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	roundNumber: integer("round_number").default(1).notNull(),
	interviewType: text("interview_type").default('technical'),
	scheduledAt: timestamp("scheduled_at", { withTimezone: true, mode: 'string' }),
	durationMinutes: integer("duration_minutes").default(60),
	timezone: text().default('America/New_York'),
	meetingLink: text("meeting_link"),
	meetingLocation: text("meeting_location"),
	interviewerNames: text("interviewer_names").array(),
	interviewerEmails: text("interviewer_emails").array(),
	scheduledBy: uuid("scheduled_by"),
	status: text().default('scheduled').notNull(),
	cancellationReason: text("cancellation_reason"),
	feedback: text(),
	rating: integer(),
	recommendation: text(),
	submittedBy: uuid("submitted_by"),
	feedbackSubmittedAt: timestamp("feedback_submitted_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	orgId: uuid("org_id").notNull(),
	proposedTimes: jsonb("proposed_times").default([]),
	confirmedAt: timestamp("confirmed_at", { withTimezone: true, mode: 'string' }),
	confirmedBy: uuid("confirmed_by"),
	rescheduledAt: timestamp("rescheduled_at", { withTimezone: true, mode: 'string' }),
	rescheduledBy: uuid("rescheduled_by"),
	rescheduleReason: text("reschedule_reason"),
	rescheduleCount: integer("reschedule_count").default(0),
	cancelledAt: timestamp("cancelled_at", { withTimezone: true, mode: 'string' }),
	cancelledBy: uuid("cancelled_by"),
	cancellationNotes: text("cancellation_notes"),
	prepCompletedAt: timestamp("prep_completed_at", { withTimezone: true, mode: 'string' }),
	prepCompletedBy: uuid("prep_completed_by"),
	prepNotes: text("prep_notes"),
	prepChecklist: jsonb("prep_checklist").default([]),
	prepMaterialsSentAt: timestamp("prep_materials_sent_at", { withTimezone: true, mode: 'string' }),
	technicalRating: integer("technical_rating"),
	communicationRating: integer("communication_rating"),
	problemSolvingRating: integer("problem_solving_rating"),
	cultureFitRating: integer("culture_fit_rating"),
	strengths: text(),
	concerns: text(),
	description: text(),
	internalNotes: text("internal_notes"),
	location: text(),
	candidateExperience: text("candidate_experience"),
	candidateInterestLevel: text("candidate_interest_level"),
	candidateFeedback: text("candidate_feedback"),
	candidateConcerns: text("candidate_concerns"),
	attendanceStatus: text("attendance_status"),
	nextSteps: text("next_steps"),
	icsUid: text("ics_uid"),
	icsSequence: integer("ics_sequence").default(0),
	contactId: uuid("contact_id"),
	primaryInterviewerContactId: uuid("primary_interviewer_contact_id"),
	coordinatorContactId: uuid("coordinator_contact_id"),
	scorecardTemplateId: uuid("scorecard_template_id"),
	scorecardCompleted: boolean("scorecard_completed").default(false),
	scorecardCompletedAt: timestamp("scorecard_completed_at", { withTimezone: true, mode: 'string' }),
	hiringDecision: varchar("hiring_decision", { length: 50 }),
	decisionNotes: text("decision_notes"),
	calendarEventId: varchar("calendar_event_id", { length: 255 }),
	isPanel: boolean("is_panel").default(false),
}, (table) => [
	index("idx_interviews_attendance").using("btree", table.attendanceStatus.asc().nullsLast().op("text_ops")),
	index("idx_interviews_candidate").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")),
	index("idx_interviews_confirmed_at").using("btree", table.confirmedAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_interviews_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_interviews_hiring_decision").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.hiringDecision.asc().nullsLast().op("uuid_ops")).where(sql`(hiring_decision IS NOT NULL)`),
	index("idx_interviews_job").using("btree", table.jobId.asc().nullsLast().op("uuid_ops")),
	index("idx_interviews_org_id").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_interviews_prep_completed").using("btree", table.prepCompletedAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_interviews_primary_interviewer").using("btree", table.primaryInterviewerContactId.asc().nullsLast().op("uuid_ops")).where(sql`(primary_interviewer_contact_id IS NOT NULL)`),
	index("idx_interviews_proposed_times").using("gin", table.proposedTimes.asc().nullsLast().op("jsonb_ops")),
	index("idx_interviews_scheduled").using("btree", table.scheduledAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_interviews_scorecard_template").using("btree", table.scorecardTemplateId.asc().nullsLast().op("uuid_ops")).where(sql`(scorecard_template_id IS NOT NULL)`),
	index("idx_interviews_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_interviews_submission").using("btree", table.submissionId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.cancelledBy],
			foreignColumns: [userProfiles.id],
			name: "interviews_cancelled_by_fkey"
		}),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "interviews_candidate_id_fkey"
		}),
	foreignKey({
			columns: [table.confirmedBy],
			foreignColumns: [userProfiles.id],
			name: "interviews_confirmed_by_fkey"
		}),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "interviews_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.coordinatorContactId],
			foreignColumns: [contacts.id],
			name: "interviews_coordinator_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.jobId],
			foreignColumns: [jobs.id],
			name: "interviews_job_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "interviews_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.prepCompletedBy],
			foreignColumns: [userProfiles.id],
			name: "interviews_prep_completed_by_fkey"
		}),
	foreignKey({
			columns: [table.primaryInterviewerContactId],
			foreignColumns: [contacts.id],
			name: "interviews_primary_interviewer_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.rescheduledBy],
			foreignColumns: [userProfiles.id],
			name: "interviews_rescheduled_by_fkey"
		}),
	foreignKey({
			columns: [table.scheduledBy],
			foreignColumns: [userProfiles.id],
			name: "interviews_scheduled_by_fkey"
		}),
	foreignKey({
			columns: [table.submissionId],
			foreignColumns: [submissions.id],
			name: "interviews_submission_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.submittedBy],
			foreignColumns: [userProfiles.id],
			name: "interviews_submitted_by_fkey"
		}),
	pgPolicy("Users can manage interviews in their organization", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE (user_profiles.auth_id = auth.uid())))` }),
	pgPolicy("Users can view interviews in their organization", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("interviews_candidate_own", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("interviews_employee_all", { as: "permissive", for: "all", to: ["public"] }),
	check("interviews_attendance_status_check", sql`attendance_status = ANY (ARRAY['attended'::text, 'no_show'::text, 'cancelled'::text, 'rescheduled'::text])`),
	check("interviews_candidate_experience_check", sql`candidate_experience = ANY (ARRAY['great'::text, 'good'::text, 'okay'::text, 'poor'::text])`),
	check("interviews_candidate_interest_level_check", sql`candidate_interest_level = ANY (ARRAY['very_high'::text, 'high'::text, 'medium'::text, 'low'::text, 'withdrawn'::text])`),
	check("interviews_communication_rating_check", sql`(communication_rating >= 1) AND (communication_rating <= 5)`),
	check("interviews_culture_fit_rating_check", sql`(culture_fit_rating >= 1) AND (culture_fit_rating <= 5)`),
	check("interviews_hiring_decision_check", sql`(hiring_decision IS NULL) OR ((hiring_decision)::text = ANY ((ARRAY['strong_hire'::character varying, 'hire'::character varying, 'neutral'::character varying, 'no_hire'::character varying, 'strong_no_hire'::character varying])::text[]))`),
	check("interviews_next_steps_check", sql`next_steps = ANY (ARRAY['schedule_next_round'::text, 'extend_offer'::text, 'reject'::text, 'on_hold'::text])`),
	check("interviews_problem_solving_rating_check", sql`(problem_solving_rating >= 1) AND (problem_solving_rating <= 5)`),
	check("interviews_rating_check", sql`(rating >= 1) AND (rating <= 5)`),
	check("interviews_technical_rating_check", sql`(technical_rating >= 1) AND (technical_rating <= 5)`),
]);

export const interviewParticipants = pgTable("interview_participants", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	interviewId: uuid("interview_id").notNull(),
	participantType: text("participant_type").notNull(),
	userId: uuid("user_id"),
	externalName: text("external_name"),
	externalEmail: text("external_email"),
	isRequired: boolean("is_required").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	contactId: uuid("contact_id"),
	role: varchar({ length: 50 }).default('interviewer'),
	isConfirmed: boolean("is_confirmed").default(false),
	confirmedAt: timestamp("confirmed_at", { withTimezone: true, mode: 'string' }),
	feedbackSubmitted: boolean("feedback_submitted").default(false),
	feedbackSubmittedAt: timestamp("feedback_submitted_at", { withTimezone: true, mode: 'string' }),
	overallRating: integer("overall_rating"),
	recommendation: varchar({ length: 50 }),
	feedbackNotes: text("feedback_notes"),
	calendarSynced: boolean("calendar_synced").default(false),
	calendarEventId: varchar("calendar_event_id", { length: 255 }),
}, (table) => [
	index("idx_interview_participants_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_interview_participants_interview").using("btree", table.interviewId.asc().nullsLast().op("uuid_ops")),
	index("idx_interview_participants_interview_id").using("btree", table.interviewId.asc().nullsLast().op("uuid_ops")),
	index("idx_interview_participants_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	uniqueIndex("idx_interview_participants_unique_contact").using("btree", table.interviewId.asc().nullsLast().op("uuid_ops"), table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	uniqueIndex("idx_interview_participants_unique_user").using("btree", table.interviewId.asc().nullsLast().op("uuid_ops"), table.userId.asc().nullsLast().op("uuid_ops")).where(sql`(user_id IS NOT NULL)`),
	index("idx_interview_participants_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")).where(sql`(user_id IS NOT NULL)`),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "interview_participants_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.interviewId],
			foreignColumns: [interviews.id],
			name: "interview_participants_interview_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "interview_participants_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "interview_participants_user_id_fkey"
		}),
	pgPolicy("interview_participants_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("interview_participants_overall_rating_check", sql`(overall_rating IS NULL) OR ((overall_rating >= 1) AND (overall_rating <= 5))`),
	check("interview_participants_recommendation_check", sql`(recommendation IS NULL) OR ((recommendation)::text = ANY ((ARRAY['strong_hire'::character varying, 'hire'::character varying, 'neutral'::character varying, 'no_hire'::character varying, 'strong_no_hire'::character varying])::text[]))`),
	check("interview_participants_role_check", sql`(role IS NULL) OR ((role)::text = ANY ((ARRAY['lead_interviewer'::character varying, 'interviewer'::character varying, 'shadow'::character varying, 'observer'::character varying, 'note_taker'::character varying, 'hiring_manager'::character varying])::text[]))`),
]);

export const interviewScorecards = pgTable("interview_scorecards", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	interviewId: uuid("interview_id").notNull(),
	participantId: uuid("participant_id"),
	submittedBy: uuid("submitted_by").notNull(),
	overallRating: integer("overall_rating").notNull(),
	recommendation: varchar({ length: 50 }).notNull(),
	criteriaScores: jsonb("criteria_scores").default({}).notNull(),
	strengths: text().array(),
	concerns: text().array(),
	additionalNotes: text("additional_notes"),
	questionsAsked: jsonb("questions_asked"),
	wouldWorkWith: boolean("would_work_with"),
	wouldRecommendForDifferentRole: boolean("would_recommend_for_different_role").default(false),
	alternativeRoleNotes: text("alternative_role_notes"),
	isSubmitted: boolean("is_submitted").default(false),
	submittedAt: timestamp("submitted_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_interview_scorecards_interview").using("btree", table.interviewId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_interview_scorecards_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_interview_scorecards_participant").using("btree", table.participantId.asc().nullsLast().op("uuid_ops")).where(sql`((participant_id IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_interview_scorecards_submitted_by").using("btree", table.submittedBy.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.interviewId],
			foreignColumns: [interviews.id],
			name: "interview_scorecards_interview_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "interview_scorecards_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.participantId],
			foreignColumns: [interviewParticipants.id],
			name: "interview_scorecards_participant_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.submittedBy],
			foreignColumns: [userProfiles.id],
			name: "interview_scorecards_submitted_by_fkey"
		}),
	pgPolicy("interview_scorecards_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("interview_scorecards_overall_rating_check", sql`(overall_rating >= 1) AND (overall_rating <= 5)`),
	check("interview_scorecards_recommendation_check", sql`(recommendation)::text = ANY ((ARRAY['strong_hire'::character varying, 'hire'::character varying, 'neutral'::character varying, 'no_hire'::character varying, 'strong_no_hire'::character varying])::text[])`),
]);

export const scorecardTemplates = pgTable("scorecard_templates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: varchar({ length: 255 }).notNull(),
	description: text(),
	interviewType: varchar("interview_type", { length: 50 }),
	jobCategory: varchar("job_category", { length: 100 }),
	criteria: jsonb().default([]).notNull(),
	ratingScale: integer("rating_scale").default(5),
	ratingLabels: jsonb("rating_labels"),
	requiredQuestions: jsonb("required_questions"),
	isDefault: boolean("is_default").default(false),
	isActive: boolean("is_active").default(true),
	createdBy: uuid("created_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_scorecard_templates_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`((deleted_at IS NULL) AND (is_active = true))`),
	index("idx_scorecard_templates_type").using("btree", table.interviewType.asc().nullsLast().op("text_ops")).where(sql`((deleted_at IS NULL) AND (is_active = true))`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "scorecard_templates_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "scorecard_templates_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("scorecard_templates_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("scorecard_templates_rating_scale_check", sql`rating_scale = ANY (ARRAY[3, 4, 5, 10])`),
]);

export const placements = pgTable("placements", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	submissionId: uuid("submission_id").notNull(),
	offerId: uuid("offer_id"),
	jobId: uuid("job_id").notNull(),
	candidateId: uuid("candidate_id").notNull(),
	placementType: text("placement_type").default('contract'),
	startDate: date("start_date").notNull(),
	endDate: date("end_date"),
	billRate: numeric("bill_rate", { precision: 10, scale:  2 }).notNull(),
	payRate: numeric("pay_rate", { precision: 10, scale:  2 }).notNull(),
	markupPercentage: numeric("markup_percentage", { precision: 5, scale:  2 }).generatedAlwaysAs(sql`round((((bill_rate - pay_rate) / pay_rate) * (100)::numeric), 2)`),
	status: text().default('active').notNull(),
	endReason: text("end_reason"),
	actualEndDate: date("actual_end_date"),
	totalRevenue: numeric("total_revenue", { precision: 12, scale:  2 }),
	totalPaid: numeric("total_paid", { precision: 12, scale:  2 }),
	onboardingStatus: text("onboarding_status").default('pending'),
	onboardingCompletedAt: timestamp("onboarding_completed_at", { withTimezone: true, mode: 'string' }),
	performanceRating: integer("performance_rating"),
	extensionCount: integer("extension_count").default(0),
	recruiterId: uuid("recruiter_id").notNull(),
	accountManagerId: uuid("account_manager_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	healthStatus: varchar("health_status", { length: 20 }).default('healthy'),
	nextCheckInDate: date("next_check_in_date"),
	lastCheckInDate: date("last_check_in_date"),
	lastCheckInBy: uuid("last_check_in_by"),
	rateType: varchar("rate_type", { length: 20 }).default('hourly'),
	employmentType: varchar("employment_type", { length: 20 }).default('w2'),
	workLocation: varchar("work_location", { length: 20 }).default('remote'),
	workSchedule: varchar("work_schedule", { length: 100 }),
	timezone: varchar({ length: 50 }).default('America/New_York'),
	onboardingFormat: varchar("onboarding_format", { length: 20 }).default('virtual'),
	firstDayMeetingLink: text("first_day_meeting_link"),
	firstDayLocation: text("first_day_location"),
	hiringManagerName: varchar("hiring_manager_name", { length: 100 }),
	hiringManagerEmail: varchar("hiring_manager_email", { length: 200 }),
	hiringManagerPhone: varchar("hiring_manager_phone", { length: 30 }),
	hrContactName: varchar("hr_contact_name", { length: 100 }),
	hrContactEmail: varchar("hr_contact_email", { length: 200 }),
	paperworkComplete: boolean("paperwork_complete").default(false),
	backgroundCheckStatus: varchar("background_check_status", { length: 20 }),
	i9Complete: boolean("i9_complete").default(false),
	ndaSigned: boolean("nda_signed").default(false),
	equipmentOrdered: boolean("equipment_ordered").default(false),
	equipmentNotes: text("equipment_notes"),
	internalNotes: text("internal_notes"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	contactId: uuid("contact_id"),
	companyId: uuid("company_id"),
	billingCompanyId: uuid("billing_company_id"),
	endClientCompanyId: uuid("end_client_company_id"),
	clientCompanyId: uuid("client_company_id"),
	vendorCompanyId: uuid("vendor_company_id"),
	clientManagerContactId: uuid("client_manager_contact_id"),
	hrContactId: uuid("hr_contact_id"),
	reportingManagerContactId: uuid("reporting_manager_contact_id"),
	contractId: uuid("contract_id"),
	rateCardId: uuid("rate_card_id"),
	rateCardItemId: uuid("rate_card_item_id"),
	hasChangeOrders: boolean("has_change_orders").default(false),
	activeChangeOrderId: uuid("active_change_order_id"),
	changeOrderCount: integer("change_order_count").default(0),
	originalEndDate: date("original_end_date"),
	originalBillRate: numeric("original_bill_rate", { precision: 10, scale:  2 }),
	approvalStatus: varchar("approval_status", { length: 50 }).default('pending'),
	approvedBy: uuid("approved_by"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	expectedHoursPerWeek: numeric("expected_hours_per_week", { precision: 5, scale:  2 }).default('40'),
	overtimeEligible: boolean("overtime_eligible").default(true),
	expensesAllowed: boolean("expenses_allowed").default(true),
	expenseBudget: numeric("expense_budget", { precision: 10, scale:  2 }),
	complianceStatus: varchar("compliance_status", { length: 50 }).default('pending'),
	complianceClearedAt: timestamp("compliance_cleared_at", { withTimezone: true, mode: 'string' }),
	complianceExpiresAt: timestamp("compliance_expires_at", { withTimezone: true, mode: 'string' }),
	workArrangement: varchar("work_arrangement", { length: 50 }).default('onsite'),
	hybridDaysPerWeek: integer("hybrid_days_per_week"),
	workAddressId: uuid("work_address_id"),
}, (table) => [
	index("idx_placements_approval").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.approvalStatus.asc().nullsLast().op("text_ops")).where(sql`(((approval_status)::text = 'pending'::text) AND (deleted_at IS NULL))`),
	index("idx_placements_billing_company").using("btree", table.billingCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`(billing_company_id IS NOT NULL)`),
	index("idx_placements_candidate").using("btree", table.candidateId.asc().nullsLast().op("uuid_ops")),
	index("idx_placements_client_company").using("btree", table.clientCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_placements_company_id").using("btree", table.companyId.asc().nullsLast().op("uuid_ops")),
	index("idx_placements_compliance").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.complianceStatus.asc().nullsLast().op("text_ops")).where(sql`((status = 'active'::text) AND (deleted_at IS NULL))`),
	index("idx_placements_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_placements_contact_id").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_placements_contract").using("btree", table.contractId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_placements_end_client").using("btree", table.endClientCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`(end_client_company_id IS NOT NULL)`),
	index("idx_placements_health_status").using("btree", table.healthStatus.asc().nullsLast().op("text_ops")),
	index("idx_placements_job").using("btree", table.jobId.asc().nullsLast().op("uuid_ops")),
	index("idx_placements_next_check_in").using("btree", table.nextCheckInDate.asc().nullsLast().op("date_ops")),
	index("idx_placements_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_placements_recruiter").using("btree", table.recruiterId.asc().nullsLast().op("uuid_ops")),
	index("idx_placements_start_date").using("btree", table.startDate.desc().nullsFirst().op("date_ops")),
	index("idx_placements_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_placements_vendor").using("btree", table.vendorCompanyId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.accountManagerId],
			foreignColumns: [userProfiles.id],
			name: "placements_account_manager_id_fkey"
		}),
	foreignKey({
			columns: [table.approvedBy],
			foreignColumns: [userProfiles.id],
			name: "placements_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.billingCompanyId],
			foreignColumns: [companies.id],
			name: "placements_billing_company_id_fkey"
		}),
	foreignKey({
			columns: [table.candidateId],
			foreignColumns: [userProfiles.id],
			name: "placements_candidate_id_fkey"
		}),
	foreignKey({
			columns: [table.clientCompanyId],
			foreignColumns: [companies.id],
			name: "placements_client_company_id_fkey"
		}),
	foreignKey({
			columns: [table.clientManagerContactId],
			foreignColumns: [contacts.id],
			name: "placements_client_manager_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "placements_company_id_fkey"
		}),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "placements_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.contractId],
			foreignColumns: [contracts.id],
			name: "placements_contract_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "placements_created_by_fkey"
		}),
	foreignKey({
			columns: [table.endClientCompanyId],
			foreignColumns: [companies.id],
			name: "placements_end_client_company_id_fkey"
		}),
	foreignKey({
			columns: [table.hrContactId],
			foreignColumns: [contacts.id],
			name: "placements_hr_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.jobId],
			foreignColumns: [jobs.id],
			name: "placements_job_id_fkey"
		}),
	foreignKey({
			columns: [table.lastCheckInBy],
			foreignColumns: [userProfiles.id],
			name: "placements_last_check_in_by_fkey"
		}),
	foreignKey({
			columns: [table.offerId],
			foreignColumns: [offers.id],
			name: "placements_offer_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "placements_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.rateCardId],
			foreignColumns: [rateCards.id],
			name: "placements_rate_card_id_fkey"
		}),
	foreignKey({
			columns: [table.rateCardItemId],
			foreignColumns: [rateCardItems.id],
			name: "placements_rate_card_item_id_fkey"
		}),
	foreignKey({
			columns: [table.recruiterId],
			foreignColumns: [userProfiles.id],
			name: "placements_recruiter_id_fkey"
		}),
	foreignKey({
			columns: [table.reportingManagerContactId],
			foreignColumns: [contacts.id],
			name: "placements_reporting_manager_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.submissionId],
			foreignColumns: [submissions.id],
			name: "placements_submission_id_fkey"
		}),
	foreignKey({
			columns: [table.vendorCompanyId],
			foreignColumns: [companies.id],
			name: "placements_vendor_company_id_fkey"
		}),
	foreignKey({
			columns: [table.workAddressId],
			foreignColumns: [addresses.id],
			name: "placements_work_address_id_fkey"
		}),
	pgPolicy("placements_candidate_own", { as: "permissive", for: "select", to: ["public"], using: sql`(candidate_id = auth.uid())` }),
	pgPolicy("placements_employee_all", { as: "permissive", for: "all", to: ["public"] }),
	pgPolicy("placements_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	check("placements_approval_status_check", sql`(approval_status IS NULL) OR ((approval_status)::text = ANY ((ARRAY['pending'::character varying, 'approved'::character varying, 'rejected'::character varying, 'expired'::character varying])::text[]))`),
	check("placements_background_check_status_check", sql`(background_check_status)::text = ANY ((ARRAY['pending'::character varying, 'passed'::character varying, 'failed'::character varying, 'waived'::character varying])::text[])`),
	check("placements_compliance_status_check", sql`(compliance_status IS NULL) OR ((compliance_status)::text = ANY ((ARRAY['pending'::character varying, 'in_progress'::character varying, 'complete'::character varying, 'expired'::character varying, 'blocked'::character varying])::text[]))`),
	check("placements_health_status_check", sql`(health_status)::text = ANY ((ARRAY['healthy'::character varying, 'at_risk'::character varying, 'critical'::character varying])::text[])`),
	check("placements_onboarding_format_check", sql`(onboarding_format)::text = ANY ((ARRAY['virtual'::character varying, 'in_person'::character varying, 'hybrid'::character varying])::text[])`),
	check("placements_performance_rating_check", sql`(performance_rating >= 1) AND (performance_rating <= 5)`),
	check("placements_work_arrangement_check", sql`(work_arrangement IS NULL) OR ((work_arrangement)::text = ANY ((ARRAY['onsite'::character varying, 'remote'::character varying, 'hybrid'::character varying])::text[]))`),
]);

export const placementVendors = pgTable("placement_vendors", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	placementId: uuid("placement_id").notNull(),
	vendorCompanyId: uuid("vendor_company_id").notNull(),
	vendorType: varchar("vendor_type", { length: 50 }).notNull(),
	positionInChain: integer("position_in_chain").default(1).notNull(),
	billRate: numeric("bill_rate", { precision: 10, scale:  2 }),
	payRate: numeric("pay_rate", { precision: 10, scale:  2 }),
	markupPercentage: numeric("markup_percentage", { precision: 5, scale:  2 }),
	marginAmount: numeric("margin_amount", { precision: 10, scale:  2 }),
	vendorContactId: uuid("vendor_contact_id"),
	vendorContractId: uuid("vendor_contract_id"),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_placement_vendors_company").using("btree", table.vendorCompanyId.asc().nullsLast().op("uuid_ops")),
	index("idx_placement_vendors_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_placement_vendors_placement").using("btree", table.placementId.asc().nullsLast().op("uuid_ops")),
	uniqueIndex("idx_placement_vendors_unique").using("btree", table.placementId.asc().nullsLast().op("int4_ops"), table.vendorCompanyId.asc().nullsLast().op("uuid_ops"), table.positionInChain.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "placement_vendors_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.placementId],
			foreignColumns: [placements.id],
			name: "placement_vendors_placement_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.vendorCompanyId],
			foreignColumns: [companies.id],
			name: "placement_vendors_vendor_company_id_fkey"
		}),
	foreignKey({
			columns: [table.vendorContactId],
			foreignColumns: [contacts.id],
			name: "placement_vendors_vendor_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.vendorContractId],
			foreignColumns: [contracts.id],
			name: "placement_vendors_vendor_contract_id_fkey"
		}),
	pgPolicy("placement_vendors_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("placement_vendors_vendor_type_check", sql`(vendor_type)::text = ANY ((ARRAY['primary'::character varying, 'sub_vendor'::character varying, 'end_client'::character varying, 'implementation_partner'::character varying])::text[])`),
]);

export const placementChangeOrders = pgTable("placement_change_orders", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	placementId: uuid("placement_id").notNull(),
	changeType: varchar("change_type", { length: 50 }).notNull(),
	originalEndDate: date("original_end_date"),
	originalBillRate: numeric("original_bill_rate", { precision: 10, scale:  2 }),
	originalPayRate: numeric("original_pay_rate", { precision: 10, scale:  2 }),
	originalHoursPerWeek: numeric("original_hours_per_week", { precision: 5, scale:  2 }),
	newEndDate: date("new_end_date"),
	newBillRate: numeric("new_bill_rate", { precision: 10, scale:  2 }),
	newPayRate: numeric("new_pay_rate", { precision: 10, scale:  2 }),
	newHoursPerWeek: numeric("new_hours_per_week", { precision: 5, scale:  2 }),
	effectiveDate: date("effective_date").notNull(),
	reason: text(),
	notes: text(),
	status: varchar({ length: 50 }).default('pending'),
	requestedBy: uuid("requested_by"),
	requestedAt: timestamp("requested_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	approvedBy: uuid("approved_by"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	appliedAt: timestamp("applied_at", { withTimezone: true, mode: 'string' }),
	documentId: uuid("document_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_placement_change_orders_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_placement_change_orders_placement").using("btree", table.placementId.asc().nullsLast().op("uuid_ops")),
	index("idx_placement_change_orders_status").using("btree", table.status.asc().nullsLast().op("text_ops")).where(sql`((status)::text = 'pending'::text)`),
	foreignKey({
			columns: [table.approvedBy],
			foreignColumns: [userProfiles.id],
			name: "placement_change_orders_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.documentId],
			foreignColumns: [documents.id],
			name: "placement_change_orders_document_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "placement_change_orders_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.placementId],
			foreignColumns: [placements.id],
			name: "placement_change_orders_placement_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.requestedBy],
			foreignColumns: [userProfiles.id],
			name: "placement_change_orders_requested_by_fkey"
		}),
	pgPolicy("placement_change_orders_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("placement_change_orders_change_type_check", sql`(change_type)::text = ANY ((ARRAY['extension'::character varying, 'rate_change'::character varying, 'hours_change'::character varying, 'role_change'::character varying, 'location_change'::character varying, 'other'::character varying])::text[])`),
	check("placement_change_orders_status_check", sql`(status)::text = ANY ((ARRAY['pending'::character varying, 'approved'::character varying, 'rejected'::character varying, 'applied'::character varying])::text[])`),
]);

export const placementCheckins = pgTable("placement_checkins", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	placementId: uuid("placement_id").notNull(),
	checkinType: varchar("checkin_type", { length: 20 }).notNull(),
	checkinDate: date("checkin_date").notNull(),
	candidateContactMethod: varchar("candidate_contact_method", { length: 20 }),
	candidateResponseStatus: varchar("candidate_response_status", { length: 20 }),
	candidateOverallSatisfaction: varchar("candidate_overall_satisfaction", { length: 20 }),
	candidateRoleSatisfaction: varchar("candidate_role_satisfaction", { length: 20 }),
	candidateTeamRelationship: varchar("candidate_team_relationship", { length: 20 }),
	candidateWorkload: varchar("candidate_workload", { length: 20 }),
	candidatePaymentStatus: varchar("candidate_payment_status", { length: 20 }),
	candidateExtensionInterest: varchar("candidate_extension_interest", { length: 30 }),
	candidateSentiment: varchar("candidate_sentiment", { length: 20 }),
	candidateConcerns: text("candidate_concerns"),
	candidateNotes: text("candidate_notes"),
	clientContactMethod: varchar("client_contact_method", { length: 20 }),
	clientContactId: uuid("client_contact_id"),
	clientPerformanceRating: varchar("client_performance_rating", { length: 20 }),
	clientTeamIntegration: varchar("client_team_integration", { length: 20 }),
	clientWorkQuality: varchar("client_work_quality", { length: 20 }),
	clientCommunication: varchar("client_communication", { length: 20 }),
	clientExtensionInterest: varchar("client_extension_interest", { length: 20 }),
	clientSatisfaction: varchar("client_satisfaction", { length: 20 }),
	clientConcerns: text("client_concerns"),
	clientNotes: text("client_notes"),
	overallHealth: varchar("overall_health", { length: 20 }).notNull(),
	riskFactors: text("risk_factors").array(),
	actionItems: jsonb("action_items").default([]),
	nextCheckinDate: date("next_checkin_date"),
	followUpRequired: varchar("follow_up_required", { length: 20 }),
	escalatedTo: uuid("escalated_to"),
	conductedBy: uuid("conducted_by").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	completedBy: uuid("completed_by"),
	followUpDate: date("follow_up_date"),
	healthScore: integer("health_score"),
	healthAssessment: varchar("health_assessment", { length: 50 }),
}, (table) => [
	index("idx_placement_checkins_date").using("btree", table.checkinDate.asc().nullsLast().op("date_ops")),
	index("idx_placement_checkins_health").using("btree", table.overallHealth.asc().nullsLast().op("text_ops")),
	index("idx_placement_checkins_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_placement_checkins_pending").using("btree", table.checkinDate.asc().nullsLast().op("date_ops")).where(sql`(completed_at IS NULL)`),
	index("idx_placement_checkins_placement").using("btree", table.placementId.asc().nullsLast().op("uuid_ops")),
	index("idx_placement_checkins_type").using("btree", table.checkinType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.clientContactId],
			foreignColumns: [userProfiles.id],
			name: "placement_checkins_client_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.completedBy],
			foreignColumns: [userProfiles.id],
			name: "placement_checkins_completed_by_fkey"
		}),
	foreignKey({
			columns: [table.conductedBy],
			foreignColumns: [userProfiles.id],
			name: "placement_checkins_conducted_by_fkey"
		}),
	foreignKey({
			columns: [table.escalatedTo],
			foreignColumns: [userProfiles.id],
			name: "placement_checkins_escalated_to_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "placement_checkins_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.placementId],
			foreignColumns: [placements.id],
			name: "placement_checkins_placement_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("Users can insert placement checkins for their org", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(org_id IN ( SELECT user_profiles.org_id
   FROM user_profiles
  WHERE ((user_profiles.id = auth.uid()) OR (user_profiles.auth_id = auth.uid()))))`  }),
	pgPolicy("Users can update their org's placement checkins", { as: "permissive", for: "update", to: ["public"] }),
	pgPolicy("Users can view their org's placement checkins", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("placement_checkins_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	check("placement_checkins_candidate_contact_method_check", sql`(candidate_contact_method)::text = ANY ((ARRAY['phone'::character varying, 'video'::character varying, 'in_person'::character varying, 'email'::character varying])::text[])`),
	check("placement_checkins_candidate_extension_interest_check", sql`(candidate_extension_interest)::text = ANY ((ARRAY['definitely_interested'::character varying, 'probably_interested'::character varying, 'unsure'::character varying, 'not_interested'::character varying, 'too_early'::character varying])::text[])`),
	check("placement_checkins_candidate_overall_satisfaction_check", sql`(candidate_overall_satisfaction)::text = ANY ((ARRAY['excellent'::character varying, 'good'::character varying, 'fair'::character varying, 'poor'::character varying])::text[])`),
	check("placement_checkins_candidate_payment_status_check", sql`(candidate_payment_status)::text = ANY ((ARRAY['no_issues'::character varying, 'minor_delay'::character varying, 'major_issue'::character varying])::text[])`),
	check("placement_checkins_candidate_response_status_check", sql`(candidate_response_status)::text = ANY ((ARRAY['completed'::character varying, 'scheduled'::character varying, 'left_message'::character varying, 'no_response'::character varying])::text[])`),
	check("placement_checkins_candidate_role_satisfaction_check", sql`(candidate_role_satisfaction)::text = ANY ((ARRAY['very_satisfied'::character varying, 'satisfied'::character varying, 'neutral'::character varying, 'unsatisfied'::character varying])::text[])`),
	check("placement_checkins_candidate_sentiment_check", sql`(candidate_sentiment)::text = ANY ((ARRAY['very_positive'::character varying, 'positive'::character varying, 'neutral'::character varying, 'negative'::character varying])::text[])`),
	check("placement_checkins_candidate_team_relationship_check", sql`(candidate_team_relationship)::text = ANY ((ARRAY['excellent'::character varying, 'good'::character varying, 'fair'::character varying, 'poor'::character varying])::text[])`),
	check("placement_checkins_candidate_workload_check", sql`(candidate_workload)::text = ANY ((ARRAY['just_right'::character varying, 'a_bit_much'::character varying, 'too_much'::character varying, 'too_little'::character varying])::text[])`),
	check("placement_checkins_checkin_type_check", sql`(checkin_type)::text = ANY ((ARRAY['7_day'::character varying, '30_day'::character varying, '60_day'::character varying, '90_day'::character varying, 'ad_hoc'::character varying])::text[])`),
	check("placement_checkins_client_communication_check", sql`(client_communication)::text = ANY ((ARRAY['excellent'::character varying, 'good'::character varying, 'fair'::character varying, 'poor'::character varying])::text[])`),
	check("placement_checkins_client_contact_method_check", sql`(client_contact_method)::text = ANY ((ARRAY['phone'::character varying, 'video'::character varying, 'in_person'::character varying, 'email'::character varying])::text[])`),
	check("placement_checkins_client_extension_interest_check", sql`(client_extension_interest)::text = ANY ((ARRAY['definitely'::character varying, 'probably'::character varying, 'unsure'::character varying, 'probably_not'::character varying])::text[])`),
	check("placement_checkins_client_performance_rating_check", sql`(client_performance_rating)::text = ANY ((ARRAY['exceeds'::character varying, 'meets'::character varying, 'below'::character varying, 'not_meeting'::character varying])::text[])`),
	check("placement_checkins_client_satisfaction_check", sql`(client_satisfaction)::text = ANY ((ARRAY['very_satisfied'::character varying, 'satisfied'::character varying, 'neutral'::character varying, 'unsatisfied'::character varying])::text[])`),
	check("placement_checkins_client_team_integration_check", sql`(client_team_integration)::text = ANY ((ARRAY['excellent'::character varying, 'good'::character varying, 'fair'::character varying, 'poor'::character varying])::text[])`),
	check("placement_checkins_client_work_quality_check", sql`(client_work_quality)::text = ANY ((ARRAY['excellent'::character varying, 'good'::character varying, 'fair'::character varying, 'poor'::character varying])::text[])`),
	check("placement_checkins_follow_up_required_check", sql`(follow_up_required)::text = ANY ((ARRAY['none'::character varying, 'scheduled'::character varying, 'escalate'::character varying])::text[])`),
	check("placement_checkins_health_assessment_check", sql`(health_assessment IS NULL) OR ((health_assessment)::text = ANY ((ARRAY['healthy'::character varying, 'minor_concerns'::character varying, 'at_risk'::character varying, 'critical'::character varying])::text[]))`),
	check("placement_checkins_health_score_check", sql`(health_score IS NULL) OR ((health_score >= 0) AND (health_score <= 100))`),
	check("placement_checkins_overall_health_check", sql`(overall_health)::text = ANY ((ARRAY['excellent'::character varying, 'good'::character varying, 'at_risk'::character varying, 'critical'::character varying])::text[])`),
]);

export const onboardingTasks = pgTable("onboarding_tasks", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	onboardingId: uuid("onboarding_id").notNull(),
	taskName: text("task_name").notNull(),
	category: taskCategory().default('other').notNull(),
	description: text(),
	isRequired: boolean("is_required").default(true),
	dueDaysFromStart: integer("due_days_from_start"),
	status: taskStatus().default('pending').notNull(),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	completedBy: uuid("completed_by"),
	notes: text(),
	sortOrder: integer("sort_order").default(0).notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	orgId: uuid("org_id"),
	assignedTo: uuid("assigned_to"),
	dueDate: date("due_date"),
	complianceItemId: uuid("compliance_item_id"),
	documentId: uuid("document_id"),
	skipReason: text("skip_reason"),
}, (table) => [
	index("idx_onboarding_tasks_assigned").using("btree", table.assignedTo.asc().nullsLast().op("uuid_ops")).where(sql`(assigned_to IS NOT NULL)`),
	index("idx_onboarding_tasks_due").using("btree", table.dueDate.asc().nullsLast().op("date_ops")).where(sql`((status = 'pending'::task_status) AND (due_date IS NOT NULL))`),
	index("idx_onboarding_tasks_onboarding_id").using("btree", table.onboardingId.asc().nullsLast().op("uuid_ops")),
	index("idx_onboarding_tasks_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(org_id IS NOT NULL)`),
	index("idx_onboarding_tasks_status").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.assignedTo],
			foreignColumns: [userProfiles.id],
			name: "onboarding_tasks_assigned_to_fkey"
		}),
	foreignKey({
			columns: [table.completedBy],
			foreignColumns: [userProfiles.id],
			name: "onboarding_tasks_completed_by_fkey"
		}),
	foreignKey({
			columns: [table.documentId],
			foreignColumns: [documents.id],
			name: "onboarding_tasks_document_id_fkey"
		}),
	foreignKey({
			columns: [table.onboardingId],
			foreignColumns: [employeeOnboarding.id],
			name: "onboarding_tasks_onboarding_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "onboarding_tasks_org_id_fkey"
		}),
]);

export const employeeOnboarding = pgTable("employee_onboarding", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	employeeId: uuid("employee_id").notNull(),
	checklistTemplateId: uuid("checklist_template_id"),
	status: onboardingStatus().default('not_started').notNull(),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	assignedTo: uuid("assigned_to"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	orgId: uuid("org_id"),
	contactId: uuid("contact_id"),
}, (table) => [
	index("idx_employee_onboarding_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_employee_onboarding_employee_id").using("btree", table.employeeId.asc().nullsLast().op("uuid_ops")),
	index("idx_employee_onboarding_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_employee_onboarding_status").using("btree", table.status.asc().nullsLast().op("enum_ops")),
	index("idx_employee_onboarding_status_active").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("uuid_ops")).where(sql`(status = ANY (ARRAY['not_started'::onboarding_status, 'in_progress'::onboarding_status]))`),
	foreignKey({
			columns: [table.assignedTo],
			foreignColumns: [userProfiles.id],
			name: "employee_onboarding_assigned_to_fkey"
		}),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "employee_onboarding_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "employee_onboarding_created_by_fkey"
		}),
	foreignKey({
			columns: [table.employeeId],
			foreignColumns: [employees.id],
			name: "employee_onboarding_employee_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "employee_onboarding_org_id_fkey"
		}),
	foreignKey({
			columns: [table.checklistTemplateId],
			foreignColumns: [onboardingTemplates.id],
			name: "employee_onboarding_template_fkey"
		}),
]);

export const onboardingTemplates = pgTable("onboarding_templates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: varchar({ length: 200 }).notNull(),
	description: text(),
	employeeType: varchar("employee_type", { length: 50 }),
	department: varchar({ length: 100 }),
	isDefault: boolean("is_default").default(false),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
}, (table) => [
	index("idx_onboarding_templates_active").using("btree", table.orgId.asc().nullsLast().op("bool_ops"), table.isActive.asc().nullsLast().op("bool_ops")).where(sql`((deleted_at IS NULL) AND (is_active = true))`),
	index("idx_onboarding_templates_default").using("btree", table.orgId.asc().nullsLast().op("bool_ops"), table.isDefault.asc().nullsLast().op("uuid_ops")).where(sql`((deleted_at IS NULL) AND (is_default = true))`),
	index("idx_onboarding_templates_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "onboarding_templates_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "onboarding_templates_org_id_fkey"
		}),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "onboarding_templates_updated_by_fkey"
		}),
	pgPolicy("onboarding_templates_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const onboardingTemplateTasks = pgTable("onboarding_template_tasks", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	templateId: uuid("template_id").notNull(),
	taskName: varchar("task_name", { length: 200 }).notNull(),
	description: text(),
	category: taskCategory().default('other').notNull(),
	dueOffsetDays: integer("due_offset_days").default(0),
	isRequired: boolean("is_required").default(true),
	sortOrder: integer("sort_order").default(0),
	assigneeRole: varchar("assignee_role", { length: 100 }),
	complianceRequirementId: uuid("compliance_requirement_id"),
	documentTemplateId: uuid("document_template_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_onboarding_template_tasks_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_onboarding_template_tasks_template").using("btree", table.templateId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.documentTemplateId],
			foreignColumns: [documents.id],
			name: "onboarding_template_tasks_document_template_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "onboarding_template_tasks_org_id_fkey"
		}),
	foreignKey({
			columns: [table.templateId],
			foreignColumns: [onboardingTemplates.id],
			name: "onboarding_template_tasks_template_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("onboarding_template_tasks_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const timesheetEntries = pgTable("timesheet_entries", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	timesheetId: uuid("timesheet_id").notNull(),
	workDate: date("work_date").notNull(),
	regularHours: numeric("regular_hours", { precision: 4, scale:  2 }).default('0'),
	overtimeHours: numeric("overtime_hours", { precision: 4, scale:  2 }).default('0'),
	doubleTimeHours: numeric("double_time_hours", { precision: 4, scale:  2 }).default('0'),
	ptoHours: numeric("pto_hours", { precision: 4, scale:  2 }).default('0'),
	holidayHours: numeric("holiday_hours", { precision: 4, scale:  2 }).default('0'),
	startTime: time("start_time"),
	endTime: time("end_time"),
	breakMinutes: integer("break_minutes").default(0),
	projectId: uuid("project_id"),
	taskCode: text("task_code"),
	costCenter: text("cost_center"),
	isBillable: boolean("is_billable").default(true),
	billRate: numeric("bill_rate", { precision: 10, scale:  2 }),
	payRate: numeric("pay_rate", { precision: 10, scale:  2 }),
	billableAmount: numeric("billable_amount", { precision: 10, scale:  2 }).default('0'),
	payableAmount: numeric("payable_amount", { precision: 10, scale:  2 }).default('0'),
	description: text(),
	internalNotes: text("internal_notes"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_timesheet_entries_timesheet").using("btree", table.timesheetId.asc().nullsLast().op("uuid_ops"), table.workDate.asc().nullsLast().op("date_ops")),
	foreignKey({
			columns: [table.timesheetId],
			foreignColumns: [timesheets.id],
			name: "timesheet_entries_timesheet_id_fkey"
		}).onDelete("cascade"),
	unique("timesheet_entries_date_unique").on(table.timesheetId, table.workDate),
]);

export const timesheetApprovals = pgTable("timesheet_approvals", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	timesheetId: uuid("timesheet_id").notNull(),
	approvalLevel: integer("approval_level").notNull(),
	approverType: text("approver_type").notNull(),
	approverId: uuid("approver_id"),
	status: approvalStatus().default('pending').notNull(),
	decisionAt: timestamp("decision_at", { withTimezone: true, mode: 'string' }),
	comments: text(),
	delegatedFrom: uuid("delegated_from"),
	delegatedReason: text("delegated_reason"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_timesheet_approvals_timesheet").using("btree", table.timesheetId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.approverId],
			foreignColumns: [userProfiles.id],
			name: "timesheet_approvals_approver_id_fkey"
		}),
	foreignKey({
			columns: [table.delegatedFrom],
			foreignColumns: [userProfiles.id],
			name: "timesheet_approvals_delegated_from_fkey"
		}),
	foreignKey({
			columns: [table.timesheetId],
			foreignColumns: [timesheets.id],
			name: "timesheet_approvals_timesheet_id_fkey"
		}).onDelete("cascade"),
	unique("timesheet_approvals_level_unique").on(table.timesheetId, table.approvalLevel),
]);

export const timesheetExpenses = pgTable("timesheet_expenses", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	timesheetId: uuid("timesheet_id").notNull(),
	expenseDate: date("expense_date").notNull(),
	category: text().notNull(),
	description: text().notNull(),
	amount: numeric({ precision: 10, scale:  2 }).notNull(),
	isBillable: boolean("is_billable").default(true),
	isReimbursable: boolean("is_reimbursable").default(true),
	receiptUrl: text("receipt_url"),
	receiptVerified: boolean("receipt_verified").default(false),
	verifiedBy: uuid("verified_by"),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_timesheet_expenses_timesheet").using("btree", table.timesheetId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.timesheetId],
			foreignColumns: [timesheets.id],
			name: "timesheet_expenses_timesheet_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.verifiedBy],
			foreignColumns: [userProfiles.id],
			name: "timesheet_expenses_verified_by_fkey"
		}),
	check("timesheet_expenses_category_check", sql`category = ANY (ARRAY['travel'::text, 'lodging'::text, 'meals'::text, 'mileage'::text, 'parking'::text, 'equipment'::text, 'supplies'::text, 'communication'::text, 'other'::text])`),
]);

export const invoiceLineItems = pgTable("invoice_line_items", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	invoiceId: uuid("invoice_id").notNull(),
	timesheetId: uuid("timesheet_id"),
	timesheetEntryId: uuid("timesheet_entry_id"),
	placementId: uuid("placement_id"),
	lineNumber: integer("line_number").notNull(),
	description: text().notNull(),
	serviceStartDate: date("service_start_date"),
	serviceEndDate: date("service_end_date"),
	quantity: numeric({ precision: 10, scale:  2 }).notNull(),
	unitType: text("unit_type").default('hours'),
	unitRate: numeric("unit_rate", { precision: 10, scale:  2 }).notNull(),
	subtotal: numeric({ precision: 12, scale:  2 }).default('0'),
	discountAmount: numeric("discount_amount", { precision: 12, scale:  2 }).default('0'),
	taxRate: numeric("tax_rate", { precision: 5, scale:  2 }).default('0'),
	taxAmount: numeric("tax_amount", { precision: 12, scale:  2 }).default('0'),
	totalAmount: numeric("total_amount", { precision: 12, scale:  2 }).notNull(),
	glCode: text("gl_code"),
	costCenter: text("cost_center"),
	projectCode: text("project_code"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_invoice_line_items_invoice").using("btree", table.invoiceId.asc().nullsLast().op("uuid_ops")),
	index("idx_invoice_line_items_timesheet").using("btree", table.timesheetId.asc().nullsLast().op("uuid_ops")).where(sql`(timesheet_id IS NOT NULL)`),
	foreignKey({
			columns: [table.invoiceId],
			foreignColumns: [invoices.id],
			name: "invoice_line_items_invoice_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.placementId],
			foreignColumns: [placements.id],
			name: "invoice_line_items_placement_id_fkey"
		}),
	foreignKey({
			columns: [table.timesheetEntryId],
			foreignColumns: [timesheetEntries.id],
			name: "invoice_line_items_timesheet_entry_id_fkey"
		}),
	foreignKey({
			columns: [table.timesheetId],
			foreignColumns: [timesheets.id],
			name: "invoice_line_items_timesheet_id_fkey"
		}),
]);

export const payItems = pgTable("pay_items", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	payRunId: uuid("pay_run_id").notNull(),
	workerType: workerType("worker_type").notNull(),
	workerId: uuid("worker_id").notNull(),
	contactId: uuid("contact_id"),
	payType: payType("pay_type").notNull(),
	timesheetIds: uuid("timesheet_ids").array(),
	regularHours: numeric("regular_hours", { precision: 6, scale:  2 }).default('0'),
	overtimeHours: numeric("overtime_hours", { precision: 6, scale:  2 }).default('0'),
	doubleTimeHours: numeric("double_time_hours", { precision: 6, scale:  2 }).default('0'),
	ptoHours: numeric("pto_hours", { precision: 6, scale:  2 }).default('0'),
	holidayHours: numeric("holiday_hours", { precision: 6, scale:  2 }).default('0'),
	totalHours: numeric("total_hours", { precision: 6, scale:  2 }).default('0'),
	regularRate: numeric("regular_rate", { precision: 10, scale:  2 }),
	overtimeRate: numeric("overtime_rate", { precision: 10, scale:  2 }),
	doubleTimeRate: numeric("double_time_rate", { precision: 10, scale:  2 }),
	regularEarnings: numeric("regular_earnings", { precision: 12, scale:  2 }).default('0'),
	overtimeEarnings: numeric("overtime_earnings", { precision: 12, scale:  2 }).default('0'),
	doubleTimeEarnings: numeric("double_time_earnings", { precision: 12, scale:  2 }).default('0'),
	ptoEarnings: numeric("pto_earnings", { precision: 12, scale:  2 }).default('0'),
	holidayEarnings: numeric("holiday_earnings", { precision: 12, scale:  2 }).default('0'),
	bonusEarnings: numeric("bonus_earnings", { precision: 12, scale:  2 }).default('0'),
	otherEarnings: numeric("other_earnings", { precision: 12, scale:  2 }).default('0'),
	grossPay: numeric("gross_pay", { precision: 12, scale:  2 }).notNull(),
	federalIncomeTax: numeric("federal_income_tax", { precision: 10, scale:  2 }).default('0'),
	stateIncomeTax: numeric("state_income_tax", { precision: 10, scale:  2 }).default('0'),
	localIncomeTax: numeric("local_income_tax", { precision: 10, scale:  2 }).default('0'),
	socialSecurityTax: numeric("social_security_tax", { precision: 10, scale:  2 }).default('0'),
	medicareTax: numeric("medicare_tax", { precision: 10, scale:  2 }).default('0'),
	totalEmployeeTaxes: numeric("total_employee_taxes", { precision: 10, scale:  2 }).default('0'),
	employerSocialSecurity: numeric("employer_social_security", { precision: 10, scale:  2 }).default('0'),
	employerMedicare: numeric("employer_medicare", { precision: 10, scale:  2 }).default('0'),
	employerFuta: numeric("employer_futa", { precision: 10, scale:  2 }).default('0'),
	employerSuta: numeric("employer_suta", { precision: 10, scale:  2 }).default('0'),
	totalEmployerTaxes: numeric("total_employer_taxes", { precision: 10, scale:  2 }).default('0'),
	preTaxDeductions: numeric("pre_tax_deductions", { precision: 10, scale:  2 }).default('0'),
	postTaxDeductions: numeric("post_tax_deductions", { precision: 10, scale:  2 }).default('0'),
	garnishments: numeric({ precision: 10, scale:  2 }).default('0'),
	totalDeductions: numeric("total_deductions", { precision: 10, scale:  2 }).default('0'),
	netPay: numeric("net_pay", { precision: 12, scale:  2 }).notNull(),
	paymentMethod: text("payment_method").default('direct_deposit'),
	bankAccountLast4: text("bank_account_last4"),
	checkNumber: text("check_number"),
	status: text().default('pending'),
	ytdGross: numeric("ytd_gross", { precision: 14, scale:  2 }),
	ytdFederalTax: numeric("ytd_federal_tax", { precision: 14, scale:  2 }),
	ytdStateTax: numeric("ytd_state_tax", { precision: 14, scale:  2 }),
	ytdSocialSecurity: numeric("ytd_social_security", { precision: 14, scale:  2 }),
	ytdMedicare: numeric("ytd_medicare", { precision: 14, scale:  2 }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_pay_items_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_pay_items_run").using("btree", table.payRunId.asc().nullsLast().op("uuid_ops")),
	index("idx_pay_items_worker").using("btree", table.workerId.asc().nullsLast().op("enum_ops"), table.workerType.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "pay_items_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.payRunId],
			foreignColumns: [payRuns.id],
			name: "pay_items_pay_run_id_fkey"
		}).onDelete("cascade"),
]);

export const payItemEarnings = pgTable("pay_item_earnings", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	payItemId: uuid("pay_item_id").notNull(),
	earningType: text("earning_type").notNull(),
	earningCode: text("earning_code"),
	description: text(),
	hours: numeric({ precision: 6, scale:  2 }),
	rate: numeric({ precision: 10, scale:  2 }),
	amount: numeric({ precision: 12, scale:  2 }).notNull(),
	isTaxable: boolean("is_taxable").default(true),
	isSubjectToFica: boolean("is_subject_to_fica").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_pay_item_earnings_item").using("btree", table.payItemId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.payItemId],
			foreignColumns: [payItems.id],
			name: "pay_item_earnings_pay_item_id_fkey"
		}).onDelete("cascade"),
]);

export const payItemDeductions = pgTable("pay_item_deductions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	payItemId: uuid("pay_item_id").notNull(),
	deductionType: text("deduction_type").notNull(),
	deductionCode: text("deduction_code"),
	description: text(),
	calculationMethod: text("calculation_method"),
	calculationBase: text("calculation_base"),
	percentage: numeric({ precision: 5, scale:  2 }),
	flatAmount: numeric("flat_amount", { precision: 10, scale:  2 }),
	employeeAmount: numeric("employee_amount", { precision: 10, scale:  2 }).notNull(),
	employerAmount: numeric("employer_amount", { precision: 10, scale:  2 }).default('0'),
	isPreTax: boolean("is_pre_tax").default(false),
	reducesFederalTax: boolean("reduces_federal_tax").default(false),
	reducesStateTax: boolean("reduces_state_tax").default(false),
	reducesFica: boolean("reduces_fica").default(false),
	annualLimit: numeric("annual_limit", { precision: 12, scale:  2 }),
	ytdAmount: numeric("ytd_amount", { precision: 12, scale:  2 }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_pay_item_deductions_item").using("btree", table.payItemId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.payItemId],
			foreignColumns: [payItems.id],
			name: "pay_item_deductions_pay_item_id_fkey"
		}).onDelete("cascade"),
]);

export const payStubs = pgTable("pay_stubs", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	payItemId: uuid("pay_item_id").notNull(),
	pdfUrl: text("pdf_url"),
	generatedAt: timestamp("generated_at", { withTimezone: true, mode: 'string' }),
	emailedTo: text("emailed_to"),
	emailedAt: timestamp("emailed_at", { withTimezone: true, mode: 'string' }),
	viewedAt: timestamp("viewed_at", { withTimezone: true, mode: 'string' }),
	accessToken: text("access_token"),
	accessExpiresAt: timestamp("access_expires_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_pay_stubs_item").using("btree", table.payItemId.asc().nullsLast().op("uuid_ops")),
	index("idx_pay_stubs_token").using("btree", table.accessToken.asc().nullsLast().op("text_ops")).where(sql`(access_token IS NOT NULL)`),
	foreignKey({
			columns: [table.payItemId],
			foreignColumns: [payItems.id],
			name: "pay_stubs_pay_item_id_fkey"
		}),
	unique("pay_stubs_access_token_key").on(table.accessToken),
]);

export const timesheets = pgTable("timesheets", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	placementId: uuid("placement_id").notNull(),
	periodStart: date("period_start").notNull(),
	periodEnd: date("period_end").notNull(),
	periodType: timesheetPeriodType("period_type").default('weekly').notNull(),
	totalRegularHours: numeric("total_regular_hours", { precision: 6, scale:  2 }).default('0'),
	totalOvertimeHours: numeric("total_overtime_hours", { precision: 6, scale:  2 }).default('0'),
	totalDoubleTimeHours: numeric("total_double_time_hours", { precision: 6, scale:  2 }).default('0'),
	totalPtoHours: numeric("total_pto_hours", { precision: 6, scale:  2 }).default('0'),
	totalHolidayHours: numeric("total_holiday_hours", { precision: 6, scale:  2 }).default('0'),
	totalBillableAmount: numeric("total_billable_amount", { precision: 12, scale:  2 }).default('0'),
	totalPayableAmount: numeric("total_payable_amount", { precision: 12, scale:  2 }).default('0'),
	rateSnapshot: jsonb("rate_snapshot"),
	status: timesheetStatus().default('draft').notNull(),
	submittedAt: timestamp("submitted_at", { withTimezone: true, mode: 'string' }),
	submittedBy: uuid("submitted_by"),
	clientApprovalStatus: approvalStatus("client_approval_status").default('pending'),
	clientApprovedAt: timestamp("client_approved_at", { withTimezone: true, mode: 'string' }),
	clientApprovedBy: uuid("client_approved_by"),
	clientApprovalNotes: text("client_approval_notes"),
	internalApprovalStatus: approvalStatus("internal_approval_status").default('pending'),
	internalApprovedAt: timestamp("internal_approved_at", { withTimezone: true, mode: 'string' }),
	internalApprovedBy: uuid("internal_approved_by"),
	internalApprovalNotes: text("internal_approval_notes"),
	processedAt: timestamp("processed_at", { withTimezone: true, mode: 'string' }),
	processedBy: uuid("processed_by"),
	invoiceId: uuid("invoice_id"),
	payrollRunId: uuid("payroll_run_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_timesheets_invoice").using("btree", table.invoiceId.asc().nullsLast().op("uuid_ops")).where(sql`((invoice_id IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_timesheets_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_timesheets_payroll").using("btree", table.payrollRunId.asc().nullsLast().op("uuid_ops")).where(sql`((payroll_run_id IS NOT NULL) AND (deleted_at IS NULL))`),
	index("idx_timesheets_placement").using("btree", table.placementId.asc().nullsLast().op("uuid_ops"), table.periodStart.desc().nullsFirst().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_timesheets_status").using("btree", table.status.asc().nullsLast().op("enum_ops"), table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_timesheets_submitted").using("btree", table.submittedAt.asc().nullsLast().op("timestamptz_ops")).where(sql`((status = 'submitted'::timesheet_status) AND (deleted_at IS NULL))`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "timesheets_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "timesheets_org_id_fkey"
		}),
	foreignKey({
			columns: [table.placementId],
			foreignColumns: [placements.id],
			name: "timesheets_placement_id_fkey"
		}),
	foreignKey({
			columns: [table.submittedBy],
			foreignColumns: [userProfiles.id],
			name: "timesheets_submitted_by_fkey"
		}),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "timesheets_updated_by_fkey"
		}),
	unique("timesheets_period_unique").on(table.placementId, table.periodStart, table.periodEnd),
	pgPolicy("timesheets_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const timesheetApprovalWorkflows = pgTable("timesheet_approval_workflows", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	description: text(),
	approvalLevels: jsonb("approval_levels").default([]).notNull(),
	autoApproveUnderHours: numeric("auto_approve_under_hours", { precision: 4, scale:  2 }),
	autoApproveIfMatchesSchedule: boolean("auto_approve_if_matches_schedule").default(false),
	escalationHours: integer("escalation_hours").default(48),
	escalationTo: uuid("escalation_to"),
	isDefault: boolean("is_default").default(false),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_timesheet_approval_workflows_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(is_active = true)`),
	foreignKey({
			columns: [table.escalationTo],
			foreignColumns: [userProfiles.id],
			name: "timesheet_approval_workflows_escalation_to_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "timesheet_approval_workflows_org_id_fkey"
		}),
	pgPolicy("timesheet_approval_workflows_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const timesheetAdjustments = pgTable("timesheet_adjustments", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	originalTimesheetId: uuid("original_timesheet_id").notNull(),
	adjustmentTimesheetId: uuid("adjustment_timesheet_id"),
	adjustmentType: text("adjustment_type").notNull(),
	reason: text().notNull(),
	hoursDelta: numeric("hours_delta", { precision: 6, scale:  2 }),
	amountDelta: numeric("amount_delta", { precision: 12, scale:  2 }),
	requestedBy: uuid("requested_by").notNull(),
	approvedBy: uuid("approved_by"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	status: text().default('pending'),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_timesheet_adjustments_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.adjustmentTimesheetId],
			foreignColumns: [timesheets.id],
			name: "timesheet_adjustments_adjustment_timesheet_id_fkey"
		}),
	foreignKey({
			columns: [table.approvedBy],
			foreignColumns: [userProfiles.id],
			name: "timesheet_adjustments_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "timesheet_adjustments_org_id_fkey"
		}),
	foreignKey({
			columns: [table.originalTimesheetId],
			foreignColumns: [timesheets.id],
			name: "timesheet_adjustments_original_timesheet_id_fkey"
		}),
	foreignKey({
			columns: [table.requestedBy],
			foreignColumns: [userProfiles.id],
			name: "timesheet_adjustments_requested_by_fkey"
		}),
	pgPolicy("timesheet_adjustments_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("timesheet_adjustments_adjustment_type_check", sql`adjustment_type = ANY (ARRAY['correction'::text, 'addition'::text, 'void'::text])`),
	check("timesheet_adjustments_status_check", sql`status = ANY (ARRAY['pending'::text, 'approved'::text, 'rejected'::text])`),
]);

export const timesheetTemplates = pgTable("timesheet_templates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	description: text(),
	periodType: timesheetPeriodType("period_type").default('weekly').notNull(),
	defaultHoursPerDay: numeric("default_hours_per_day", { precision: 4, scale:  2 }).default('8'),
	defaultDaysPerWeek: integer("default_days_per_week").default(5),
	defaultEntries: jsonb("default_entries").default([]),
	isDefault: boolean("is_default").default(false),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_timesheet_templates_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(is_active = true)`),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "timesheet_templates_org_id_fkey"
		}),
	pgPolicy("timesheet_templates_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const invoices = pgTable("invoices", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	invoiceNumber: text("invoice_number").notNull(),
	referenceNumber: text("reference_number"),
	companyId: uuid("company_id"),
	billingContactId: uuid("billing_contact_id"),
	invoiceType: invoiceType("invoice_type").default('standard').notNull(),
	invoiceDate: date("invoice_date").notNull(),
	dueDate: date("due_date").notNull(),
	currency: text().default('USD').notNull(),
	exchangeRate: numeric("exchange_rate", { precision: 10, scale:  6 }).default('1'),
	subtotal: numeric({ precision: 12, scale:  2 }).default('0').notNull(),
	discountAmount: numeric("discount_amount", { precision: 12, scale:  2 }).default('0'),
	discountPercentage: numeric("discount_percentage", { precision: 5, scale:  2 }),
	taxAmount: numeric("tax_amount", { precision: 12, scale:  2 }).default('0'),
	totalAmount: numeric("total_amount", { precision: 12, scale:  2 }).default('0').notNull(),
	amountPaid: numeric("amount_paid", { precision: 12, scale:  2 }).default('0'),
	balanceDue: numeric("balance_due", { precision: 12, scale:  2 }).default('0'),
	status: invoiceStatus().default('draft').notNull(),
	sentAt: timestamp("sent_at", { withTimezone: true, mode: 'string' }),
	sentTo: text("sent_to").array(),
	viewedAt: timestamp("viewed_at", { withTimezone: true, mode: 'string' }),
	paymentTermsId: uuid("payment_terms_id"),
	paymentInstructions: text("payment_instructions"),
	agingBucket: text("aging_bucket"),
	lastReminderSent: timestamp("last_reminder_sent", { withTimezone: true, mode: 'string' }),
	reminderCount: integer("reminder_count").default(0),
	isDisputed: boolean("is_disputed").default(false),
	disputeReason: text("dispute_reason"),
	disputeOpenedAt: timestamp("dispute_opened_at", { withTimezone: true, mode: 'string' }),
	disputeResolvedAt: timestamp("dispute_resolved_at", { withTimezone: true, mode: 'string' }),
	writtenOffAmount: numeric("written_off_amount", { precision: 12, scale:  2 }).default('0'),
	writtenOffAt: timestamp("written_off_at", { withTimezone: true, mode: 'string' }),
	writtenOffReason: text("written_off_reason"),
	internalNotes: text("internal_notes"),
	clientNotes: text("client_notes"),
	termsAndConditions: text("terms_and_conditions"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_invoices_company").using("btree", table.companyId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_invoices_due_date").using("btree", table.dueDate.asc().nullsLast().op("date_ops")).where(sql`((status <> ALL (ARRAY['paid'::invoice_status, 'void'::invoice_status])) AND (deleted_at IS NULL))`),
	index("idx_invoices_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_invoices_overdue").using("btree", table.dueDate.asc().nullsLast().op("numeric_ops"), table.balanceDue.asc().nullsLast().op("numeric_ops")).where(sql`((status = 'overdue'::invoice_status) AND (deleted_at IS NULL))`),
	index("idx_invoices_status").using("btree", table.status.asc().nullsLast().op("enum_ops"), table.orgId.asc().nullsLast().op("enum_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.billingContactId],
			foreignColumns: [contacts.id],
			name: "invoices_billing_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.companyId],
			foreignColumns: [companies.id],
			name: "invoices_company_id_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "invoices_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "invoices_org_id_fkey"
		}),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "invoices_updated_by_fkey"
		}),
	unique("invoices_number_unique").on(table.orgId, table.invoiceNumber),
	pgPolicy("invoices_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const invoicePayments = pgTable("invoice_payments", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	invoiceId: uuid("invoice_id").notNull(),
	paymentDate: date("payment_date").notNull(),
	amount: numeric({ precision: 12, scale:  2 }).notNull(),
	paymentMethod: text("payment_method").notNull(),
	referenceNumber: text("reference_number"),
	bankReference: text("bank_reference"),
	matchedToLineItems: jsonb("matched_to_line_items"),
	depositDate: date("deposit_date"),
	depositAccount: text("deposit_account"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_invoice_payments_invoice").using("btree", table.invoiceId.asc().nullsLast().op("uuid_ops")),
	index("idx_invoice_payments_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "invoice_payments_created_by_fkey"
		}),
	foreignKey({
			columns: [table.invoiceId],
			foreignColumns: [invoices.id],
			name: "invoice_payments_invoice_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "invoice_payments_org_id_fkey"
		}),
	pgPolicy("invoice_payments_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("invoice_payments_payment_method_check", sql`payment_method = ANY (ARRAY['check'::text, 'ach'::text, 'wire'::text, 'credit_card'::text, 'other'::text])`),
]);

export const paymentTerms = pgTable("payment_terms", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	description: text(),
	daysUntilDue: integer("days_until_due").default(30).notNull(),
	earlyPaymentDiscountPercent: numeric("early_payment_discount_percent", { precision: 5, scale:  2 }),
	earlyPaymentDiscountDays: integer("early_payment_discount_days"),
	lateFeePercent: numeric("late_fee_percent", { precision: 5, scale:  2 }),
	lateFeeFlat: numeric("late_fee_flat", { precision: 10, scale:  2 }),
	lateFeeGraceDays: integer("late_fee_grace_days").default(0),
	isDefault: boolean("is_default").default(false),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_payment_terms_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(is_active = true)`),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "payment_terms_org_id_fkey"
		}),
	pgPolicy("payment_terms_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const invoiceBatches = pgTable("invoice_batches", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	batchNumber: text("batch_number").notNull(),
	batchDate: date("batch_date").notNull(),
	invoiceCount: integer("invoice_count").default(0),
	totalAmount: numeric("total_amount", { precision: 14, scale:  2 }).default('0'),
	status: text().default('draft'),
	generatedAt: timestamp("generated_at", { withTimezone: true, mode: 'string' }),
	sentAt: timestamp("sent_at", { withTimezone: true, mode: 'string' }),
	includeAccounts: uuid("include_accounts").array(),
	excludeAccounts: uuid("exclude_accounts").array(),
	cutoffDate: date("cutoff_date"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_invoice_batches_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "invoice_batches_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "invoice_batches_org_id_fkey"
		}),
	pgPolicy("invoice_batches_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("invoice_batches_status_check", sql`status = ANY (ARRAY['draft'::text, 'processing'::text, 'sent'::text, 'completed'::text])`),
]);

export const invoiceTemplates = pgTable("invoice_templates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	description: text(),
	headerHtml: text("header_html"),
	footerHtml: text("footer_html"),
	lineItemFormat: text("line_item_format"),
	logoUrl: text("logo_url"),
	primaryColor: text("primary_color"),
	fontFamily: text("font_family"),
	defaultPaymentTermsId: uuid("default_payment_terms_id"),
	defaultNotes: text("default_notes"),
	defaultTermsAndConditions: text("default_terms_and_conditions"),
	isDefault: boolean("is_default").default(false),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_invoice_templates_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(is_active = true)`),
	foreignKey({
			columns: [table.defaultPaymentTermsId],
			foreignColumns: [paymentTerms.id],
			name: "invoice_templates_default_payment_terms_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "invoice_templates_org_id_fkey"
		}),
	pgPolicy("invoice_templates_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const payPeriods = pgTable("pay_periods", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	periodNumber: integer("period_number").notNull(),
	year: integer().notNull(),
	periodStart: date("period_start").notNull(),
	periodEnd: date("period_end").notNull(),
	payDate: date("pay_date").notNull(),
	periodType: timesheetPeriodType("period_type").notNull(),
	status: payPeriodStatus().default('upcoming').notNull(),
	timesheetCutoff: timestamp("timesheet_cutoff", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_pay_periods_dates").using("btree", table.orgId.asc().nullsLast().op("date_ops"), table.periodStart.asc().nullsLast().op("uuid_ops"), table.periodEnd.asc().nullsLast().op("uuid_ops")),
	index("idx_pay_periods_org").using("btree", table.orgId.asc().nullsLast().op("int4_ops"), table.year.asc().nullsLast().op("int4_ops"), table.periodNumber.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "pay_periods_org_id_fkey"
		}),
	unique("pay_periods_unique").on(table.orgId, table.periodNumber, table.year),
	pgPolicy("pay_periods_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const payRuns = pgTable("pay_runs", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	payPeriodId: uuid("pay_period_id").notNull(),
	runNumber: text("run_number").notNull(),
	runType: payRunType("run_type").default('regular').notNull(),
	checkDate: date("check_date").notNull(),
	directDepositDate: date("direct_deposit_date"),
	totalGross: numeric("total_gross", { precision: 14, scale:  2 }).default('0'),
	totalEmployerTaxes: numeric("total_employer_taxes", { precision: 14, scale:  2 }).default('0'),
	totalEmployeeTaxes: numeric("total_employee_taxes", { precision: 14, scale:  2 }).default('0'),
	totalDeductions: numeric("total_deductions", { precision: 14, scale:  2 }).default('0'),
	totalNet: numeric("total_net", { precision: 14, scale:  2 }).default('0'),
	totalEmployerCost: numeric("total_employer_cost", { precision: 14, scale:  2 }).default('0'),
	employeeCount: integer("employee_count").default(0),
	consultantCount: integer("consultant_count").default(0),
	contractorCount: integer("contractor_count").default(0),
	status: payRunStatus().default('draft').notNull(),
	calculatedAt: timestamp("calculated_at", { withTimezone: true, mode: 'string' }),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	approvedBy: uuid("approved_by"),
	submittedAt: timestamp("submitted_at", { withTimezone: true, mode: 'string' }),
	processedAt: timestamp("processed_at", { withTimezone: true, mode: 'string' }),
	payrollProvider: text("payroll_provider"),
	externalRunId: text("external_run_id"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_pay_runs_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_pay_runs_period").using("btree", table.payPeriodId.asc().nullsLast().op("uuid_ops")),
	index("idx_pay_runs_status").using("btree", table.status.asc().nullsLast().op("enum_ops"), table.orgId.asc().nullsLast().op("enum_ops")),
	foreignKey({
			columns: [table.approvedBy],
			foreignColumns: [userProfiles.id],
			name: "pay_runs_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "pay_runs_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "pay_runs_org_id_fkey"
		}),
	foreignKey({
			columns: [table.payPeriodId],
			foreignColumns: [payPeriods.id],
			name: "pay_runs_pay_period_id_fkey"
		}),
	unique("pay_runs_number_unique").on(table.orgId, table.runNumber),
	pgPolicy("pay_runs_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const workerTaxSetup = pgTable("worker_tax_setup", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	contactId: uuid("contact_id").notNull(),
	federalFilingStatus: text("federal_filing_status"),
	federalAllowances: integer("federal_allowances").default(0),
	additionalFederalWithholding: numeric("additional_federal_withholding", { precision: 10, scale:  2 }).default('0'),
	federalExempt: boolean("federal_exempt").default(false),
	workState: text("work_state").notNull(),
	stateFilingStatus: text("state_filing_status"),
	stateAllowances: integer("state_allowances").default(0),
	additionalStateWithholding: numeric("additional_state_withholding", { precision: 10, scale:  2 }).default('0'),
	stateExempt: boolean("state_exempt").default(false),
	residentState: text("resident_state"),
	residentStateFilingStatus: text("resident_state_filing_status"),
	localTaxJurisdiction: text("local_tax_jurisdiction"),
	localTaxRate: numeric("local_tax_rate", { precision: 5, scale:  4 }),
	ficaExempt: boolean("fica_exempt").default(false),
	w4FormDate: date("w4_form_date"),
	w4MultipleJobs: boolean("w4_multiple_jobs").default(false),
	w4DependentsCredit: numeric("w4_dependents_credit", { precision: 10, scale:  2 }).default('0'),
	w4OtherIncome: numeric("w4_other_income", { precision: 10, scale:  2 }).default('0'),
	w4Deductions: numeric("w4_deductions", { precision: 10, scale:  2 }).default('0'),
	effectiveDate: date("effective_date").notNull(),
	endDate: date("end_date"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_worker_tax_setup_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")),
	index("idx_worker_tax_setup_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "worker_tax_setup_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "worker_tax_setup_org_id_fkey"
		}),
	pgPolicy("worker_tax_setup_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const workerBenefits = pgTable("worker_benefits", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	contactId: uuid("contact_id").notNull(),
	benefitPlanId: uuid("benefit_plan_id").notNull(),
	enrollmentDate: date("enrollment_date").notNull(),
	terminationDate: date("termination_date"),
	coverageLevel: text("coverage_level"),
	employeeContribution: numeric("employee_contribution", { precision: 10, scale:  2 }).notNull(),
	employerContribution: numeric("employer_contribution", { precision: 10, scale:  2 }).notNull(),
	contributionFrequency: text("contribution_frequency").default('per_pay_period'),
	annualElection: numeric("annual_election", { precision: 10, scale:  2 }),
	ytdContribution: numeric("ytd_contribution", { precision: 10, scale:  2 }).default('0'),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_worker_benefits_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")),
	index("idx_worker_benefits_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "worker_benefits_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "worker_benefits_org_id_fkey"
		}),
	pgPolicy("worker_benefits_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
]);

export const workerGarnishments = pgTable("worker_garnishments", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	contactId: uuid("contact_id").notNull(),
	garnishmentType: text("garnishment_type").notNull(),
	caseNumber: text("case_number"),
	issuingAgency: text("issuing_agency"),
	calculationType: text("calculation_type").notNull(),
	amount: numeric({ precision: 10, scale:  2 }),
	percentage: numeric({ precision: 5, scale:  2 }),
	maximumPercentage: numeric("maximum_percentage", { precision: 5, scale:  2 }),
	totalAmountOwed: numeric("total_amount_owed", { precision: 12, scale:  2 }),
	amountPaid: numeric("amount_paid", { precision: 12, scale:  2 }).default('0'),
	priority: integer().default(1),
	startDate: date("start_date").notNull(),
	endDate: date("end_date"),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_worker_garnishments_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")).where(sql`(is_active = true)`),
	index("idx_worker_garnishments_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "worker_garnishments_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "worker_garnishments_org_id_fkey"
		}),
	pgPolicy("worker_garnishments_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("worker_garnishments_calculation_type_check", sql`calculation_type = ANY (ARRAY['flat'::text, 'percentage'::text, 'percentage_after_taxes'::text])`),
	check("worker_garnishments_garnishment_type_check", sql`garnishment_type = ANY (ARRAY['child_support'::text, 'tax_levy'::text, 'creditor'::text, 'student_loan'::text, 'bankruptcy'::text, 'other'::text])`),
]);

export const taxDocuments = pgTable("tax_documents", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	documentType: text("document_type").notNull(),
	taxYear: integer("tax_year").notNull(),
	workerType: workerType("worker_type").notNull(),
	workerId: uuid("worker_id").notNull(),
	contactId: uuid("contact_id"),
	documentData: jsonb("document_data").notNull(),
	pdfUrl: text("pdf_url"),
	generatedAt: timestamp("generated_at", { withTimezone: true, mode: 'string' }),
	filedWithIrs: boolean("filed_with_irs").default(false),
	filedAt: timestamp("filed_at", { withTimezone: true, mode: 'string' }),
	irsConfirmation: text("irs_confirmation"),
	isCorrected: boolean("is_corrected").default(false),
	correctsDocumentId: uuid("corrects_document_id"),
	correctionReason: text("correction_reason"),
	mailedAt: timestamp("mailed_at", { withTimezone: true, mode: 'string' }),
	mailingAddress: jsonb("mailing_address"),
	emailedAt: timestamp("emailed_at", { withTimezone: true, mode: 'string' }),
	viewedAt: timestamp("viewed_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_tax_documents_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_tax_documents_worker").using("btree", table.workerId.asc().nullsLast().op("uuid_ops"), table.taxYear.asc().nullsLast().op("uuid_ops")),
	index("idx_tax_documents_year").using("btree", table.taxYear.asc().nullsLast().op("text_ops"), table.documentType.asc().nullsLast().op("int4_ops")).where(sql`(filed_with_irs = false)`),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "tax_documents_contact_id_fkey"
		}),
	foreignKey({
			columns: [table.correctsDocumentId],
			foreignColumns: [table.id],
			name: "tax_documents_corrects_document_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "tax_documents_org_id_fkey"
		}),
	unique("tax_documents_unique").on(table.orgId, table.documentType, table.taxYear, table.workerId),
	pgPolicy("tax_documents_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("tax_documents_document_type_check", sql`document_type = ANY (ARRAY['w2'::text, '1099_nec'::text, '1099_misc'::text])`),
]);

export const workflowExecutions = pgTable("workflow_executions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	instanceId: uuid("instance_id").notNull(),
	status: varchar({ length: 50 }).default('pending').notNull(),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	pausedAt: timestamp("paused_at", { withTimezone: true, mode: 'string' }),
	triggeredBy: uuid("triggered_by"),
	triggerType: varchar("trigger_type", { length: 50 }),
	triggerEvent: jsonb("trigger_event"),
	currentStepIndex: integer("current_step_index").default(0),
	totalSteps: integer("total_steps").default(0),
	errorMessage: text("error_message"),
	errorStack: text("error_stack"),
	retryCount: integer("retry_count").default(0),
	maxRetries: integer("max_retries").default(3),
	nextRetryAt: timestamp("next_retry_at", { withTimezone: true, mode: 'string' }),
	executionContext: jsonb("execution_context").default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_workflow_executions_instance").using("btree", table.instanceId.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("text_ops")),
	index("idx_workflow_executions_org").using("btree", table.orgId.asc().nullsLast().op("timestamptz_ops"), table.status.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")),
	index("idx_workflow_executions_retry").using("btree", table.nextRetryAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(((status)::text = 'failed'::text) AND (retry_count < max_retries))`),
	index("idx_workflow_executions_running").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`((status)::text = 'running'::text)`),
	foreignKey({
			columns: [table.instanceId],
			foreignColumns: [workflowInstances.id],
			name: "workflow_executions_instance_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "workflow_executions_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.triggeredBy],
			foreignColumns: [userProfiles.id],
			name: "workflow_executions_triggered_by_fkey"
		}),
	pgPolicy("org_isolation_workflow_executions", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("workflow_executions_status_check", sql`(status)::text = ANY ((ARRAY['pending'::character varying, 'running'::character varying, 'completed'::character varying, 'failed'::character varying, 'cancelled'::character varying, 'paused'::character varying])::text[])`),
	check("workflow_executions_trigger_type_check", sql`(trigger_type)::text = ANY ((ARRAY['manual'::character varying, 'automatic'::character varying, 'scheduled'::character varying, 'event'::character varying, 'api'::character varying])::text[])`),
]);

export const workflowSteps = pgTable("workflow_steps", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	executionId: uuid("execution_id").notNull(),
	stateId: uuid("state_id"),
	transitionId: uuid("transition_id"),
	stepType: varchar("step_type", { length: 50 }).notNull(),
	stepName: varchar("step_name", { length: 255 }),
	stepConfig: jsonb("step_config").default({}).notNull(),
	position: integer().notNull(),
	status: varchar({ length: 50 }).default('pending').notNull(),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	waitUntil: timestamp("wait_until", { withTimezone: true, mode: 'string' }),
	waitCondition: jsonb("wait_condition"),
	result: jsonb(),
	errorMessage: text("error_message"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_workflow_steps_execution").using("btree", table.executionId.asc().nullsLast().op("int4_ops"), table.position.asc().nullsLast().op("uuid_ops")),
	index("idx_workflow_steps_status").using("btree", table.executionId.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("text_ops")),
	index("idx_workflow_steps_waiting").using("btree", table.waitUntil.asc().nullsLast().op("timestamptz_ops")).where(sql`((status)::text = 'waiting'::text)`),
	foreignKey({
			columns: [table.executionId],
			foreignColumns: [workflowExecutions.id],
			name: "workflow_steps_execution_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.stateId],
			foreignColumns: [workflowStates.id],
			name: "workflow_steps_state_id_fkey"
		}),
	foreignKey({
			columns: [table.transitionId],
			foreignColumns: [workflowTransitions.id],
			name: "workflow_steps_transition_id_fkey"
		}),
	pgPolicy("execution_access_workflow_steps", { as: "permissive", for: "all", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM workflow_executions we
  WHERE ((we.id = workflow_steps.execution_id) AND (we.org_id = (current_setting('app.org_id'::text, true))::uuid))))` }),
	check("workflow_steps_status_check", sql`(status)::text = ANY ((ARRAY['pending'::character varying, 'running'::character varying, 'completed'::character varying, 'failed'::character varying, 'skipped'::character varying, 'waiting'::character varying])::text[])`),
	check("workflow_steps_step_type_check", sql`(step_type)::text = ANY ((ARRAY['state'::character varying, 'transition'::character varying, 'action'::character varying, 'condition'::character varying, 'wait'::character varying, 'approval'::character varying])::text[])`),
]);

export const workflowActions = pgTable("workflow_actions", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	executionId: uuid("execution_id").notNull(),
	stepId: uuid("step_id"),
	actionType: varchar("action_type", { length: 50 }).notNull(),
	actionConfig: jsonb("action_config").notNull(),
	status: varchar({ length: 50 }).default('pending').notNull(),
	scheduledAt: timestamp("scheduled_at", { withTimezone: true, mode: 'string' }),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	result: jsonb(),
	errorMessage: text("error_message"),
	errorCode: varchar("error_code", { length: 50 }),
	retryCount: integer("retry_count").default(0),
	maxRetries: integer("max_retries").default(3),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_workflow_actions_execution").using("btree", table.executionId.asc().nullsLast().op("uuid_ops")),
	index("idx_workflow_actions_scheduled").using("btree", table.scheduledAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(((status)::text = 'pending'::text) AND (scheduled_at IS NOT NULL))`),
	index("idx_workflow_actions_status").using("btree", table.status.asc().nullsLast().op("text_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")).where(sql`((status)::text = ANY ((ARRAY['pending'::character varying, 'running'::character varying, 'failed'::character varying])::text[]))`),
	index("idx_workflow_actions_step").using("btree", table.stepId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.executionId],
			foreignColumns: [workflowExecutions.id],
			name: "workflow_actions_execution_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.stepId],
			foreignColumns: [workflowSteps.id],
			name: "workflow_actions_step_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("execution_access_workflow_actions", { as: "permissive", for: "all", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM workflow_executions we
  WHERE ((we.id = workflow_actions.execution_id) AND (we.org_id = (current_setting('app.org_id'::text, true))::uuid))))` }),
	check("workflow_actions_action_type_check", sql`(action_type)::text = ANY ((ARRAY['send_email'::character varying, 'send_notification'::character varying, 'create_task'::character varying, 'create_activity'::character varying, 'update_field'::character varying, 'webhook'::character varying, 'wait'::character varying, 'condition'::character varying, 'assign'::character varying, 'escalate'::character varying, 'create_document'::character varying, 'update_status'::character varying, 'add_note'::character varying, 'trigger_workflow'::character varying])::text[])`),
	check("workflow_actions_status_check", sql`(status)::text = ANY ((ARRAY['pending'::character varying, 'running'::character varying, 'completed'::character varying, 'failed'::character varying, 'skipped'::character varying, 'cancelled'::character varying])::text[])`),
]);

export const workflowApprovals = pgTable("workflow_approvals", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	executionId: uuid("execution_id").notNull(),
	stepId: uuid("step_id"),
	approverId: uuid("approver_id").notNull(),
	approverType: varchar("approver_type", { length: 50 }),
	approverRole: varchar("approver_role", { length: 100 }),
	status: varchar({ length: 50 }).default('pending').notNull(),
	requestedAt: timestamp("requested_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	dueAt: timestamp("due_at", { withTimezone: true, mode: 'string' }),
	respondedAt: timestamp("responded_at", { withTimezone: true, mode: 'string' }),
	responseNotes: text("response_notes"),
	delegatedTo: uuid("delegated_to"),
	delegatedAt: timestamp("delegated_at", { withTimezone: true, mode: 'string' }),
	delegationReason: text("delegation_reason"),
	escalatedTo: uuid("escalated_to"),
	escalatedAt: timestamp("escalated_at", { withTimezone: true, mode: 'string' }),
	escalationReason: text("escalation_reason"),
	escalationLevel: integer("escalation_level").default(0),
	sequenceOrder: integer("sequence_order").default(1),
	isParallel: boolean("is_parallel").default(false),
	approvalContext: jsonb("approval_context").default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_workflow_approvals_approver").using("btree", table.approverId.asc().nullsLast().op("text_ops"), table.status.asc().nullsLast().op("text_ops")),
	index("idx_workflow_approvals_due").using("btree", table.dueAt.asc().nullsLast().op("timestamptz_ops")).where(sql`((status)::text = 'pending'::text)`),
	index("idx_workflow_approvals_execution").using("btree", table.executionId.asc().nullsLast().op("uuid_ops")),
	index("idx_workflow_approvals_org_pending").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`((status)::text = 'pending'::text)`),
	foreignKey({
			columns: [table.approverId],
			foreignColumns: [userProfiles.id],
			name: "workflow_approvals_approver_id_fkey"
		}),
	foreignKey({
			columns: [table.delegatedTo],
			foreignColumns: [userProfiles.id],
			name: "workflow_approvals_delegated_to_fkey"
		}),
	foreignKey({
			columns: [table.escalatedTo],
			foreignColumns: [userProfiles.id],
			name: "workflow_approvals_escalated_to_fkey"
		}),
	foreignKey({
			columns: [table.executionId],
			foreignColumns: [workflowExecutions.id],
			name: "workflow_approvals_execution_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "workflow_approvals_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.stepId],
			foreignColumns: [workflowSteps.id],
			name: "workflow_approvals_step_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("org_isolation_workflow_approvals", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("workflow_approvals_approver_type_check", sql`(approver_type)::text = ANY ((ARRAY['user'::character varying, 'role'::character varying, 'manager'::character varying, 'owner'::character varying, 'pod_lead'::character varying])::text[])`),
	check("workflow_approvals_status_check", sql`(status)::text = ANY ((ARRAY['pending'::character varying, 'approved'::character varying, 'rejected'::character varying, 'delegated'::character varying, 'escalated'::character varying, 'expired'::character varying, 'cancelled'::character varying])::text[])`),
]);

export const workflowExecutionLogs = pgTable("workflow_execution_logs", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	executionId: uuid("execution_id").notNull(),
	stepId: uuid("step_id"),
	actionId: uuid("action_id"),
	level: varchar({ length: 20 }).default('info').notNull(),
	message: text().notNull(),
	data: jsonb(),
	source: varchar({ length: 100 }),
	occurredAt: timestamp("occurred_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_workflow_execution_logs_execution").using("btree", table.executionId.asc().nullsLast().op("timestamptz_ops"), table.occurredAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_workflow_execution_logs_level").using("btree", table.level.asc().nullsLast().op("timestamptz_ops"), table.occurredAt.desc().nullsFirst().op("text_ops")).where(sql`((level)::text = ANY ((ARRAY['warning'::character varying, 'error'::character varying])::text[]))`),
	index("idx_workflow_execution_logs_step").using("btree", table.stepId.asc().nullsLast().op("uuid_ops")).where(sql`(step_id IS NOT NULL)`),
	foreignKey({
			columns: [table.actionId],
			foreignColumns: [workflowActions.id],
			name: "workflow_execution_logs_action_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.executionId],
			foreignColumns: [workflowExecutions.id],
			name: "workflow_execution_logs_execution_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.stepId],
			foreignColumns: [workflowSteps.id],
			name: "workflow_execution_logs_step_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("execution_access_workflow_logs", { as: "permissive", for: "all", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM workflow_executions we
  WHERE ((we.id = workflow_execution_logs.execution_id) AND (we.org_id = (current_setting('app.org_id'::text, true))::uuid))))` }),
	check("workflow_execution_logs_level_check", sql`(level)::text = ANY ((ARRAY['debug'::character varying, 'info'::character varying, 'warning'::character varying, 'error'::character varying])::text[])`),
]);

export const notificationPreferences = pgTable("notification_preferences", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	userId: uuid("user_id").notNull(),
	category: varchar({ length: 100 }).notNull(),
	channels: jsonb().default(["in_app"]),
	frequency: varchar({ length: 50 }).default('immediate'),
	digestTime: time("digest_time").default('09:00:00'),
	digestDay: varchar("digest_day", { length: 10 }).default('monday'),
	quietHoursEnabled: boolean("quiet_hours_enabled").default(false),
	quietHoursStart: time("quiet_hours_start").default('22:00:00'),
	quietHoursEnd: time("quiet_hours_end").default('08:00:00'),
	quietHoursTimezone: varchar("quiet_hours_timezone", { length: 50 }).default('America/New_York'),
	dndEnabled: boolean("dnd_enabled").default(false),
	dndUntil: timestamp("dnd_until", { withTimezone: true, mode: 'string' }),
	soundEnabled: boolean("sound_enabled").default(true),
	emailUnsubscribed: boolean("email_unsubscribed").default(false),
	emailUnsubscribedAt: timestamp("email_unsubscribed_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_notification_preferences_dnd").using("btree", table.dndUntil.asc().nullsLast().op("timestamptz_ops")).where(sql`(dnd_enabled = true)`),
	index("idx_notification_preferences_org_user").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.userId.asc().nullsLast().op("uuid_ops")),
	index("idx_notification_preferences_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "notification_preferences_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "notification_preferences_user_id_fkey"
		}).onDelete("cascade"),
	unique("unique_user_category").on(table.userId, table.category),
	pgPolicy("user_isolation_notification_preferences", { as: "permissive", for: "all", to: ["public"], using: sql`(user_id = (current_setting('app.user_id'::text, true))::uuid)` }),
	check("notification_preferences_frequency_check", sql`(frequency)::text = ANY ((ARRAY['immediate'::character varying, 'hourly_digest'::character varying, 'daily_digest'::character varying, 'weekly_digest'::character varying, 'never'::character varying])::text[])`),
]);

export const notificationTemplates = pgTable("notification_templates", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id"),
	name: varchar({ length: 100 }).notNull(),
	slug: varchar({ length: 100 }).notNull(),
	description: text(),
	category: varchar({ length: 100 }).notNull(),
	titleTemplate: varchar("title_template", { length: 500 }).notNull(),
	messageTemplate: text("message_template").notNull(),
	defaultType: varchar("default_type", { length: 50 }).default('info'),
	defaultPriority: varchar("default_priority", { length: 20 }).default('normal'),
	actionUrlTemplate: text("action_url_template"),
	actionLabel: varchar("action_label", { length: 100 }),
	emailSubjectTemplate: varchar("email_subject_template", { length: 500 }),
	emailBodyTemplate: text("email_body_template"),
	emailBodyTextTemplate: text("email_body_text_template"),
	smsTemplate: varchar("sms_template", { length: 500 }),
	pushTitleTemplate: varchar("push_title_template", { length: 100 }),
	pushBodyTemplate: varchar("push_body_template", { length: 255 }),
	pushImageUrl: text("push_image_url"),
	defaultChannels: jsonb("default_channels").default(["in_app"]),
	variables: jsonb().default([]),
	conditions: jsonb().default({}),
	isActive: boolean("is_active").default(true),
	isSystem: boolean("is_system").default(false),
	version: integer().default(1),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	createdBy: uuid("created_by"),
}, (table) => [
	index("idx_notification_templates_category").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.category.asc().nullsLast().op("uuid_ops")).where(sql`(is_active = true)`),
	index("idx_notification_templates_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")).where(sql`(is_active = true)`),
	index("idx_notification_templates_slug").using("btree", table.slug.asc().nullsLast().op("text_ops")).where(sql`(is_active = true)`),
	uniqueIndex("idx_notification_templates_unique_slug").using("btree", sql`COALESCE(org_id, '00000000-0000-0000-0000-000000000000'::uuid)`, sql`slug`).where(sql`(is_active = true)`),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "notification_templates_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "notification_templates_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("org_isolation_notification_templates", { as: "permissive", for: "all", to: ["public"], using: sql`((org_id IS NULL) OR (org_id = (current_setting('app.org_id'::text, true))::uuid))` }),
	check("notification_templates_default_priority_check", sql`(default_priority)::text = ANY ((ARRAY['low'::character varying, 'normal'::character varying, 'high'::character varying, 'urgent'::character varying])::text[])`),
	check("notification_templates_default_type_check", sql`(default_type)::text = ANY ((ARRAY['info'::character varying, 'success'::character varying, 'warning'::character varying, 'error'::character varying, 'action_required'::character varying])::text[])`),
]);

export const campaigns = pgTable("campaigns", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	name: text().notNull(),
	description: text(),
	campaignType: text("campaign_type").default('talent_sourcing').notNull(),
	channel: text().default('email').notNull(),
	status: text().default('draft').notNull(),
	targetAudience: text("target_audience"),
	targetLocations: text("target_locations").array(),
	targetSkills: text("target_skills").array(),
	targetCompanySizes: text("target_company_sizes").array(),
	isAbTest: boolean("is_ab_test").default(false),
	variantATemplateId: uuid("variant_a_template_id"),
	variantBTemplateId: uuid("variant_b_template_id"),
	abSplitPercentage: integer("ab_split_percentage").default(50),
	targetContactsCount: integer("target_contacts_count"),
	targetResponseRate: numeric("target_response_rate", { precision: 5, scale:  2 }),
	targetConversionCount: integer("target_conversion_count"),
	contactsReached: integer("contacts_reached").default(0),
	emailsSent: integer("emails_sent").default(0),
	linkedinMessagesSent: integer("linkedin_messages_sent").default(0),
	responsesReceived: integer("responses_received").default(0),
	conversions: integer().default(0),
	responseRate: numeric("response_rate", { precision: 5, scale:  2 }).generatedAlwaysAs(sql`
CASE
    WHEN (emails_sent > 0) THEN round((((responses_received)::numeric / (emails_sent)::numeric) * (100)::numeric), 2)
    ELSE (0)::numeric
END`),
	startDate: date("start_date"),
	endDate: date("end_date"),
	ownerId: uuid("owner_id").notNull(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	goal: text(),
	targetCriteria: jsonb("target_criteria").default({}),
	channels: text().array().default([""]),
	sequences: jsonb().default({}),
	budgetTotal: numeric("budget_total", { precision: 12, scale:  2 }).default('0'),
	budgetCurrency: text("budget_currency").default('USD'),
	targetLeads: integer("target_leads").default(0),
	targetMeetings: integer("target_meetings").default(0),
	targetRevenue: numeric("target_revenue", { precision: 12, scale:  2 }).default('0'),
	complianceSettings: jsonb("compliance_settings").default({"casl":true,"gdpr":true,"canSpam":true,"includeUnsubscribe":true}),
	approvedBy: uuid("approved_by"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	rejectionReason: text("rejection_reason"),
	approvalStatus: text("approval_status").default('not_required'),
	abTestConfig: jsonb("ab_test_config"),
	budgetSpent: numeric("budget_spent", { precision: 12, scale:  2 }).default('0'),
	leadsGenerated: integer("leads_generated").default(0),
	meetingsBooked: integer("meetings_booked").default(0),
	revenueGenerated: numeric("revenue_generated", { precision: 12, scale:  2 }).default('0'),
	audienceSize: integer("audience_size").default(0),
	prospectsContacted: integer("prospects_contacted").default(0),
	prospectsOpened: integer("prospects_opened").default(0),
	prospectsClicked: integer("prospects_clicked").default(0),
	prospectsResponded: integer("prospects_responded").default(0),
	// TODO: failed to parse database type 'tsvector'
	searchVector: unknown("search_vector"),
	sequenceTemplateIds: uuid("sequence_template_ids").array().default([""]),
	updatedBy: uuid("updated_by"),
	sendWindowStart: time("send_window_start").default('09:00:00'),
	sendWindowEnd: time("send_window_end").default('17:00:00'),
	sendDays: text("send_days").array().default(["RAY['mon'::text", "'tue'::text", "'wed'::text", "'thu'::text", "'fri'::tex"]),
	timezone: text().default('America/New_York'),
	totalSent: integer("total_sent").default(0),
	totalCompleted: integer("total_completed").default(0),
	totalActive: integer("total_active").default(0),
	totalBounced: integer("total_bounced").default(0),
	totalUnsubscribed: integer("total_unsubscribed").default(0),
}, (table) => [
	index("idx_campaigns_approval_status").using("btree", table.approvalStatus.asc().nullsLast().op("text_ops")),
	index("idx_campaigns_channels").using("gin", table.channels.asc().nullsLast().op("array_ops")),
	index("idx_campaigns_dates").using("btree", table.startDate.asc().nullsLast().op("date_ops"), table.endDate.asc().nullsLast().op("date_ops")),
	index("idx_campaigns_deleted_at").using("btree", table.deletedAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_campaigns_goal").using("btree", table.goal.asc().nullsLast().op("text_ops")),
	index("idx_campaigns_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_campaigns_org_created").using("btree", table.orgId.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_campaigns_org_status").using("btree", table.orgId.asc().nullsLast().op("text_ops"), table.status.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_campaigns_owner").using("btree", table.ownerId.asc().nullsLast().op("uuid_ops")),
	index("idx_campaigns_search").using("gin", table.searchVector.asc().nullsLast().op("tsvector_ops")),
	index("idx_campaigns_sequence_template_ids").using("gin", table.sequenceTemplateIds.asc().nullsLast().op("array_ops")),
	index("idx_campaigns_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("idx_campaigns_type").using("btree", table.campaignType.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.approvedBy],
			foreignColumns: [userProfiles.id],
			name: "campaigns_approved_by_fkey"
		}),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "campaigns_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "campaigns_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.ownerId],
			foreignColumns: [userProfiles.id],
			name: "campaigns_owner_id_fkey"
		}),
	foreignKey({
			columns: [table.updatedBy],
			foreignColumns: [userProfiles.id],
			name: "campaigns_updated_by_fkey"
		}),
	pgPolicy("campaigns_create", { as: "permissive", for: "insert", to: ["public"], withCheck: sql`(auth_has_role('admin'::text) OR auth_has_role('recruiter'::text))`  }),
	pgPolicy("campaigns_employee_all", { as: "permissive", for: "all", to: ["public"] }),
	pgPolicy("campaigns_employee_select", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("campaigns_org_isolation", { as: "permissive", for: "all", to: ["public"] }),
	pgPolicy("campaigns_owner_update", { as: "permissive", for: "update", to: ["public"] }),
]);

export const campaignEnrollments = pgTable("campaign_enrollments", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	campaignId: uuid("campaign_id").notNull(),
	contactId: uuid("contact_id").notNull(),
	primaryChannel: text("primary_channel"),
	sequenceStep: integer("sequence_step").default(0),
	sequenceStatus: text("sequence_status").default('pending'),
	stopReason: text("stop_reason"),
	firstContactedAt: timestamp("first_contacted_at", { withTimezone: true, mode: 'string' }),
	lastContactedAt: timestamp("last_contacted_at", { withTimezone: true, mode: 'string' }),
	openedAt: timestamp("opened_at", { withTimezone: true, mode: 'string' }),
	clickedAt: timestamp("clicked_at", { withTimezone: true, mode: 'string' }),
	respondedAt: timestamp("responded_at", { withTimezone: true, mode: 'string' }),
	responseType: text("response_type"),
	responseText: text("response_text"),
	convertedToLeadAt: timestamp("converted_to_lead_at", { withTimezone: true, mode: 'string' }),
	convertedLeadId: uuid("converted_lead_id"),
	meetingBookedAt: timestamp("meeting_booked_at", { withTimezone: true, mode: 'string' }),
	meetingScheduledFor: timestamp("meeting_scheduled_for", { withTimezone: true, mode: 'string' }),
	engagementScore: integer("engagement_score").default(0),
	status: text().default('enrolled'),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	currentStep: integer("current_step").default(0),
	nextStepAt: timestamp("next_step_at", { withTimezone: true, mode: 'string' }),
	stepsCompleted: integer("steps_completed").default(0),
	lastStepAt: timestamp("last_step_at", { withTimezone: true, mode: 'string' }),
	abVariant: text("ab_variant"),
	emailsSent: integer("emails_sent").default(0),
	linkedinSent: integer("linkedin_sent").default(0),
	callsMade: integer("calls_made").default(0),
	smsSent: integer("sms_sent").default(0),
	errorCount: integer("error_count").default(0),
	lastError: text("last_error"),
	lastErrorAt: timestamp("last_error_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_campaign_enrollments_active").using("btree", table.campaignId.asc().nullsLast().op("text_ops"), table.status.asc().nullsLast().op("text_ops"), table.nextStepAt.asc().nullsLast().op("text_ops")).where(sql`(status = ANY (ARRAY['enrolled'::text, 'contacted'::text, 'engaged'::text]))`),
	index("idx_campaign_enrollments_campaign").using("btree", table.campaignId.asc().nullsLast().op("uuid_ops")),
	index("idx_campaign_enrollments_campaign_org").using("btree", table.campaignId.asc().nullsLast().op("uuid_ops"), table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_campaign_enrollments_contact").using("btree", table.contactId.asc().nullsLast().op("uuid_ops")),
	index("idx_campaign_enrollments_funnel").using("btree", table.campaignId.asc().nullsLast().op("timestamptz_ops"), table.firstContactedAt.asc().nullsLast().op("timestamptz_ops"), table.openedAt.asc().nullsLast().op("timestamptz_ops"), table.clickedAt.asc().nullsLast().op("timestamptz_ops"), table.respondedAt.asc().nullsLast().op("timestamptz_ops"), table.convertedToLeadAt.asc().nullsLast().op("timestamptz_ops"), table.meetingBookedAt.asc().nullsLast().op("timestamptz_ops")),
	index("idx_campaign_enrollments_next_step").using("btree", table.nextStepAt.asc().nullsLast().op("timestamptz_ops")).where(sql`((status = 'enrolled'::text) AND (next_step_at IS NOT NULL))`),
	index("idx_campaign_enrollments_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops")),
	index("idx_campaign_enrollments_sequence").using("btree", table.campaignId.asc().nullsLast().op("text_ops"), table.sequenceStatus.asc().nullsLast().op("uuid_ops")),
	index("idx_campaign_enrollments_status").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.campaignId],
			foreignColumns: [campaigns.id],
			name: "campaign_enrollments_campaign_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "campaign_enrollments_contact_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.convertedLeadId],
			foreignColumns: [leads.id],
			name: "campaign_enrollments_converted_lead_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "campaign_enrollments_org_id_fkey"
		}).onDelete("cascade"),
	unique("campaign_enrollments_campaign_id_contact_id_key").on(table.campaignId, table.contactId),
	pgPolicy("campaign_enrollments_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = ((auth.jwt() ->> 'org_id'::text))::uuid)` }),
	check("campaign_enrollments_engagement_score_check", sql`(engagement_score >= 0) AND (engagement_score <= 100)`),
	check("campaign_enrollments_primary_channel_check", sql`primary_channel = ANY (ARRAY['email'::text, 'linkedin'::text, 'phone'::text, 'sms'::text])`),
	check("campaign_enrollments_response_type_check", sql`(response_type IS NULL) OR (response_type = ANY (ARRAY['positive'::text, 'neutral'::text, 'negative'::text, 'auto_reply'::text, 'out_of_office'::text]))`),
	check("campaign_enrollments_sequence_status_check", sql`sequence_status = ANY (ARRAY['pending'::text, 'in_progress'::text, 'stopped'::text, 'completed'::text, 'paused'::text])`),
	check("campaign_enrollments_status_check", sql`status = ANY (ARRAY['enrolled'::text, 'contacted'::text, 'engaged'::text, 'responded'::text, 'converted'::text, 'unsubscribed'::text, 'bounced'::text, 'stopped'::text])`),
]);

export const campaignSequenceLogs = pgTable("campaign_sequence_logs", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	campaignId: uuid("campaign_id").notNull(),
	channel: text().notNull(),
	stepNumber: integer("step_number").notNull(),
	actionType: text("action_type").notNull(),
	actionAt: timestamp("action_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	subject: text(),
	contentPreview: text("content_preview"),
	linkClicked: text("link_clicked"),
	callDurationSeconds: integer("call_duration_seconds"),
	callOutcome: text("call_outcome"),
	responseText: text("response_text"),
	sentiment: text(),
	metadata: jsonb().default({}),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	enrollmentId: uuid("enrollment_id"),
	sequenceId: uuid("sequence_id"),
	abVariant: text("ab_variant"),
	scheduledAt: timestamp("scheduled_at", { withTimezone: true, mode: 'string' }),
	sentAt: timestamp("sent_at", { withTimezone: true, mode: 'string' }),
	templateId: uuid("template_id"),
	variablesUsed: jsonb("variables_used"),
	errorMessage: text("error_message"),
	status: text().default('pending'),
}, (table) => [
	index("idx_campaign_sequence_logs_action_at").using("btree", table.actionAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_campaign_sequence_logs_action_type").using("btree", table.actionType.asc().nullsLast().op("text_ops")),
	index("idx_campaign_sequence_logs_campaign").using("btree", table.campaignId.asc().nullsLast().op("uuid_ops")),
	index("idx_campaign_sequence_logs_enrollment").using("btree", table.enrollmentId.asc().nullsLast().op("int4_ops"), table.stepNumber.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.campaignId],
			foreignColumns: [campaigns.id],
			name: "campaign_sequence_logs_campaign_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.enrollmentId],
			foreignColumns: [campaignEnrollments.id],
			name: "campaign_sequence_logs_enrollment_id_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "campaign_sequence_logs_org_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("campaign_sequence_logs_org_isolation", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = auth_org_id())` }),
	pgPolicy("campaign_sequence_logs_select", { as: "permissive", for: "select", to: ["public"] }),
	check("campaign_sequence_logs_status_check", sql`(status IS NULL) OR (status = ANY (ARRAY['pending'::text, 'sent'::text, 'skipped'::text, 'failed'::text, 'bounced'::text, 'opened'::text, 'clicked'::text, 'replied'::text]))`),
]);

export const communications = pgTable("communications", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	orgId: uuid("org_id").notNull(),
	channel: varchar({ length: 50 }).notNull(),
	direction: varchar({ length: 20 }).notNull(),
	threadId: uuid("thread_id"),
	parentId: uuid("parent_id"),
	threadPosition: integer("thread_position").default(0),
	fromAddress: text("from_address"),
	fromName: text("from_name"),
	toAddress: text("to_address").notNull(),
	toName: text("to_name"),
	ccAddresses: jsonb("cc_addresses").default([]),
	bccAddresses: jsonb("bcc_addresses").default([]),
	subject: text(),
	bodyText: text("body_text"),
	bodyHtml: text("body_html"),
	preview: text(),
	attachments: jsonb().default([]),
	entityType: varchar("entity_type", { length: 50 }),
	entityId: uuid("entity_id"),
	secondaryEntityType: varchar("secondary_entity_type", { length: 50 }),
	secondaryEntityId: uuid("secondary_entity_id"),
	contactId: uuid("contact_id"),
	provider: varchar({ length: 50 }),
	providerMessageId: text("provider_message_id"),
	providerThreadId: text("provider_thread_id"),
	status: varchar({ length: 50 }).default('pending').notNull(),
	scheduledAt: timestamp("scheduled_at", { withTimezone: true, mode: 'string' }),
	sentAt: timestamp("sent_at", { withTimezone: true, mode: 'string' }),
	deliveredAt: timestamp("delivered_at", { withTimezone: true, mode: 'string' }),
	openedAt: timestamp("opened_at", { withTimezone: true, mode: 'string' }),
	clickedAt: timestamp("clicked_at", { withTimezone: true, mode: 'string' }),
	repliedAt: timestamp("replied_at", { withTimezone: true, mode: 'string' }),
	failedAt: timestamp("failed_at", { withTimezone: true, mode: 'string' }),
	openCount: integer("open_count").default(0),
	clickCount: integer("click_count").default(0),
	replyCount: integer("reply_count").default(0),
	clickedLinks: jsonb("clicked_links").default([]),
	errorCode: varchar("error_code", { length: 50 }),
	errorMessage: text("error_message"),
	retryCount: integer("retry_count").default(0),
	maxRetries: integer("max_retries").default(3),
	campaignId: uuid("campaign_id"),
	sequenceStepId: uuid("sequence_step_id"),
	abVariant: varchar("ab_variant", { length: 50 }),
	templateId: uuid("template_id"),
	templateName: text("template_name"),
	templateVariables: jsonb("template_variables").default({}),
	metadata: jsonb().default({}),
	tags: text().array().default([""]),
	createdBy: uuid("created_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_communications_campaign").using("btree", table.campaignId.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")).where(sql`(campaign_id IS NOT NULL)`),
	index("idx_communications_channel").using("btree", table.orgId.asc().nullsLast().op("timestamptz_ops"), table.channel.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_communications_contact").using("btree", table.contactId.asc().nullsLast().op("timestamptz_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")).where(sql`(contact_id IS NOT NULL)`),
	index("idx_communications_entity").using("btree", table.entityType.asc().nullsLast().op("timestamptz_ops"), table.entityId.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")),
	index("idx_communications_org").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_communications_provider").using("btree", table.providerMessageId.asc().nullsLast().op("text_ops")).where(sql`(provider_message_id IS NOT NULL)`),
	index("idx_communications_queue").using("btree", table.scheduledAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(((status)::text = ANY ((ARRAY['pending'::character varying, 'queued'::character varying])::text[])) AND (scheduled_at IS NOT NULL))`),
	index("idx_communications_status").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.status.asc().nullsLast().op("uuid_ops"), table.createdAt.desc().nullsFirst().op("uuid_ops")),
	index("idx_communications_thread").using("btree", table.threadId.asc().nullsLast().op("uuid_ops")).where(sql`(thread_id IS NOT NULL)`),
	foreignKey({
			columns: [table.campaignId],
			foreignColumns: [campaigns.id],
			name: "communications_campaign_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.contactId],
			foreignColumns: [contacts.id],
			name: "communications_contact_id_fkey"
		}).onDelete("set null"),
	foreignKey({
			columns: [table.createdBy],
			foreignColumns: [userProfiles.id],
			name: "communications_created_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "communications_org_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.parentId],
			foreignColumns: [table.id],
			name: "communications_parent_id_fkey"
		}),
	foreignKey({
			columns: [table.threadId],
			foreignColumns: [table.id],
			name: "communications_thread_id_fkey"
		}),
	pgPolicy("org_isolation_communications", { as: "permissive", for: "all", to: ["public"], using: sql`(org_id = (current_setting('app.org_id'::text, true))::uuid)` }),
	check("communications_channel_check", sql`(channel)::text = ANY ((ARRAY['email'::character varying, 'sms'::character varying, 'linkedin'::character varying, 'phone'::character varying, 'whatsapp'::character varying, 'in_app'::character varying])::text[])`),
	check("communications_direction_check", sql`(direction)::text = ANY ((ARRAY['outbound'::character varying, 'inbound'::character varying])::text[])`),
	check("communications_status_check", sql`(status)::text = ANY ((ARRAY['pending'::character varying, 'queued'::character varying, 'sending'::character varying, 'sent'::character varying, 'delivered'::character varying, 'opened'::character varying, 'clicked'::character varying, 'replied'::character varying, 'bounced'::character varying, 'failed'::character varying, 'spam'::character varying, 'unsubscribed'::character varying, 'received'::character varying])::text[])`),
]);

export const communicationEvents = pgTable("communication_events", {
	id: uuid().defaultRandom().primaryKey().notNull(),
	communicationId: uuid("communication_id").notNull(),
	eventType: varchar("event_type", { length: 50 }).notNull(),
	eventData: jsonb("event_data").default({}),
	providerEventId: text("provider_event_id"),
	rawPayload: jsonb("raw_payload"),
	occurredAt: timestamp("occurred_at", { withTimezone: true, mode: 'string' }).defaultNow(),
}, (table) => [
	index("idx_communication_events_comm").using("btree", table.communicationId.asc().nullsLast().op("timestamptz_ops"), table.occurredAt.desc().nullsFirst().op("timestamptz_ops")),
	index("idx_communication_events_type").using("btree", table.eventType.asc().nullsLast().op("text_ops"), table.occurredAt.desc().nullsFirst().op("text_ops")),
	foreignKey({
			columns: [table.communicationId],
			foreignColumns: [communications.id],
			name: "communication_events_communication_id_fkey"
		}).onDelete("cascade"),
	pgPolicy("comm_access_communication_events", { as: "permissive", for: "all", to: ["public"], using: sql`(EXISTS ( SELECT 1
   FROM communications c
  WHERE ((c.id = communication_events.communication_id) AND (c.org_id = (current_setting('app.org_id'::text, true))::uuid))))` }),
	check("communication_events_event_type_check", sql`(event_type)::text = ANY ((ARRAY['created'::character varying, 'queued'::character varying, 'sending'::character varying, 'sent'::character varying, 'delivered'::character varying, 'opened'::character varying, 'clicked'::character varying, 'replied'::character varying, 'bounced'::character varying, 'failed'::character varying, 'spam'::character varying, 'unsubscribed'::character varying, 'retried'::character varying])::text[])`),
]);

export const ptoBalances = pgTable("pto_balances", {
	employeeId: uuid("employee_id").notNull(),
	year: integer().notNull(),
	annualAccrualDays: numeric("annual_accrual_days", { precision: 5, scale:  2 }).default('15.0'),
	accrualRatePerPayPeriod: numeric("accrual_rate_per_pay_period", { precision: 5, scale:  2 }),
	totalAccrued: numeric("total_accrued", { precision: 5, scale:  2 }).default('0'),
	totalUsed: numeric("total_used", { precision: 5, scale:  2 }).default('0'),
	totalPending: numeric("total_pending", { precision: 5, scale:  2 }).default('0'),
	currentBalance: numeric("current_balance", { precision: 5, scale:  2 }).generatedAlwaysAs(sql`((total_accrued - total_used) - total_pending)`),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("idx_pto_balances_employee").using("btree", table.employeeId.asc().nullsLast().op("uuid_ops")),
	index("idx_pto_balances_year").using("btree", table.year.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.employeeId],
			foreignColumns: [userProfiles.id],
			name: "pto_balances_employee_id_fkey"
		}).onDelete("cascade"),
	primaryKey({ columns: [table.employeeId, table.year], name: "pto_balances_pkey"}),
	pgPolicy("pto_balances_employee_own", { as: "permissive", for: "select", to: ["public"], using: sql`(employee_id = auth.uid())` }),
	pgPolicy("pto_balances_hr_all", { as: "permissive", for: "all", to: ["public"] }),
]);

export const userRoles = pgTable("user_roles", {
	userId: uuid("user_id").notNull(),
	roleId: uuid("role_id").notNull(),
	assignedAt: timestamp("assigned_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	assignedBy: uuid("assigned_by"),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }),
	isPrimary: boolean("is_primary").default(false),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("idx_user_roles_expires").using("btree", table.expiresAt.asc().nullsLast().op("timestamptz_ops")).where(sql`(expires_at IS NOT NULL)`),
	index("idx_user_roles_primary").using("btree", table.userId.asc().nullsLast().op("bool_ops"), table.isPrimary.asc().nullsLast().op("bool_ops")).where(sql`(is_primary = true)`),
	index("idx_user_roles_role").using("btree", table.roleId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	index("idx_user_roles_user").using("btree", table.userId.asc().nullsLast().op("uuid_ops")).where(sql`(deleted_at IS NULL)`),
	foreignKey({
			columns: [table.assignedBy],
			foreignColumns: [userProfiles.id],
			name: "user_roles_assigned_by_fkey"
		}),
	foreignKey({
			columns: [table.roleId],
			foreignColumns: [roles.id],
			name: "user_roles_role_id_fkey"
		}).onDelete("cascade"),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "user_roles_user_id_fkey"
		}).onDelete("cascade"),
	primaryKey({ columns: [table.userId, table.roleId], name: "user_roles_pkey"}),
	pgPolicy("Admins can manage user roles", { as: "permissive", for: "all", to: ["public"], using: sql`user_is_admin()`, withCheck: sql`user_is_admin()`  }),
	pgPolicy("Admins can view all user roles", { as: "permissive", for: "select", to: ["public"] }),
	pgPolicy("Users can view own roles", { as: "permissive", for: "select", to: ["public"] }),
]);

export const systemEvents202512 = pgTable("system_events_2025_12", {
	id: uuid().defaultRandom().notNull(),
	orgId: uuid("org_id"),
	eventType: varchar("event_type", { length: 100 }).notNull(),
	eventCategory: eventCategory("event_category").notNull(),
	entityType: varchar("entity_type", { length: 50 }),
	entityId: uuid("entity_id"),
	details: jsonb().default({}).notNull(),
	severity: eventSeverity().default('info'),
	message: text(),
	userId: uuid("user_id"),
	ipAddress: inet("ip_address"),
	userAgent: text("user_agent"),
	requestId: uuid("request_id"),
	apiEndpoint: varchar("api_endpoint", { length: 200 }),
	httpMethod: varchar("http_method", { length: 10 }),
	occurredAt: timestamp("occurred_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	durationMs: integer("duration_ms"),
}, (table) => [
	index("system_events_2025_12_entity_type_entity_id_occurred_at_idx").using("btree", table.entityType.asc().nullsLast().op("timestamptz_ops"), table.entityId.asc().nullsLast().op("uuid_ops"), table.occurredAt.desc().nullsFirst().op("timestamptz_ops")).where(sql`(entity_type IS NOT NULL)`),
	index("system_events_2025_12_event_category_occurred_at_idx").using("btree", table.eventCategory.asc().nullsLast().op("enum_ops"), table.occurredAt.desc().nullsFirst().op("enum_ops")),
	index("system_events_2025_12_event_type_occurred_at_idx").using("btree", table.eventType.asc().nullsLast().op("text_ops"), table.occurredAt.desc().nullsFirst().op("text_ops")),
	index("system_events_2025_12_severity_occurred_at_idx").using("btree", table.severity.asc().nullsLast().op("enum_ops"), table.occurredAt.desc().nullsFirst().op("enum_ops")).where(sql`(severity = ANY (ARRAY['warning'::event_severity, 'error'::event_severity, 'critical'::event_severity]))`),
	index("system_events_2025_12_user_id_occurred_at_idx").using("btree", table.userId.asc().nullsLast().op("uuid_ops"), table.occurredAt.desc().nullsFirst().op("timestamptz_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "system_events_org_id_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "system_events_user_id_fkey"
		}),
	primaryKey({ columns: [table.id, table.occurredAt], name: "system_events_2025_12_pkey"}),
]);

export const systemEvents202601 = pgTable("system_events_2026_01", {
	id: uuid().defaultRandom().notNull(),
	orgId: uuid("org_id"),
	eventType: varchar("event_type", { length: 100 }).notNull(),
	eventCategory: eventCategory("event_category").notNull(),
	entityType: varchar("entity_type", { length: 50 }),
	entityId: uuid("entity_id"),
	details: jsonb().default({}).notNull(),
	severity: eventSeverity().default('info'),
	message: text(),
	userId: uuid("user_id"),
	ipAddress: inet("ip_address"),
	userAgent: text("user_agent"),
	requestId: uuid("request_id"),
	apiEndpoint: varchar("api_endpoint", { length: 200 }),
	httpMethod: varchar("http_method", { length: 10 }),
	occurredAt: timestamp("occurred_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	durationMs: integer("duration_ms"),
}, (table) => [
	index("system_events_2026_01_entity_type_entity_id_occurred_at_idx").using("btree", table.entityType.asc().nullsLast().op("timestamptz_ops"), table.entityId.asc().nullsLast().op("uuid_ops"), table.occurredAt.desc().nullsFirst().op("timestamptz_ops")).where(sql`(entity_type IS NOT NULL)`),
	index("system_events_2026_01_event_category_occurred_at_idx").using("btree", table.eventCategory.asc().nullsLast().op("enum_ops"), table.occurredAt.desc().nullsFirst().op("enum_ops")),
	index("system_events_2026_01_event_type_occurred_at_idx").using("btree", table.eventType.asc().nullsLast().op("text_ops"), table.occurredAt.desc().nullsFirst().op("text_ops")),
	index("system_events_2026_01_severity_occurred_at_idx").using("btree", table.severity.asc().nullsLast().op("enum_ops"), table.occurredAt.desc().nullsFirst().op("enum_ops")).where(sql`(severity = ANY (ARRAY['warning'::event_severity, 'error'::event_severity, 'critical'::event_severity]))`),
	index("system_events_2026_01_user_id_occurred_at_idx").using("btree", table.userId.asc().nullsLast().op("uuid_ops"), table.occurredAt.desc().nullsFirst().op("timestamptz_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "system_events_org_id_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "system_events_user_id_fkey"
		}),
	primaryKey({ columns: [table.id, table.occurredAt], name: "system_events_2026_01_pkey"}),
]);

export const systemEvents202602 = pgTable("system_events_2026_02", {
	id: uuid().defaultRandom().notNull(),
	orgId: uuid("org_id"),
	eventType: varchar("event_type", { length: 100 }).notNull(),
	eventCategory: eventCategory("event_category").notNull(),
	entityType: varchar("entity_type", { length: 50 }),
	entityId: uuid("entity_id"),
	details: jsonb().default({}).notNull(),
	severity: eventSeverity().default('info'),
	message: text(),
	userId: uuid("user_id"),
	ipAddress: inet("ip_address"),
	userAgent: text("user_agent"),
	requestId: uuid("request_id"),
	apiEndpoint: varchar("api_endpoint", { length: 200 }),
	httpMethod: varchar("http_method", { length: 10 }),
	occurredAt: timestamp("occurred_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	durationMs: integer("duration_ms"),
}, (table) => [
	index("system_events_2026_02_entity_type_entity_id_occurred_at_idx").using("btree", table.entityType.asc().nullsLast().op("timestamptz_ops"), table.entityId.asc().nullsLast().op("uuid_ops"), table.occurredAt.desc().nullsFirst().op("timestamptz_ops")).where(sql`(entity_type IS NOT NULL)`),
	index("system_events_2026_02_event_category_occurred_at_idx").using("btree", table.eventCategory.asc().nullsLast().op("enum_ops"), table.occurredAt.desc().nullsFirst().op("enum_ops")),
	index("system_events_2026_02_event_type_occurred_at_idx").using("btree", table.eventType.asc().nullsLast().op("text_ops"), table.occurredAt.desc().nullsFirst().op("text_ops")),
	index("system_events_2026_02_severity_occurred_at_idx").using("btree", table.severity.asc().nullsLast().op("enum_ops"), table.occurredAt.desc().nullsFirst().op("enum_ops")).where(sql`(severity = ANY (ARRAY['warning'::event_severity, 'error'::event_severity, 'critical'::event_severity]))`),
	index("system_events_2026_02_user_id_occurred_at_idx").using("btree", table.userId.asc().nullsLast().op("uuid_ops"), table.occurredAt.desc().nullsFirst().op("timestamptz_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "system_events_org_id_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "system_events_user_id_fkey"
		}),
	primaryKey({ columns: [table.id, table.occurredAt], name: "system_events_2026_02_pkey"}),
]);

export const systemEvents202603 = pgTable("system_events_2026_03", {
	id: uuid().defaultRandom().notNull(),
	orgId: uuid("org_id"),
	eventType: varchar("event_type", { length: 100 }).notNull(),
	eventCategory: eventCategory("event_category").notNull(),
	entityType: varchar("entity_type", { length: 50 }),
	entityId: uuid("entity_id"),
	details: jsonb().default({}).notNull(),
	severity: eventSeverity().default('info'),
	message: text(),
	userId: uuid("user_id"),
	ipAddress: inet("ip_address"),
	userAgent: text("user_agent"),
	requestId: uuid("request_id"),
	apiEndpoint: varchar("api_endpoint", { length: 200 }),
	httpMethod: varchar("http_method", { length: 10 }),
	occurredAt: timestamp("occurred_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	durationMs: integer("duration_ms"),
}, (table) => [
	index("system_events_2026_03_entity_type_entity_id_occurred_at_idx").using("btree", table.entityType.asc().nullsLast().op("timestamptz_ops"), table.entityId.asc().nullsLast().op("uuid_ops"), table.occurredAt.desc().nullsFirst().op("timestamptz_ops")).where(sql`(entity_type IS NOT NULL)`),
	index("system_events_2026_03_event_category_occurred_at_idx").using("btree", table.eventCategory.asc().nullsLast().op("enum_ops"), table.occurredAt.desc().nullsFirst().op("enum_ops")),
	index("system_events_2026_03_event_type_occurred_at_idx").using("btree", table.eventType.asc().nullsLast().op("text_ops"), table.occurredAt.desc().nullsFirst().op("text_ops")),
	index("system_events_2026_03_severity_occurred_at_idx").using("btree", table.severity.asc().nullsLast().op("enum_ops"), table.occurredAt.desc().nullsFirst().op("enum_ops")).where(sql`(severity = ANY (ARRAY['warning'::event_severity, 'error'::event_severity, 'critical'::event_severity]))`),
	index("system_events_2026_03_user_id_occurred_at_idx").using("btree", table.userId.asc().nullsLast().op("uuid_ops"), table.occurredAt.desc().nullsFirst().op("timestamptz_ops")),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "system_events_org_id_fkey"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [userProfiles.id],
			name: "system_events_user_id_fkey"
		}),
	primaryKey({ columns: [table.id, table.occurredAt], name: "system_events_2026_03_pkey"}),
]);

export const auditLog202602 = pgTable("audit_log_2026_02", {
	id: uuid().defaultRandom().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	operation: varchar({ length: 20 }).notNull(),
	changes: jsonb().notNull(),
	changeCount: integer("change_count"),
	containsPii: boolean("contains_pii").default(false),
	piiFields: text("pii_fields"),
	isMasked: boolean("is_masked").default(false),
	requestId: uuid("request_id"),
	ipAddress: inet("ip_address"),
	userAgent: text("user_agent"),
	sessionId: varchar("session_id", { length: 100 }),
	performedBy: uuid("performed_by"),
	performedAt: timestamp("performed_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	impersonatedBy: uuid("impersonated_by"),
	retentionUntil: date("retention_until"),
	archivedAt: timestamp("archived_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("audit_log_2026_02_contains_pii_is_masked_idx").using("btree", table.containsPii.asc().nullsLast().op("bool_ops"), table.isMasked.asc().nullsLast().op("bool_ops")).where(sql`(contains_pii = true)`),
	index("audit_log_2026_02_entity_type_entity_id_performed_at_idx").using("btree", table.entityType.asc().nullsLast().op("timestamptz_ops"), table.entityId.asc().nullsLast().op("text_ops"), table.performedAt.desc().nullsFirst().op("text_ops")),
	index("audit_log_2026_02_org_id_performed_at_idx").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.performedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("audit_log_2026_02_performed_by_performed_at_idx").using("btree", table.performedBy.asc().nullsLast().op("timestamptz_ops"), table.performedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("audit_log_2026_02_retention_until_idx").using("btree", table.retentionUntil.asc().nullsLast().op("date_ops")).where(sql`(retention_until IS NOT NULL)`),
	foreignKey({
			columns: [table.impersonatedBy],
			foreignColumns: [userProfiles.id],
			name: "audit_log_impersonated_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "audit_log_org_id_fkey"
		}),
	foreignKey({
			columns: [table.performedBy],
			foreignColumns: [userProfiles.id],
			name: "audit_log_performed_by_fkey"
		}),
	primaryKey({ columns: [table.id, table.performedAt], name: "audit_log_2026_02_pkey"}),
	check("audit_log_operation_check", sql`(operation)::text = ANY ((ARRAY['create'::character varying, 'update'::character varying, 'delete'::character varying, 'restore'::character varying])::text[])`),
]);

export const auditLog202603 = pgTable("audit_log_2026_03", {
	id: uuid().defaultRandom().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	operation: varchar({ length: 20 }).notNull(),
	changes: jsonb().notNull(),
	changeCount: integer("change_count"),
	containsPii: boolean("contains_pii").default(false),
	piiFields: text("pii_fields"),
	isMasked: boolean("is_masked").default(false),
	requestId: uuid("request_id"),
	ipAddress: inet("ip_address"),
	userAgent: text("user_agent"),
	sessionId: varchar("session_id", { length: 100 }),
	performedBy: uuid("performed_by"),
	performedAt: timestamp("performed_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	impersonatedBy: uuid("impersonated_by"),
	retentionUntil: date("retention_until"),
	archivedAt: timestamp("archived_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("audit_log_2026_03_contains_pii_is_masked_idx").using("btree", table.containsPii.asc().nullsLast().op("bool_ops"), table.isMasked.asc().nullsLast().op("bool_ops")).where(sql`(contains_pii = true)`),
	index("audit_log_2026_03_entity_type_entity_id_performed_at_idx").using("btree", table.entityType.asc().nullsLast().op("timestamptz_ops"), table.entityId.asc().nullsLast().op("text_ops"), table.performedAt.desc().nullsFirst().op("text_ops")),
	index("audit_log_2026_03_org_id_performed_at_idx").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.performedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("audit_log_2026_03_performed_by_performed_at_idx").using("btree", table.performedBy.asc().nullsLast().op("timestamptz_ops"), table.performedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("audit_log_2026_03_retention_until_idx").using("btree", table.retentionUntil.asc().nullsLast().op("date_ops")).where(sql`(retention_until IS NOT NULL)`),
	foreignKey({
			columns: [table.impersonatedBy],
			foreignColumns: [userProfiles.id],
			name: "audit_log_impersonated_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "audit_log_org_id_fkey"
		}),
	foreignKey({
			columns: [table.performedBy],
			foreignColumns: [userProfiles.id],
			name: "audit_log_performed_by_fkey"
		}),
	primaryKey({ columns: [table.id, table.performedAt], name: "audit_log_2026_03_pkey"}),
	check("audit_log_operation_check", sql`(operation)::text = ANY ((ARRAY['create'::character varying, 'update'::character varying, 'delete'::character varying, 'restore'::character varying])::text[])`),
]);

export const auditLog202512 = pgTable("audit_log_2025_12", {
	id: uuid().defaultRandom().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	operation: varchar({ length: 20 }).notNull(),
	changes: jsonb().notNull(),
	changeCount: integer("change_count"),
	containsPii: boolean("contains_pii").default(false),
	piiFields: text("pii_fields"),
	isMasked: boolean("is_masked").default(false),
	requestId: uuid("request_id"),
	ipAddress: inet("ip_address"),
	userAgent: text("user_agent"),
	sessionId: varchar("session_id", { length: 100 }),
	performedBy: uuid("performed_by"),
	performedAt: timestamp("performed_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	impersonatedBy: uuid("impersonated_by"),
	retentionUntil: date("retention_until"),
	archivedAt: timestamp("archived_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("audit_log_2025_12_contains_pii_is_masked_idx").using("btree", table.containsPii.asc().nullsLast().op("bool_ops"), table.isMasked.asc().nullsLast().op("bool_ops")).where(sql`(contains_pii = true)`),
	index("audit_log_2025_12_entity_type_entity_id_performed_at_idx").using("btree", table.entityType.asc().nullsLast().op("timestamptz_ops"), table.entityId.asc().nullsLast().op("text_ops"), table.performedAt.desc().nullsFirst().op("text_ops")),
	index("audit_log_2025_12_org_id_performed_at_idx").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.performedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("audit_log_2025_12_performed_by_performed_at_idx").using("btree", table.performedBy.asc().nullsLast().op("timestamptz_ops"), table.performedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("audit_log_2025_12_retention_until_idx").using("btree", table.retentionUntil.asc().nullsLast().op("date_ops")).where(sql`(retention_until IS NOT NULL)`),
	foreignKey({
			columns: [table.impersonatedBy],
			foreignColumns: [userProfiles.id],
			name: "audit_log_impersonated_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "audit_log_org_id_fkey"
		}),
	foreignKey({
			columns: [table.performedBy],
			foreignColumns: [userProfiles.id],
			name: "audit_log_performed_by_fkey"
		}),
	primaryKey({ columns: [table.id, table.performedAt], name: "audit_log_2025_12_pkey"}),
	check("audit_log_operation_check", sql`(operation)::text = ANY ((ARRAY['create'::character varying, 'update'::character varying, 'delete'::character varying, 'restore'::character varying])::text[])`),
]);

export const auditLog202601 = pgTable("audit_log_2026_01", {
	id: uuid().defaultRandom().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	operation: varchar({ length: 20 }).notNull(),
	changes: jsonb().notNull(),
	changeCount: integer("change_count"),
	containsPii: boolean("contains_pii").default(false),
	piiFields: text("pii_fields"),
	isMasked: boolean("is_masked").default(false),
	requestId: uuid("request_id"),
	ipAddress: inet("ip_address"),
	userAgent: text("user_agent"),
	sessionId: varchar("session_id", { length: 100 }),
	performedBy: uuid("performed_by"),
	performedAt: timestamp("performed_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	impersonatedBy: uuid("impersonated_by"),
	retentionUntil: date("retention_until"),
	archivedAt: timestamp("archived_at", { withTimezone: true, mode: 'string' }),
}, (table) => [
	index("audit_log_2026_01_contains_pii_is_masked_idx").using("btree", table.containsPii.asc().nullsLast().op("bool_ops"), table.isMasked.asc().nullsLast().op("bool_ops")).where(sql`(contains_pii = true)`),
	index("audit_log_2026_01_entity_type_entity_id_performed_at_idx").using("btree", table.entityType.asc().nullsLast().op("timestamptz_ops"), table.entityId.asc().nullsLast().op("text_ops"), table.performedAt.desc().nullsFirst().op("text_ops")),
	index("audit_log_2026_01_org_id_performed_at_idx").using("btree", table.orgId.asc().nullsLast().op("uuid_ops"), table.performedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("audit_log_2026_01_performed_by_performed_at_idx").using("btree", table.performedBy.asc().nullsLast().op("timestamptz_ops"), table.performedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("audit_log_2026_01_retention_until_idx").using("btree", table.retentionUntil.asc().nullsLast().op("date_ops")).where(sql`(retention_until IS NOT NULL)`),
	foreignKey({
			columns: [table.impersonatedBy],
			foreignColumns: [userProfiles.id],
			name: "audit_log_impersonated_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "audit_log_org_id_fkey"
		}),
	foreignKey({
			columns: [table.performedBy],
			foreignColumns: [userProfiles.id],
			name: "audit_log_performed_by_fkey"
		}),
	primaryKey({ columns: [table.id, table.performedAt], name: "audit_log_2026_01_pkey"}),
	check("audit_log_operation_check", sql`(operation)::text = ANY ((ARRAY['create'::character varying, 'update'::character varying, 'delete'::character varying, 'restore'::character varying])::text[])`),
]);

export const entityHistory202601 = pgTable("entity_history_2026_01", {
	id: uuid().defaultRandom().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	changeType: historyChangeType("change_type").notNull(),
	fieldName: varchar("field_name", { length: 100 }).notNull(),
	oldValue: varchar("old_value", { length: 500 }),
	newValue: varchar("new_value", { length: 500 }),
	oldValueLabel: varchar("old_value_label", { length: 200 }),
	newValueLabel: varchar("new_value_label", { length: 200 }),
	reason: text(),
	comment: text(),
	relatedEntityType: varchar("related_entity_type", { length: 50 }),
	relatedEntityId: uuid("related_entity_id"),
	correlationId: uuid("correlation_id"),
	workflowId: uuid("workflow_id"),
	workflowStepId: uuid("workflow_step_id"),
	isAutomated: boolean("is_automated").default(false),
	timeInPreviousState: interval("time_in_previous_state"),
	changedBy: uuid("changed_by"),
	changedAt: timestamp("changed_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	metadata: jsonb(),
}, (table) => [
	index("entity_history_2026_01_changed_by_changed_at_idx").using("btree", table.changedBy.asc().nullsLast().op("timestamptz_ops"), table.changedAt.desc().nullsFirst().op("uuid_ops")),
	index("entity_history_2026_01_correlation_id_idx").using("btree", table.correlationId.asc().nullsLast().op("uuid_ops")).where(sql`(correlation_id IS NOT NULL)`),
	index("entity_history_2026_01_entity_type_entity_id_changed_at_idx").using("btree", table.entityType.asc().nullsLast().op("timestamptz_ops"), table.entityId.asc().nullsLast().op("timestamptz_ops"), table.changedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("entity_history_2026_01_entity_type_field_name_changed_at_idx").using("btree", table.entityType.asc().nullsLast().op("timestamptz_ops"), table.fieldName.asc().nullsLast().op("timestamptz_ops"), table.changedAt.desc().nullsFirst().op("text_ops")),
	index("entity_history_2026_01_org_id_changed_at_idx").using("btree", table.orgId.asc().nullsLast().op("timestamptz_ops"), table.changedAt.desc().nullsFirst().op("uuid_ops")),
	foreignKey({
			columns: [table.changedBy],
			foreignColumns: [userProfiles.id],
			name: "entity_history_changed_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "entity_history_org_id_fkey"
		}),
	primaryKey({ columns: [table.id, table.changedAt], name: "entity_history_2026_01_pkey"}),
]);

export const entityHistory202602 = pgTable("entity_history_2026_02", {
	id: uuid().defaultRandom().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	changeType: historyChangeType("change_type").notNull(),
	fieldName: varchar("field_name", { length: 100 }).notNull(),
	oldValue: varchar("old_value", { length: 500 }),
	newValue: varchar("new_value", { length: 500 }),
	oldValueLabel: varchar("old_value_label", { length: 200 }),
	newValueLabel: varchar("new_value_label", { length: 200 }),
	reason: text(),
	comment: text(),
	relatedEntityType: varchar("related_entity_type", { length: 50 }),
	relatedEntityId: uuid("related_entity_id"),
	correlationId: uuid("correlation_id"),
	workflowId: uuid("workflow_id"),
	workflowStepId: uuid("workflow_step_id"),
	isAutomated: boolean("is_automated").default(false),
	timeInPreviousState: interval("time_in_previous_state"),
	changedBy: uuid("changed_by"),
	changedAt: timestamp("changed_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	metadata: jsonb(),
}, (table) => [
	index("entity_history_2026_02_changed_by_changed_at_idx").using("btree", table.changedBy.asc().nullsLast().op("uuid_ops"), table.changedAt.desc().nullsFirst().op("uuid_ops")),
	index("entity_history_2026_02_correlation_id_idx").using("btree", table.correlationId.asc().nullsLast().op("uuid_ops")).where(sql`(correlation_id IS NOT NULL)`),
	index("entity_history_2026_02_entity_type_entity_id_changed_at_idx").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("text_ops"), table.changedAt.desc().nullsFirst().op("text_ops")),
	index("entity_history_2026_02_entity_type_field_name_changed_at_idx").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.fieldName.asc().nullsLast().op("timestamptz_ops"), table.changedAt.desc().nullsFirst().op("text_ops")),
	index("entity_history_2026_02_org_id_changed_at_idx").using("btree", table.orgId.asc().nullsLast().op("timestamptz_ops"), table.changedAt.desc().nullsFirst().op("uuid_ops")),
	foreignKey({
			columns: [table.changedBy],
			foreignColumns: [userProfiles.id],
			name: "entity_history_changed_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "entity_history_org_id_fkey"
		}),
	primaryKey({ columns: [table.id, table.changedAt], name: "entity_history_2026_02_pkey"}),
]);

export const entityHistory202603 = pgTable("entity_history_2026_03", {
	id: uuid().defaultRandom().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	changeType: historyChangeType("change_type").notNull(),
	fieldName: varchar("field_name", { length: 100 }).notNull(),
	oldValue: varchar("old_value", { length: 500 }),
	newValue: varchar("new_value", { length: 500 }),
	oldValueLabel: varchar("old_value_label", { length: 200 }),
	newValueLabel: varchar("new_value_label", { length: 200 }),
	reason: text(),
	comment: text(),
	relatedEntityType: varchar("related_entity_type", { length: 50 }),
	relatedEntityId: uuid("related_entity_id"),
	correlationId: uuid("correlation_id"),
	workflowId: uuid("workflow_id"),
	workflowStepId: uuid("workflow_step_id"),
	isAutomated: boolean("is_automated").default(false),
	timeInPreviousState: interval("time_in_previous_state"),
	changedBy: uuid("changed_by"),
	changedAt: timestamp("changed_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	metadata: jsonb(),
}, (table) => [
	index("entity_history_2026_03_changed_by_changed_at_idx").using("btree", table.changedBy.asc().nullsLast().op("uuid_ops"), table.changedAt.desc().nullsFirst().op("uuid_ops")),
	index("entity_history_2026_03_correlation_id_idx").using("btree", table.correlationId.asc().nullsLast().op("uuid_ops")).where(sql`(correlation_id IS NOT NULL)`),
	index("entity_history_2026_03_entity_type_entity_id_changed_at_idx").using("btree", table.entityType.asc().nullsLast().op("uuid_ops"), table.entityId.asc().nullsLast().op("text_ops"), table.changedAt.desc().nullsFirst().op("text_ops")),
	index("entity_history_2026_03_entity_type_field_name_changed_at_idx").using("btree", table.entityType.asc().nullsLast().op("text_ops"), table.fieldName.asc().nullsLast().op("timestamptz_ops"), table.changedAt.desc().nullsFirst().op("text_ops")),
	index("entity_history_2026_03_org_id_changed_at_idx").using("btree", table.orgId.asc().nullsLast().op("timestamptz_ops"), table.changedAt.desc().nullsFirst().op("uuid_ops")),
	foreignKey({
			columns: [table.changedBy],
			foreignColumns: [userProfiles.id],
			name: "entity_history_changed_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "entity_history_org_id_fkey"
		}),
	primaryKey({ columns: [table.id, table.changedAt], name: "entity_history_2026_03_pkey"}),
]);

export const entityHistory202512 = pgTable("entity_history_2025_12", {
	id: uuid().defaultRandom().notNull(),
	orgId: uuid("org_id").notNull(),
	entityType: varchar("entity_type", { length: 50 }).notNull(),
	entityId: uuid("entity_id").notNull(),
	changeType: historyChangeType("change_type").notNull(),
	fieldName: varchar("field_name", { length: 100 }).notNull(),
	oldValue: varchar("old_value", { length: 500 }),
	newValue: varchar("new_value", { length: 500 }),
	oldValueLabel: varchar("old_value_label", { length: 200 }),
	newValueLabel: varchar("new_value_label", { length: 200 }),
	reason: text(),
	comment: text(),
	relatedEntityType: varchar("related_entity_type", { length: 50 }),
	relatedEntityId: uuid("related_entity_id"),
	correlationId: uuid("correlation_id"),
	workflowId: uuid("workflow_id"),
	workflowStepId: uuid("workflow_step_id"),
	isAutomated: boolean("is_automated").default(false),
	timeInPreviousState: interval("time_in_previous_state"),
	changedBy: uuid("changed_by"),
	changedAt: timestamp("changed_at", { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
	metadata: jsonb(),
}, (table) => [
	index("entity_history_2025_12_changed_by_changed_at_idx").using("btree", table.changedBy.asc().nullsLast().op("timestamptz_ops"), table.changedAt.desc().nullsFirst().op("uuid_ops")),
	index("entity_history_2025_12_correlation_id_idx").using("btree", table.correlationId.asc().nullsLast().op("uuid_ops")).where(sql`(correlation_id IS NOT NULL)`),
	index("entity_history_2025_12_entity_type_entity_id_changed_at_idx").using("btree", table.entityType.asc().nullsLast().op("timestamptz_ops"), table.entityId.asc().nullsLast().op("timestamptz_ops"), table.changedAt.desc().nullsFirst().op("timestamptz_ops")),
	index("entity_history_2025_12_entity_type_field_name_changed_at_idx").using("btree", table.entityType.asc().nullsLast().op("timestamptz_ops"), table.fieldName.asc().nullsLast().op("timestamptz_ops"), table.changedAt.desc().nullsFirst().op("text_ops")),
	index("entity_history_2025_12_org_id_changed_at_idx").using("btree", table.orgId.asc().nullsLast().op("timestamptz_ops"), table.changedAt.desc().nullsFirst().op("uuid_ops")),
	foreignKey({
			columns: [table.changedBy],
			foreignColumns: [userProfiles.id],
			name: "entity_history_changed_by_fkey"
		}),
	foreignKey({
			columns: [table.orgId],
			foreignColumns: [organizations.id],
			name: "entity_history_org_id_fkey"
		}),
	primaryKey({ columns: [table.id, table.changedAt], name: "entity_history_2025_12_pkey"}),
]);
export const revenueAnalytics = pgMaterializedView("revenue_analytics", {	month: timestamp({ withTimezone: true, mode: 'string' }),
	mrr: numeric(),
	totalRevenue: numeric("total_revenue"),
	oneTimeRevenue: numeric("one_time_revenue"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalEnrollments: bigint("total_enrollments", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	activeSubscriptions: bigint("active_subscriptions", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	newSubscriptions: bigint("new_subscriptions", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	churnedSubscriptions: bigint("churned_subscriptions", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	successfulPayments: bigint("successful_payments", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	failedPayments: bigint("failed_payments", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	refundedPayments: bigint("refunded_payments", { mode: "number" }),
	refundAmount: numeric("refund_amount"),
	avgRevenuePerEnrollment: numeric("avg_revenue_per_enrollment"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniquePayingStudents: bigint("unique_paying_students", { mode: "number" }),
}).as(sql`SELECT date_trunc('month'::text, pt.created_at) AS month, sum( CASE WHEN pt.status = 'succeeded'::text AND se.payment_type = 'subscription'::text THEN pt.amount ELSE 0::numeric END) AS mrr, sum( CASE WHEN pt.status = 'succeeded'::text THEN pt.amount ELSE 0::numeric END) AS total_revenue, sum( CASE WHEN pt.status = 'succeeded'::text AND se.payment_type = 'one_time'::text THEN pt.amount ELSE 0::numeric END) AS one_time_revenue, count(DISTINCT se.id) AS total_enrollments, count(DISTINCT CASE WHEN se.status = 'active'::text AND se.payment_type = 'subscription'::text THEN se.id ELSE NULL::uuid END) AS active_subscriptions, count(DISTINCT CASE WHEN se.payment_type = 'subscription'::text AND date_trunc('month'::text, se.enrolled_at) = date_trunc('month'::text, pt.created_at) THEN se.id ELSE NULL::uuid END) AS new_subscriptions, count(DISTINCT CASE WHEN (se.status = ANY (ARRAY['dropped'::text, 'expired'::text])) AND se.payment_type = 'subscription'::text AND date_trunc('month'::text, se.updated_at) = date_trunc('month'::text, pt.created_at) THEN se.id ELSE NULL::uuid END) AS churned_subscriptions, count( CASE WHEN pt.status = 'succeeded'::text THEN 1 ELSE NULL::integer END) AS successful_payments, count( CASE WHEN pt.status = 'failed'::text THEN 1 ELSE NULL::integer END) AS failed_payments, count( CASE WHEN pt.status = 'refunded'::text THEN 1 ELSE NULL::integer END) AS refunded_payments, sum( CASE WHEN pt.status = 'refunded'::text THEN pt.amount ELSE 0::numeric END) AS refund_amount, avg( CASE WHEN pt.status = 'succeeded'::text THEN pt.amount ELSE NULL::numeric END) AS avg_revenue_per_enrollment, count(DISTINCT pt.user_id) AS unique_paying_students FROM payment_transactions pt JOIN student_enrollments se ON se.id = pt.enrollment_id GROUP BY (date_trunc('month'::text, pt.created_at))`);

export const courseRevenueAnalytics = pgMaterializedView("course_revenue_analytics", {	courseId: uuid("course_id"),
	courseTitle: text("course_title"),
	courseSlug: text("course_slug"),
	totalRevenue: numeric("total_revenue"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalEnrollments: bigint("total_enrollments", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	activeEnrollments: bigint("active_enrollments", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	completedEnrollments: bigint("completed_enrollments", { mode: "number" }),
	avgRevenuePerEnrollment: numeric("avg_revenue_per_enrollment"),
	completionRatePercent: numeric("completion_rate_percent"),
	firstEnrollmentAt: timestamp("first_enrollment_at", { withTimezone: true, mode: 'string' }),
	lastEnrollmentAt: timestamp("last_enrollment_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT c.id AS course_id, c.title AS course_title, c.slug AS course_slug, sum( CASE WHEN pt.status = 'succeeded'::text THEN pt.amount ELSE 0::numeric END) AS total_revenue, count(DISTINCT se.id) AS total_enrollments, count(DISTINCT CASE WHEN se.status = 'active'::text THEN se.id ELSE NULL::uuid END) AS active_enrollments, count(DISTINCT CASE WHEN se.status = 'completed'::text THEN se.id ELSE NULL::uuid END) AS completed_enrollments, avg( CASE WHEN pt.status = 'succeeded'::text THEN pt.amount ELSE NULL::numeric END) AS avg_revenue_per_enrollment, round(count(DISTINCT CASE WHEN se.status = 'completed'::text THEN se.id ELSE NULL::uuid END)::numeric / NULLIF(count(DISTINCT se.id), 0)::numeric * 100::numeric, 2) AS completion_rate_percent, min(se.enrolled_at) AS first_enrollment_at, max(se.enrolled_at) AS last_enrollment_at FROM courses c LEFT JOIN student_enrollments se ON se.course_id = c.id LEFT JOIN payment_transactions pt ON pt.enrollment_id = se.id WHERE c.deleted_at IS NULL GROUP BY c.id, c.title, c.slug`);

export const userXpTotals = pgMaterializedView("user_xp_totals", {	userId: uuid("user_id"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalXp: bigint("total_xp", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	transactionCount: bigint("transaction_count", { mode: "number" }),
	lastXpEarnedAt: timestamp("last_xp_earned_at", { withTimezone: true, mode: 'string' }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	leaderboardRank: bigint("leaderboard_rank", { mode: "number" }),
}).as(sql`SELECT user_id, sum(amount) AS total_xp, count(*) AS transaction_count, max(awarded_at) AS last_xp_earned_at, rank() OVER (ORDER BY (sum(amount)) DESC) AS leaderboard_rank FROM xp_transactions GROUP BY user_id`);

export const studentLtvAnalytics = pgMaterializedView("student_ltv_analytics", {	studentId: uuid("student_id"),
	studentName: text("student_name"),
	studentEmail: text("student_email"),
	lifetimeRevenue: numeric("lifetime_revenue"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalEnrollments: bigint("total_enrollments", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	activeSubscriptions: bigint("active_subscriptions", { mode: "number" }),
	avgRevenuePerEnrollment: numeric("avg_revenue_per_enrollment"),
	firstPurchaseAt: timestamp("first_purchase_at", { withTimezone: true, mode: 'string' }),
	lastPurchaseAt: timestamp("last_purchase_at", { withTimezone: true, mode: 'string' }),
	monthsAsCustomer: numeric("months_as_customer"),
}).as(sql`SELECT up.id AS student_id, up.full_name AS student_name, up.email AS student_email, sum( CASE WHEN pt.status = 'succeeded'::text THEN pt.amount ELSE 0::numeric END) AS lifetime_revenue, count(DISTINCT se.id) AS total_enrollments, count(DISTINCT CASE WHEN se.status = 'active'::text AND se.payment_type = 'subscription'::text THEN se.id ELSE NULL::uuid END) AS active_subscriptions, avg( CASE WHEN pt.status = 'succeeded'::text THEN pt.amount ELSE NULL::numeric END) AS avg_revenue_per_enrollment, min(pt.created_at) AS first_purchase_at, max(pt.created_at) AS last_purchase_at, EXTRACT(epoch FROM max(pt.created_at) - min(pt.created_at)) / (30 * 24 * 60 * 60)::numeric AS months_as_customer FROM user_profiles up JOIN payment_transactions pt ON pt.user_id = up.id JOIN student_enrollments se ON se.id = pt.enrollment_id WHERE pt.status = 'succeeded'::text GROUP BY up.id, up.full_name, up.email`);

export const vSprint5Status = pgView("v_sprint_5_status", {	tableName: text("table_name"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalRecords: bigint("total_records", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueOrgs: bigint("unique_orgs", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueUsers: bigint("unique_users", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	placements: bigint({ mode: "number" }),
	avgQuality: numeric("avg_quality"),
}).as(sql`SELECT 'generated_resumes'::text AS table_name, count(*) AS total_records, count(DISTINCT generated_resumes.org_id) AS unique_orgs, count(DISTINCT generated_resumes.user_id) AS unique_users, count(*) FILTER (WHERE generated_resumes.placement_achieved = true) AS placements, round(avg(generated_resumes.quality_score), 2) AS avg_quality FROM generated_resumes UNION ALL SELECT 'candidate_embeddings'::text AS table_name, count(*) AS total_records, count(DISTINCT candidate_embeddings.org_id) AS unique_orgs, count(DISTINCT candidate_embeddings.candidate_id) AS unique_users, NULL::bigint AS placements, NULL::numeric AS avg_quality FROM candidate_embeddings UNION ALL SELECT 'requisition_embeddings'::text AS table_name, count(*) AS total_records, count(DISTINCT requisition_embeddings.org_id) AS unique_orgs, count(DISTINCT requisition_embeddings.requisition_id) AS unique_users, NULL::bigint AS placements, NULL::numeric AS avg_quality FROM requisition_embeddings UNION ALL SELECT 'resume_matches'::text AS table_name, count(*) AS total_records, count(DISTINCT resume_matches.org_id) AS unique_orgs, count(DISTINCT resume_matches.candidate_id) AS unique_users, count(*) FILTER (WHERE resume_matches.placement_achieved = true) AS placements, round(avg(resume_matches.match_score), 2) AS avg_quality FROM resume_matches`);

export const discountEffectivenessAnalytics = pgMaterializedView("discount_effectiveness_analytics", {	discountCodeId: uuid("discount_code_id"),
	discountCode: text("discount_code"),
	discountName: text("discount_name"),
	discountType: text("discount_type"),
	discountValue: numeric("discount_value", { precision: 10, scale:  2 }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalUses: bigint("total_uses", { mode: "number" }),
	maxUsesLimit: integer("max_uses_limit"),
	totalOriginalAmount: numeric("total_original_amount"),
	totalDiscountGiven: numeric("total_discount_given"),
	totalRevenueGenerated: numeric("total_revenue_generated"),
	avgDiscountPerUse: numeric("avg_discount_per_use"),
	roiRatio: numeric("roi_ratio"),
	firstUsedAt: timestamp("first_used_at", { withTimezone: true, mode: 'string' }),
	lastUsedAt: timestamp("last_used_at", { withTimezone: true, mode: 'string' }),
	isActive: boolean("is_active"),
	validFrom: timestamp("valid_from", { withTimezone: true, mode: 'string' }),
	validUntil: timestamp("valid_until", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT dc.id AS discount_code_id, dc.code AS discount_code, dc.name AS discount_name, dc.discount_type, dc.discount_value, count(dcu.id) AS total_uses, dc.max_uses AS max_uses_limit, sum(dcu.original_amount) AS total_original_amount, sum(dcu.discount_amount) AS total_discount_given, sum(dcu.final_amount) AS total_revenue_generated, avg(dcu.discount_amount) AS avg_discount_per_use, round(sum(dcu.final_amount) / NULLIF(sum(dcu.discount_amount), 0::numeric), 2) AS roi_ratio, min(dcu.used_at) AS first_used_at, max(dcu.used_at) AS last_used_at, dc.is_active, dc.valid_from, dc.valid_until FROM discount_codes dc LEFT JOIN discount_code_usage dcu ON dcu.discount_code_id = dc.id WHERE dc.deleted_at IS NULL GROUP BY dc.id, dc.code, dc.name, dc.discount_type, dc.discount_value, dc.max_uses, dc.is_active, dc.valid_from, dc.valid_until`);

export const moduleUnlockRequirements = pgView("module_unlock_requirements", {	moduleId: uuid("module_id"),
	courseId: uuid("course_id"),
	moduleTitle: text("module_title"),
	moduleNumber: integer("module_number"),
	prerequisiteModuleIds: uuid("prerequisite_module_ids"),
	prerequisiteTitles: text("prerequisite_titles"),
	prerequisiteNumbers: integer("prerequisite_numbers"),
}).as(sql`SELECT id AS module_id, course_id, title AS module_title, module_number, prerequisite_module_ids, ( SELECT array_agg(cm2.title) AS array_agg FROM course_modules cm2 WHERE cm2.id = ANY (cm.prerequisite_module_ids)) AS prerequisite_titles, ( SELECT array_agg(cm2.module_number) AS array_agg FROM course_modules cm2 WHERE cm2.id = ANY (cm.prerequisite_module_ids)) AS prerequisite_numbers FROM course_modules cm`);

export const topicUnlockRequirements = pgView("topic_unlock_requirements", {	topicId: uuid("topic_id"),
	moduleId: uuid("module_id"),
	topicTitle: text("topic_title"),
	topicNumber: integer("topic_number"),
	prerequisiteTopicIds: uuid("prerequisite_topic_ids"),
	prerequisiteTitles: text("prerequisite_titles"),
	prerequisiteNumbers: integer("prerequisite_numbers"),
}).as(sql`SELECT id AS topic_id, module_id, title AS topic_title, topic_number, prerequisite_topic_ids, ( SELECT array_agg(mt2.title) AS array_agg FROM module_topics mt2 WHERE mt2.id = ANY (mt.prerequisite_topic_ids)) AS prerequisite_titles, ( SELECT array_agg(mt2.topic_number) AS array_agg FROM module_topics mt2 WHERE mt2.id = ANY (mt.prerequisite_topic_ids)) AS prerequisite_numbers FROM module_topics mt`);

export const videoWatchStats = pgView("video_watch_stats", {	userId: uuid("user_id"),
	topicId: uuid("topic_id"),
	enrollmentId: uuid("enrollment_id"),
	topicTitle: text("topic_title"),
	moduleTitle: text("module_title"),
	courseTitle: text("course_title"),
	totalWatchTimeSeconds: integer("total_watch_time_seconds"),
	completionPercentage: integer("completion_percentage"),
	sessionCount: integer("session_count"),
	lastWatchedAt: timestamp("last_watched_at", { withTimezone: true, mode: 'string' }),
	videoDurationSeconds: integer("video_duration_seconds"),
	videoProvider: text("video_provider"),
	engagementScore: integer("engagement_score"),
}).as(sql`SELECT vp.user_id, vp.topic_id, vp.enrollment_id, mt.title AS topic_title, cm.title AS module_title, c.title AS course_title, vp.total_watch_time_seconds, vp.completion_percentage, vp.session_count, vp.last_watched_at, vp.video_duration_seconds, vp.video_provider, CASE WHEN vp.video_duration_seconds > 0 THEN LEAST(100, vp.total_watch_time_seconds * 100 / vp.video_duration_seconds) ELSE 0 END AS engagement_score FROM video_progress vp JOIN module_topics mt ON mt.id = vp.topic_id JOIN course_modules cm ON cm.id = mt.module_id JOIN courses c ON c.id = cm.course_id`);

export const vTimelineRecent = pgView("v_timeline_recent", {	id: uuid(),
	sessionId: varchar("session_id", { length: 50 }),
	sessionDate: timestamp("session_date", { withTimezone: true, mode: 'string' }),
	agentType: varchar("agent_type", { length: 50 }),
	agentModel: varchar("agent_model", { length: 100 }),
	duration: varchar({ length: 50 }),
	conversationSummary: text("conversation_summary"),
	userIntent: text("user_intent"),
	actionsTaken: jsonb("actions_taken"),
	filesChanged: jsonb("files_changed"),
	decisions: jsonb(),
	assumptions: jsonb(),
	results: jsonb(),
	futureNotes: jsonb("future_notes"),
	relatedCommits: text("related_commits"),
	relatedPrs: text("related_prs"),
	relatedDocs: text("related_docs"),
	tags: text(),
	aiGeneratedSummary: text("ai_generated_summary"),
	keyLearnings: text("key_learnings"),
	// TODO: failed to parse database type 'tsvector'
	searchVector: unknown("search_vector"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	isArchived: boolean("is_archived"),
	sessionStartedAt: timestamp("session_started_at", { withTimezone: true, mode: 'string' }),
	sessionEndedAt: timestamp("session_ended_at", { withTimezone: true, mode: 'string' }),
	sessionBranch: varchar("session_branch", { length: 100 }),
	successfullyCompleted: boolean("successfully_completed"),
}).as(sql`SELECT pt.id, pt.session_id, pt.session_date, pt.agent_type, pt.agent_model, pt.duration, pt.conversation_summary, pt.user_intent, pt.actions_taken, pt.files_changed, pt.decisions, pt.assumptions, pt.results, pt.future_notes, pt.related_commits, pt.related_prs, pt.related_docs, pt.tags, pt.ai_generated_summary, pt.key_learnings, pt.search_vector, pt.created_at, pt.updated_at, pt.deleted_at, pt.is_archived, sm.started_at AS session_started_at, sm.ended_at AS session_ended_at, sm.branch AS session_branch, sm.successfully_completed FROM project_timeline pt LEFT JOIN session_metadata sm ON pt.session_id::text = sm.session_id::text WHERE pt.is_archived = false AND pt.deleted_at IS NULL ORDER BY pt.session_date DESC LIMIT 100`);

export const vTimelineStatsByTag = pgView("v_timeline_stats_by_tag", {	tag: text(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	entryCount: bigint("entry_count", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	sessionCount: bigint("session_count", { mode: "number" }),
	firstOccurrence: timestamp("first_occurrence", { withTimezone: true, mode: 'string' }),
	lastOccurrence: timestamp("last_occurrence", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT unnest(tags) AS tag, count(*) AS entry_count, count(DISTINCT session_id) AS session_count, min(session_date) AS first_occurrence, max(session_date) AS last_occurrence FROM project_timeline WHERE is_archived = false AND deleted_at IS NULL GROUP BY (unnest(tags)) ORDER BY (count(*)) DESC`);

export const vSessionSummary = pgView("v_session_summary", {	id: uuid(),
	sessionId: varchar("session_id", { length: 50 }),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }),
	endedAt: timestamp("ended_at", { withTimezone: true, mode: 'string' }),
	duration: varchar({ length: 50 }),
	branch: varchar({ length: 100 }),
	commitHash: varchar("commit_hash", { length: 40 }),
	environment: varchar({ length: 20 }),
	filesModified: integer("files_modified"),
	linesAdded: integer("lines_added"),
	linesRemoved: integer("lines_removed"),
	commandsExecuted: integer("commands_executed"),
	overallGoal: text("overall_goal"),
	successfullyCompleted: boolean("successfully_completed"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	timelineEntries: bigint("timeline_entries", { mode: "number" }),
	allTags: text("all_tags"),
}).as(sql`SELECT sm.id, sm.session_id, sm.started_at, sm.ended_at, sm.duration, sm.branch, sm.commit_hash, sm.environment, sm.files_modified, sm.lines_added, sm.lines_removed, sm.commands_executed, sm.overall_goal, sm.successfully_completed, sm.created_at, sm.updated_at, count(pt.id) AS timeline_entries, COALESCE(array_agg(DISTINCT t.tag) FILTER (WHERE t.tag IS NOT NULL), ARRAY[]::text[]) AS all_tags FROM session_metadata sm LEFT JOIN project_timeline pt ON sm.session_id::text = pt.session_id::text LEFT JOIN LATERAL unnest(pt.tags) t(tag) ON true GROUP BY sm.id ORDER BY sm.started_at DESC`);

export const vActiveUsers = pgView("v_active_users", {	id: uuid(),
	authId: uuid("auth_id"),
	email: text(),
	fullName: text("full_name"),
	avatarUrl: text("avatar_url"),
	phone: text(),
	timezone: text(),
	locale: text(),
	studentEnrollmentDate: timestamp("student_enrollment_date", { withTimezone: true, mode: 'string' }),
	studentCourseId: uuid("student_course_id"),
	studentCurrentModule: text("student_current_module"),
	studentCourseProgress: jsonb("student_course_progress"),
	studentGraduationDate: timestamp("student_graduation_date", { withTimezone: true, mode: 'string' }),
	studentCertificates: jsonb("student_certificates"),
	employeeHireDate: timestamp("employee_hire_date", { withTimezone: true, mode: 'string' }),
	employeeDepartment: text("employee_department"),
	employeePosition: text("employee_position"),
	employeeSalary: numeric("employee_salary", { precision: 10, scale:  2 }),
	employeeStatus: text("employee_status"),
	employeeManagerId: uuid("employee_manager_id"),
	employeePerformanceRating: numeric("employee_performance_rating", { precision: 3, scale:  2 }),
	candidateStatus: text("candidate_status"),
	candidateResumeUrl: text("candidate_resume_url"),
	candidateSkills: text("candidate_skills"),
	candidateExperienceYears: integer("candidate_experience_years"),
	candidateCurrentVisa: text("candidate_current_visa"),
	candidateVisaExpiry: timestamp("candidate_visa_expiry", { withTimezone: true, mode: 'string' }),
	candidateHourlyRate: numeric("candidate_hourly_rate", { precision: 10, scale:  2 }),
	candidateBenchStartDate: timestamp("candidate_bench_start_date", { withTimezone: true, mode: 'string' }),
	candidateAvailability: text("candidate_availability"),
	candidateLocation: text("candidate_location"),
	candidateWillingToRelocate: boolean("candidate_willing_to_relocate"),
	clientCompanyName: text("client_company_name"),
	clientIndustry: text("client_industry"),
	clientTier: text("client_tier"),
	clientContractStartDate: timestamp("client_contract_start_date", { withTimezone: true, mode: 'string' }),
	clientContractEndDate: timestamp("client_contract_end_date", { withTimezone: true, mode: 'string' }),
	clientPaymentTerms: integer("client_payment_terms"),
	clientPreferredMarkupPercentage: numeric("client_preferred_markup_percentage", { precision: 5, scale:  2 }),
	recruiterTerritory: text("recruiter_territory"),
	recruiterSpecialization: text("recruiter_specialization"),
	recruiterMonthlyPlacementTarget: integer("recruiter_monthly_placement_target"),
	recruiterPodId: uuid("recruiter_pod_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
	createdBy: uuid("created_by"),
	updatedBy: uuid("updated_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	isActive: boolean("is_active"),
	// TODO: failed to parse database type 'tsvector'
	searchVector: unknown("search_vector"),
}).as(sql`SELECT id, auth_id, email, full_name, avatar_url, phone, timezone, locale, student_enrollment_date, student_course_id, student_current_module, student_course_progress, student_graduation_date, student_certificates, employee_hire_date, employee_department, employee_position, employee_salary, employee_status, employee_manager_id, employee_performance_rating, candidate_status, candidate_resume_url, candidate_skills, candidate_experience_years, candidate_current_visa, candidate_visa_expiry, candidate_hourly_rate, candidate_bench_start_date, candidate_availability, candidate_location, candidate_willing_to_relocate, client_company_name, client_industry, client_tier, client_contract_start_date, client_contract_end_date, client_payment_terms, client_preferred_markup_percentage, recruiter_territory, recruiter_specialization, recruiter_monthly_placement_target, recruiter_pod_id, created_at, updated_at, created_by, updated_by, deleted_at, is_active, search_vector FROM user_profiles WHERE deleted_at IS NULL AND is_active = true`);

export const vStudents = pgView("v_students", {	id: uuid(),
	email: text(),
	fullName: text("full_name"),
	studentEnrollmentDate: timestamp("student_enrollment_date", { withTimezone: true, mode: 'string' }),
	studentCurrentModule: text("student_current_module"),
	studentCourseProgress: jsonb("student_course_progress"),
	studentGraduationDate: timestamp("student_graduation_date", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT id, email, full_name, student_enrollment_date, student_current_module, student_course_progress, student_graduation_date, created_at FROM user_profiles WHERE student_enrollment_date IS NOT NULL AND deleted_at IS NULL ORDER BY student_enrollment_date DESC`);

export const vBenchCandidates = pgView("v_bench_candidates", {	id: uuid(),
	email: text(),
	fullName: text("full_name"),
	candidateSkills: text("candidate_skills"),
	candidateExperienceYears: integer("candidate_experience_years"),
	candidateCurrentVisa: text("candidate_current_visa"),
	candidateHourlyRate: numeric("candidate_hourly_rate", { precision: 10, scale:  2 }),
	candidateAvailability: text("candidate_availability"),
	candidateLocation: text("candidate_location"),
	candidateBenchStartDate: timestamp("candidate_bench_start_date", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT id, email, full_name, candidate_skills, candidate_experience_years, candidate_current_visa, candidate_hourly_rate, candidate_availability, candidate_location, candidate_bench_start_date FROM user_profiles WHERE candidate_status = 'bench'::text AND deleted_at IS NULL ORDER BY candidate_bench_start_date`);

export const vEmployees = pgView("v_employees", {	id: uuid(),
	email: text(),
	fullName: text("full_name"),
	employeeDepartment: text("employee_department"),
	employeePosition: text("employee_position"),
	employeeHireDate: timestamp("employee_hire_date", { withTimezone: true, mode: 'string' }),
	employeeManagerId: uuid("employee_manager_id"),
	employeeStatus: text("employee_status"),
}).as(sql`SELECT id, email, full_name, employee_department, employee_position, employee_hire_date, employee_manager_id, employee_status FROM user_profiles WHERE employee_hire_date IS NOT NULL AND employee_status = 'active'::text AND deleted_at IS NULL ORDER BY employee_hire_date DESC`);

export const vClients = pgView("v_clients", {	id: uuid(),
	email: text(),
	contactName: text("contact_name"),
	clientCompanyName: text("client_company_name"),
	clientIndustry: text("client_industry"),
	clientTier: text("client_tier"),
	clientContractStartDate: timestamp("client_contract_start_date", { withTimezone: true, mode: 'string' }),
	clientContractEndDate: timestamp("client_contract_end_date", { withTimezone: true, mode: 'string' }),
	clientPaymentTerms: integer("client_payment_terms"),
}).as(sql`SELECT id, email, full_name AS contact_name, client_company_name, client_industry, client_tier, client_contract_start_date, client_contract_end_date, client_payment_terms FROM user_profiles WHERE client_company_name IS NOT NULL AND deleted_at IS NULL ORDER BY client_tier DESC, client_company_name`);

export const vUserRolesDetailed = pgView("v_user_roles_detailed", {	userId: uuid("user_id"),
	email: text(),
	fullName: text("full_name"),
	roleName: text("role_name"),
	roleDisplayName: text("role_display_name"),
	isPrimary: boolean("is_primary"),
	assignedAt: timestamp("assigned_at", { withTimezone: true, mode: 'string' }),
	expiresAt: timestamp("expires_at", { withTimezone: true, mode: 'string' }),
	roleStatus: text("role_status"),
}).as(sql`SELECT up.id AS user_id, up.email, up.full_name, r.name AS role_name, r.display_name AS role_display_name, ur.is_primary, ur.assigned_at, ur.expires_at, CASE WHEN ur.expires_at IS NOT NULL AND ur.expires_at < now() THEN 'expired'::text WHEN ur.deleted_at IS NOT NULL THEN 'revoked'::text ELSE 'active'::text END AS role_status FROM user_profiles up JOIN user_roles ur ON up.id = ur.user_id JOIN roles r ON ur.role_id = r.id WHERE up.deleted_at IS NULL ORDER BY up.email, ur.is_primary DESC, r.name`);

export const vAuditLogsRecent = pgView("v_audit_logs_recent", {	id: uuid(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	tableName: text("table_name"),
	action: text(),
	userEmail: text("user_email"),
	changedFields: text("changed_fields"),
	severity: text(),
	userName: text("user_name"),
}).as(sql`SELECT al.id, al.created_at, al.table_name, al.action, al.user_email, al.changed_fields, al.severity, up.full_name AS user_name FROM audit_logs al LEFT JOIN user_profiles up ON al.user_id = up.id WHERE al.created_at > (now() - '7 days'::interval) ORDER BY al.created_at DESC LIMIT 1000`);

export const vAuditLogsCritical = pgView("v_audit_logs_critical", {	id: uuid(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	tableName: text("table_name"),
	action: text(),
	userEmail: text("user_email"),
	recordId: uuid("record_id"),
	metadata: jsonb(),
	userName: text("user_name"),
}).as(sql`SELECT al.id, al.created_at, al.table_name, al.action, al.user_email, al.record_id, al.metadata, up.full_name AS user_name FROM audit_logs al LEFT JOIN user_profiles up ON al.user_id = up.id WHERE al.severity = ANY (ARRAY['error'::text, 'critical'::text]) ORDER BY al.created_at DESC`);

export const vUserActivitySummary = pgView("v_user_activity_summary", {	userId: uuid("user_id"),
	userEmail: text("user_email"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalActions: bigint("total_actions", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	inserts: bigint({ mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	updates: bigint({ mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	deletes: bigint({ mode: "number" }),
	lastActivity: timestamp("last_activity", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT user_id, user_email, count(*) AS total_actions, count(*) FILTER (WHERE action = 'INSERT'::text) AS inserts, count(*) FILTER (WHERE action = 'UPDATE'::text) AS updates, count(*) FILTER (WHERE action = 'DELETE'::text) AS deletes, max(created_at) AS last_activity FROM audit_logs WHERE user_id IS NOT NULL AND created_at > (now() - '30 days'::interval) GROUP BY user_id, user_email ORDER BY (count(*)) DESC`);

export const vEventsRecent = pgView("v_events_recent", {	id: uuid(),
	eventType: text("event_type"),
	eventCategory: text("event_category"),
	status: text(),
	userEmail: text("user_email"),
	payload: jsonb(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	triggeredBy: text("triggered_by"),
}).as(sql`SELECT e.id, e.event_type, e.event_category, e.status, e.user_email, e.payload, e.created_at, up.full_name AS triggered_by FROM events e LEFT JOIN user_profiles up ON e.user_id = up.id WHERE e.created_at > (now() - '24:00:00'::interval) ORDER BY e.created_at DESC LIMIT 100`);

export const vEventsFailed = pgView("v_events_failed", {	id: uuid(),
	eventType: text("event_type"),
	status: text(),
	retryCount: integer("retry_count"),
	maxRetries: integer("max_retries"),
	nextRetryAt: timestamp("next_retry_at", { withTimezone: true, mode: 'string' }),
	errorMessage: text("error_message"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	failedAt: timestamp("failed_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT id, event_type, status, retry_count, max_retries, next_retry_at, error_message, created_at, failed_at FROM events e WHERE status = ANY (ARRAY['failed'::text, 'dead_letter'::text]) ORDER BY created_at DESC`);

export const vEventStatsByType = pgView("v_event_stats_by_type", {	eventType: text("event_type"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalEvents: bigint("total_events", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	completed: bigint({ mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	failed: bigint({ mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	deadLetter: bigint("dead_letter", { mode: "number" }),
	avgProcessingTimeSeconds: numeric("avg_processing_time_seconds"),
	lastEventAt: timestamp("last_event_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT event_type, count(*) AS total_events, count(*) FILTER (WHERE status = 'completed'::text) AS completed, count(*) FILTER (WHERE status = 'failed'::text) AS failed, count(*) FILTER (WHERE status = 'dead_letter'::text) AS dead_letter, avg(EXTRACT(epoch FROM processed_at - created_at)) AS avg_processing_time_seconds, max(created_at) AS last_event_at FROM events WHERE created_at > (now() - '7 days'::interval) GROUP BY event_type ORDER BY (count(*)) DESC`);

export const vSubscriberPerformance = pgView("v_subscriber_performance", {	subscriberName: text("subscriber_name"),
	eventPattern: text("event_pattern"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalDeliveries: bigint("total_deliveries", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	successful: bigint({ mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	failed: bigint({ mode: "number" }),
	avgDurationMs: numeric("avg_duration_ms"),
	lastDeliveryAt: timestamp("last_delivery_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT es.subscriber_name, es.event_pattern, count(edl.id) AS total_deliveries, count(*) FILTER (WHERE edl.status = 'success'::text) AS successful, count(*) FILTER (WHERE edl.status = 'failure'::text) AS failed, avg(edl.duration_ms) AS avg_duration_ms, max(edl.attempted_at) AS last_delivery_at FROM event_subscriptions es LEFT JOIN event_delivery_log edl ON es.id = edl.subscription_id WHERE edl.attempted_at > (now() - '7 days'::interval) GROUP BY es.id, es.subscriber_name, es.event_pattern ORDER BY (count(edl.id)) DESC`);

export const vRlsStatus = pgView("v_rls_status", {	// TODO: failed to parse database type 'name'
	schemaname: unknown("schemaname"),
	// TODO: failed to parse database type 'name'
	tablename: unknown("tablename"),
	rlsEnabled: boolean("rls_enabled"),
}).as(sql`SELECT schemaname, tablename, rowsecurity AS rls_enabled FROM pg_tables WHERE schemaname = 'public'::name AND (tablename = ANY (ARRAY['user_profiles'::name, 'roles'::name, 'permissions'::name, 'user_roles'::name, 'role_permissions'::name, 'audit_logs'::name, 'events'::name, 'event_subscriptions'::name])) ORDER BY tablename`);

export const vRlsPolicies = pgView("v_rls_policies", {	// TODO: failed to parse database type 'name'
	schemaname: unknown("schemaname"),
	// TODO: failed to parse database type 'name'
	tablename: unknown("tablename"),
	// TODO: failed to parse database type 'name'
	policyname: unknown("policyname"),
	permissive: text(),
	// TODO: failed to parse database type 'name[]'
	roles: unknown("roles"),
	cmd: text(),
	qual: text(),
	withCheck: text("with_check"),
}).as(sql`SELECT schemaname, tablename, policyname, permissive, roles, cmd, qual, with_check FROM pg_policies WHERE schemaname = 'public'::name ORDER BY tablename, policyname`);

export const vMultiTenancyStatus = pgView("v_multi_tenancy_status", {	tableName: text("table_name"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalRecords: bigint("total_records", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueOrgs: bigint("unique_orgs", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	activeOrgs: bigint("active_orgs", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	softDeletedOrgs: bigint("soft_deleted_orgs", { mode: "number" }),
}).as(sql`SELECT 'organizations'::text AS table_name, count(*) AS total_records, count(DISTINCT organizations.id) AS unique_orgs, count(*) FILTER (WHERE organizations.status = 'active'::text) AS active_orgs, count(*) FILTER (WHERE organizations.deleted_at IS NOT NULL) AS soft_deleted_orgs FROM organizations UNION ALL SELECT 'user_profiles'::text AS table_name, count(*) AS total_records, count(DISTINCT user_profiles.org_id) AS unique_orgs, count(*) FILTER (WHERE user_profiles.org_id IS NOT NULL) AS active_orgs, NULL::bigint AS soft_deleted_orgs FROM user_profiles UNION ALL SELECT 'audit_logs'::text AS table_name, count(*) AS total_records, count(DISTINCT audit_logs.org_id) AS unique_orgs, count(*) FILTER (WHERE audit_logs.org_id IS NOT NULL) AS active_orgs, NULL::bigint AS soft_deleted_orgs FROM audit_logs UNION ALL SELECT 'events'::text AS table_name, count(*) AS total_records, count(DISTINCT events.org_id) AS unique_orgs, count(*) FILTER (WHERE events.org_id IS NOT NULL) AS active_orgs, NULL::bigint AS soft_deleted_orgs FROM events UNION ALL SELECT 'event_delivery_log'::text AS table_name, count(*) AS total_records, count(DISTINCT event_delivery_log.org_id) AS unique_orgs, count(*) FILTER (WHERE event_delivery_log.org_id IS NOT NULL) AS active_orgs, NULL::bigint AS soft_deleted_orgs FROM event_delivery_log UNION ALL SELECT 'project_timeline'::text AS table_name, count(*) AS total_records, count(DISTINCT project_timeline.org_id) AS unique_orgs, count(*) FILTER (WHERE project_timeline.org_id IS NOT NULL) AS active_orgs, NULL::bigint AS soft_deleted_orgs FROM project_timeline UNION ALL SELECT 'session_metadata'::text AS table_name, count(*) AS total_records, count(DISTINCT session_metadata.org_id) AS unique_orgs, count(*) FILTER (WHERE session_metadata.org_id IS NOT NULL) AS active_orgs, NULL::bigint AS soft_deleted_orgs FROM session_metadata`);

export const vOrganizationStats = pgView("v_organization_stats", {	id: uuid(),
	name: text(),
	slug: text(),
	subscriptionTier: text("subscription_tier"),
	subscriptionStatus: text("subscription_status"),
	status: text(),
	maxUsers: integer("max_users"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	currentUsers: bigint("current_users", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	availableUserSlots: bigint("available_user_slots", { mode: "number" }),
	maxCandidates: integer("max_candidates"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	currentCandidates: bigint("current_candidates", { mode: "number" }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT o.id, o.name, o.slug, o.subscription_tier, o.subscription_status, o.status, o.max_users, count(DISTINCT up.id) AS current_users, o.max_users - count(DISTINCT up.id) AS available_user_slots, o.max_candidates, count(DISTINCT up.id) FILTER (WHERE up.candidate_status IS NOT NULL) AS current_candidates, o.created_at, o.updated_at FROM organizations o LEFT JOIN user_profiles up ON up.org_id = o.id AND up.deleted_at IS NULL WHERE o.deleted_at IS NULL GROUP BY o.id`);

export const aiFoundationValidation = pgView("ai_foundation_validation", {	component: text(),
	status: text(),
}).as(sql`SELECT 'RLS Functions'::text AS component, CASE WHEN count(*) = 4 THEN 'OK'::text ELSE 'MISSING'::text END AS status FROM pg_proc WHERE (pg_proc.proname = ANY (ARRAY['auth_user_id'::name, 'auth_user_org_id'::name, 'user_is_admin'::name, 'user_has_role'::name])) AND pg_proc.pronamespace = 'public'::regnamespace::oid UNION ALL SELECT 'AI Tables'::text AS component, CASE WHEN count(*) = 3 THEN 'OK'::text ELSE 'MISSING'::text END AS status FROM pg_tables WHERE pg_tables.schemaname = 'public'::name AND (pg_tables.tablename = ANY (ARRAY['ai_conversations'::name, 'ai_embeddings'::name, 'ai_patterns'::name])) UNION ALL SELECT 'pgvector Extension'::text AS component, CASE WHEN count(*) = 1 THEN 'OK'::text ELSE 'NOT INSTALLED'::text END AS status FROM pg_extension WHERE pg_extension.extname = 'vector'::name UNION ALL SELECT 'Vector Search Function'::text AS component, CASE WHEN count(*) = 1 THEN 'OK'::text ELSE 'MISSING'::text END AS status FROM pg_proc WHERE pg_proc.proname = 'search_embeddings'::name AND pg_proc.pronamespace = 'public'::regnamespace::oid`);

export const vAgentFrameworkStatus = pgView("v_agent_framework_status", {	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	activePrompts: bigint("active_prompts", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueTemplates: bigint("unique_templates", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	costEntries24H: bigint("cost_entries_24h", { mode: "number" }),
	cost24HUsd: numeric("cost_24h_usd"),
	cost30DUsd: numeric("cost_30d_usd"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	interactions24H: bigint("interactions_24h", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	failures24H: bigint("failures_24h", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	activeAgents7D: bigint("active_agents_7d", { mode: "number" }),
}).as(sql`SELECT ( SELECT count(*) AS count FROM ai_prompts WHERE ai_prompts.is_active = true) AS active_prompts, ( SELECT count(DISTINCT ai_prompts.name) AS count FROM ai_prompts) AS unique_templates, ( SELECT count(*) AS count FROM ai_cost_tracking WHERE ai_cost_tracking.created_at > (now() - '24:00:00'::interval)) AS cost_entries_24h, ( SELECT COALESCE(sum(ai_cost_tracking.cost_usd), 0::numeric) AS "coalesce" FROM ai_cost_tracking WHERE ai_cost_tracking.created_at > (now() - '24:00:00'::interval)) AS cost_24h_usd, ( SELECT COALESCE(sum(ai_cost_tracking.cost_usd), 0::numeric) AS "coalesce" FROM ai_cost_tracking WHERE ai_cost_tracking.created_at > (now() - '30 days'::interval)) AS cost_30d_usd, ( SELECT count(*) AS count FROM ai_agent_interactions WHERE ai_agent_interactions.created_at > (now() - '24:00:00'::interval)) AS interactions_24h, ( SELECT count(*) AS count FROM ai_agent_interactions WHERE ai_agent_interactions.created_at > (now() - '24:00:00'::interval) AND ai_agent_interactions.success = false) AS failures_24h, ( SELECT count(DISTINCT ai_agent_interactions.agent_name) AS count FROM ai_agent_interactions WHERE ai_agent_interactions.created_at > (now() - '7 days'::interval)) AS active_agents_7d`);

export const readingStats = pgView("reading_stats", {	userId: uuid("user_id"),
	topicId: uuid("topic_id"),
	enrollmentId: uuid("enrollment_id"),
	topicTitle: text("topic_title"),
	moduleTitle: text("module_title"),
	courseTitle: text("course_title"),
	scrollPercentage: integer("scroll_percentage"),
	totalReadingTimeSeconds: integer("total_reading_time_seconds"),
	sessionCount: integer("session_count"),
	lastReadAt: timestamp("last_read_at", { withTimezone: true, mode: 'string' }),
	contentType: text("content_type"),
	currentPage: integer("current_page"),
	totalPages: integer("total_pages"),
	engagementScore: integer("engagement_score"),
}).as(sql`SELECT rp.user_id, rp.topic_id, rp.enrollment_id, mt.title AS topic_title, cm.title AS module_title, c.title AS course_title, rp.scroll_percentage, rp.total_reading_time_seconds, rp.session_count, rp.last_read_at, rp.content_type, rp.current_page, rp.total_pages, CASE WHEN rp.scroll_percentage >= 90 THEN 100 WHEN rp.scroll_percentage >= 75 THEN 85 WHEN rp.scroll_percentage >= 50 THEN 70 WHEN rp.scroll_percentage >= 25 THEN 50 ELSE 25 END AS engagement_score FROM reading_progress rp JOIN module_topics mt ON mt.id = rp.topic_id JOIN course_modules cm ON cm.id = mt.module_id JOIN courses c ON c.id = cm.course_id`);

export const gradingQueue = pgView("grading_queue", {	submissionId: uuid("submission_id"),
	userId: uuid("user_id"),
	studentName: text("student_name"),
	studentEmail: text("student_email"),
	topicId: uuid("topic_id"),
	topicTitle: text("topic_title"),
	moduleTitle: text("module_title"),
	courseTitle: text("course_title"),
	repositoryUrl: text("repository_url"),
	commitSha: text("commit_sha"),
	submittedAt: timestamp("submitted_at", { withTimezone: true, mode: 'string' }),
	status: text(),
	autoGradeScore: numeric("auto_grade_score", { precision: 5, scale:  2 }),
	attemptNumber: integer("attempt_number"),
	enrollmentId: uuid("enrollment_id"),
}).as(sql`SELECT ls.id AS submission_id, ls.user_id, up.full_name AS student_name, up.email AS student_email, ls.topic_id, mt.title AS topic_title, cm.title AS module_title, c.title AS course_title, ls.repository_url, ls.commit_sha, ls.submitted_at, ls.status, ls.auto_grade_score, ls.attempt_number, ls.enrollment_id FROM lab_submissions ls JOIN user_profiles up ON up.id = ls.user_id JOIN module_topics mt ON mt.id = ls.topic_id JOIN course_modules cm ON cm.id = mt.module_id JOIN courses c ON c.id = cm.course_id WHERE ls.status = ANY (ARRAY['pending'::text, 'manual_review'::text]) ORDER BY ls.submitted_at`);

export const questionBankStats = pgView("question_bank_stats", {	questionId: uuid("question_id"),
	topicId: uuid("topic_id"),
	questionText: text("question_text"),
	questionType: text("question_type"),
	difficulty: text(),
	points: integer(),
	isPublic: boolean("is_public"),
	createdBy: uuid("created_by"),
	createdByName: text("created_by_name"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	timesUsed: bigint("times_used", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueStudents: bigint("unique_students", { mode: "number" }),
	avgCorrectPercentage: numeric("avg_correct_percentage"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT qq.id AS question_id, qq.topic_id, qq.question_text, qq.question_type, qq.difficulty, qq.points, qq.is_public, qq.created_by, up.full_name AS created_by_name, count(DISTINCT qa.id) AS times_used, count(DISTINCT qa.user_id) AS unique_students, COALESCE(avg( CASE WHEN qa.submitted_at IS NOT NULL THEN CASE WHEN (qa.answers -> qq.id::text) = qq.correct_answers THEN 100.0 ELSE 0.0 END ELSE NULL::numeric END), 0::numeric) AS avg_correct_percentage, qq.created_at, qq.updated_at FROM quiz_questions qq LEFT JOIN user_profiles up ON qq.created_by = up.id LEFT JOIN quiz_attempts qa ON qa.topic_id = qq.topic_id GROUP BY qq.id, up.full_name`);

export const quizAnalytics = pgView("quiz_analytics", {	topicId: uuid("topic_id"),
	topicTitle: text("topic_title"),
	moduleId: uuid("module_id"),
	moduleTitle: text("module_title"),
	courseId: uuid("course_id"),
	courseTitle: text("course_title"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalQuestions: bigint("total_questions", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	easyQuestions: bigint("easy_questions", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	mediumQuestions: bigint("medium_questions", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	hardQuestions: bigint("hard_questions", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalAttempts: bigint("total_attempts", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueStudents: bigint("unique_students", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	passedAttempts: bigint("passed_attempts", { mode: "number" }),
	avgScore: numeric("avg_score"),
	avgTimeSeconds: numeric("avg_time_seconds"),
	passRate: doublePrecision("pass_rate"),
}).as(sql`SELECT mt.id AS topic_id, mt.title AS topic_title, cm.id AS module_id, cm.title AS module_title, c.id AS course_id, c.title AS course_title, count(DISTINCT qq.id) AS total_questions, count(DISTINCT CASE WHEN qq.difficulty = 'easy'::text THEN qq.id ELSE NULL::uuid END) AS easy_questions, count(DISTINCT CASE WHEN qq.difficulty = 'medium'::text THEN qq.id ELSE NULL::uuid END) AS medium_questions, count(DISTINCT CASE WHEN qq.difficulty = 'hard'::text THEN qq.id ELSE NULL::uuid END) AS hard_questions, count(DISTINCT qa.id) AS total_attempts, count(DISTINCT qa.user_id) AS unique_students, count(DISTINCT CASE WHEN qa.passed = true THEN qa.id ELSE NULL::uuid END) AS passed_attempts, COALESCE(avg(qa.score), 0::numeric) AS avg_score, COALESCE(avg(qa.time_taken_seconds), 0::numeric) AS avg_time_seconds, COALESCE(count(DISTINCT CASE WHEN qa.passed = true THEN qa.id ELSE NULL::uuid END)::double precision / NULLIF(count(DISTINCT qa.id), 0)::double precision * 100::double precision, 0::double precision) AS pass_rate FROM module_topics mt JOIN course_modules cm ON mt.module_id = cm.id JOIN courses c ON cm.course_id = c.id LEFT JOIN quiz_questions qq ON qq.topic_id = mt.id LEFT JOIN quiz_attempts qa ON qa.topic_id = mt.id AND qa.submitted_at IS NOT NULL WHERE mt.content_type = 'quiz'::text GROUP BY mt.id, cm.id, c.id`);

export const capstoneGradingQueue = pgView("capstone_grading_queue", {	id: uuid(),
	userId: uuid("user_id"),
	enrollmentId: uuid("enrollment_id"),
	courseId: uuid("course_id"),
	studentName: text("student_name"),
	studentEmail: text("student_email"),
	courseTitle: text("course_title"),
	repositoryUrl: text("repository_url"),
	demoVideoUrl: text("demo_video_url"),
	description: text(),
	submittedAt: timestamp("submitted_at", { withTimezone: true, mode: 'string' }),
	status: text(),
	revisionCount: integer("revision_count"),
	peerReviewCount: integer("peer_review_count"),
	avgPeerRating: numeric("avg_peer_rating", { precision: 3, scale:  2 }),
	hoursWaiting: numeric("hours_waiting"),
}).as(sql`SELECT cs.id, cs.user_id, cs.enrollment_id, cs.course_id, up.full_name AS student_name, up.email AS student_email, c.title AS course_title, cs.repository_url, cs.demo_video_url, cs.description, cs.submitted_at, cs.status, cs.revision_count, cs.peer_review_count, cs.avg_peer_rating, EXTRACT(epoch FROM now() - cs.submitted_at) / 3600::numeric AS hours_waiting FROM capstone_submissions cs JOIN user_profiles up ON cs.user_id = up.id JOIN courses c ON cs.course_id = c.id WHERE cs.status = ANY (ARRAY['pending'::text, 'peer_review'::text, 'trainer_review'::text]) ORDER BY cs.submitted_at`);

export const vAuthRlsStatus = pgView("v_auth_rls_status", {	// TODO: failed to parse database type 'name'
	tableName: unknown("table_name"),
	rlsEnabled: boolean("rls_enabled"),
	rlsForced: boolean("rls_forced"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	policyCount: bigint("policy_count", { mode: "number" }),
	// TODO: failed to parse database type 'name[]'
	policies: unknown("policies"),
}).as(sql`SELECT c.relname AS table_name, c.relrowsecurity AS rls_enabled, c.relforcerowsecurity AS rls_forced, count(p.polname) AS policy_count, array_agg(p.polname ORDER BY p.polname) AS policies FROM pg_class c LEFT JOIN pg_policy p ON p.polrelid = c.oid WHERE c.relnamespace = 'public'::regnamespace::oid AND c.relkind = 'r'::"char" AND (c.relname = ANY (ARRAY['user_profiles'::name, 'roles'::name, 'permissions'::name, 'user_roles'::name, 'role_permissions'::name, 'organizations'::name, 'audit_logs'::name])) GROUP BY c.relname, c.relrowsecurity, c.relforcerowsecurity ORDER BY c.relname`);

export const capstoneStatistics = pgView("capstone_statistics", {	courseId: uuid("course_id"),
	courseTitle: text("course_title"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalSubmissions: bigint("total_submissions", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	passedCount: bigint("passed_count", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	failedCount: bigint("failed_count", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	revisionCount: bigint("revision_count", { mode: "number" }),
	avgGrade: numeric("avg_grade"),
	avgPeerReviews: numeric("avg_peer_reviews"),
	avgRevisions: numeric("avg_revisions"),
}).as(sql`SELECT cs.course_id, c.title AS course_title, count(*) AS total_submissions, count( CASE WHEN cs.status = 'passed'::text THEN 1 ELSE NULL::integer END) AS passed_count, count( CASE WHEN cs.status = 'failed'::text THEN 1 ELSE NULL::integer END) AS failed_count, count( CASE WHEN cs.status = 'revision_requested'::text THEN 1 ELSE NULL::integer END) AS revision_count, avg(cs.grade) FILTER (WHERE cs.grade IS NOT NULL) AS avg_grade, avg(cs.peer_review_count) AS avg_peer_reviews, avg(cs.revision_count) AS avg_revisions FROM capstone_submissions cs JOIN courses c ON cs.course_id = c.id GROUP BY cs.course_id, c.title`);

export const peerReviewLeaderboard = pgView("peer_review_leaderboard", {	reviewerId: uuid("reviewer_id"),
	reviewerName: text("reviewer_name"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	reviewsCompleted: bigint("reviews_completed", { mode: "number" }),
	avgRatingGiven: numeric("avg_rating_given"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	coursesReviewed: bigint("courses_reviewed", { mode: "number" }),
}).as(sql`SELECT pr.reviewer_id, up.full_name AS reviewer_name, count(*) AS reviews_completed, avg(pr.rating) AS avg_rating_given, count(DISTINCT cs.course_id) AS courses_reviewed FROM peer_reviews pr JOIN user_profiles up ON pr.reviewer_id = up.id JOIN capstone_submissions cs ON pr.submission_id = cs.id GROUP BY pr.reviewer_id, up.full_name ORDER BY (count(*)) DESC`);

export const aiMentorDailyStats = pgView("ai_mentor_daily_stats", {	date: date(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalChats: bigint("total_chats", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueUsers: bigint("unique_users", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalTokens: bigint("total_tokens", { mode: "number" }),
	totalCost: numeric("total_cost"),
	avgResponseTimeMs: numeric("avg_response_time_ms"),
	avgRating: numeric("avg_rating"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	flaggedCount: bigint("flagged_count", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	escalatedCount: bigint("escalated_count", { mode: "number" }),
}).as(sql`SELECT date(created_at) AS date, count(*) AS total_chats, count(DISTINCT user_id) AS unique_users, sum(tokens_used) AS total_tokens, sum(cost_usd) AS total_cost, avg(response_time_ms) AS avg_response_time_ms, avg(student_rating) FILTER (WHERE student_rating IS NOT NULL) AS avg_rating, count(*) FILTER (WHERE flagged_for_review = true) AS flagged_count, count(*) FILTER (WHERE escalated_to_trainer = true) AS escalated_count FROM ai_mentor_chats GROUP BY (date(created_at)) ORDER BY (date(created_at)) DESC`);

export const aiMentorStudentStats = pgView("ai_mentor_student_stats", {	userId: uuid("user_id"),
	fullName: text("full_name"),
	email: text(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalChats: bigint("total_chats", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalTokens: bigint("total_tokens", { mode: "number" }),
	totalCost: numeric("total_cost"),
	avgResponseTimeMs: numeric("avg_response_time_ms"),
	avgRating: numeric("avg_rating"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	flaggedCount: bigint("flagged_count", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	escalatedCount: bigint("escalated_count", { mode: "number" }),
	lastChatAt: timestamp("last_chat_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT u.id AS user_id, u.full_name, u.email, count(c.id) AS total_chats, sum(c.tokens_used) AS total_tokens, sum(c.cost_usd) AS total_cost, avg(c.response_time_ms) AS avg_response_time_ms, avg(c.student_rating) FILTER (WHERE c.student_rating IS NOT NULL) AS avg_rating, count(*) FILTER (WHERE c.flagged_for_review = true) AS flagged_count, count(*) FILTER (WHERE c.escalated_to_trainer = true) AS escalated_count, max(c.created_at) AS last_chat_at FROM user_profiles u LEFT JOIN ai_mentor_chats c ON c.user_id = u.id WHERE (EXISTS ( SELECT 1 FROM user_roles ur JOIN roles r ON r.id = ur.role_id WHERE ur.user_id = u.id AND r.name = 'student'::text)) GROUP BY u.id, u.full_name, u.email`);

export const aiMentorTopicStats = pgView("ai_mentor_topic_stats", {	topicId: uuid("topic_id"),
	topicTitle: text("topic_title"),
	courseTitle: text("course_title"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalChats: bigint("total_chats", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueStudents: bigint("unique_students", { mode: "number" }),
	avgRating: numeric("avg_rating"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	escalationCount: bigint("escalation_count", { mode: "number" }),
}).as(sql`SELECT mt.id AS topic_id, mt.title AS topic_title, c.title AS course_title, count(mc.id) AS total_chats, count(DISTINCT mc.user_id) AS unique_students, avg(mc.student_rating) FILTER (WHERE mc.student_rating IS NOT NULL) AS avg_rating, count(*) FILTER (WHERE mc.escalated_to_trainer = true) AS escalation_count FROM module_topics mt JOIN course_modules m ON m.id = mt.module_id JOIN courses c ON c.id = m.course_id LEFT JOIN ai_mentor_chats mc ON mc.topic_id = mt.id GROUP BY mt.id, mt.title, c.title ORDER BY (count(mc.id)) DESC`);

export const escalationQueue = pgView("escalation_queue", {	escalationId: uuid("escalation_id"),
	chatId: uuid("chat_id"),
	userId: uuid("user_id"),
	studentName: text("student_name"),
	studentEmail: text("student_email"),
	topicId: uuid("topic_id"),
	topicTitle: text("topic_title"),
	reason: text(),
	confidence: numeric({ precision: 3, scale:  2 }),
	autoDetected: boolean("auto_detected"),
	triggers: jsonb(),
	metadata: jsonb(),
	status: text(),
	assignedTo: uuid("assigned_to"),
	assignedTrainerName: text("assigned_trainer_name"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	waitTimeMinutes: numeric("wait_time_minutes"),
	originalQuestion: text("original_question"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	responseCount: bigint("response_count", { mode: "number" }),
}).as(sql`SELECT e.id AS escalation_id, e.chat_id, e.user_id, u.full_name AS student_name, u.email AS student_email, e.topic_id, mt.title AS topic_title, e.reason, e.confidence, e.auto_detected, e.triggers, e.metadata, e.status, e.assigned_to, trainer.full_name AS assigned_trainer_name, e.created_at, EXTRACT(epoch FROM now() - e.created_at) / 60::numeric AS wait_time_minutes, c.question AS original_question, ( SELECT count(*) AS count FROM trainer_responses WHERE trainer_responses.escalation_id = e.id) AS response_count FROM ai_mentor_escalations e JOIN user_profiles u ON u.id = e.user_id LEFT JOIN module_topics mt ON mt.id = e.topic_id LEFT JOIN user_profiles trainer ON trainer.id = e.assigned_to LEFT JOIN ai_mentor_chats c ON c.id = e.chat_id WHERE e.status = ANY (ARRAY['pending'::text, 'in_progress'::text]) ORDER BY e.created_at`);

export const aiMentorHourlyStats = pgView("ai_mentor_hourly_stats", {	hour: timestamp({ withTimezone: true, mode: 'string' }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalChats: bigint("total_chats", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueUsers: bigint("unique_users", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalTokens: bigint("total_tokens", { mode: "number" }),
	totalCost: numeric("total_cost"),
	avgResponseTimeMs: numeric("avg_response_time_ms"),
	avgRating: numeric("avg_rating"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	positiveRatings: bigint("positive_ratings", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	negativeRatings: bigint("negative_ratings", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	flaggedCount: bigint("flagged_count", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	escalatedCount: bigint("escalated_count", { mode: "number" }),
}).as(sql`SELECT date_trunc('hour'::text, created_at) AS hour, count(*) AS total_chats, count(DISTINCT user_id) AS unique_users, sum(tokens_used) AS total_tokens, sum(cost_usd) AS total_cost, avg(response_time_ms) AS avg_response_time_ms, avg(student_rating) FILTER (WHERE student_rating IS NOT NULL) AS avg_rating, count(*) FILTER (WHERE student_rating >= 4) AS positive_ratings, count(*) FILTER (WHERE student_rating <= 2) AS negative_ratings, count(*) FILTER (WHERE flagged_for_review = true) AS flagged_count, count(*) FILTER (WHERE escalated_to_trainer = true) AS escalated_count FROM ai_mentor_chats WHERE created_at >= (now() - '7 days'::interval) GROUP BY (date_trunc('hour'::text, created_at)) ORDER BY (date_trunc('hour'::text, created_at)) DESC`);

export const aiMentorTopicQuality = pgView("ai_mentor_topic_quality", {	topicId: uuid("topic_id"),
	topicTitle: text("topic_title"),
	courseTitle: text("course_title"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalChats: bigint("total_chats", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueStudents: bigint("unique_students", { mode: "number" }),
	avgRating: numeric("avg_rating"),
	helpfulPercentage: numeric("helpful_percentage"),
	unhelpfulPercentage: numeric("unhelpful_percentage"),
	avgResponseTimeMs: numeric("avg_response_time_ms"),
	avgTokensUsed: numeric("avg_tokens_used"),
	totalCost: numeric("total_cost"),
	escalationRate: numeric("escalation_rate"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	flaggedCount: bigint("flagged_count", { mode: "number" }),
}).as(sql`SELECT mt.id AS topic_id, mt.title AS topic_title, c.title AS course_title, count(mc.id) AS total_chats, count(DISTINCT mc.user_id) AS unique_students, avg(mc.student_rating) FILTER (WHERE mc.student_rating IS NOT NULL) AS avg_rating, count(*) FILTER (WHERE mc.student_rating >= 4)::numeric / NULLIF(count(*) FILTER (WHERE mc.student_rating IS NOT NULL), 0)::numeric * 100::numeric AS helpful_percentage, count(*) FILTER (WHERE mc.student_rating <= 2)::numeric / NULLIF(count(*) FILTER (WHERE mc.student_rating IS NOT NULL), 0)::numeric * 100::numeric AS unhelpful_percentage, avg(mc.response_time_ms) AS avg_response_time_ms, avg(mc.tokens_used) AS avg_tokens_used, sum(mc.cost_usd) AS total_cost, count(*) FILTER (WHERE mc.escalated_to_trainer = true)::numeric / NULLIF(count(*), 0)::numeric * 100::numeric AS escalation_rate, count(*) FILTER (WHERE mc.flagged_for_review = true) AS flagged_count FROM module_topics mt JOIN course_modules cm ON cm.id = mt.module_id JOIN courses c ON c.id = cm.course_id LEFT JOIN ai_mentor_chats mc ON mc.topic_id = mt.id GROUP BY mt.id, mt.title, c.title HAVING count(mc.id) > 0 ORDER BY (count(mc.id)) DESC`);

export const aiPromptVariantPerformance = pgView("ai_prompt_variant_performance", {	variantId: uuid("variant_id"),
	variantName: text("variant_name"),
	isActive: boolean("is_active"),
	trafficPercentage: integer("traffic_percentage"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalUses: bigint("total_uses", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueUsers: bigint("unique_users", { mode: "number" }),
	avgRating: numeric("avg_rating"),
	helpfulPercentage: numeric("helpful_percentage"),
	avgResponseTimeMs: numeric("avg_response_time_ms"),
	avgTokensUsed: numeric("avg_tokens_used"),
	avgCostPerChat: numeric("avg_cost_per_chat"),
	escalationRate: numeric("escalation_rate"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	flaggedCount: bigint("flagged_count", { mode: "number" }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT pv.id AS variant_id, pv.variant_name, pv.is_active, pv.traffic_percentage, count(mc.id) AS total_uses, count(DISTINCT mc.user_id) AS unique_users, avg(mc.student_rating) FILTER (WHERE mc.student_rating IS NOT NULL) AS avg_rating, count(*) FILTER (WHERE mc.student_rating >= 4)::numeric / NULLIF(count(*) FILTER (WHERE mc.student_rating IS NOT NULL), 0)::numeric * 100::numeric AS helpful_percentage, avg(mc.response_time_ms) AS avg_response_time_ms, avg(mc.tokens_used) AS avg_tokens_used, avg(mc.cost_usd) AS avg_cost_per_chat, count(*) FILTER (WHERE mc.escalated_to_trainer = true)::numeric / NULLIF(count(*), 0)::numeric * 100::numeric AS escalation_rate, count(*) FILTER (WHERE mc.flagged_for_review = true) AS flagged_count, pv.created_at FROM ai_prompt_variants pv LEFT JOIN ai_mentor_chats mc ON mc.prompt_variant_id = pv.id GROUP BY pv.id, pv.variant_name, pv.is_active, pv.traffic_percentage, pv.created_at ORDER BY pv.created_at DESC`);

export const aiMentorCostBreakdown = pgView("ai_mentor_cost_breakdown", {	date: date(),
	topicId: uuid("topic_id"),
	topicTitle: text("topic_title"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	chatCount: bigint("chat_count", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalTokens: bigint("total_tokens", { mode: "number" }),
	totalCost: numeric("total_cost"),
	avgCostPerChat: numeric("avg_cost_per_chat"),
	costPer1KTokens: numeric("cost_per_1k_tokens"),
	costPerHelpfulResponse: numeric("cost_per_helpful_response"),
}).as(sql`SELECT date(mc.created_at) AS date, mc.topic_id, mt.title AS topic_title, count(*) AS chat_count, sum(mc.tokens_used) AS total_tokens, sum(mc.cost_usd) AS total_cost, avg(mc.cost_usd) AS avg_cost_per_chat, sum(mc.cost_usd) / NULLIF(sum(mc.tokens_used), 0)::numeric * 1000::numeric AS cost_per_1k_tokens, sum(mc.cost_usd) / NULLIF(count(*) FILTER (WHERE mc.student_rating >= 4), 0)::numeric AS cost_per_helpful_response FROM ai_mentor_chats mc LEFT JOIN module_topics mt ON mt.id = mc.topic_id WHERE mc.created_at >= (CURRENT_DATE - '30 days'::interval) GROUP BY (date(mc.created_at)), mc.topic_id, mt.title ORDER BY (date(mc.created_at)) DESC, (sum(mc.cost_usd)) DESC`);

export const badgeCompletionStats = pgView("badge_completion_stats", {	badgeId: uuid("badge_id"),
	badgeName: text("badge_name"),
	rarity: text(),
	triggerType: text("trigger_type"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalEarned: bigint("total_earned", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueEarners: bigint("unique_earners", { mode: "number" }),
	completionPercentage: numeric("completion_percentage"),
	firstEarnedAt: timestamp("first_earned_at", { withTimezone: true, mode: 'string' }),
	lastEarnedAt: timestamp("last_earned_at", { withTimezone: true, mode: 'string' }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalShares: bigint("total_shares", { mode: "number" }),
}).as(sql`SELECT b.id AS badge_id, b.name AS badge_name, b.rarity, b.trigger_type, count(ub.id) AS total_earned, count(DISTINCT ub.user_id) AS unique_earners, count(DISTINCT ub.user_id)::numeric / NULLIF(( SELECT count(DISTINCT user_badges.user_id) AS count FROM user_badges), 0)::numeric * 100::numeric AS completion_percentage, min(ub.earned_at) AS first_earned_at, max(ub.earned_at) AS last_earned_at, sum(ub.share_count) AS total_shares FROM badges b LEFT JOIN user_badges ub ON ub.badge_id = b.id GROUP BY b.id, b.name, b.rarity, b.trigger_type ORDER BY (count(ub.id)) DESC`);

export const aiMentorStudentEngagement = pgView("ai_mentor_student_engagement", {	userId: uuid("user_id"),
	fullName: text("full_name"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalChats: bigint("total_chats", { mode: "number" }),
	firstChatDate: date("first_chat_date"),
	lastChatDate: date("last_chat_date"),
	activeDays: numeric("active_days"),
	avgRatingGiven: numeric("avg_rating_given"),
	ratingFrequency: numeric("rating_frequency"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	topicsExplored: bigint("topics_explored", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	escalations: bigint({ mode: "number" }),
	totalCostIncurred: numeric("total_cost_incurred"),
}).as(sql`SELECT u.id AS user_id, u.full_name, count(mc.id) AS total_chats, date(min(mc.created_at)) AS first_chat_date, date(max(mc.created_at)) AS last_chat_date, EXTRACT(epoch FROM max(mc.created_at) - min(mc.created_at)) / 86400::numeric AS active_days, avg(mc.student_rating) FILTER (WHERE mc.student_rating IS NOT NULL) AS avg_rating_given, count(*) FILTER (WHERE mc.student_rating IS NOT NULL)::numeric / NULLIF(count(*), 0)::numeric * 100::numeric AS rating_frequency, count(DISTINCT mc.topic_id) AS topics_explored, count(*) FILTER (WHERE mc.escalated_to_trainer = true) AS escalations, sum(mc.cost_usd) AS total_cost_incurred FROM user_profiles u JOIN ai_mentor_chats mc ON mc.user_id = u.id GROUP BY u.id, u.full_name ORDER BY (count(mc.id)) DESC`);

export const userBadgeProgress = pgView("user_badge_progress", {	userId: uuid("user_id"),
	fullName: text("full_name"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	commonBadges: bigint("common_badges", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	rareBadges: bigint("rare_badges", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	epicBadges: bigint("epic_badges", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	legendaryBadges: bigint("legendary_badges", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalBadgesEarned: bigint("total_badges_earned", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalBadgesAvailable: bigint("total_badges_available", { mode: "number" }),
	completionPercentage: numeric("completion_percentage"),
	lastBadgeEarnedAt: timestamp("last_badge_earned_at", { withTimezone: true, mode: 'string' }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	newBadgesCount: bigint("new_badges_count", { mode: "number" }),
}).as(sql`SELECT u.id AS user_id, u.full_name, count(ub.id) FILTER (WHERE b.rarity = 'common'::text) AS common_badges, count(ub.id) FILTER (WHERE b.rarity = 'rare'::text) AS rare_badges, count(ub.id) FILTER (WHERE b.rarity = 'epic'::text) AS epic_badges, count(ub.id) FILTER (WHERE b.rarity = 'legendary'::text) AS legendary_badges, count(ub.id) AS total_badges_earned, ( SELECT count(*) AS count FROM badges WHERE badges.is_hidden = false) AS total_badges_available, count(ub.id)::numeric / NULLIF(( SELECT count(*) AS count FROM badges WHERE badges.is_hidden = false), 0)::numeric * 100::numeric AS completion_percentage, max(ub.earned_at) AS last_badge_earned_at, count(*) FILTER (WHERE ub.is_new = true) AS new_badges_count FROM user_profiles u LEFT JOIN user_badges ub ON ub.user_id = u.id LEFT JOIN badges b ON b.id = ub.badge_id GROUP BY u.id, u.full_name ORDER BY (count(ub.id)) DESC`);

export const rareAchievements = pgView("rare_achievements", {	badgeId: uuid("badge_id"),
	badgeName: text("badge_name"),
	rarity: text(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	earnerCount: bigint("earner_count", { mode: "number" }),
	earnerPercentage: numeric("earner_percentage"),
}).as(sql`SELECT b.id AS badge_id, b.name AS badge_name, b.rarity, count(ub.id) AS earner_count, count(DISTINCT ub.user_id)::numeric / NULLIF(( SELECT count(DISTINCT user_badges.user_id) AS count FROM user_badges), 0)::numeric * 100::numeric AS earner_percentage FROM badges b LEFT JOIN user_badges ub ON ub.badge_id = b.id GROUP BY b.id, b.name, b.rarity HAVING (count(DISTINCT ub.user_id)::numeric / NULLIF(( SELECT count(DISTINCT user_badges.user_id) AS count FROM user_badges), 0)::numeric * 100::numeric) <= 1.0 ORDER BY (count(DISTINCT ub.user_id)::numeric / NULLIF(( SELECT count(DISTINCT user_badges.user_id) AS count FROM user_badges), 0)::numeric * 100::numeric)`);

export const vWorkflowInstancesWithState = pgView("v_workflow_instances_with_state", {	id: uuid(),
	orgId: uuid("org_id"),
	workflowName: text("workflow_name"),
	entityType: text("entity_type"),
	entityId: uuid("entity_id"),
	currentState: text("current_state"),
	currentStateDisplay: text("current_state_display"),
	isTerminal: boolean("is_terminal"),
	status: text(),
	startedAt: timestamp("started_at", { withTimezone: true, mode: 'string' }),
	completedAt: timestamp("completed_at", { withTimezone: true, mode: 'string' }),
	cancelledAt: timestamp("cancelled_at", { withTimezone: true, mode: 'string' }),
	durationHours: numeric("duration_hours"),
	createdByName: text("created_by_name"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT wi.id, wi.org_id, w.name AS workflow_name, wi.entity_type, wi.entity_id, ws.name AS current_state, ws.display_name AS current_state_display, ws.is_terminal, wi.status, wi.started_at, wi.completed_at, wi.cancelled_at, EXTRACT(epoch FROM COALESCE(wi.completed_at, now()) - wi.started_at) / 3600::numeric AS duration_hours, up.full_name AS created_by_name, wi.created_at, wi.updated_at FROM workflow_instances wi JOIN workflows w ON wi.workflow_id = w.id JOIN workflow_states ws ON wi.current_state_id = ws.id JOIN user_profiles up ON wi.created_by = up.id WHERE wi.org_id = auth_user_org_id() OR user_is_admin()`);

export const vWorkflowMetrics = pgView("v_workflow_metrics", {	workflowId: uuid("workflow_id"),
	workflowName: text("workflow_name"),
	entityType: text("entity_type"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalInstances: bigint("total_instances", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	activeInstances: bigint("active_instances", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	completedInstances: bigint("completed_instances", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	cancelledInstances: bigint("cancelled_instances", { mode: "number" }),
	avgCompletionHours: numeric("avg_completion_hours"),
	lastStartedAt: timestamp("last_started_at", { withTimezone: true, mode: 'string' }),
	orgId: uuid("org_id"),
}).as(sql`SELECT w.id AS workflow_id, w.name AS workflow_name, w.entity_type, count(*) AS total_instances, count(*) FILTER (WHERE wi.status = 'active'::text) AS active_instances, count(*) FILTER (WHERE wi.status = 'completed'::text) AS completed_instances, count(*) FILTER (WHERE wi.status = 'cancelled'::text) AS cancelled_instances, round(avg(EXTRACT(epoch FROM wi.completed_at - wi.started_at) / 3600::numeric), 2) AS avg_completion_hours, max(wi.started_at) AS last_started_at, w.org_id FROM workflows w LEFT JOIN workflow_instances wi ON w.id = wi.workflow_id WHERE w.org_id = auth_user_org_id() OR user_is_admin() GROUP BY w.id, w.name, w.entity_type, w.org_id`);

export const leaderboardGlobal = pgView("leaderboard_global", {	userId: uuid("user_id"),
	fullName: text("full_name"),
	avatarUrl: text("avatar_url"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalXp: bigint("total_xp", { mode: "number" }),
	level: integer(),
	levelName: text("level_name"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	rank: bigint({ mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	denseRank: bigint("dense_rank", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	xpDiffFromAbove: bigint("xp_diff_from_above", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	xpToNextRank: bigint("xp_to_next_rank", { mode: "number" }),
}).as(sql`WITH ranked_users AS ( SELECT up.id AS user_id, up.full_name, up.avatar_url, uxp.total_xp, floor((uxp.total_xp / 1000)::double precision)::integer + 1 AS level, CASE WHEN uxp.total_xp < 1000 THEN 'Beginner'::text WHEN uxp.total_xp < 5000 THEN 'Intermediate'::text WHEN uxp.total_xp < 10000 THEN 'Advanced'::text WHEN uxp.total_xp < 25000 THEN 'Expert'::text ELSE 'Master'::text END AS level_name, rank() OVER (ORDER BY uxp.total_xp DESC) AS rank, dense_rank() OVER (ORDER BY uxp.total_xp DESC) AS dense_rank FROM user_profiles up JOIN user_xp_totals uxp ON uxp.user_id = up.id WHERE up.leaderboard_visible = true AND uxp.total_xp > 0 ) SELECT user_id, full_name, avatar_url, total_xp, level, level_name, rank, dense_rank, total_xp - lag(total_xp) OVER (ORDER BY rank DESC) AS xp_diff_from_above, lead(total_xp) OVER (ORDER BY rank DESC) - total_xp AS xp_to_next_rank FROM ranked_users ORDER BY rank`);

export const leaderboardByCourse = pgView("leaderboard_by_course", {	courseId: uuid("course_id"),
	courseTitle: text("course_title"),
	userId: uuid("user_id"),
	fullName: text("full_name"),
	avatarUrl: text("avatar_url"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	courseXp: bigint("course_xp", { mode: "number" }),
	completionPercentage: integer("completion_percentage"),
	modulesCompleted: integer("modules_completed"),
	totalModules: integer("total_modules"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	rank: bigint({ mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalStudents: bigint("total_students", { mode: "number" }),
	percentile: numeric(),
}).as(sql`WITH ranked_students AS ( SELECT e.course_id, c.title AS course_title, up.id AS user_id, up.full_name, up.avatar_url, uxp.total_xp AS course_xp, e.completion_percentage, 0 AS modules_completed, 0 AS total_modules, rank() OVER (PARTITION BY e.course_id ORDER BY uxp.total_xp DESC) AS rank, count(*) OVER (PARTITION BY e.course_id) AS total_students FROM student_enrollments e JOIN user_profiles up ON up.id = e.user_id JOIN courses c ON c.id = e.course_id JOIN user_xp_totals uxp ON uxp.user_id = e.user_id WHERE up.leaderboard_visible = true AND (e.status = ANY (ARRAY['active'::text, 'completed'::text])) AND uxp.total_xp > 0 ) SELECT course_id, course_title, user_id, full_name, avatar_url, course_xp, completion_percentage, modules_completed, total_modules, rank, total_students, round((1::numeric - rank::numeric / total_students::numeric) * 100::numeric, 1) AS percentile FROM ranked_students ORDER BY course_id, rank`);

export const leaderboardByCohort = pgView("leaderboard_by_cohort", {	courseId: uuid("course_id"),
	courseTitle: text("course_title"),
	cohortMonth: timestamp("cohort_month", { withTimezone: true, mode: 'string' }),
	cohortName: text("cohort_name"),
	userId: uuid("user_id"),
	fullName: text("full_name"),
	avatarUrl: text("avatar_url"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalXp: bigint("total_xp", { mode: "number" }),
	completionPercentage: integer("completion_percentage"),
	enrolledAt: timestamp("enrolled_at", { withTimezone: true, mode: 'string' }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	rank: bigint({ mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	cohortSize: bigint("cohort_size", { mode: "number" }),
	cohortPercentile: numeric("cohort_percentile"),
}).as(sql`WITH cohorts AS ( SELECT e.course_id, c.title AS course_title, date_trunc('month'::text, e.enrolled_at) AS cohort_month, to_char(e.enrolled_at, 'Month YYYY'::text) AS cohort_name, up.id AS user_id, up.full_name, up.avatar_url, uxp.total_xp, e.completion_percentage, e.enrolled_at FROM student_enrollments e JOIN user_profiles up ON up.id = e.user_id JOIN courses c ON c.id = e.course_id JOIN user_xp_totals uxp ON uxp.user_id = up.id WHERE up.leaderboard_visible = true AND (e.status = ANY (ARRAY['active'::text, 'completed'::text])) ), ranked_cohorts AS ( SELECT cohorts.course_id, cohorts.course_title, cohorts.cohort_month, cohorts.cohort_name, cohorts.user_id, cohorts.full_name, cohorts.avatar_url, cohorts.total_xp, cohorts.completion_percentage, cohorts.enrolled_at, rank() OVER (PARTITION BY cohorts.course_id, cohorts.cohort_month ORDER BY cohorts.total_xp DESC) AS rank, count(*) OVER (PARTITION BY cohorts.course_id, cohorts.cohort_month) AS cohort_size FROM cohorts ) SELECT course_id, course_title, cohort_month, cohort_name, user_id, full_name, avatar_url, total_xp, completion_percentage, enrolled_at, rank, cohort_size, round((1::numeric - rank::numeric / cohort_size::numeric) * 100::numeric, 1) AS cohort_percentile FROM ranked_cohorts ORDER BY cohort_month DESC, rank`);

export const leaderboardWeekly = pgView("leaderboard_weekly", {	weekStart: timestamp("week_start", { withTimezone: true, mode: 'string' }),
	weekLabel: text("week_label"),
	userId: uuid("user_id"),
	fullName: text("full_name"),
	avatarUrl: text("avatar_url"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	weeklyXp: bigint("weekly_xp", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	rank: bigint({ mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	participants: bigint({ mode: "number" }),
	isCurrentWeek: boolean("is_current_week"),
}).as(sql`WITH weekly_xp AS ( SELECT xt.user_id, up.full_name, up.avatar_url, date_trunc('week'::text, xt.created_at) AS week_start, to_char(date_trunc('week'::text, xt.created_at), 'Mon DD, YYYY'::text) AS week_label, sum(xt.amount) AS weekly_xp FROM xp_transactions xt JOIN user_profiles up ON up.id = xt.user_id WHERE up.leaderboard_visible = true AND xt.created_at >= (CURRENT_DATE - '84 days'::interval) GROUP BY xt.user_id, up.full_name, up.avatar_url, (date_trunc('week'::text, xt.created_at)) ), ranked_weekly AS ( SELECT weekly_xp.week_start, weekly_xp.week_label, weekly_xp.user_id, weekly_xp.full_name, weekly_xp.avatar_url, weekly_xp.weekly_xp, rank() OVER (PARTITION BY weekly_xp.week_start ORDER BY weekly_xp.weekly_xp DESC) AS rank, count(*) OVER (PARTITION BY weekly_xp.week_start) AS participants FROM weekly_xp WHERE weekly_xp.weekly_xp > 0 ) SELECT week_start, week_label, user_id, full_name, avatar_url, weekly_xp, rank, participants, CASE WHEN week_start = date_trunc('week'::text, CURRENT_DATE::timestamp with time zone) THEN true ELSE false END AS is_current_week FROM ranked_weekly ORDER BY week_start DESC, rank`);

export const leaderboardAllTime = pgView("leaderboard_all_time", {	userId: uuid("user_id"),
	fullName: text("full_name"),
	avatarUrl: text("avatar_url"),
	joinedAt: timestamp("joined_at", { withTimezone: true, mode: 'string' }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalXp: bigint("total_xp", { mode: "number" }),
	level: integer(),
	levelName: text("level_name"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	badgeCount: bigint("badge_count", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	coursesCompleted: bigint("courses_completed", { mode: "number" }),
	daysActive: numeric("days_active"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	rank: bigint({ mode: "number" }),
	avgXpPerDay: numeric("avg_xp_per_day"),
}).as(sql`WITH all_time_stats AS ( SELECT up.id AS user_id, up.full_name, up.avatar_url, up.created_at AS joined_at, uxp.total_xp, floor((uxp.total_xp / 1000)::double precision)::integer + 1 AS level, CASE WHEN uxp.total_xp < 1000 THEN 'Beginner'::text WHEN uxp.total_xp < 5000 THEN 'Intermediate'::text WHEN uxp.total_xp < 10000 THEN 'Advanced'::text WHEN uxp.total_xp < 25000 THEN 'Expert'::text ELSE 'Master'::text END AS level_name, ( SELECT count(*) AS count FROM user_badges WHERE user_badges.user_id = up.id) AS badge_count, ( SELECT count(*) AS count FROM student_enrollments WHERE student_enrollments.user_id = up.id AND student_enrollments.status = 'completed'::text) AS courses_completed, (CURRENT_DATE - up.created_at::date)::numeric AS days_active FROM user_profiles up JOIN user_xp_totals uxp ON uxp.user_id = up.id WHERE up.leaderboard_visible = true AND uxp.total_xp > 0 ), ranked_all_time AS ( SELECT all_time_stats.user_id, all_time_stats.full_name, all_time_stats.avatar_url, all_time_stats.joined_at, all_time_stats.total_xp, all_time_stats.level, all_time_stats.level_name, all_time_stats.badge_count, all_time_stats.courses_completed, all_time_stats.days_active, rank() OVER (ORDER BY all_time_stats.total_xp DESC) AS rank, CASE WHEN all_time_stats.days_active > 0::numeric THEN round(all_time_stats.total_xp::numeric / all_time_stats.days_active, 2) ELSE 0::numeric END AS avg_xp_per_day FROM all_time_stats ) SELECT user_id, full_name, avatar_url, joined_at, total_xp, level, level_name, badge_count, courses_completed, days_active, rank, avg_xp_per_day FROM ranked_all_time WHERE rank <= 100 ORDER BY rank`);

export const badgeLeaderboard = pgView("badge_leaderboard", {	userId: uuid("user_id"),
	fullName: text("full_name"),
	avatarUrl: text("avatar_url"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	badgeCount: bigint("badge_count", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	rarityScore: bigint("rarity_score", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	badgeXpEarned: bigint("badge_xp_earned", { mode: "number" }),
	recentBadges: jsonb("recent_badges"),
}).as(sql`WITH top_users AS ( SELECT u.id, u.full_name, u.avatar_url, count(ub_1.id) AS badge_count, sum( CASE b_1.rarity WHEN 'legendary'::text THEN 4 WHEN 'epic'::text THEN 3 WHEN 'rare'::text THEN 2 WHEN 'common'::text THEN 1 ELSE 0 END) AS rarity_score, sum(b_1.xp_reward) AS badge_xp_earned FROM user_profiles u LEFT JOIN user_badges ub_1 ON ub_1.user_id = u.id LEFT JOIN badges b_1 ON b_1.id = ub_1.badge_id GROUP BY u.id, u.full_name, u.avatar_url ORDER BY (count(ub_1.id)) DESC, (sum( CASE b_1.rarity WHEN 'legendary'::text THEN 4 WHEN 'epic'::text THEN 3 WHEN 'rare'::text THEN 2 WHEN 'common'::text THEN 1 ELSE 0 END)) DESC LIMIT 100 ) SELECT tu.id AS user_id, tu.full_name, tu.avatar_url, tu.badge_count, tu.rarity_score, tu.badge_xp_earned, COALESCE(jsonb_agg(jsonb_build_object('badge_id', b.id, 'name', b.name, 'rarity', b.rarity, 'earned_at', ub.earned_at) ORDER BY ub.earned_at DESC) FILTER (WHERE ub.id IS NOT NULL), '[]'::jsonb) AS recent_badges FROM top_users tu LEFT JOIN user_badges ub ON ub.user_id = tu.id LEFT JOIN badges b ON b.id = ub.badge_id GROUP BY tu.id, tu.full_name, tu.avatar_url, tu.badge_count, tu.rarity_score, tu.badge_xp_earned ORDER BY tu.badge_count DESC, tu.rarity_score DESC`);

export const organizationAddressesView = pgView("organization_addresses_view", {	organizationId: uuid("organization_id"),
	organizationName: text("organization_name"),
	addressId: uuid("address_id"),
	addressType: text("address_type"),
	addressLine1: text("address_line_1"),
	addressLine2: text("address_line_2"),
	addressLine3: text("address_line_3"),
	city: text(),
	stateProvince: text("state_province"),
	postalCode: text("postal_code"),
	countryCode: text("country_code"),
	county: text(),
	latitude: numeric({ precision: 10, scale:  7 }),
	longitude: numeric({ precision: 10, scale:  7 }),
	isVerified: boolean("is_verified"),
	isPrimary: boolean("is_primary"),
	effectiveFrom: date("effective_from"),
	effectiveTo: date("effective_to"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT o.id AS organization_id, o.name AS organization_name, addr.id AS address_id, addr.address_type, addr.address_line_1, addr.address_line_2, addr.address_line_3, addr.city, addr.state_province, addr.postal_code, addr.country_code, addr.county, addr.latitude, addr.longitude, addr.is_verified, addr.is_primary, addr.effective_from, addr.effective_to, addr.notes, addr.created_at, addr.updated_at FROM organizations o LEFT JOIN addresses addr ON addr.entity_type = 'organization'::text AND addr.entity_id = o.id`);

export const leadAddressesView = pgView("lead_addresses_view", {	leadId: uuid("lead_id"),
	orgId: uuid("org_id"),
	companyName: text("company_name"),
	firstName: text("first_name"),
	lastName: text("last_name"),
	addressId: uuid("address_id"),
	addressType: text("address_type"),
	addressLine1: text("address_line_1"),
	addressLine2: text("address_line_2"),
	addressLine3: text("address_line_3"),
	city: text(),
	stateProvince: text("state_province"),
	postalCode: text("postal_code"),
	countryCode: text("country_code"),
	county: text(),
	latitude: numeric({ precision: 10, scale:  7 }),
	longitude: numeric({ precision: 10, scale:  7 }),
	isVerified: boolean("is_verified"),
	isPrimary: boolean("is_primary"),
	effectiveFrom: date("effective_from"),
	effectiveTo: date("effective_to"),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT l.id AS lead_id, l.org_id, l.company_name, l.first_name, l.last_name, addr.id AS address_id, addr.address_type, addr.address_line_1, addr.address_line_2, addr.address_line_3, addr.city, addr.state_province, addr.postal_code, addr.country_code, addr.county, addr.latitude, addr.longitude, addr.is_verified, addr.is_primary, addr.effective_from, addr.effective_to, addr.notes, addr.created_at, addr.updated_at FROM leads l LEFT JOIN addresses addr ON addr.entity_type = 'lead'::text AND addr.entity_id = l.id`);

export const employeeAddressesView = pgView("employee_addresses_view", {	employeeId: uuid("employee_id"),
	orgId: uuid("org_id"),
	employeeName: text("employee_name"),
	email: text(),
	addressId: uuid("address_id"),
	addressType: text("address_type"),
	addressLine1: text("address_line_1"),
	city: text(),
	stateProvince: text("state_province"),
	postalCode: text("postal_code"),
	countryCode: text("country_code"),
	isPrimary: boolean("is_primary"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT e.id AS employee_id, e.org_id, up.full_name AS employee_name, up.email, addr.id AS address_id, addr.address_type, addr.address_line_1, addr.city, addr.state_province, addr.postal_code, addr.country_code, addr.is_primary, addr.created_at, addr.updated_at FROM employees e LEFT JOIN user_profiles up ON up.id = e.user_id LEFT JOIN addresses addr ON addr.entity_type = 'employee'::text AND addr.entity_id = e.id WHERE e.deleted_at IS NULL`);

export const interviewAddressesView = pgView("interview_addresses_view", {	interviewId: uuid("interview_id"),
	orgId: uuid("org_id"),
	interviewType: text("interview_type"),
	scheduledAt: timestamp("scheduled_at", { withTimezone: true, mode: 'string' }),
	addressId: uuid("address_id"),
	addressType: text("address_type"),
	addressLine1: text("address_line_1"),
	city: text(),
	stateProvince: text("state_province"),
	addressNotes: text("address_notes"),
	isPrimary: boolean("is_primary"),
}).as(sql`SELECT i.id AS interview_id, i.org_id, i.interview_type, i.scheduled_at, addr.id AS address_id, addr.address_type, addr.address_line_1, addr.city, addr.state_province, addr.notes AS address_notes, addr.is_primary FROM interviews i LEFT JOIN addresses addr ON addr.entity_type = 'interview'::text AND addr.entity_id = i.id WHERE i.cancelled_at IS NULL`);

export const contactAddressesView = pgView("contact_addresses_view", {	contactId: uuid("contact_id"),
	orgId: uuid("org_id"),
	firstName: text("first_name"),
	lastName: text("last_name"),
	email: text(),
	addressId: uuid("address_id"),
	addressType: text("address_type"),
	addressLine1: text("address_line_1"),
	city: text(),
	stateProvince: text("state_province"),
	postalCode: text("postal_code"),
	countryCode: text("country_code"),
	isPrimary: boolean("is_primary"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT c.id AS contact_id, c.org_id, c.first_name, c.last_name, c.email, addr.id AS address_id, addr.address_type, addr.address_line_1, addr.city, addr.state_province, addr.postal_code, addr.country_code, addr.is_primary, addr.created_at, addr.updated_at FROM contacts c LEFT JOIN addresses addr ON addr.entity_type = 'contact'::text AND addr.entity_id = c.id WHERE c.deleted_at IS NULL`);

export const placementAddressesView = pgView("placement_addresses_view", {	placementId: uuid("placement_id"),
	orgId: uuid("org_id"),
	placementStatus: text("placement_status"),
	startDate: date("start_date"),
	addressId: uuid("address_id"),
	addressType: text("address_type"),
	addressLine1: text("address_line_1"),
	city: text(),
	stateProvince: text("state_province"),
	addressNotes: text("address_notes"),
	isPrimary: boolean("is_primary"),
}).as(sql`SELECT p.id AS placement_id, p.org_id, p.status AS placement_status, p.start_date, addr.id AS address_id, addr.address_type, addr.address_line_1, addr.city, addr.state_province, addr.notes AS address_notes, addr.is_primary FROM placements p LEFT JOIN addresses addr ON addr.entity_type = 'placement'::text AND addr.entity_id = p.id`);

export const labStatistics = pgView("lab_statistics", {	topicId: uuid("topic_id"),
	labTitle: text("lab_title"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalStudentsStarted: bigint("total_students_started", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalStudentsSubmitted: bigint("total_students_submitted", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalPassed: bigint("total_passed", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalFailed: bigint("total_failed", { mode: "number" }),
	avgFinalScore: numeric("avg_final_score"),
	avgTimeSpentSeconds: numeric("avg_time_spent_seconds"),
}).as(sql`SELECT mt.id AS topic_id, mt.title AS lab_title, count(DISTINCT li.user_id) AS total_students_started, count(DISTINCT ls.user_id) AS total_students_submitted, count(ls.id) FILTER (WHERE ls.passed = true) AS total_passed, count(ls.id) FILTER (WHERE ls.passed = false) AS total_failed, avg(ls.final_score) AS avg_final_score, avg(li.time_spent_seconds) FILTER (WHERE li.status = 'completed'::text) AS avg_time_spent_seconds FROM module_topics mt LEFT JOIN lab_instances li ON li.topic_id = mt.id LEFT JOIN lab_submissions ls ON ls.topic_id = mt.id WHERE mt.content_type = 'lab'::text GROUP BY mt.id, mt.title`);

export const escalationDailyStats = pgView("escalation_daily_stats", {	date: date(),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalEscalations: bigint("total_escalations", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueStudents: bigint("unique_students", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	autoDetectedCount: bigint("auto_detected_count", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	manualCount: bigint("manual_count", { mode: "number" }),
	avgConfidence: numeric("avg_confidence"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	resolvedCount: bigint("resolved_count", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	dismissedCount: bigint("dismissed_count", { mode: "number" }),
	avgResolutionTimeMinutes: numeric("avg_resolution_time_minutes"),
}).as(sql`SELECT date(created_at) AS date, count(*) AS total_escalations, count(DISTINCT user_id) AS unique_students, count(*) FILTER (WHERE auto_detected = true) AS auto_detected_count, count(*) FILTER (WHERE auto_detected = false) AS manual_count, avg(confidence) AS avg_confidence, count(*) FILTER (WHERE status = 'resolved'::text) AS resolved_count, count(*) FILTER (WHERE status = 'dismissed'::text) AS dismissed_count, avg(resolution_time_minutes) FILTER (WHERE resolution_time_minutes IS NOT NULL) AS avg_resolution_time_minutes FROM ai_mentor_escalations GROUP BY (date(created_at)) ORDER BY (date(created_at)) DESC`);

export const trainerEscalationStats = pgView("trainer_escalation_stats", {	trainerId: uuid("trainer_id"),
	trainerName: text("trainer_name"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalAssigned: bigint("total_assigned", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	resolvedCount: bigint("resolved_count", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	dismissedCount: bigint("dismissed_count", { mode: "number" }),
	avgResolutionTimeMinutes: numeric("avg_resolution_time_minutes"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	totalResponses: bigint("total_responses", { mode: "number" }),
	lastResolutionAt: timestamp("last_resolution_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT t.id AS trainer_id, t.full_name AS trainer_name, count(e.id) AS total_assigned, count(*) FILTER (WHERE e.status = 'resolved'::text) AS resolved_count, count(*) FILTER (WHERE e.status = 'dismissed'::text) AS dismissed_count, avg(e.resolution_time_minutes) FILTER (WHERE e.resolution_time_minutes IS NOT NULL) AS avg_resolution_time_minutes, count(tr.id) AS total_responses, max(e.resolved_at) AS last_resolution_at FROM user_profiles t JOIN user_roles ur ON ur.user_id = t.id JOIN roles r ON r.id = ur.role_id LEFT JOIN ai_mentor_escalations e ON e.assigned_to = t.id LEFT JOIN trainer_responses tr ON tr.trainer_id = t.id WHERE r.name = 'trainer'::text GROUP BY t.id, t.full_name`);

export const topicDifficultyStats = pgView("topic_difficulty_stats", {	topicId: uuid("topic_id"),
	topicTitle: text("topic_title"),
	moduleTitle: text("module_title"),
	courseTitle: text("course_title"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	escalationCount: bigint("escalation_count", { mode: "number" }),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	uniqueStudents: bigint("unique_students", { mode: "number" }),
	avgEscalationConfidence: numeric("avg_escalation_confidence"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	resolvedCount: bigint("resolved_count", { mode: "number" }),
}).as(sql`SELECT mt.id AS topic_id, mt.title AS topic_title, cm.title AS module_title, c.title AS course_title, count(e.id) AS escalation_count, count(DISTINCT e.user_id) AS unique_students, avg(e.confidence) AS avg_escalation_confidence, count(*) FILTER (WHERE e.status = 'resolved'::text) AS resolved_count FROM module_topics mt JOIN course_modules cm ON cm.id = mt.module_id JOIN courses c ON c.id = cm.course_id LEFT JOIN ai_mentor_escalations e ON e.topic_id = mt.id GROUP BY mt.id, mt.title, cm.title, c.title HAVING count(e.id) > 0 ORDER BY (count(e.id)) DESC`);

export const submissionsLegacyV = pgView("submissions_legacy_v", {	id: uuid(),
	orgId: uuid("org_id"),
	jobId: uuid("job_id"),
	candidateId: uuid("candidate_id"),
	accountId: uuid("account_id"),
	status: text(),
	aiMatchScore: integer("ai_match_score"),
	recruiterMatchScore: integer("recruiter_match_score"),
	matchExplanation: text("match_explanation"),
	submittedRate: numeric("submitted_rate", { precision: 10, scale:  2 }),
	submittedRateType: text("submitted_rate_type"),
	submissionNotes: text("submission_notes"),
	submittedToClientAt: timestamp("submitted_to_client_at", { withTimezone: true, mode: 'string' }),
	submittedToClientBy: uuid("submitted_to_client_by"),
	clientResumeFileId: uuid("client_resume_file_id"),
	clientProfileUrl: text("client_profile_url"),
	interviewCount: integer("interview_count"),
	lastInterviewDate: timestamp("last_interview_date", { withTimezone: true, mode: 'string' }),
	interviewFeedback: text("interview_feedback"),
	offerExtendedAt: timestamp("offer_extended_at", { withTimezone: true, mode: 'string' }),
	offerAcceptedAt: timestamp("offer_accepted_at", { withTimezone: true, mode: 'string' }),
	offerDeclinedAt: timestamp("offer_declined_at", { withTimezone: true, mode: 'string' }),
	offerDeclineReason: text("offer_decline_reason"),
	rejectedAt: timestamp("rejected_at", { withTimezone: true, mode: 'string' }),
	rejectionReason: text("rejection_reason"),
	rejectionSource: text("rejection_source"),
	ownerId: uuid("owner_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
	createdBy: uuid("created_by"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	vendorSubmittedAt: timestamp("vendor_submitted_at", { withTimezone: true, mode: 'string' }),
	vendorSubmittedBy: uuid("vendor_submitted_by"),
	vendorDecision: text("vendor_decision"),
	vendorDecisionAt: timestamp("vendor_decision_at", { withTimezone: true, mode: 'string' }),
	vendorDecisionBy: uuid("vendor_decision_by"),
	vendorNotes: text("vendor_notes"),
	vendorScreeningNotes: text("vendor_screening_notes"),
	vendorScreeningCompletedAt: timestamp("vendor_screening_completed_at", { withTimezone: true, mode: 'string' }),
	clientDecision: text("client_decision"),
	clientDecisionAt: timestamp("client_decision_at", { withTimezone: true, mode: 'string' }),
	clientDecisionNotes: text("client_decision_notes"),
	offerId: uuid("offer_id"),
	placementId: uuid("placement_id"),
	contactId: uuid("contact_id"),
	companyId: uuid("company_id"),
	submittedByCompanyId: uuid("submitted_by_company_id"),
	submittedByContactId: uuid("submitted_by_contact_id"),
	isVendorSubmission: boolean("is_vendor_submission"),
	rtrObtained: boolean("rtr_obtained"),
	rtrObtainedAt: timestamp("rtr_obtained_at", { withTimezone: true, mode: 'string' }),
	rtrExpiresAt: timestamp("rtr_expires_at", { withTimezone: true, mode: 'string' }),
	rtrDocumentId: uuid("rtr_document_id"),
	rateCardId: uuid("rate_card_id"),
	rateCardItemId: uuid("rate_card_item_id"),
	negotiatedBillRate: numeric("negotiated_bill_rate", { precision: 10, scale:  2 }),
	negotiatedPayRate: numeric("negotiated_pay_rate", { precision: 10, scale:  2 }),
	rateNegotiationNotes: text("rate_negotiation_notes"),
	statusEnteredAt: timestamp("status_entered_at", { withTimezone: true, mode: 'string' }),
	expectedDecisionDate: date("expected_decision_date"),
	submissionScore: integer("submission_score"),
	scoreBreakdown: jsonb("score_breakdown"),
	rankAmongSubmissions: integer("rank_among_submissions"),
	isDuplicate: boolean("is_duplicate"),
	duplicateOfSubmissionId: uuid("duplicate_of_submission_id"),
	unifiedContactId: uuid("unified_contact_id"),
	legacyCandidateId: uuid("legacy_candidate_id"),
}).as(sql`SELECT id, org_id, job_id, candidate_id, account_id, status, ai_match_score, recruiter_match_score, match_explanation, submitted_rate, submitted_rate_type, submission_notes, submitted_to_client_at, submitted_to_client_by, client_resume_file_id, client_profile_url, interview_count, last_interview_date, interview_feedback, offer_extended_at, offer_accepted_at, offer_declined_at, offer_decline_reason, rejected_at, rejection_reason, rejection_source, owner_id, created_at, updated_at, created_by, deleted_at, vendor_submitted_at, vendor_submitted_by, vendor_decision, vendor_decision_at, vendor_decision_by, vendor_notes, vendor_screening_notes, vendor_screening_completed_at, client_decision, client_decision_at, client_decision_notes, offer_id, placement_id, contact_id, company_id, submitted_by_company_id, submitted_by_contact_id, is_vendor_submission, rtr_obtained, rtr_obtained_at, rtr_expires_at, rtr_document_id, rate_card_id, rate_card_item_id, negotiated_bill_rate, negotiated_pay_rate, rate_negotiation_notes, status_entered_at, expected_decision_date, submission_score, score_breakdown, rank_among_submissions, is_duplicate, duplicate_of_submission_id, COALESCE(contact_id, candidate_id) AS unified_contact_id, candidate_id AS legacy_candidate_id FROM submissions s`);

export const campaignProspectsView = pgView("campaign_prospects_view", {	id: uuid(),
	orgId: uuid("org_id"),
	campaignId: uuid("campaign_id"),
	leadId: uuid("lead_id"),
	firstName: text("first_name"),
	lastName: text("last_name"),
	email: text(),
	phone: text(),
	linkedinUrl: text("linkedin_url"),
	companyName: text("company_name"),
	companyIndustry: text("company_industry"),
	companySize: text("company_size"),
	title: text(),
	location: text(),
	timezone: text(),
	primaryChannel: text("primary_channel"),
	sequenceStep: integer("sequence_step"),
	sequenceStatus: text("sequence_status"),
	stopReason: text("stop_reason"),
	firstContactedAt: timestamp("first_contacted_at", { withTimezone: true, mode: 'string' }),
	lastContactedAt: timestamp("last_contacted_at", { withTimezone: true, mode: 'string' }),
	openedAt: timestamp("opened_at", { withTimezone: true, mode: 'string' }),
	clickedAt: timestamp("clicked_at", { withTimezone: true, mode: 'string' }),
	respondedAt: timestamp("responded_at", { withTimezone: true, mode: 'string' }),
	responseType: text("response_type"),
	responseText: text("response_text"),
	convertedToLeadAt: timestamp("converted_to_lead_at", { withTimezone: true, mode: 'string' }),
	convertedLeadId: uuid("converted_lead_id"),
	meetingBookedAt: timestamp("meeting_booked_at", { withTimezone: true, mode: 'string' }),
	meetingScheduledFor: timestamp("meeting_scheduled_for", { withTimezone: true, mode: 'string' }),
	engagementScore: integer("engagement_score"),
	status: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
	contactId: uuid("contact_id"),
}).as(sql`SELECT ce.id, ce.org_id, ce.campaign_id, NULL::uuid AS lead_id, c.first_name, c.last_name, c.email, c.phone, c.linkedin_url, c.company_name, NULL::text AS company_industry, NULL::text AS company_size, c.title, NULL::text AS location, c.timezone, ce.primary_channel, ce.sequence_step, ce.sequence_status, ce.stop_reason, ce.first_contacted_at, ce.last_contacted_at, ce.opened_at, ce.clicked_at, ce.responded_at, ce.response_type, ce.response_text, ce.converted_to_lead_at, ce.converted_lead_id, ce.meeting_booked_at, ce.meeting_scheduled_for, ce.engagement_score, ce.status, ce.created_at, ce.updated_at, ce.contact_id FROM campaign_enrollments ce JOIN contacts c ON c.id = ce.contact_id AND c.deleted_at IS NULL`);

export const legacyComplianceRequirementsView = pgView("legacy_compliance_requirements_view", {	id: uuid(),
	orgId: uuid("org_id"),
	name: varchar({ length: 200 }),
	type: text(),
	jurisdiction: varchar({ length: 50 }),
	appliesTo: text("applies_to"),
	frequency: text(),
	description: text(),
	documentTemplateUrl: text("document_template_url"),
	isActive: boolean("is_active"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
	createdBy: uuid("created_by"),
}).as(sql`SELECT id, org_id, requirement_name AS name, category::text AS type, jurisdiction, 'all'::text AS applies_to, CASE WHEN validity_period_days IS NULL THEN 'once'::text WHEN validity_period_days <= 365 THEN 'annual'::text ELSE 'once'::text END AS frequency, description, NULL::text AS document_template_url, is_active, created_at, updated_at, created_by FROM compliance_requirements WHERE deleted_at IS NULL`);

export const contactComplianceLegacy = pgView("contact_compliance_legacy", {	id: uuid(),
	orgId: uuid("org_id"),
	contactId: uuid("contact_id"),
	complianceType: varchar("compliance_type"),
	status: text(),
	documentUrl: varchar("document_url", { length: 500 }),
	documentReceivedAt: timestamp("document_received_at", { withTimezone: true, mode: 'string' }),
	effectiveDate: date("effective_date"),
	expiryDate: date("expiry_date"),
	verifiedBy: uuid("verified_by"),
	verifiedAt: timestamp("verified_at", { withTimezone: true, mode: 'string' }),
	verificationNotes: text("verification_notes"),
	policyNumber: varchar("policy_number", { length: 100 }),
	coverageAmount: numeric("coverage_amount", { precision: 12, scale:  2 }),
	insuranceCarrier: varchar("insurance_carrier", { length: 200 }),
	expiryAlertSentAt: timestamp("expiry_alert_sent_at", { withTimezone: true, mode: 'string' }),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT ci.id, ci.org_id, ci.entity_id AS contact_id, COALESCE(ci.compliance_type, cr.category) AS compliance_type, CASE ci.status::text WHEN 'pending'::text THEN 'pending'::text WHEN 'received'::text THEN 'received'::text WHEN 'under_review'::text THEN 'received'::text WHEN 'verified'::text THEN 'verified'::text WHEN 'expiring'::text THEN 'expiring'::text WHEN 'expired'::text THEN 'expired'::text WHEN 'rejected'::text THEN 'rejected'::text WHEN 'waived'::text THEN 'verified'::text ELSE 'pending'::text END AS status, ci.document_url, ci.document_received_at, ci.effective_date, ci.expiry_date, ci.verified_by, ci.verified_at, ci.verification_notes, ci.policy_number, ci.coverage_amount, ci.insurance_carrier, ci.expiry_alert_sent_at, ci.created_at, ci.updated_at, ci.deleted_at FROM compliance_items ci LEFT JOIN compliance_requirements cr ON cr.id = ci.requirement_id WHERE ci.entity_type::text = 'contact'::text`);

export const contactAgreementsLegacy = pgView("contact_agreements_legacy", {	id: uuid(),
	orgId: uuid("org_id"),
	contactId: uuid("contact_id"),
	agreementType: text("agreement_type"),
	agreementName: varchar("agreement_name", { length: 300 }),
	effectiveDate: date("effective_date"),
	expiryDate: date("expiry_date"),
	autoRenew: boolean("auto_renew"),
	renewalNoticeDays: integer("renewal_notice_days"),
	status: text(),
	documentUrl: varchar("document_url", { length: 500 }),
	signedDocumentUrl: varchar("signed_document_url", { length: 500 }),
	ourSignerId: uuid("our_signer_id"),
	ourSignedAt: timestamp("our_signed_at", { withTimezone: true, mode: 'string' }),
	theirSignerName: varchar("their_signer_name"),
	theirSignedAt: timestamp("their_signed_at", { withTimezone: true, mode: 'string' }),
	terms: jsonb(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT id, org_id, entity_id AS contact_id, CASE contract_type::text WHEN 'msa'::text THEN 'msa'::text WHEN 'nda'::text THEN 'nda'::text WHEN 'sow'::text THEN 'sow'::text WHEN 'rate_card_agreement'::text THEN 'rate_card'::text WHEN 'sla'::text THEN 'sla'::text WHEN 'vendor_agreement'::text THEN 'vendor_agreement'::text ELSE 'other'::text END AS agreement_type, contract_name AS agreement_name, effective_date, expiry_date, auto_renew, renewal_notice_days, CASE status::text WHEN 'draft'::text THEN 'draft'::text WHEN 'pending_review'::text THEN 'pending'::text WHEN 'pending_signature'::text THEN 'pending'::text WHEN 'partially_signed'::text THEN 'pending'::text WHEN 'active'::text THEN 'active'::text WHEN 'expired'::text THEN 'expired'::text WHEN 'terminated'::text THEN 'terminated'::text WHEN 'renewed'::text THEN 'active'::text WHEN 'superseded'::text THEN 'expired'::text ELSE 'draft'::text END AS status, document_url, signed_document_url, ( SELECT cp.user_id FROM contract_parties cp WHERE cp.contract_id = c.id AND cp.party_type::text = 'internal'::text AND cp.is_required = true LIMIT 1) AS our_signer_id, ( SELECT cp.signed_at FROM contract_parties cp WHERE cp.contract_id = c.id AND cp.party_type::text = 'internal'::text AND cp.is_required = true AND cp.signatory_status = 'signed'::signatory_status LIMIT 1) AS our_signed_at, ( SELECT COALESCE(cp.party_name, concat_ws(' '::text, ct.first_name, ct.last_name)::character varying) AS "coalesce" FROM contract_parties cp LEFT JOIN contacts ct ON ct.id = cp.contact_id WHERE cp.contract_id = c.id AND cp.party_type::text <> 'internal'::text AND cp.is_required = true LIMIT 1) AS their_signer_name, ( SELECT cp.signed_at FROM contract_parties cp WHERE cp.contract_id = c.id AND cp.party_type::text <> 'internal'::text AND cp.is_required = true AND cp.signatory_status = 'signed'::signatory_status LIMIT 1) AS their_signed_at, terms, created_at, updated_at, deleted_at FROM contracts c WHERE entity_type::text = 'contact'::text`);

export const contactRateCardsLegacy = pgView("contact_rate_cards_legacy", {	id: uuid(),
	orgId: uuid("org_id"),
	contactId: uuid("contact_id"),
	clientId: uuid("client_id"),
	skillId: uuid("skill_id"),
	jobId: uuid("job_id"),
	billRateHourly: numeric("bill_rate_hourly", { precision: 10, scale:  2 }),
	payRateHourly: numeric("pay_rate_hourly", { precision: 10, scale:  2 }),
	markupPercentage: numeric("markup_percentage", { precision: 5, scale:  2 }),
	overtimeMultiplier: numeric("overtime_multiplier"),
	effectiveDate: date("effective_date"),
	expiryDate: date("expiry_date"),
	isActive: boolean("is_active"),
	approvedBy: uuid("approved_by"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	notes: text(),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT id, org_id, entity_id AS contact_id, context_client_id AS client_id, NULL::uuid AS skill_id, context_job_id AS job_id, bill_rate AS bill_rate_hourly, pay_rate AS pay_rate_hourly, markup_percentage, CASE WHEN pay_rate > 0::numeric AND ot_pay_rate IS NOT NULL THEN round(ot_pay_rate / pay_rate, 2) ELSE 1.5 END AS overtime_multiplier, effective_date, end_date AS expiry_date, is_current AS is_active, approved_by, approved_at, negotiation_notes AS notes, created_at, updated_at, deleted_at FROM entity_rates er WHERE entity_type::text = 'contact'::text`);

export const placementsExtendedV = pgView("placements_extended_v", {	id: uuid(),
	orgId: uuid("org_id"),
	submissionId: uuid("submission_id"),
	offerId: uuid("offer_id"),
	jobId: uuid("job_id"),
	candidateId: uuid("candidate_id"),
	placementType: text("placement_type"),
	startDate: date("start_date"),
	endDate: date("end_date"),
	billRate: numeric("bill_rate", { precision: 10, scale:  2 }),
	payRate: numeric("pay_rate", { precision: 10, scale:  2 }),
	markupPercentage: numeric("markup_percentage", { precision: 5, scale:  2 }),
	status: text(),
	endReason: text("end_reason"),
	actualEndDate: date("actual_end_date"),
	totalRevenue: numeric("total_revenue", { precision: 12, scale:  2 }),
	totalPaid: numeric("total_paid", { precision: 12, scale:  2 }),
	onboardingStatus: text("onboarding_status"),
	onboardingCompletedAt: timestamp("onboarding_completed_at", { withTimezone: true, mode: 'string' }),
	performanceRating: integer("performance_rating"),
	extensionCount: integer("extension_count"),
	recruiterId: uuid("recruiter_id"),
	accountManagerId: uuid("account_manager_id"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
	createdBy: uuid("created_by"),
	healthStatus: varchar("health_status", { length: 20 }),
	nextCheckInDate: date("next_check_in_date"),
	lastCheckInDate: date("last_check_in_date"),
	lastCheckInBy: uuid("last_check_in_by"),
	rateType: varchar("rate_type", { length: 20 }),
	employmentType: varchar("employment_type", { length: 20 }),
	workLocation: varchar("work_location", { length: 20 }),
	workSchedule: varchar("work_schedule", { length: 100 }),
	timezone: varchar({ length: 50 }),
	onboardingFormat: varchar("onboarding_format", { length: 20 }),
	firstDayMeetingLink: text("first_day_meeting_link"),
	firstDayLocation: text("first_day_location"),
	hiringManagerName: varchar("hiring_manager_name", { length: 100 }),
	hiringManagerEmail: varchar("hiring_manager_email", { length: 200 }),
	hiringManagerPhone: varchar("hiring_manager_phone", { length: 30 }),
	hrContactName: varchar("hr_contact_name", { length: 100 }),
	hrContactEmail: varchar("hr_contact_email", { length: 200 }),
	paperworkComplete: boolean("paperwork_complete"),
	backgroundCheckStatus: varchar("background_check_status", { length: 20 }),
	i9Complete: boolean("i9_complete"),
	ndaSigned: boolean("nda_signed"),
	equipmentOrdered: boolean("equipment_ordered"),
	equipmentNotes: text("equipment_notes"),
	internalNotes: text("internal_notes"),
	deletedAt: timestamp("deleted_at", { withTimezone: true, mode: 'string' }),
	contactId: uuid("contact_id"),
	companyId: uuid("company_id"),
	billingCompanyId: uuid("billing_company_id"),
	endClientCompanyId: uuid("end_client_company_id"),
	clientCompanyId: uuid("client_company_id"),
	vendorCompanyId: uuid("vendor_company_id"),
	clientManagerContactId: uuid("client_manager_contact_id"),
	hrContactId: uuid("hr_contact_id"),
	reportingManagerContactId: uuid("reporting_manager_contact_id"),
	contractId: uuid("contract_id"),
	rateCardId: uuid("rate_card_id"),
	rateCardItemId: uuid("rate_card_item_id"),
	hasChangeOrders: boolean("has_change_orders"),
	activeChangeOrderId: uuid("active_change_order_id"),
	changeOrderCount: integer("change_order_count"),
	originalEndDate: date("original_end_date"),
	originalBillRate: numeric("original_bill_rate", { precision: 10, scale:  2 }),
	approvalStatus: varchar("approval_status", { length: 50 }),
	approvedBy: uuid("approved_by"),
	approvedAt: timestamp("approved_at", { withTimezone: true, mode: 'string' }),
	expectedHoursPerWeek: numeric("expected_hours_per_week", { precision: 5, scale:  2 }),
	overtimeEligible: boolean("overtime_eligible"),
	expensesAllowed: boolean("expenses_allowed"),
	expenseBudget: numeric("expense_budget", { precision: 10, scale:  2 }),
	complianceStatus: varchar("compliance_status", { length: 50 }),
	complianceClearedAt: timestamp("compliance_cleared_at", { withTimezone: true, mode: 'string' }),
	complianceExpiresAt: timestamp("compliance_expires_at", { withTimezone: true, mode: 'string' }),
	workArrangement: varchar("work_arrangement", { length: 50 }),
	hybridDaysPerWeek: integer("hybrid_days_per_week"),
	workAddressId: uuid("work_address_id"),
	contactName: text("contact_name"),
	contactEmail: text("contact_email"),
	clientCompanyName: text("client_company_name"),
	endClientCompanyName: text("end_client_company_name"),
	vendorCompanyName: text("vendor_company_name"),
}).as(sql`SELECT p.id, p.org_id, p.submission_id, p.offer_id, p.job_id, p.candidate_id, p.placement_type, p.start_date, p.end_date, p.bill_rate, p.pay_rate, p.markup_percentage, p.status, p.end_reason, p.actual_end_date, p.total_revenue, p.total_paid, p.onboarding_status, p.onboarding_completed_at, p.performance_rating, p.extension_count, p.recruiter_id, p.account_manager_id, p.created_at, p.updated_at, p.created_by, p.health_status, p.next_check_in_date, p.last_check_in_date, p.last_check_in_by, p.rate_type, p.employment_type, p.work_location, p.work_schedule, p.timezone, p.onboarding_format, p.first_day_meeting_link, p.first_day_location, p.hiring_manager_name, p.hiring_manager_email, p.hiring_manager_phone, p.hr_contact_name, p.hr_contact_email, p.paperwork_complete, p.background_check_status, p.i9_complete, p.nda_signed, p.equipment_ordered, p.equipment_notes, p.internal_notes, p.deleted_at, p.contact_id, p.company_id, p.billing_company_id, p.end_client_company_id, p.client_company_id, p.vendor_company_id, p.client_manager_contact_id, p.hr_contact_id, p.reporting_manager_contact_id, p.contract_id, p.rate_card_id, p.rate_card_item_id, p.has_change_orders, p.active_change_order_id, p.change_order_count, p.original_end_date, p.original_bill_rate, p.approval_status, p.approved_by, p.approved_at, p.expected_hours_per_week, p.overtime_eligible, p.expenses_allowed, p.expense_budget, p.compliance_status, p.compliance_cleared_at, p.compliance_expires_at, p.work_arrangement, p.hybrid_days_per_week, p.work_address_id, COALESCE((c.first_name || ' '::text) || c.last_name, c.first_name, c.last_name) AS contact_name, c.email AS contact_email, cc.name AS client_company_name, ec.name AS end_client_company_name, vc.name AS vendor_company_name FROM placements p LEFT JOIN contacts c ON c.id = p.contact_id LEFT JOIN companies cc ON cc.id = p.client_company_id LEFT JOIN companies ec ON ec.id = p.end_client_company_id LEFT JOIN companies vc ON vc.id = p.vendor_company_id`);

export const dealStagesHistoryLegacy = pgView("deal_stages_history_legacy", {	id: uuid(),
	orgId: uuid("org_id"),
	entityId: uuid("entity_id"),
	entityType: text("entity_type"),
	changeType: text("change_type"),
	fieldName: text("field_name"),
	oldValue: jsonb("old_value"),
	newValue: jsonb("new_value"),
	changedBy: uuid("changed_by"),
	changedAt: timestamp("changed_at", { withTimezone: true, mode: 'string' }),
	metadata: jsonb(),
}).as(sql`SELECT dsh.id, d.org_id, dsh.deal_id AS entity_id, 'deal'::text AS entity_type, 'stage_change'::text AS change_type, 'stage'::text AS field_name, to_jsonb(dsh.previous_stage) AS old_value, to_jsonb(dsh.stage) AS new_value, dsh.changed_by, dsh.entered_at AS changed_at, jsonb_build_object('duration_days', dsh.duration_days, 'notes', dsh.notes, 'reason', dsh.reason) AS metadata FROM deal_stages_history dsh LEFT JOIN deals d ON d.id = dsh.deal_id`);

export const unifiedInbox = pgView("unified_inbox", {	id: uuid(),
	orgId: uuid("org_id"),
	channel: varchar({ length: 50 }),
	direction: varchar({ length: 20 }),
	threadId: uuid("thread_id"),
	parentId: uuid("parent_id"),
	threadPosition: integer("thread_position"),
	fromAddress: text("from_address"),
	fromName: text("from_name"),
	toAddress: text("to_address"),
	toName: text("to_name"),
	ccAddresses: jsonb("cc_addresses"),
	bccAddresses: jsonb("bcc_addresses"),
	subject: text(),
	bodyText: text("body_text"),
	bodyHtml: text("body_html"),
	preview: text(),
	attachments: jsonb(),
	entityType: varchar("entity_type", { length: 50 }),
	entityId: uuid("entity_id"),
	secondaryEntityType: varchar("secondary_entity_type", { length: 50 }),
	secondaryEntityId: uuid("secondary_entity_id"),
	contactId: uuid("contact_id"),
	provider: varchar({ length: 50 }),
	providerMessageId: text("provider_message_id"),
	providerThreadId: text("provider_thread_id"),
	status: varchar({ length: 50 }),
	scheduledAt: timestamp("scheduled_at", { withTimezone: true, mode: 'string' }),
	sentAt: timestamp("sent_at", { withTimezone: true, mode: 'string' }),
	deliveredAt: timestamp("delivered_at", { withTimezone: true, mode: 'string' }),
	openedAt: timestamp("opened_at", { withTimezone: true, mode: 'string' }),
	clickedAt: timestamp("clicked_at", { withTimezone: true, mode: 'string' }),
	repliedAt: timestamp("replied_at", { withTimezone: true, mode: 'string' }),
	failedAt: timestamp("failed_at", { withTimezone: true, mode: 'string' }),
	openCount: integer("open_count"),
	clickCount: integer("click_count"),
	replyCount: integer("reply_count"),
	clickedLinks: jsonb("clicked_links"),
	errorCode: varchar("error_code", { length: 50 }),
	errorMessage: text("error_message"),
	retryCount: integer("retry_count"),
	maxRetries: integer("max_retries"),
	campaignId: uuid("campaign_id"),
	sequenceStepId: uuid("sequence_step_id"),
	abVariant: varchar("ab_variant", { length: 50 }),
	templateId: uuid("template_id"),
	templateName: text("template_name"),
	templateVariables: jsonb("template_variables"),
	metadata: jsonb(),
	tags: text(),
	createdBy: uuid("created_by"),
	createdAt: timestamp("created_at", { withTimezone: true, mode: 'string' }),
	updatedAt: timestamp("updated_at", { withTimezone: true, mode: 'string' }),
	contactFirstName: text("contact_first_name"),
	contactLastName: text("contact_last_name"),
	contactEmail: text("contact_email"),
	contactCompany: text("contact_company"),
	// You can use { mode: "bigint" } if numbers are exceeding js number limitations
	threadCount: bigint("thread_count", { mode: "number" }),
	threadUpdatedAt: timestamp("thread_updated_at", { withTimezone: true, mode: 'string' }),
}).as(sql`SELECT c.id, c.org_id, c.channel, c.direction, c.thread_id, c.parent_id, c.thread_position, c.from_address, c.from_name, c.to_address, c.to_name, c.cc_addresses, c.bcc_addresses, c.subject, c.body_text, c.body_html, c.preview, c.attachments, c.entity_type, c.entity_id, c.secondary_entity_type, c.secondary_entity_id, c.contact_id, c.provider, c.provider_message_id, c.provider_thread_id, c.status, c.scheduled_at, c.sent_at, c.delivered_at, c.opened_at, c.clicked_at, c.replied_at, c.failed_at, c.open_count, c.click_count, c.reply_count, c.clicked_links, c.error_code, c.error_message, c.retry_count, c.max_retries, c.campaign_id, c.sequence_step_id, c.ab_variant, c.template_id, c.template_name, c.template_variables, c.metadata, c.tags, c.created_by, c.created_at, c.updated_at, ct.first_name AS contact_first_name, ct.last_name AS contact_last_name, ct.email AS contact_email, ct.company_name AS contact_company, CASE WHEN c.thread_id IS NOT NULL THEN ( SELECT count(*) AS count FROM communications WHERE communications.thread_id = c.thread_id) ELSE 1::bigint END AS thread_count, CASE WHEN c.thread_id IS NOT NULL THEN ( SELECT max(communications.created_at) AS max FROM communications WHERE communications.thread_id = c.thread_id) ELSE c.created_at END AS thread_updated_at FROM communications c LEFT JOIN contacts ct ON c.contact_id = ct.id`);