/**
 * Course Event Handlers
 *
 * Handlers for course-related events (graduation, enrollment, etc.)
 */

import { registerEventHandler } from '../decorators';
import type { Event, CourseGraduatedPayload, CourseEnrolledPayload, CapstoneGradedPayload, StudentAtRiskPayload } from '../types';
import { createClient } from '@/lib/supabase/server';

/**
 * When student graduates, create candidate profile
 *
 * This demonstrates cross-module integration via events:
 * Academy module publishes 'course.graduated' â†’ Recruiting module creates candidate
 *
 * @param event - course.graduated event
 */
export async function handleCourseGraduated(event: Event<CourseGraduatedPayload>) {
  const { studentId, courseName, grade } = event.payload;

  console.log(`[Handler:create_candidate_profile] Processing graduation for student ${studentId}`);

  const supabase = await createClient();

  try {
    // Grant candidate role
    await supabase.rpc('grant_role_to_user', {
      p_user_id: studentId,
      p_role_name: 'candidate',
      p_granted_by: 'system' // Automated grant via event handler
    });

    // Update user profile with candidate status
    await supabase
      .from('user_profiles')
      .update({
        candidate_status: 'bench',
        candidate_ready_for_placement: grade >= 80 // Only if grade is B or higher
      })
      .eq('id', studentId);

    console.log(`[Handler:create_candidate_profile] Student ${studentId} promoted to candidate after completing ${courseName} (grade: ${grade})`);
  } catch (error) {
    console.error(`[Handler:create_candidate_profile] Failed to create candidate profile:`, error);
    throw error;
  }
}

/**
 * Notify recruiting team of new graduate
 *
 * @param event - course.graduated event
 */
export async function notifyRecruitingTeam(event: Event<CourseGraduatedPayload>) {
  const { studentId, courseName, grade } = event.payload;

  console.log(`[Handler:notify_recruiting_team] Notifying team about new graduate`);

  // In Sprint 2, just log. In future sprints, send Slack notification
  console.log(`[Handler:notify_recruiting_team] New graduate available: Student ${studentId} completed ${courseName} with grade ${grade}`);

  // TODO: Send Slack notification to recruiting channel
  /*
  await fetch(process.env.SLACK_WEBHOOK_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      text: `ðŸŽ“ New graduate available!`,
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `Student ${studentId} completed *${courseName}* with grade *${grade}*`
          }
        }
      ]
    })
  });
  */
}

/**
 * Send congratulations email to graduate (ACAD-022)
 *
 * @param event - course.graduated event
 */
export async function sendGraduationEmail(event: Event<CourseGraduatedPayload>) {
  const { studentId, courseName, grade, courseId } = event.payload;

  console.log(`[Handler:send_graduation_email] Sending congratulations email to student ${studentId}`);

  const supabase = await createClient();

  try {
    // Get student details
    const { data: student } = await supabase
      .from('user_profiles')
      .select('email, full_name')
      .eq('id', studentId)
      .single();

    if (!student) {
      throw new Error(`Student ${studentId} not found`);
    }

    // Queue email job (will be processed by background job system)
    await (supabase.from as any)('background_jobs').insert({
      job_type: 'send_email',
      status: 'pending',
      payload: {
        to: student.email,
        template: 'course_graduation',
        data: {
          student_name: student.full_name,
          course_name: courseName,
          grade,
          certificate_url: `/students/certificates/${courseId}`, // Will be generated by certificate handler
        },
      },
      priority: 'high',
      max_attempts: 3,
    });

    console.log(`[Handler:send_graduation_email] Queued graduation email for ${student.email}`);
  } catch (error) {
    console.error(`[Handler:send_graduation_email] Failed to queue email:`, error);
    throw error;
  }
}

/**
 * Trigger certificate generation (ACAD-022 + ACAD-023)
 *
 * @param event - course.graduated event
 */
export async function generateCertificate(event: Event<CourseGraduatedPayload>) {
  const { studentId, courseName, grade, courseId } = event.payload;

  console.log(`[Handler:generate_certificate] Generating certificate for student ${studentId}`);

  const supabase = await createClient();

  try {
    // Get student and course details
    const [studentResult, courseResult] = await Promise.all([
      supabase
        .from('user_profiles')
        .select('full_name, email')
        .eq('id', studentId)
        .single(),
      supabase
        .from('courses')
        .select('title, estimated_duration_weeks')
        .eq('id', courseId)
        .single(),
    ]);

    if (!studentResult.data || !courseResult.data) {
      throw new Error('Student or course not found');
    }

    const student = studentResult.data;
    const course = courseResult.data;

    // Create certificate record (will trigger actual PDF generation via webhook/job)
    const { data: certificate, error } = await (supabase.from as any)('student_certificates')
      .insert({
        student_id: studentId,
        course_id: courseId,
        certificate_number: `CERT-${Date.now()}-${studentId.slice(0, 8)}`,
        issued_date: new Date().toISOString(),
        student_name: student.full_name,
        course_title: course.title,
        completion_date: new Date().toISOString(),
        grade_achieved: grade,
        certificate_type: 'course_completion',
        status: 'pending', // Will be 'issued' once PDF is generated
      })
      .select()
      .single();

    if (error) {
      throw error;
    }

    // Queue certificate generation job
    await (supabase.from as any)('background_jobs').insert({
      job_type: 'generate_certificate_pdf',
      status: 'pending',
      payload: {
        certificate_id: certificate.id,
        student_name: student.full_name,
        course_name: course.title,
        grade,
        issue_date: new Date().toISOString(),
      },
      priority: 'normal',
      max_attempts: 3,
    });

    console.log(`[Handler:generate_certificate] Created certificate record ${certificate.id} for student ${studentId}`);
  } catch (error) {
    console.error(`[Handler:generate_certificate] Failed to generate certificate:`, error);
    throw error;
  }
}

/**
 * Send welcome email when student enrolls (ACAD-024)
 *
 * @param event - course.enrolled event
 */
export async function sendWelcomeEmail(event: Event<CourseEnrolledPayload>) {
  const { studentId, courseName, enrollmentId } = event.payload;

  console.log(`[Handler:send_welcome_email] Sending welcome email to student ${studentId}`);

  const supabase = await createClient();

  try {
    // Get student details
    const { data: student } = await supabase
      .from('user_profiles')
      .select('email, full_name')
      .eq('id', studentId)
      .single();

    if (!student) {
      throw new Error(`Student ${studentId} not found`);
    }

    // Queue welcome email job
    await (supabase.from as any)('background_jobs').insert({
      job_type: 'send_email',
      status: 'pending',
      payload: {
        to: student.email,
        template: 'course_welcome',
        data: {
          student_name: student.full_name,
          course_name: courseName,
          dashboard_url: '/students/dashboard',
          first_module_url: `/students/enrollments/${enrollmentId}`,
        },
      },
      priority: 'high',
      max_attempts: 3,
    });

    console.log(`[Handler:send_welcome_email] Queued welcome email for ${student.email}`);
  } catch (error) {
    console.error(`[Handler:send_welcome_email] Failed to queue email:`, error);
    throw error;
  }
}

/**
 * Create onboarding checklist when student enrolls (ACAD-024)
 *
 * @param event - course.enrolled event
 */
export async function createOnboardingChecklist(event: Event<CourseEnrolledPayload>) {
  const { studentId, enrollmentId, courseId } = event.payload;

  console.log(`[Handler:create_onboarding_checklist] Creating checklist for student ${studentId}`);

  const supabase = await createClient();

  try {
    // Create onboarding checklist items
    const checklistItems = [
      {
        enrollment_id: enrollmentId,
        user_id: studentId,
        item_key: 'complete_profile',
        title: 'Complete your profile',
        description: 'Add your professional information and preferences',
        sort_order: 1,
        is_completed: false,
      },
      {
        enrollment_id: enrollmentId,
        user_id: studentId,
        item_key: 'watch_intro_video',
        title: 'Watch the course introduction',
        description: 'Learn what you will accomplish in this course',
        sort_order: 2,
        is_completed: false,
      },
      {
        enrollment_id: enrollmentId,
        user_id: studentId,
        item_key: 'complete_first_topic',
        title: 'Complete your first topic',
        description: 'Start learning and earn your first XP',
        sort_order: 3,
        is_completed: false,
      },
      {
        enrollment_id: enrollmentId,
        user_id: studentId,
        item_key: 'meet_ai_mentor',
        title: 'Meet your AI Mentor',
        description: 'Ask a question and get personalized help',
        sort_order: 4,
        is_completed: false,
      },
      {
        enrollment_id: enrollmentId,
        user_id: studentId,
        item_key: 'setup_study_schedule',
        title: 'Set your study schedule',
        description: 'Plan when you will dedicate time to learning',
        sort_order: 5,
        is_completed: false,
      },
    ];

    await (supabase.from as any)('onboarding_checklist').insert(checklistItems);

    console.log(`[Handler:create_onboarding_checklist] Created ${checklistItems.length} checklist items for enrollment ${enrollmentId}`);
  } catch (error) {
    console.error(`[Handler:create_onboarding_checklist] Failed to create checklist:`, error);
    throw error;
  }
}

/**
 * Send grade notification email when capstone is graded (ACAD-026)
 *
 * @param event - capstone.graded event
 */
export async function sendGradeNotification(event: Event<CapstoneGradedPayload>) {
  const { studentName, studentEmail, courseName, grade, feedback, status } = event.payload;

  console.log(`[Handler:send_grade_notification] Sending grade notification to ${studentEmail}`);

  const supabase = await createClient();

  try {
    // Determine email template based on status
    const statusMessages = {
      passed: {
        subject: 'Congratulations! Your Capstone Has Been Graded',
        message: 'You passed! ðŸŽ‰',
      },
      failed: {
        subject: 'Your Capstone Needs More Work',
        message: 'Please review the feedback and resubmit.',
      },
      revision_requested: {
        subject: 'Revision Requested for Your Capstone',
        message: 'Minor improvements needed. Review feedback and resubmit.',
      },
    };

    // Queue grade notification email
    await (supabase.from as any)('background_jobs').insert({
      job_type: 'send_email',
      status: 'pending',
      payload: {
        to: studentEmail,
        template: 'capstone_graded',
        data: {
          student_name: studentName,
          course_name: courseName,
          grade,
          feedback,
          status,
          status_message: statusMessages[status].message,
          subject: statusMessages[status].subject,
          submission_url: '/students/dashboard',
        },
      },
      priority: 'high',
      max_attempts: 3,
    });

    console.log(`[Handler:send_grade_notification] Queued grade notification email for ${studentEmail}`);
  } catch (error) {
    console.error(`[Handler:send_grade_notification] Failed to queue email:`, error);
    throw error;
  }
}

// Register graduation handlers
registerEventHandler('course.graduated', 'create_candidate_profile', handleCourseGraduated);
registerEventHandler('course.graduated', 'notify_recruiting_team', notifyRecruitingTeam);
registerEventHandler('course.graduated', 'send_graduation_email', sendGraduationEmail);
registerEventHandler('course.graduated', 'generate_certificate', generateCertificate);

// Register enrollment handlers (ACAD-024)
registerEventHandler('course.enrolled', 'send_welcome_email', sendWelcomeEmail);
registerEventHandler('course.enrolled', 'create_onboarding_checklist', createOnboardingChecklist);

/**
 * Send at-risk alert to trainer (ACAD-027)
 *
 * @param event - student.at_risk_detected event
 */
export async function sendAtRiskAlert(event: Event<StudentAtRiskPayload>) {
  const { studentName, studentEmail, courseName, riskReasons, riskLevel, trainerId } = event.payload;

  console.log(`[Handler:send_at_risk_alert] Sending at-risk alert for student ${studentName}`);

  const supabase = await createClient();

  try {
    // Get trainer details
    const { data: trainer } = await supabase
      .from('user_profiles')
      .select('email, full_name')
      .eq('id', trainerId)
      .single();

    if (!trainer) {
      throw new Error(`Trainer ${trainerId} not found`);
    }

    // Queue at-risk alert email to trainer
    await (supabase.from as any)('background_jobs').insert({
      job_type: 'send_email',
      status: 'pending',
      payload: {
        to: trainer.email,
        template: 'student_at_risk_alert',
        data: {
          trainer_name: trainer.full_name,
          student_name: studentName,
          student_email: studentEmail,
          course_name: courseName,
          risk_reasons: riskReasons.join(', '),
          risk_level: riskLevel,
          dashboard_url: '/trainer/dashboard?tab=at-risk',
        },
      },
      priority: 'high',
      max_attempts: 3,
    });

    // TODO: Send Slack notification to trainer channel
    /*
    await fetch(process.env.SLACK_WEBHOOK_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text: `ðŸš¨ At-Risk Student Alert`,
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `*Student:* ${studentName}\n*Course:* ${courseName}\n*Risk Level:* ${riskLevel.toUpperCase()}\n*Reasons:* ${riskReasons.join(', ')}`
            }
          },
          {
            type: 'actions',
            elements: [
              {
                type: 'button',
                text: {
                  type: 'plain_text',
                  text: 'View Dashboard'
                },
                url: `${process.env.NEXT_PUBLIC_APP_URL}/trainer/dashboard?tab=at-risk`
              }
            ]
          }
        ]
      })
    });
    */

    console.log(`[Handler:send_at_risk_alert] Queued at-risk alert for ${trainer.email}`);
  } catch (error) {
    console.error(`[Handler:send_at_risk_alert] Failed to queue alert:`, error);
    throw error;
  }
}

// Register capstone grading handlers (ACAD-026)
registerEventHandler('capstone.graded', 'send_grade_notification', sendGradeNotification);

// Register at-risk alert handlers (ACAD-027)
registerEventHandler('student.at_risk_detected', 'send_at_risk_alert', sendAtRiskAlert);
