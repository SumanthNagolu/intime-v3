{
  "lessonId": "ch11-l07",
  "chapterId": 11,
  "chapterSlug": "ch11",
  "lessonNumber": 7,
  "title": "Integration Views",
  "sourceFile": "Integration Views.pptx",
  "sourceFolder": "In_Integration_07",
  "totalSlides": 35,
  "estimatedMinutes": 105,
  "slides": [
    {
      "slideNumber": 1,
      "title": "Integration Views",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Integration Views",
      "ocrWordCount": 2,
      "ocrConfidence": 95.5,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "title"
    },
    {
      "slideNumber": 2,
      "title": "Learning Objectives",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Lesson\nobjectives\n\n• Define the purpose of Integration Views\n\nConfigure an Integration View schema,\nmapping, and filter\n\nGenerate JSON output\n\nGenerate XML output",
      "ocrWordCount": 23,
      "ocrConfidence": 94.17,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives"
    },
    {
      "slideNumber": 3,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 4,
      "title": "Why use an Integration View?",
      "bodyParagraphs": [],
      "originalNotes": "Why use an Integration View?\nIntegration Views are intended to supersede and eventually replace XML models.",
      "notes": "Why use an Integration View?\nIntegration Views are intended to supersede and eventually replace XML models.",
      "narration": "",
      "ocrText": "| Why use an Integration View?\n\n• Produce external views of the\nGuidewire domain model\n\n* Schemas and mappings are explicitly\nnamed and versioned\n\n+ Different versions of the same schema\nand/or mappings can co-exist\n\n• Output format is explicitly designed in\nthe schema\n\n• Simple design approach\n\n• Define the output schema first and then\nmap the data to that output\n\nGi\n\nSs s\nes\n\nExternal\nView\n{\n\n}-06-20T04:00:00.0002\",\n\nm Andy\",\n“primaryAddress™ : {\nTaddressType” : “home”\n}\n)",
      "ocrWordCount": 80,
      "ocrConfidence": 82.89,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 5,
      "title": "Integration View components",
      "bodyParagraphs": [],
      "originalNotes": "Integration View components\nJSON\nStands for \"JavaScript Object Notation\", a simple data interchange format\nIt is used primarily to transmit data between a server and web application, as an alternative to XML\nIt is easy for machines to parse and generate\nIt is based on a subset of the JavaScript Programming Language, Standard ECMA- 262 3rd Edition – December 1999\n\nJSON Schema\nFor further reference: https://spacetelescope.github.i o/understanding-json- schema/index-html",
      "notes": "Integration View components\nJSON\nStands for \"JavaScript Object Notation\", a simple data interchange format\nIt is used primarily to transmit data between a server and web application, as an alternative to XML\nIt is easy for machines to parse and generate\nIt is based on a subset of the JavaScript Programming Language, Standard ECMA- 262 3rd Edition – December 1999\n\nJSON Schema\nFor further reference: https://spacetelescope.github.i o/understanding-json- schema/index-html",
      "narration": "",
      "ocrText": "| Integration View components Gi\n\n• An Integration View has the following\n\ncomponents: _ Ni configuration » 1% config ) [5 integration\n* Schemas\n. > apis\n+ AJSON Schema defines the structure of the data Eu filterstmta\n* Can be targeted by multiple mappings & address_minimel-1.0.9ql\n2 contact_details-1.0.gql\n* Mappings @ contactnote_details-1.0.gql\n—>v mappings.tmn.ta\n+ Describes how to transform a given source object such as an entity if) address-1.0.mapping,json\ninto a JSON or XML document that conforms to that schema & contact-1.0.mapping,json\n. ‘§ contactnote-1.0.mapping,json\n+ Targets a single JSON Schema == vB schemas\n> ppl fi Kk\n+ Filters ie\n* Optional GraphQL-style filters that whitelist the fields to actually {, address-1.0.schema,json\n\n4 atts init ntact-1.0.schs j\nmaterialize and serialize oes pean\n4) contactnote-1.0.schema,json\n\n+ These include virtual fields",
      "ocrWordCount": 131,
      "ocrConfidence": 76.14,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 6,
      "title": "Use case",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "| Use case Gi\n\n\"general\",\n\n• Export the following contact sear eee eee 1. Define the schemas\n\nian Andy has discovered @ serious data entry issue\",\n\ndata in either JSON or XML pe ree » Create the necessary\nformat: “ete ay he ace tome, schema files to define the\n* Name “Willian Andy has a new Licence™ structure of the data\n\n* Date of Birth 2. Define the mappings\n\n+ Create the necessary\nmapping files to define the\ndomain fields to export\n\n3. Define the filters\n\n* Create the filter files to\nexport a subset of contact\ndata\n\n+ Gender\n* Primary address and its fields ts seieste\n* Contact notes and its fields\n\n« Export a subset of data\n+ Without contact notes 1\n\n* Contact notes only",
      "ocrWordCount": 129,
      "ocrConfidence": 80.41,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 7,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 95.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 8,
      "title": "Create a JSON Schema",
      "bodyParagraphs": [],
      "originalNotes": "Create a JSON Schema\nCode example\nLine 2\nComments are not technically allowed in JSON, but are allowed in Guidewire's framework.\nLine 3\nEvery JSON schema starts with the schema declaration.\nLine 4\nDefine each definition name under definitions.\n\nVersioning\nUse minor versions for backwards-compatible changes in cases where you need both schema versions to co-exist, and use major versions for breaking changes or significant changes to the schema. But ultimately it's up to whomever is writing the schemas to decide if it's worth it to produce a new version of the schema, versus just modifying an existing version in place.\nThe version portion of the schema name can have any number of characters, along with an optional textsuffix. so 1.0, 1.1, 1.0.1, and 1.0.3-alpha are all valid versions\n\nJSON Schema\nJSON Schema (draft 4) document that describes the serialize data (technically we use a subset of JSON Schema).\nIn particular, it is used to define objects that will be serialized with support for defining types of objects, arrays, and the types of properties they containCan be used for Integration Views and REST APIs.\nA given schema candefine any number of object types (i.e-'definitions\")\nSchemas are explicitly named and versioned.\nJSON Schema Subset\nLimited subset of JSON schema\nSimplifies mapping, composition, and schema->0bject generation\nLines up with the subset Swagger supports, but even more limited\nNo nested anonymous object types: only top- level named types\nNo nested arrays: arrays can only be of scalars or objects\nProperties have a single type\n\nNote: The JSON schema defined composition model of anyOf, allOf, and oneOf is not currently supported as Integration Views has its own way of reasoning about a versioned combination of schemas-",
      "notes": "Create a JSON Schema\nCode example\nLine 2\nComments are not technically allowed in JSON, but are allowed in Guidewire's framework.\nLine 3\nEvery JSON schema starts with the schema declaration.\nLine 4\nDefine each definition name under definitions.\n\nVersioning\nUse minor versions for backwards-compatible changes in cases where you need both schema versions to co-exist, and use major versions for breaking changes or significant changes to the schema. But ultimately it's up to whomever is writing the schemas to decide if it's worth it to produce a new version of the schema, versus just modifying an existing version in place.\nThe version portion of the schema name can have any number of characters, along with an optional textsuffix. so 1.0, 1.1, 1.0.1, and 1.0.3-alpha are all valid versions\n\nJSON Schema\nJSON Schema (draft 4) document that describes the serialize data (technically we use a subset of JSON Schema).\nIn particular, it is used to define objects that will be serialized with support for defining types of objects, arrays, and the types of properties they containCan be used for Integration Views and REST APIs.\nA given schema candefine any number of object types (i.e-'definitions\")\nSchemas are explicitly named and versioned.\nJSON Schema Subset\nLimited subset of JSON schema\nSimplifies mapping, composition, and schema->0bject generation\nLines up with the subset Swagger supports, but even more limited\nNo nested anonymous object types: only top- level named types\nNo nested arrays: arrays can only be of scalars or objects\nProperties have a single type\n\nNote: The JSON schema defined composition model of anyOf, allOf, and oneOf is not currently supported as Integration Views has its own way of reasoning about a versioned combination of schemas-",
      "narration": "",
      "ocrText": "| Create a JSON Schema Gi\n\n* Create a new package under integration.schemas\n\n+ config.integration.schemas.<company_code>.<product_code>\n\n* Create a new file with the following syntax:\n\n7 A 7 > pl fi k\n\n« <mechanism>- {version} .schema. json oe Famewor\n\nv irn.ta\n address-1.0.schema,json\n4) contact-1.0.schema,json\n\n4} contactnote-1.0.schema,json\n\n6 contact-1.0.schema,json\n\n{\n\n\"$schema\": \"http: //json-schema.org/draft-04/schema#\",\n\"definitions\": {}\n\n}",
      "ocrWordCount": 54,
      "ocrConfidence": 73.87,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 9,
      "title": "Supported data types",
      "bodyParagraphs": [],
      "originalNotes": "Supported data types\nWhat is Swagger?\nSwagger is a specification for documenting REST APIs that has become the closest thing to an industry standard that you'll find, with a growing ecosystem of tools (including Amazon's API Gateway) that can understand Swagger schemas- The IS REST Framework uses Swagger version 2.0 schemas to define the APIs themselves, including the available resources (i.e. the paths), the verbs that can be used with those resources (i.e. the operations), what parameters each operation accepts, and the schema for any payload or response if those are specified in JSON. More information on InsuranceSuite REST APIs can be found in the REST API Framework lesson.\n\nSwagger 2.0 defines a number of standard formats that are part of the Swagger specification, and InsuranceSuite adopts those conventions and adds in some other, custom formats for data types like fixed-point decimals (i.e. BigDecimals in Java) that aren't covered.\n\nInsurance Suite also allows for the x-gw-type property on Swagger parameters and JSON schema properties, which is used to indicate a specific internal Insurance Suite type that a property will be mapped to for serialization and d.serialization- x-gw-type is currently used for typekey types and to differentiate between Currency Amount and Monetary Amount for money data types.\nThe combination of type, format, and x-gw-type determines the serialization format on the wire and the POJO type that inputs deserialize to.\n\nPOJO Plain Old Java Object is a Java object not bound by any restriction other than those forced by the Java Language Specification; i.e., a POJO should not have to\nExtend prespecified classes\nImplement prespecified interfaces\nContain prespecified annotations\n\nSupported JSON data types and formats can be found in the Integration Guide documentation under JSON schema support specification.",
      "notes": "Supported data types\nWhat is Swagger?\nSwagger is a specification for documenting REST APIs that has become the closest thing to an industry standard that you'll find, with a growing ecosystem of tools (including Amazon's API Gateway) that can understand Swagger schemas- The IS REST Framework uses Swagger version 2.0 schemas to define the APIs themselves, including the available resources (i.e. the paths), the verbs that can be used with those resources (i.e. the operations), what parameters each operation accepts, and the schema for any payload or response if those are specified in JSON. More information on InsuranceSuite REST APIs can be found in the REST API Framework lesson.\n\nSwagger 2.0 defines a number of standard formats that are part of the Swagger specification, and InsuranceSuite adopts those conventions and adds in some other, custom formats for data types like fixed-point decimals (i.e. BigDecimals in Java) that aren't covered.\n\nInsurance Suite also allows for the x-gw-type property on Swagger parameters and JSON schema properties, which is used to indicate a specific internal Insurance Suite type that a property will be mapped to for serialization and d.serialization- x-gw-type is currently used for typekey types and to differentiate between Currency Amount and Monetary Amount for money data types.\nThe combination of type, format, and x-gw-type determines the serialization format on the wire and the POJO type that inputs deserialize to.\n\nPOJO Plain Old Java Object is a Java object not bound by any restriction other than those forced by the Java Language Specification; i.e., a POJO should not have to\nExtend prespecified classes\nImplement prespecified interfaces\nContain prespecified annotations\n\nSupported JSON data types and formats can be found in the Integration Guide documentation under JSON schema support specification.",
      "narration": "",
      "ocrText": "| Supported data types\n\n« JSON natively defines a small set of primitive types: string, boolean, numbers\n\n(which are interpreted as doubles), object, and array\n\n« JSON Schema (and Swagger) define an integer type, which is a number with a decimal\n\ncomponent of .0\n\n« JSON Schema (and Swagger) has a format property to describe more complex\ndata types: dates, numeric types that require a higher level of precision, binary\n\ndata, and so forth\n\n*« Custom x-gw-type property is added to map Guidewire internal types in cases\nwhere a format would be ambiguous, such as: typekeys, MonetaryAmount and\n\nCurrencyAmount\n\nType\n\nFormat\n\nx-gw-type Standard\n\nstring\nstring\n\nstring\n\ngw-money\ngw-money\n\n<none>\n\ngw.pl.currency.MonetaryAmount Guidewire\ngw.api.financials.currencyAmount Guidewire\n\n<any typekey>.* type Guidewire\n\nGi",
      "ocrWordCount": 118,
      "ocrConfidence": 90.06,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 10,
      "title": "Add schema definitions",
      "bodyParagraphs": [],
      "originalNotes": "Add schema definitions\nCode example — ABContact properties\nLine 8\nDefinition name is defined.\nLines 11,14,18\nScalar properties are defined.\nLine 16\nThe date-time format is used to further define the string type.\nLine 20\nGuidewire custom property is used to define the typekey.\n\nType-specific keywords\nThe type keyword is fundamental to JSON Schema. It specifies the data type for a schema. At its core, JSON Schema defines the following basic types:\nstring\ninteger\nnumeric types\nboolean\nobject\narray\nNull\n\nAbout Nulls\nJSON has three states: non-null, null, and undefined\nAs a general rule, JSON represents null values as undefined properties\nBy default, JSON Schema properties are not nullable\nBy default, on output, null properties on Json Object are omitted\nYou can override this via JsonSerialization in the Swagger schema, but be carefull\nBy drfault, on input explicity-null properties are not allowed\nTo allow this you have to specify “x-gw-nullable”;”true on the property\n\nJSON schema template\n{\n\"Sschema\": \"http://json-\nschema.org/draft-\n04/schema#\",\n\"definitions\": {\n\"<name>\" : {\n\"type\" : \"object\",\n\"properties\" : {\n\"scalarProperty\" : {\n\"type\"\n<string/integer/number/boole an* , l/ Required for scalar properties\n\"format\" : \"<format>\", // Optional format, i.e. date-time or gw-bigdecimal\n\"x-gw-type“ \"typekey. Foo\" l/ For typekeys and currency versus monetary amount\n}\n\"objectProperty\" : {\n\"Sref’\n}\n\"#fdefinitions<Name>\"\n\"arrayProperty\" : {\n\"type\" : \"array\",\n\"items\" : {\n\"type\" : \"<type>\", l/\nFor arrays of scalar values\n“$ref' : \"<ref>\" // For\narrays of objects\n }\n }\n }\n }\n }\n}",
      "notes": "Add schema definitions\nCode example — ABContact properties\nLine 8\nDefinition name is defined.\nLines 11,14,18\nScalar properties are defined.\nLine 16\nThe date-time format is used to further define the string type.\nLine 20\nGuidewire custom property is used to define the typekey.\n\nType-specific keywords\nThe type keyword is fundamental to JSON Schema. It specifies the data type for a schema. At its core, JSON Schema defines the following basic types:\nstring\ninteger\nnumeric types\nboolean\nobject\narray\nNull\n\nAbout Nulls\nJSON has three states: non-null, null, and undefined\nAs a general rule, JSON represents null values as undefined properties\nBy default, JSON Schema properties are not nullable\nBy default, on output, null properties on Json Object are omitted\nYou can override this via JsonSerialization in the Swagger schema, but be carefull\nBy drfault, on input explicity-null properties are not allowed\nTo allow this you have to specify “x-gw-nullable”;”true on the property\n\nJSON schema template\n{\n\"Sschema\": \"http://json-\nschema.org/draft-\n04/schema#\",\n\"definitions\": {\n\"<name>\" : {\n\"type\" : \"object\",\n\"properties\" : {\n\"scalarProperty\" : {\n\"type\"\n<string/integer/number/boole an* , l/ Required for scalar properties\n\"format\" : \"<format>\", // Optional format, i.e. date-time or gw-bigdecimal\n\"x-gw-type“ \"typekey. Foo\" l/ For typekeys and currency versus monetary amount\n}\n\"objectProperty\" : {\n\"Sref’\n}\n\"#fdefinitions<Name>\"\n\"arrayProperty\" : {\n\"type\" : \"array\",\n\"items\" : {\n\"type\" : \"<type>\", l/\nFor arrays of scalar values\n“$ref' : \"<ref>\" // For\narrays of objects\n }\n }\n }\n }\n }\n}",
      "narration": "",
      "ocrText": "| Add schema definitions\n\n* Each definition must\ndefine its name, type,\nand properties\n\n* By default, JSON\nSchema properties are\nnot nullable\n\n* On output, null properties\non JsonObject are omitted\n\nGi\n\n\"$schema\" : \"http: //json-schema.org/draft-04/schema#\",\n\"x-gw-import\" : {\n\n\"address\" : \"trn.ta.address-1.0\",\n\"contactnote\" : \"trn.ta.contactnote-1.0\"\nle\n\"definitions\" : {\n\n\"ContactDetails\" : {\n\"type\" : \"object\",\n\"properties\" : {\n\"Name\" : {\n\"type\" : \"string\"\nlh\n\"DateOfBirth\" : {\n\"type\" : \"string\",\n\"format' \"date-time\"\n\"Gender\" : {\n\"type\" : \"string\",\n\"x-gw-type\" : \"typekey.GenderType\"\n}",
      "ocrWordCount": 84,
      "ocrConfidence": 79.87,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 11,
      "title": "Schema file import",
      "bodyParagraphs": [],
      "originalNotes": "Schema file import\nCode Example — ABContact related properties\nLine 3\nCustom import property to reference other schemas.\nLines 4-5\nSchema aliases and reference paths are defined.\nReference to the imported schema are prefixed with the alias before the # symbol.\nLine 23\nObject property is defined and references the imported schema.\nLine 25\nArray property is defined and references the imported schema.\nImport and combine\n(covered later in the lesson) both provide units of reuse; a code analogy would be that combine is the equivalent of sub-classing a given class, while import is the equivalent of merely referencing that class in arguments or return types.\nImports always exist in a separate logical namespace; if A imports B, definitions in A and Bthat have the same name are still two different types.\nCombines, on the other hand, exist in a single namespace, such that if A combines B, definitions in A that have the same name as definitions in B are combined together to produce a single definition\nFrom the point of view of downstream systems, everything ends up merged together anyway, so the choice between import and combine really comes down to whether you want definitions with the same name to be merged together or not. In cases where you’re logically extending a schema, e.g. creating a customer- specific schema that extends an out of the box schema, you'll want the combination behavior. In cases where you're referencing a shared schema authored by another team for another purpose, you probably don't want that behavior and want to keep the namespaces separate so you don't have to worry about name conflicts producing unexpected results.",
      "notes": "Schema file import\nCode Example — ABContact related properties\nLine 3\nCustom import property to reference other schemas.\nLines 4-5\nSchema aliases and reference paths are defined.\nReference to the imported schema are prefixed with the alias before the # symbol.\nLine 23\nObject property is defined and references the imported schema.\nLine 25\nArray property is defined and references the imported schema.\nImport and combine\n(covered later in the lesson) both provide units of reuse; a code analogy would be that combine is the equivalent of sub-classing a given class, while import is the equivalent of merely referencing that class in arguments or return types.\nImports always exist in a separate logical namespace; if A imports B, definitions in A and Bthat have the same name are still two different types.\nCombines, on the other hand, exist in a single namespace, such that if A combines B, definitions in A that have the same name as definitions in B are combined together to produce a single definition\nFrom the point of view of downstream systems, everything ends up merged together anyway, so the choice between import and combine really comes down to whether you want definitions with the same name to be merged together or not. In cases where you’re logically extending a schema, e.g. creating a customer- specific schema that extends an out of the box schema, you'll want the combination behavior. In cases where you're referencing a shared schema authored by another team for another purpose, you probably don't want that behavior and want to keep the namespaces separate so you don't have to worry about name conflicts producing unexpected results.",
      "narration": "",
      "ocrText": "| Schema file import Gi\n\n* Schema import provides a mechanism for reuse of schemas, by creating a shared\nschema for common pieces and then importing that schema in order to reference\nits types\n\n• If Aimports B, definitions in A and B that have the same name are still two different types\n\n1 {\n\"$schema\" : \"http://json-schema.org/draft-04/schema#\",\n—> \"x-gw-import\" : {\n4 \"address\" : \"trn.ta.address-1.0\",\ns \"contactnote” : \"trn.ta.contactnote-1.0\"\n\nhe\n\n2 \"PrimaryAddress\" : {\n—p>: \"$ref\" : \"address#/definitions/AddressDetails”\n\n—>:",
      "ocrWordCount": 80,
      "ocrConfidence": 86.33,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 12,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 95.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 13,
      "title": "Create a mapping file",
      "bodyParagraphs": [],
      "originalNotes": "Create a mapping file\nCode example\nLine 2\nSchema used by the mapper file.\nLine 3\nImport other mapper files.\nLine 7\nDefine each mapper name under mappers.\n\nJust like schema files, mapping files are also named and versioned, and target a specific schema versiom",
      "notes": "Create a mapping file\nCode example\nLine 2\nSchema used by the mapper file.\nLine 3\nImport other mapper files.\nLine 7\nDefine each mapper name under mappers.\n\nJust like schema files, mapping files are also named and versioned, and target a specific schema versiom",
      "narration": "",
      "ocrText": "| Create a mapping file\n\n* Create a new package under integration.mappings\n\nGi\n\n* config.integration.mappings .<company_code>.<product_code>\n\n* Create a new file with the following syntax:\n\n* <mechanism>-{version}.mapping. json\n\n4} contact-1.0.mapping,json |\n\n=>\n>\n\ni\n\n\"schemaName\" : \"trn.ta.contact-1.0\",\n\"import\" : {\n\"address\" : \"trn.ta.address-1.0\",\n\n\"contactnote\" : \"trn.ta.contactnote-1.\n\nje\n\"mappers\" : {...}\n\nv\n\ntrn.ta\n4) address-1.0.mapping,json\n4) contact-1.0.mapping,json\n4) contactnote-1.0.mapping,json",
      "ocrWordCount": 58,
      "ocrConfidence": 80.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 14,
      "title": "Add mappers to the mapping file",
      "bodyParagraphs": [],
      "originalNotes": "Add mappers to the mapping file\nCode example\nLine 8\nMapper name is defined.\nLine 9\nSchema name reference.\nLine 10\nFully qualified class name where the data comes from.\nLines 12,15,19\nScalar properties are defined.\nLine 21\nPredicate property is evaluated before the path expression is evaluated.\nLine 23\nObject property is defined and its corresponding mapper.\nLine 27\nArray property is defined and its corresponding mapper.\n\npath\nEach mapping property must specify a \"path\" expression, which is a Gosu expression that evaluates to the value that should be used as the output of that schema property. The path expression has a single symbol available to it, with a type equal to the mapper's root type and a name equal to the relative name of that type. For example, if the root type for the mapper is entity-Contact, the path expressions on the mapper's properties will have a single symbol named Contact with a type of entity-Contact The path expression must evaluate to something appropriate for the referenced schema property:\nIf the schema property is a scalar property, the path expression must evaluate to something listed as a \"Java Input Type\", based on the schema property’s typefformat/x-gw-type- For example, if the schema type is \"string\" and the format is \"date-time,\" the \"path\" expression must evaluate to something assignable to java.util-Date\nIf the schema property is an array of scalars, the path expression must evaluate to an Iterable or array whose elements can be inputs to the data conversion for the type of the schema property’s items\nIf the schema property is an object property, then the \"mapper\" property must be specified, and the path expression's returntype must be assigned to the root type of the referenced mapper. For example, if the referenced mapper is address#/mappers/Address and the Address mapper has a root type of entity. Address , the path expression must evaluate to an entity-Address or subtype there of\nIf the schema property is an object array property, then the mapper property must be specified, and the path expression must evaluate to an Iterable or array whose elements can be assigned to the root type of the referenced mapper\n\nThere's no automatic coercion performed for path expressions; that means that if a schema property is of type \"string\" with no format o x-gw-type, the Gosu expression must actually evaluate to a java.lang. String, with no implicit invocation of toString or anything similar. The path expression can be an arbitrary Gosu expression, so there's no restriction that it be a simple property path: it could also be a method call or static method call or other complex expression.\n\npredicate\nThe predicate property is an optional boolean (or Boolean) predicate that will be evaluated before the path expression is evaluated- The \"predicate\" property ca return a java.lang. Boolean, but should never return null at runtime. If the predicate expression evaluates to false, the path expression will never be evaluated, and the property will be treated as having a null value. The predicate expression can be used to guard the evaluation can be useful if the output schema flattens subtype columns onto a single object. For example, the output schema for Contact may define properties firstName and lastName; in that case, the predicate expression might be Contact typeis Person and the path expression could be (Contact as Person).FirstName. Using the predicate expression in this way allows the path expression to downcast directly instead of using a more awkward ternary expression, i.e. \"Contact typeis Person ? (Contact as Person).FirstName : null\".\n\nMapper\nThe mapper property definesthe mapper to use when the schema property is an object or array of objects. Mapper references use a similar syntax to schema property references, and are either of the form #/mappers/<name> when the referenced mapper is defined in the samemapping, or <alias>#/mappers/<name>\nwhen the mapper is in the mapping imported as <alias>- The referenced mapper must have a schemaDefinition property that matches the Sref on the schema property. For example, suppose that the Contact JSON Schema definition has a primaryAddress schema property with a Sref of address#/definitions/Address.\nIn that case, the primaryAddress property on the Contact Integration Mapper should have a mapper import reference schemaDefinition as address.",
      "notes": "Add mappers to the mapping file\nCode example\nLine 8\nMapper name is defined.\nLine 9\nSchema name reference.\nLine 10\nFully qualified class name where the data comes from.\nLines 12,15,19\nScalar properties are defined.\nLine 21\nPredicate property is evaluated before the path expression is evaluated.\nLine 23\nObject property is defined and its corresponding mapper.\nLine 27\nArray property is defined and its corresponding mapper.\n\npath\nEach mapping property must specify a \"path\" expression, which is a Gosu expression that evaluates to the value that should be used as the output of that schema property. The path expression has a single symbol available to it, with a type equal to the mapper's root type and a name equal to the relative name of that type. For example, if the root type for the mapper is entity-Contact, the path expressions on the mapper's properties will have a single symbol named Contact with a type of entity-Contact The path expression must evaluate to something appropriate for the referenced schema property:\nIf the schema property is a scalar property, the path expression must evaluate to something listed as a \"Java Input Type\", based on the schema property’s typefformat/x-gw-type- For example, if the schema type is \"string\" and the format is \"date-time,\" the \"path\" expression must evaluate to something assignable to java.util-Date\nIf the schema property is an array of scalars, the path expression must evaluate to an Iterable or array whose elements can be inputs to the data conversion for the type of the schema property’s items\nIf the schema property is an object property, then the \"mapper\" property must be specified, and the path expression's returntype must be assigned to the root type of the referenced mapper. For example, if the referenced mapper is address#/mappers/Address and the Address mapper has a root type of entity. Address , the path expression must evaluate to an entity-Address or subtype there of\nIf the schema property is an object array property, then the mapper property must be specified, and the path expression must evaluate to an Iterable or array whose elements can be assigned to the root type of the referenced mapper\n\nThere's no automatic coercion performed for path expressions; that means that if a schema property is of type \"string\" with no format o x-gw-type, the Gosu expression must actually evaluate to a java.lang. String, with no implicit invocation of toString or anything similar. The path expression can be an arbitrary Gosu expression, so there's no restriction that it be a simple property path: it could also be a method call or static method call or other complex expression.\n\npredicate\nThe predicate property is an optional boolean (or Boolean) predicate that will be evaluated before the path expression is evaluated- The \"predicate\" property ca return a java.lang. Boolean, but should never return null at runtime. If the predicate expression evaluates to false, the path expression will never be evaluated, and the property will be treated as having a null value. The predicate expression can be used to guard the evaluation can be useful if the output schema flattens subtype columns onto a single object. For example, the output schema for Contact may define properties firstName and lastName; in that case, the predicate expression might be Contact typeis Person and the path expression could be (Contact as Person).FirstName. Using the predicate expression in this way allows the path expression to downcast directly instead of using a more awkward ternary expression, i.e. \"Contact typeis Person ? (Contact as Person).FirstName : null\".\n\nMapper\nThe mapper property definesthe mapper to use when the schema property is an object or array of objects. Mapper references use a similar syntax to schema property references, and are either of the form #/mappers/<name> when the referenced mapper is defined in the samemapping, or <alias>#/mappers/<name>\nwhen the mapper is in the mapping imported as <alias>- The referenced mapper must have a schemaDefinition property that matches the Sref on the schema property. For example, suppose that the Contact JSON Schema definition has a primaryAddress schema property with a Sref of address#/definitions/Address.\nIn that case, the primaryAddress property on the Contact Integration Mapper should have a mapper import reference schemaDefinition as address.",
      "narration": "",
      "ocrText": "| Add mappers to the mapping file\n\nEach mapper must\ndefine its:\n\nName\nschemaDefinition\nroot\n\nproperties\n\n+ The properties on an\nintegration mapper must\ncorrespond to properties\non the associated JSON\nschema definition\n\n+ Define how to get the value\nfor that property\n\n—pP27\n\n\"mappers\" : {\n\"ContactDetails” : {\n\"schemaDefinition\" : \"ContactDetails\",\n\"root\" : \"entity.ABContact\",\n\"properties\" : {\n\n“ABContact.DisplayName\"\n\n\"DateOfBirth” : {\n\"path\" : \"(ABContact as ABPerson) .DateOfBirth”,\n\"predicate\" : \"ABContact typeis ABPerson”\n\n(ABContact as ABPerson) .Gender\",\n\"predicate\" : \"ABContact typeis ABPerson\"\n\nye\n\n\"PrimaryAddress\": {\n\"path\" : \"ABContact.PrimaryAddress\",\n\"mapper\" : \"address#/mappers/AddressDetails\"\n\nMe\n\n\"ContactNotes\" : {\n\n\"ABContact.ContactNotes\",\n\n+ \"contactnote#/mappers/ContactNloteDetails\"",
      "ocrWordCount": 99,
      "ocrConfidence": 80.52,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 15,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 95.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 16,
      "title": "Filters",
      "bodyParagraphs": [],
      "originalNotes": "Filters\nIt's often the case that two different external systems need substantially similar views of the same data, but not exactly the same thing. This could be two different downstream systems that both need policy information, but which might need different levels of detail about coverage options or transaction data, or it could be two different client systems that want to display a different subset of the data to their end-users. A developer putting together an integration message or building a REST API thus has to decide if they want to create a single schema that represents the superset of data that all such systems might want, or if they should create separate, more targeted schemas that only contain exactly what a particular system or use case requires- Having a single shared schema reduces implementation and maintenance costs, potentially dramatically, but comes at the cost of fetching, processing, and serializing out data that a given client is simply going to ignore. The Integration Views feature attempts to meet these competing needs by allowing you to specify a filter that gets applied to a schema and mapping file, which serves as a whitelist of the properties that should be included for a given invocation of a mapping file. Properties that are not\nincluded as part of a given filter never have their associated path or predicate expressions executed and will not end up in the resulting TransformResult object at all, saving the cost of fetching, processing, and serializing the associated data. Filters can also be used to create a stable \"view\" on top of a given schema; by whitelisting the properties desired, newly-added properties will never show up unless the filter is explicitly changed.\n\nDifferences from GraphQL Proper\nWhile our filter syntax leverages the basics of GraphQL for the syntax of basic field selection, nested objects/arrays, and fragments, it differs from GraphQL proper in some important ways:\nThere's no query operation, the query operation is always implied\nNo mutations are supported\nNone of our fields accept arguments\nFields cannot be aliased to change the result property's name\nOur GraphQL syntax allows for using the original unicode name of a schema property, rather than restricting everything to a limited ASCII subset\n\nSee https://graphql.org/ and http:/ffacebook.github.io/grap hql/October2016/ for more details about the specification-",
      "notes": "Filters\nIt's often the case that two different external systems need substantially similar views of the same data, but not exactly the same thing. This could be two different downstream systems that both need policy information, but which might need different levels of detail about coverage options or transaction data, or it could be two different client systems that want to display a different subset of the data to their end-users. A developer putting together an integration message or building a REST API thus has to decide if they want to create a single schema that represents the superset of data that all such systems might want, or if they should create separate, more targeted schemas that only contain exactly what a particular system or use case requires- Having a single shared schema reduces implementation and maintenance costs, potentially dramatically, but comes at the cost of fetching, processing, and serializing out data that a given client is simply going to ignore. The Integration Views feature attempts to meet these competing needs by allowing you to specify a filter that gets applied to a schema and mapping file, which serves as a whitelist of the properties that should be included for a given invocation of a mapping file. Properties that are not\nincluded as part of a given filter never have their associated path or predicate expressions executed and will not end up in the resulting TransformResult object at all, saving the cost of fetching, processing, and serializing the associated data. Filters can also be used to create a stable \"view\" on top of a given schema; by whitelisting the properties desired, newly-added properties will never show up unless the filter is explicitly changed.\n\nDifferences from GraphQL Proper\nWhile our filter syntax leverages the basics of GraphQL for the syntax of basic field selection, nested objects/arrays, and fragments, it differs from GraphQL proper in some important ways:\nThere's no query operation, the query operation is always implied\nNo mutations are supported\nNone of our fields accept arguments\nFields cannot be aliased to change the result property's name\nOur GraphQL syntax allows for using the original unicode name of a schema property, rather than restricting everything to a limited ASCII subset\n\nSee https://graphql.org/ and http:/ffacebook.github.io/grap hql/October2016/ for more details about the specification-",
      "narration": "",
      "ocrText": "| Filters G\n\n+ Filters make use of a simplified version : ! =\nof GraphQL syntax to describe the sch » pong « Pama\ndata to be fetched\n\n5 4\n\n* Serves as a whitelist of the properties that\n\nshould be included for a given invocation of\na mapping file\n\n• Allows reuse of a more complete\nf a\nschema/mapping for use cases that\nonly require a subset of that data aS\n\n+ Reduces implementation and maintenance « secuoseireht + saoso-a2-oer04;00100,0008\",\ncosts “Gender” : \"M\",\n\nName\" : \"William Andy\",\n\"PrimaryAddress™ : {\n\"AddressType” : “home”\n}\niB",
      "ocrWordCount": 98,
      "ocrConfidence": 82.49,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 17,
      "title": "Create a filter",
      "bodyParagraphs": [],
      "originalNotes": "Create a filter\nCode example 1 — exclude contact notes\nLines 2-4\nProperties to include from the Contact object.\nLine 6\nProperty to include from the address object.\nCode example 2 — only contact notes\nLines 3-6\nProperties to include from the contactNotes array object.\n\nA filter is a simple declarative whitelist — just type the properties that you want to export.",
      "notes": "Create a filter\nCode example 1 — exclude contact notes\nLines 2-4\nProperties to include from the Contact object.\nLine 6\nProperty to include from the address object.\nCode example 2 — only contact notes\nLines 3-6\nProperties to include from the contactNotes array object.\n\nA filter is a simple declarative whitelist — just type the properties that you want to export.",
      "narration": "",
      "ocrText": "| Create a filter Gi\n\n* Create a new package under integration.filters\n* config.integration.filters.<company_code>.<product_code>\n\n* Create a new file with the following syntax:\naddress_minimal-1.0.gql\n\ncontact_details-1.0.gql\n\ncontactnote_details-1.0.gql\n\n« <mechanism>-{version}.gql\n\n@ contact_details-1.0.gql * | 2 contactnote_details-1.0.9q1\ni TE\nName, 2 ContactNotes {\nDateOfBirth, 3 ContactNoteType,\nGender, 4 Confidential,\nPrimaryAddress { s Subject,\n> • AddressType Body\n\n} }\n\nil Eee |",
      "ocrWordCount": 59,
      "ocrConfidence": 76.29,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 18,
      "title": "Fragments",
      "bodyParagraphs": [],
      "originalNotes": "Fragments\nCode example\nLine 2\nReferencing PrimaryAddress properties to include using the addressParts fragment.\nLine 5\nReferencing AllAddresses properties to include using the addressParts fragment.\nLine 9\naddressParts fragment defined.",
      "notes": "Fragments\nCode example\nLine 2\nReferencing PrimaryAddress properties to include using the addressParts fragment.\nLine 5\nReferencing AllAddresses properties to include using the addressParts fragment.\nLine 9\naddressParts fragment defined.",
      "narration": "",
      "ocrText": "| Fragments Gi\n\n•« AGraphQL feature that allow you to  adddress_rninimal- 1.0.94)\nquery a fragment that can be applied —! «  cetmarynadvesst\nto a given object | ++-addressParts\n• Useful in cases where the same sub-object —>: panacea. arts\ntype appears within multiple places in the ,\ndata you want to fetch 8 }\n—> fragment addressParts on Address {\n* For example, a Contact may have both AddressType\nPrimaryAddress and AllAddresses cael\nproperties that map to the same Address }\ntype\n\n+ Define the set of properties you want from an\nAddress once, as a fragment\n\n+ Reference that fragment in each context that\nyou want that same set of properties",
      "ocrWordCount": 112,
      "ocrConfidence": 87.88,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 19,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 95.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 20,
      "title": "Generate wrapper classes",
      "bodyParagraphs": [],
      "originalNotes": "Generate wrapper classes\nThe codegen-schema.txt file defines what schemas the JsonSchemaCodegen will process.\nClient-side errors (bad types, unknown properties, constraint violations) are detected at parse time and reported. Parsing, deserialization, and validation are done in a single step.\nServer-side errors (i.e. bad output) will be (optionally) detected during serialization.\n\nThe framework works in terms of a JsonObject, which is basically just a Map<String, Object>\n JsonObject contains deserialized scalars and objects, i.e. Date, BigDecimal and typekeys, not just javascript primitives\nLists are used for JSON arrays\n\nWrapper classes\nOptionally generated statically-typed classes can wrap the JsonObject\nThe framework layers on statically-typed getters and setters\nThe framework knows how to automatically wrap/unwrap them\nWrap a JsonObject with the static wrap method\nUnwrap it back with the instance –unwrap method\nYou can also parse directly into the wrapper classes via static parse methods.\n\nWrapper classes can also be generated by running gwb jsonSchemaCodegen in a command prompt window.\nHow to configure Json Schema Codegen server in Studio\n1. In Studio, click Run Edit Configuration\n2. Select Server and click Copy Configuration icon\n3. Modify the Name and Main class fields\nName = JsonSchemaCodegen\nMain class = com-guidewire.tools.js on. JsonSchemaWrap perCodegenTool",
      "notes": "Generate wrapper classes\nThe codegen-schema.txt file defines what schemas the JsonSchemaCodegen will process.\nClient-side errors (bad types, unknown properties, constraint violations) are detected at parse time and reported. Parsing, deserialization, and validation are done in a single step.\nServer-side errors (i.e. bad output) will be (optionally) detected during serialization.\n\nThe framework works in terms of a JsonObject, which is basically just a Map<String, Object>\n JsonObject contains deserialized scalars and objects, i.e. Date, BigDecimal and typekeys, not just javascript primitives\nLists are used for JSON arrays\n\nWrapper classes\nOptionally generated statically-typed classes can wrap the JsonObject\nThe framework layers on statically-typed getters and setters\nThe framework knows how to automatically wrap/unwrap them\nWrap a JsonObject with the static wrap method\nUnwrap it back with the instance –unwrap method\nYou can also parse directly into the wrapper classes via static parse methods.\n\nWrapper classes can also be generated by running gwb jsonSchemaCodegen in a command prompt window.\nHow to configure Json Schema Codegen server in Studio\n1. In Studio, click Run Edit Configuration\n2. Select Server and click Copy Configuration icon\n3. Modify the Name and Main class fields\nName = JsonSchemaCodegen\nMain class = com-guidewire.tools.js on. JsonSchemaWrap perCodegenTool",
      "narration": "",
      "ocrText": "| Generate wrapper classes\n\n1. Add the fully-qualified name of the\nschema(s) in the codegen-\n\nschemas.txt file in schemas package\n\n2. From the Server drop-down in Studio,\nselect JsonSchemaCodegen\n\n* Execute by selecting Run ‘Server’ icon\n\n3. Generated wrapper classes will be\nunder\n\nconfiguration.srce.jsonschema\n\nGi\n\ntrn.ta.contact-1.0\ntrn.ta.contactnote-1.0\ntrn.ta.address-1.0\n\n2 codegen-schemas.tt\n\nBuild Run Tools VCS Wind:\n\n[i> Edit Configurations...\n(B TestServer\n\n[B Dropps\n\n[Server\n\nj=) JsonSchemaCodegen\n\nv Biljsonschema\n> Bil sita.contactv1_0\nv Bitmte\n\nv Ei address.vi_0\n© AddressDetails\nv Bai contactv1_0\n© ContactDetails\n© ContactUpdate\nv Emi contactnotev1_0\n© ContactNoteDetails",
      "ocrWordCount": 89,
      "ocrConfidence": 77.96,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 21,
      "title": "Example 1 — JSON Output",
      "bodyParagraphs": [],
      "originalNotes": "Example 1 — JSON Output\nCode example\nLine 10\nCreate the JsonMapper object.\nDefine the fully qualified path to the mapper file.\nDefine the mapper name.\nLine 12\nCreate the TransformResult object.\nLine 14\nCreate the JSON payload.\ntoPrettyJsonString formats the output in multiple rows.\n\n JsonMapper\nThe JsonMapper interface provides runtime access to actually execute the mapper. The general way to obtain a JsonMapper instance is by using the JsonConfigAccess class to get a handle to the JsonMapping- Once you have access to a JsonMapper instance, you can then invoke one of the transformObject or transformObjects method variants to obtain a TransformResult object.\nTransform Result\nThe TransformResult object represents the results of completed transform call: it contains the result of executing each of the path expressions against the supplied root object. The TransformResult is an intermediate representation of the data that can then be serialized out to either JSON or XML. The TransformResult object is similar to JsonObject, in that it's mainly a map of property names to values, but it differs in that each property value embeds information about the JSON Schema property it represents. Serializing out a JsonObject requires passing the JSON Schema definitionin as an argument during serialization, whereas the TransformResult has schema information already embedded in it and always serializes based on that schema. So you can just invoke methods like toPrettyJsonString or toXmlString directly.\n\nSerialization Options The various serialization methods on TransformResult objects can take an optional JsonSerializationOptions object, which controls aspects of how the serialization works. By default, serializing a TransformResult will ignore null properties, null list items, and empty arrays. (Note that this last default is different from default JsonObject serialization. The reason is that entity arrays are never null, and mappings will often be used with entities.) You can use the JsonSerializationOptions to change that serializationbehavior, though note that including null properties or elements will require that the associated JSON Schema properties or items be marked as x-gw-nullable. The JsonSerializationOptions can also be used to include some special properties on the root object when the data is serialized, for example the fully-qualified name of the schema definition, the correlation ID of the current request (if any), or the timestamp at which the transform was executed. These options are only valid for serialization to JSON. See the javadoc on JsonSerializationOptions for more details.\n\nUsage in REST In REST API implementations, a TransformResult can be returned directly by a handler method or embedded as the\nentity in a Response object. There's no need to explicitly call any of the serialization methods like toJsonString; the REST API Framework itself will serialize the TransformResult appropriately based on the negotiated content type of the response.",
      "notes": "Example 1 — JSON Output\nCode example\nLine 10\nCreate the JsonMapper object.\nDefine the fully qualified path to the mapper file.\nDefine the mapper name.\nLine 12\nCreate the TransformResult object.\nLine 14\nCreate the JSON payload.\ntoPrettyJsonString formats the output in multiple rows.\n\n JsonMapper\nThe JsonMapper interface provides runtime access to actually execute the mapper. The general way to obtain a JsonMapper instance is by using the JsonConfigAccess class to get a handle to the JsonMapping- Once you have access to a JsonMapper instance, you can then invoke one of the transformObject or transformObjects method variants to obtain a TransformResult object.\nTransform Result\nThe TransformResult object represents the results of completed transform call: it contains the result of executing each of the path expressions against the supplied root object. The TransformResult is an intermediate representation of the data that can then be serialized out to either JSON or XML. The TransformResult object is similar to JsonObject, in that it's mainly a map of property names to values, but it differs in that each property value embeds information about the JSON Schema property it represents. Serializing out a JsonObject requires passing the JSON Schema definitionin as an argument during serialization, whereas the TransformResult has schema information already embedded in it and always serializes based on that schema. So you can just invoke methods like toPrettyJsonString or toXmlString directly.\n\nSerialization Options The various serialization methods on TransformResult objects can take an optional JsonSerializationOptions object, which controls aspects of how the serialization works. By default, serializing a TransformResult will ignore null properties, null list items, and empty arrays. (Note that this last default is different from default JsonObject serialization. The reason is that entity arrays are never null, and mappings will often be used with entities.) You can use the JsonSerializationOptions to change that serializationbehavior, though note that including null properties or elements will require that the associated JSON Schema properties or items be marked as x-gw-nullable. The JsonSerializationOptions can also be used to include some special properties on the root object when the data is serialized, for example the fully-qualified name of the schema definition, the correlation ID of the current request (if any), or the timestamp at which the transform was executed. These options are only valid for serialization to JSON. See the javadoc on JsonSerializationOptions for more details.\n\nUsage in REST In REST API implementations, a TransformResult can be returned directly by a handler method or embedded as the\nentity in a Response object. There's no need to explicitly call any of the serialization methods like toJsonString; the REST API Framework itself will serialize the TransformResult appropriately based on the negotiated content type of the response.",
      "narration": "",
      "ocrText": "| Example 1 — JSON Output\n\nDIR KH ewNP\n\n3\n\nuses gw.api.database.Query\nuses gw.api.database.Relop\nuses gw.api.json.JsonConfigAccess\n\n// Query for Contact\n\nvar queryObj = Query.make (ABContact)\nPublicID, Relop. Equals, \"ab:5\")\n\nqueryObj.. compare (\nvar targetObj =\n// Create IsonMapper object\n\n“Contactliotes™ : [ {\n“Body” : “William Andy has more questions related to data privacy\",\n“ContactiioteType” : “general”,\n“Subject” : “William Andy has an inguiry™ iy |\net\n\"Body\" : “William Andy has many general questions\",\n“ContactNotelype” : “general”,\n“Subject” : “William Andy has questions”\ndie\n“DaceogBirth™\n“Gender” : “M\",\n“Name” : \"William Andy\",\n“Primaryaddress” : {\nvaddressLinel” : \"345 Fir Lane,\nvAddressType” : \"hone\",\n\"City\" : “La Canada”,\n“PostalCode” : \"91352\",\n“State” : \"CAT\n\n'1980~08-06T04:00:00.0002\",\n\nvar jsonMapper = JsonConfigAccess.getMapper(\"trn.ta.contact-1.0\", \"ContactDetails\")\n\n// Create TransformResult object\n\nvar transformResult = jsonMapper.transform0bject (targetObj)\n\n// Create outpul\n\nvar payloadJSON = transformResult.toPrettyJsonString()\n\nprint (payloadJSON)",
      "ocrWordCount": 138,
      "ocrConfidence": 76.86,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 22,
      "title": "Example 2 — XML Output",
      "bodyParagraphs": [],
      "originalNotes": "Example 2 — XML Output\nCode example\nLine 14\nCreate XML payload\nXML Output\nThe JsonObject and TransformResult classes both support serialization to XML rather than serialization to JSON. In both cases, exactly the same serialization and validation rules apply to serializing out to XML as to JSON, it's merely the output format that differs.\nTo serialize a JsonObject to XML, invoke one of the toXmlElement methods and then serialize the XmlElement as desired\nTo serialize a TransformResult to XML, invoke one of the toXmlElement methods and then serialize the XmlElement as desired, or call one of the toXmlStringconvenience method.\nIn addition, if a TransformResult or JsonObject is returned from a REST API handler, the REST API Framework willautomatically serialize the data to XML if the negotiated content type is \"application/xml\" or \"text/xml\"-\n\nX SD Translation\nThe XML that is output from serializing a JsonObject with a schema, or TransformResult (which always has a schema), will conform to the XSD that is produced as a transformation on the JSON Schema. In general, the translation to an XSD follows the following rules:\nThe generated XSD will have a single namespace of\nhttp://guidewire.com/xsd /<schema-fqn> by default; this can be overridden by specifying the x-gw-xml property on the root of the JSON Schema, and setting the namespace attribute\nAll JSON Schema definitions are translated into XSD complexTypes as well as top-level elements that reference those types, i.e. any such element is a legal\ndocument root\nBy default, definition properties are mapped to sub-elements rather than attributes, unless the schema property specifies the x-gw-xml element andsets the attribute property on it to true\nProperties under anelement will be unordered in the XML, and given an xs:all in the XSD ratherthan an xs:sequence\nThe element or attribute name for a property name will have the same name in an XSD as the JSON Schema property, but will the name will be adjusted if it is not a legal XML element or attribute name\n Arrays will always be wrapped in a container element, with individual elements of the array wrapped in elements. The item elements will default to having a name based on the referenced object definition (if the elements are objects) or have the same name as thecontaining property (if the elements are scalars). The x-gw-xml element can be specified on the items and given a name property to explicitly name the child elements\nJSON data types will map to equivalent XSD data types, when available Validation constraints like minLength or maxLengthon the property will be reproduced in the XSD where possible\nA schema definition that contains additionalProperties will be mapped into an XSD if no explicitly-named properties are defined on the definition, but will be represented as an xs:any if additionalProperties is mixed with explicitly- named elements.",
      "notes": "Example 2 — XML Output\nCode example\nLine 14\nCreate XML payload\nXML Output\nThe JsonObject and TransformResult classes both support serialization to XML rather than serialization to JSON. In both cases, exactly the same serialization and validation rules apply to serializing out to XML as to JSON, it's merely the output format that differs.\nTo serialize a JsonObject to XML, invoke one of the toXmlElement methods and then serialize the XmlElement as desired\nTo serialize a TransformResult to XML, invoke one of the toXmlElement methods and then serialize the XmlElement as desired, or call one of the toXmlStringconvenience method.\nIn addition, if a TransformResult or JsonObject is returned from a REST API handler, the REST API Framework willautomatically serialize the data to XML if the negotiated content type is \"application/xml\" or \"text/xml\"-\n\nX SD Translation\nThe XML that is output from serializing a JsonObject with a schema, or TransformResult (which always has a schema), will conform to the XSD that is produced as a transformation on the JSON Schema. In general, the translation to an XSD follows the following rules:\nThe generated XSD will have a single namespace of\nhttp://guidewire.com/xsd /<schema-fqn> by default; this can be overridden by specifying the x-gw-xml property on the root of the JSON Schema, and setting the namespace attribute\nAll JSON Schema definitions are translated into XSD complexTypes as well as top-level elements that reference those types, i.e. any such element is a legal\ndocument root\nBy default, definition properties are mapped to sub-elements rather than attributes, unless the schema property specifies the x-gw-xml element andsets the attribute property on it to true\nProperties under anelement will be unordered in the XML, and given an xs:all in the XSD ratherthan an xs:sequence\nThe element or attribute name for a property name will have the same name in an XSD as the JSON Schema property, but will the name will be adjusted if it is not a legal XML element or attribute name\n Arrays will always be wrapped in a container element, with individual elements of the array wrapped in elements. The item elements will default to having a name based on the referenced object definition (if the elements are objects) or have the same name as thecontaining property (if the elements are scalars). The x-gw-xml element can be specified on the items and given a name property to explicitly name the child elements\nJSON data types will map to equivalent XSD data types, when available Validation constraints like minLength or maxLengthon the property will be reproduced in the XSD where possible\nA schema definition that contains additionalProperties will be mapped into an XSD if no explicitly-named properties are defined on the definition, but will be represented as an xs:any if additionalProperties is mixed with explicitly- named elements.",
      "narration": "",
      "ocrText": "Example 2 — XML Output\n\nOptionally generate XSD\n\n+ Execute gwb genExternalSchemas in command prompt window\n+ Default output directory\n\n<app>\\modules\\configuration\\build\\external-schemas\n\n13\n—> 16\n\nas\n\nvar payloadXML = transformResult.toxmlString()\nprint (payloadXML)\n\n‘ceontactloreDetatla>\n‘eboappaitiiam Andy as many gteerel questionsc/B0ay>\n‘Ccontactictetypengeseraic/Coneactictetype>\n\n‘cSunyeceowillian Rody hav queationsc/Subyect>\n“/fontactionedetasia>\n\n‘entacetotebetatla>\n‘cboapWiiiam Andy has discovered « serious data entry semvec/Bodi>\n‘ContactioceTypenproblenc/ContactioteType>\n\n‘chubyeceo¥Willian Rady reported an iamvec/Subyect>\n“/Contacetotedetaiia>\n\n‘GlaneDWil tam Aadyc/tane>\n\n‘cinta Canancreiey>\n‘cSeavercnc/seate>\ncyreinaryaaaress>\n<fecanannenation\n\nGi\n\ncontactnote XSD\n\nant contact dachema\n\nPom versie\n\n‘argwtianespacen\"ntp://guldevire.com/esd/tentacontactnote 1.0\"\n\nclesertrorsbefantte\"qalstsea\"",
      "ocrWordCount": 80,
      "ocrConfidence": 69.07,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 23,
      "title": "Example 3 — Filtered JSON output",
      "bodyParagraphs": [],
      "originalNotes": "Example 3 — Filtered JSON output\nCode example\nLine 13\nCreate the JsonMappingOptions object.\nLine 14\nAdd the filter fully qualified path.\nLine 16\nCreate the TransformResult object with filter applied.\nOutput\nOnly filtered fields are exported.\n\nJsonMappingOptions\nThe transformObject methods can optionally take a JsonMappingOptions object that can change some aspects of how the transform is performed. The JsonMappingOptions object is the mechanism for applying a GraphQL filter to the mapping.",
      "notes": "Example 3 — Filtered JSON output\nCode example\nLine 13\nCreate the JsonMappingOptions object.\nLine 14\nAdd the filter fully qualified path.\nLine 16\nCreate the TransformResult object with filter applied.\nOutput\nOnly filtered fields are exported.\n\nJsonMappingOptions\nThe transformObject methods can optionally take a JsonMappingOptions object that can change some aspects of how the transform is performed. The JsonMappingOptions object is the mechanism for applying a GraphQL filter to the mapping.",
      "narration": "",
      "ocrText": "| Example 3 — Filtered JSON output G\n\n2 uses gw.api.database.Query\n\n2 uses gw.api.database.Relop\n\n3 uses gw.api.json.JsonConfighccess\n\n4 uses gw.api.json.mapping. JsonMappingOptions\nG // Query for Contact\n\nvar queryObj = Query.make(ABContact)\n\n// Create JsonMapper object\nvar jsonMapper = JsonConfigAccess.getMapper(\"trn.ta.contact-1.0\", \"ContactDetails\")\n\n// Create JsonMappingOptions object\n\nvar mappingOpts = new JsonMappingOptions()\nmappingOpts.withFilter(\"trn.ta.contact_details-1.0\"\n\n// Create TransformResult object\n\nvar transformResult = jsonMapper.transformObject (targetOb3, mappingOpts)\n\n// Create output\n\nvar payloadJSON = transformResult.toPrettyJsonString()\n\nprint (payloadJSON) {\n\n“DateOfBirth” : \"1980-08-06T04:00:00.0002\",\n\"Gender\" : \"M\",\n\"Name\" : \"William Andy\",\n\"PrimaryAddress” : {\n“AddressType\" : “home”",
      "ocrWordCount": 85,
      "ocrConfidence": 82.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 24,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 95.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 25,
      "title": "Schema file combination",
      "bodyParagraphs": [],
      "originalNotes": "Schema file combination\nCode example — Succeed Insurance is extending the TrainingApp contact schema\nLine 3\nCustom combine property used to combine contact schemas.\nLines 10,15\nNew object property is defined and its corresponding definition.\n\nComposition for Swagger schemas, JSON schemas, and Integration Mappings all\nworks similarly. The combination mechanism for Swagger schemas allows for creating Swagger schemas that combine together multiple pieces to form asingle, logical resulting schema document. The combination mechanism can be used for a number of different purposes:\nSimple hierarchical extension — Customers can extend an application schema, which in turnmight extend a platform schema.\nContent composition — Customers might combine together several different content pieces, for example LOB-specific schemas (Line-Of- Business), along with their own extensions and perhaps a base schema, i.e. customer extensions + Personal Auto LOB + Business Owner Policy LOB + base policy schema.\nSchema file combination Schema aggregation – A large, complex schema can be broken into multiple files that are maintained by different teams, and then aggregated together for publishing as a single logical API with a single, consistent baselJrl and version.\n Minor version changes — A new minor version of a schema can use combination to extend the previous major or minor version, minimizing schema duplication and ensuring the changes are backwards-compatible.\nAPI templates — The API template mechanism implicitly works via combination, by implicitly adding the template to the list of combined schemas for a given published schema.\n\nCombination Ordering\n The combination mechanismallows for theoretically arbitrary chains of combination, though the combinations must not have any cycles in the graph, i.e. you can't have A combine B, B combine C, and C combine A. Schemas are combined in the order they appear in the x-gw-combine property, and referenced schemas are themselves loaded and combined before processing. To make that more concrete,suppose we designate Schema A to mean the file",
      "notes": "Schema file combination\nCode example — Succeed Insurance is extending the TrainingApp contact schema\nLine 3\nCustom combine property used to combine contact schemas.\nLines 10,15\nNew object property is defined and its corresponding definition.\n\nComposition for Swagger schemas, JSON schemas, and Integration Mappings all\nworks similarly. The combination mechanism for Swagger schemas allows for creating Swagger schemas that combine together multiple pieces to form asingle, logical resulting schema document. The combination mechanism can be used for a number of different purposes:\nSimple hierarchical extension — Customers can extend an application schema, which in turnmight extend a platform schema.\nContent composition — Customers might combine together several different content pieces, for example LOB-specific schemas (Line-Of- Business), along with their own extensions and perhaps a base schema, i.e. customer extensions + Personal Auto LOB + Business Owner Policy LOB + base policy schema.\nSchema file combination Schema aggregation – A large, complex schema can be broken into multiple files that are maintained by different teams, and then aggregated together for publishing as a single logical API with a single, consistent baselJrl and version.\n Minor version changes — A new minor version of a schema can use combination to extend the previous major or minor version, minimizing schema duplication and ensuring the changes are backwards-compatible.\nAPI templates — The API template mechanism implicitly works via combination, by implicitly adding the template to the list of combined schemas for a given published schema.\n\nCombination Ordering\n The combination mechanismallows for theoretically arbitrary chains of combination, though the combinations must not have any cycles in the graph, i.e. you can't have A combine B, B combine C, and C combine A. Schemas are combined in the order they appear in the x-gw-combine property, and referenced schemas are themselves loaded and combined before processing. To make that more concrete,suppose we designate Schema A to mean the file",
      "narration": "",
      "ocrText": "| Schema file combination\n\n* Schema combination provides a\n\nmechanism for reuse of schemas\n\n* Ability to create a schema that logically\nextends and overrides one or more other\n\nschemas\n\n* If Acombines [B, C] listed in that order in\n\nthe combine property\n+ Contents of B are merged on top of C\n\n+ Contents of A are merged on top of the\ncombined schema\n\n+ Similar names are merged together to produce a single definition\n\n* Combination cannot remove definitions\n\n* Original schemas are not touched\n\nYBa integration\napis\n\nfitertmnte\nmappings ay |\n\neve\n\n> Bademo.ta\n> Bl gw.plframework\nv Da sita\n\ncontact-1,0.schemajzon\n\n\"$schema\" : \"http://json-schema.org/draft-04/schema#\",\n\"x-gw-combine\" : [\n\"trn.ta.contact-1.0\"\nI,\n“definitions” : {\n\"ContactDetails” : {\n\"type\" : \"object\",\n\"properties\" : {\n\"AssignedUser\" : {\n\"$ref\" : \"#/definitions/AssignedUser\"\n}\n}\nh\n\"AssignedUser\" : {\n\"type\" : \"object\",\n\"properties\" : {\n\"DisplayName\" : {\n\"type\" : \"string\"",
      "ocrWordCount": 148,
      "ocrConfidence": 80.69,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 26,
      "title": "Mapper file combination",
      "bodyParagraphs": [],
      "originalNotes": "Mapper file combination\nCode example — Succeed Insurance is extending the TrainingApp contact mapper\nLine 3\nCombine property used to combine contact mappers.\nLines 10,17\nNew object property is define and its corresponding mappe",
      "notes": "Mapper file combination\nCode example — Succeed Insurance is extending the TrainingApp contact mapper\nLine 3\nCombine property used to combine contact mappers.\nLines 10,17\nNew object property is define and its corresponding mappe",
      "narration": "",
      "ocrText": "| Mapper file combination\n\n* Mapper combination provides a\nmechanism for reuse of mappers\n\n* Combination rules used for schemas apply\n\nto mappers\n\nv Bil integration\n> Bil apis\n> Eu filters.tmn.ta\nv Ea mappings\n> Bl demota\n\nGi\n\n\"schemaName\" : \"si.ta.contact-1.0\",\n\n\"combine\" : [\n\"trn.ta.contact-1.0\"\n\nly\n\n\"mappers\" : {\n\n\"ContactDetails\" : {\n\"schemaDefinition\" : \"ContactDetails\",\n\"root\" : “entity.ABContact\",\n\"properties\" : {\n\"AssignedUser\" : {\n\"path\" : \"ABContact.AssignedUser\",\n\"mapper\" : \"#/mappers/AssignedUser\"\n}\n}\nye\n\"AssignedUser\" : {\n\"schemaDefinition\" : \"AssignedUser\",\n\"root\" : “entity.User\",\n\"properties\" : {\n\"DisplayName\" : {\n\"path\" : \"User.DisplayName\"",
      "ocrWordCount": 92,
      "ocrConfidence": 75.78,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 27,
      "title": "Example 4 -— JSON output using combination =",
      "bodyParagraphs": [],
      "originalNotes": "Example 4 — JSON output usin combination\nCode example\nLine 10\nJsonMapper object using the new combined schema.\nOutput\nAssignedUser property is combined to JSON output.",
      "notes": "Example 4 — JSON output usin combination\nCode example\nLine 10\nJsonMapper object using the new combined schema.\nOutput\nAssignedUser property is combined to JSON output.",
      "narration": "",
      "ocrText": "| Example 4 -— JSON output using combination =\n\n3 // Create JsonMapper object\n\n—Pio var jsonMapper = JsonConfigAccess.getMapper(\"si.ta.contact-1.0\", \"ContactDetails\")\n\nJSON Output\n> “Assignedvser™ = {\n\n“Contactiiores™ = [ {\n\"Body\" : “William Andy hes more questions related to date privacy\",\n“ContactlioteType” : “general\n“Subject” : \"Willian Andy has an inquiry”\nwt\n“Body” : “William Andy has many general questions\",\n“ContactNoteType” : “general\n\"Subject\" : \"Willian Andy has questions”\nMi\n“DaveOfBirch™ : *1980-08-06T04:00:00.0002\",\n\"Gender\" : “M\",\n“Maritalscatus\" : “married”,\nWane\" : “Willian Andy\",\n“PrimaryAddress” = (\n“AddressLinel™ : \"34S Fir Lane\",\n“AddressType” : \"hone\",\n“City” : “La Canada\",\n“PostalCode : \"91352\",\nState\" : \"CAT",
      "ocrWordCount": 104,
      "ocrConfidence": 70.22,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 28,
      "title": "Demonstration",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "| Demonstration G\nCreate a User Integration View\n\nclick here\n\nNote: The demonstration opens a new tab in your browser. When the demonstration ends, the\noriginal course launch window appears. Return to this window to continue this presentation.",
      "ocrWordCount": 38,
      "ocrConfidence": 95.47,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_instruction",
      "demoVideoIndex": 0
    },
    {
      "slideNumber": 29,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": false,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_video"
    },
    {
      "slideNumber": 30,
      "title": "Question",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question G\ninorder to generate JSON wrapper classes, you must: (Select three)\n•\nA) Add anew Run/Debug configuration whose main class is defined as:\ncom. guidewire. tools. json. JsonSchemaWrapperCodegenTool\nB) Run the server in Debug ‘Server’ mode.\nCc\nD\nE\nF) Add the schema fully qualified name to the codegen-schemas.txt.\nwv\nAdd a package called src.jsonschema.\nRun the JSONSchemaWrapperCodegen Tool.\nRestart the server after wrapper classes are created.\na=\nSeo e Soe esses see see",
      "ocrWordCount": 79,
      "ocrConfidence": 87.19,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "In order to generate JSON wrapper classes, you must: (Select three)",
        "answer": "_- — In order to generate JSON wrapper classes, you must: (Select three) v7 “ A) Add anew Run/Debug configuration whose main class is defined as: com.guidewire. tools. json. JsonSchemaWrapperCodegenTool B) Run the server in Debug ‘Server’ mode. F) Add the schema fully qualified name to the codegen-schemas.txt. Add a package called src.jsonschema. Run the JSONSchemaWrapperCodegenTool. Restart the server after wrapper classes are created. The correct answers are A, D, and F."
      }
    },
    {
      "slideNumber": 31,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer Gi\n_- — In order to generate JSON wrapper classes, you must: (Select three)\n“ A) Add anew Run/Debug configuration whose main class is defined as:\ncom.guidewire. tools. json. JsonSchemaWrapperCodegenTool\nB) Run the server in Debug ‘Server’ mode.\nCc\nD\nE\nF) Add the schema fully qualified name to the codegen-schemas.txt.\nwv\nAdd a package called src.jsonschema.\nRun the JSONSchemaWrapperCodegenTool.\nRestart the server after wrapper classes are created.\nThe correct answers are A, D, and F.\nSoo eS eee soe ese ese",
      "ocrWordCount": 83,
      "ocrConfidence": 84.94,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 32,
      "title": "Knowledge Check",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question\n/- — *-gw-type Is added in a JSON schema to map Guidewire internal types\nin cases where a format would be ambiguous, such as: typekeys,\nMonetaryAmount and CurrencyAmount. (True or False)\nSeo e Soe esses see see\nGi",
      "ocrWordCount": 40,
      "ocrConfidence": 83.38,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "*-gw-type Is added in a JSON schema to map Guidewire internal types",
        "answer": "/- — X-gw-type Is added in a JSON schema to map Guidewire internal types Pa in cases where a format would be ambiguous, such as: typekeys, MonetaryAmount and CurrencyAmount. (True or False)"
      }
    },
    {
      "slideNumber": 33,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer\n/- — X-gw-type Is added in a JSON schema to map Guidewire internal types\nin cases where a format would be ambiguous, such as: typekeys,\nMonetaryAmount and CurrencyAmount. (True or False)\nTrue\nSoo eS eee soe ese ese\nGi",
      "ocrWordCount": 41,
      "ocrConfidence": 79.2,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 34,
      "title": "Key Takeaways",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Lesson\nobjectives • Define the purpose of Integration Views\n\nreview • Configure an Integration View schema,\nmapping, and filter\n* Generate JSON output\n* Generate XML output",
      "ocrWordCount": 27,
      "ocrConfidence": 87.41,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives_review"
    },
    {
      "slideNumber": 35,
      "title": "Student Exercise",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "| Student exercise\n\nCreate a Contact Integration View",
      "ocrWordCount": 8,
      "ocrConfidence": 95.78,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "exercise"
    }
  ],
  "videos": [
    {
      "index": 1,
      "filename": "In_07_01.mp4",
      "path": "/academy/guidewire/videos/ch11/In_07_01.mp4"
    }
  ],
  "hasNotes": true,
  "hasTables": false,
  "hasImages": true,
  "ocrMetadata": {
    "totalWords": 2179,
    "avgConfidence": 84.47,
    "extractedAt": "2026-02-15T18:20:27.092852"
  }
}
