{
  "lessonId": "ch11-l02",
  "chapterId": 11,
  "chapterSlug": "ch11",
  "lessonNumber": 2,
  "title": "Gosu for Integration",
  "sourceFile": "Gosu for Integration.pptx",
  "sourceFolder": "In_Integration_02",
  "totalSlides": 36,
  "estimatedMinutes": 108,
  "slides": [
    {
      "slideNumber": 1,
      "title": "Gosu for Integration",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Gosu for Integration",
      "ocrWordCount": 3,
      "ocrConfidence": 94.25,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "title"
    },
    {
      "slideNumber": 2,
      "title": "Learning Objectives",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Lesson\nobjectives • Describe the general capabilities of a Gosu\n\nclass and its properties\n* Describe common Gosu features used for\nintegration, such as:\n+ Logging\n+ Exception handling\n+ Annotations\n\n+ Sequence utility",
      "ocrWordCount": 34,
      "ocrConfidence": 89.5,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives"
    },
    {
      "slideNumber": 3,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 4,
      "title": "i Packages",
      "bodyParagraphs": [],
      "originalNotes": "Packages\nA package is an aspect of object oriented programming languages. A package is collection of grouped classes- The classes in a package have a similar function or related purpose. Often,classes in a package require access to each other while classes outside of the package do not need access. You reference a class in a package with a fully qualified name- A fully qualified name details the package hierarchy. In the slide example, the ABContactSummary class exists in the hierarchy of the si package- The fully qualified name for the ABContactSummary class is si.ta.classes.entity.ABCont actSummary\n\nPer package hierarchy, you can only have one unique class name. Guidewire recommended naming convention for packages is: <company_code>. <product code>- <functional area> where-.\n<company_code> is the company's name or a suitable abbreviation\nIn training, we work for Succeed Insurance, so a suitable company code is si\n<product_code> is the Guidewire application's two- letter abbreviation:\nPolicyCenter: pc\nBillingCenter: bc\nClaimCenter: cc\nContact Manager: cm\n• TrainingApp: ta\n<mechanism> is one of:\nbatch\nmessaging\nplugin (for predefined (non-messaging, non- startable) plugins) startable\nwebservice\nclasses (for any package that isn’t covered by one of the above mechanisms)\nenhancements\n<functional area> is the functional area of the application",
      "notes": "Packages\nA package is an aspect of object oriented programming languages. A package is collection of grouped classes- The classes in a package have a similar function or related purpose. Often,classes in a package require access to each other while classes outside of the package do not need access. You reference a class in a package with a fully qualified name- A fully qualified name details the package hierarchy. In the slide example, the ABContactSummary class exists in the hierarchy of the si package- The fully qualified name for the ABContactSummary class is si.ta.classes.entity.ABCont actSummary\n\nPer package hierarchy, you can only have one unique class name. Guidewire recommended naming convention for packages is: <company_code>. <product code>- <functional area> where-.\n<company_code> is the company's name or a suitable abbreviation\nIn training, we work for Succeed Insurance, so a suitable company code is si\n<product_code> is the Guidewire application's two- letter abbreviation:\nPolicyCenter: pc\nBillingCenter: bc\nClaimCenter: cc\nContact Manager: cm\n• TrainingApp: ta\n<mechanism> is one of:\nbatch\nmessaging\nplugin (for predefined (non-messaging, non- startable) plugins) startable\nwebservice\nclasses (for any package that isn’t covered by one of the above mechanisms)\nenhancements\n<functional area> is the functional area of the application",
      "narration": "",
      "ocrText": "i Packages\n\n* Packages organize related artifacts in a hierarchy\n• Classes, Enhancements and other files\n• All packages reside under .../configuration/gsrc folder\n* Guidewire recommends the following naming conventions:\n\n« <company_code>.<product_code>.mechanism.<functional_area>\n\n+ Examples v Di gsre\n* si.ta.classes.utilities > BB com.guidewire.pl\n> gw\n* si.ta.enhancements.entity > Bai libraries\n* Class/file names must be unique within v Bil classes\nthe package v Bil entity\n© AsBContactSummary\nutilities\n\nenhancements.entity",
      "ocrWordCount": 68,
      "ocrConfidence": 76.85,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 5,
      "title": "i Access modifier keywords",
      "bodyParagraphs": [],
      "originalNotes": "Access modifier keywords\nShown in the slide is a chart of information about access modifier keywords and their differing characteristics.",
      "notes": "Access modifier keywords\nShown in the slide is a chart of information about access modifier keywords and their differing characteristics.",
      "narration": "",
      "ocrText": "i Access modifier keywords Ga\n\n« Use access modifier keywords to set the level of access to a top-level type (class,\ninterface, enumeration), or a type member (method, variable, or property)\n\nue, Description Applies to | Appliesto | Visiblein | Visiblein | Visible in | Visible Gosu default for\ntop-level | type class package subclass | byall\n— types members\n\npublic Fully accessible Yes Top-level types\nMethod\nProperty\nprotected Accessible only by types with - Yes Yes Yes Yes -\nsame package and subtypes\ninternal Accessible only in same Yes Yes Yes Yes - ~ =\npackage\nprivate Accessible only by declaring - Yes Yes - - - Variable\n\ntype that defines it",
      "ocrWordCount": 113,
      "ocrConfidence": 87.16,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 6,
      "title": "i Other modifier keywords",
      "bodyParagraphs": [],
      "originalNotes": "Other modifier keywords\nA static method is a method that belongs to the class in which it is declared:\nRequires no object instance to call the method\nOnly exists on the type, not an instance of the type\nGosu uses the following syntax to call a static member on a type:\nUses <companycode>. <productcode>.class. MyC lass\nMyClass. PropertyName I I get a static property name\nMyClass.methodName II get a static method",
      "notes": "Other modifier keywords\nA static method is a method that belongs to the class in which it is declared:\nRequires no object instance to call the method\nOnly exists on the type, not an instance of the type\nGosu uses the following syntax to call a static member on a type:\nUses <companycode>. <productcode>.class. MyC lass\nMyClass. PropertyName I I get a static property name\nMyClass.methodName II get a static method",
      "narration": "",
      "ocrText": "i Other modifier keywords G\n\nOther Description\n\nModifier\n\nkeyword\n\nOverride Apply the override modifier to a method or property override function myMethod(\nimplementation to declare that the subtype overrides the myParameter : String )\n\nimplementation of an inherited method or property with the\nsame signature.\n\nAbstract Indicates that a type is intended only to be a base type of other —_ abstract class Vehicle {\ntypes. }\nFinal Specifies that the value of a property, local variable, or class exampleABC {\n\nparameter cannot be modified after the initial value is assigned. _ final var_name : String = \"John”}\nThe final modifier cannot be combined with the abstract\nmodifier on anything.\n\nStatic Gosu classes can define a variable stored once per Gosu class, private static var _name : String\nrather than once per instance of the class. This modifier can also\nbe used with properties and methods. If a class variable is static,\nit is referred to as a static variable.",
      "ocrWordCount": 160,
      "ocrConfidence": 92.12,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 7,
      "title": "i Gosu classes",
      "bodyParagraphs": [],
      "originalNotes": "Gosu classes\nGosu classes have a package structure which contains the individual classes and the classes are extendable- Using Gosu, you can write your own custom classes and call these classes from within GOSLI- You create and reference Gosu classes by name. Technical developers often utilize all OOP programming techniques for all types of Gosu classes, including:\nEnhancements\nExtending existing classes\nImplementing interfaces\nCreating instances of\nclasses\nOverriding methods\n\nObject-oriented programming (OOP) is a programming approach in which developers create classes, which are instructions for how to build a set of objects and the properties and behaviors those objects will have, and create and manipulate individual objects, known as instances of a class or type. Every class is created by a class definition, which specifies the class name, the properties that every instance of the class has, and the methods that every instance of the class has.\n\nObject-oriented programming consists of four principles: Encapsulation, Abstraction, Polymorphism, and Inheritance.\nEncapsulation — Is the hiding of a data implementation by restricting access to accessors and mutators. An accessor is a method that is used to ask an object about itself. It can be a property or a public method. Mutators are public methods that modify the state of an object, while hiding the implementation of exactly how the data gets modified.\nAbstraction — Denotes the essential characteristics of an object that distinguish it from all other kinds of object and thus provide crisply defined conceptual boundaries, relative to the perspective of the viewer.\nPolymorphism — Means one name, many forms- Polymorphism manifests itself by having multiple methods all with the same name, but slightly different functionality.\nInheritance — Allows you to inherit functionality from another class, called a superclass or base class. Inheritance is the ability to extend components without any knowledge of the way in which a class was implemented.",
      "notes": "Gosu classes\nGosu classes have a package structure which contains the individual classes and the classes are extendable- Using Gosu, you can write your own custom classes and call these classes from within GOSLI- You create and reference Gosu classes by name. Technical developers often utilize all OOP programming techniques for all types of Gosu classes, including:\nEnhancements\nExtending existing classes\nImplementing interfaces\nCreating instances of\nclasses\nOverriding methods\n\nObject-oriented programming (OOP) is a programming approach in which developers create classes, which are instructions for how to build a set of objects and the properties and behaviors those objects will have, and create and manipulate individual objects, known as instances of a class or type. Every class is created by a class definition, which specifies the class name, the properties that every instance of the class has, and the methods that every instance of the class has.\n\nObject-oriented programming consists of four principles: Encapsulation, Abstraction, Polymorphism, and Inheritance.\nEncapsulation — Is the hiding of a data implementation by restricting access to accessors and mutators. An accessor is a method that is used to ask an object about itself. It can be a property or a public method. Mutators are public methods that modify the state of an object, while hiding the implementation of exactly how the data gets modified.\nAbstraction — Denotes the essential characteristics of an object that distinguish it from all other kinds of object and thus provide crisply defined conceptual boundaries, relative to the perspective of the viewer.\nPolymorphism — Means one name, many forms- Polymorphism manifests itself by having multiple methods all with the same name, but slightly different functionality.\nInheritance — Allows you to inherit functionality from another class, called a superclass or base class. Inheritance is the ability to extend components without any knowledge of the way in which a class was implemented.",
      "narration": "",
      "ocrText": "i Gosu classes\n\n• AGosu class (.gs file) describes an object properties and behaviors ©\n* Gosu classes are similar to classes in other object-oriented languages\n\n* To create a class, use the class keyword, followed by the class name, and then\n\ndefine its constructor, variables, properties, and methods\n\n« Meaningful name with Pascal case\n(First letter of each word is capitalized)\n\n* Optionally include access modifier as required/desired\n\n• Non-static classes are instantiated using the new keyword\n\nAccess is public by default\n\nPass any constructor arguments in parentheses\n\nGi\n\n© MySampleClass.gs x\n1 package si.ta.classes\n\n{\n\nclass Mys\n\nconstruct () {\n}\n\neIKVHewoN\n\n}\n\n® Gosu Scratchpad x\n\nae\n1 uses si.ta.classes.MySampleClass\n2 var myInstance = new MySampleClass ()",
      "ocrWordCount": 120,
      "ocrConfidence": 87.76,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 8,
      "title": "i Extending a class",
      "bodyParagraphs": [],
      "originalNotes": "Extending a class\nCode example\nLine 5\nAdd extends keyword to the superclass name in the class declaration.\nWhen one class extends another, the extending class (Square in the example above) is said to be a subclass of the extended class (Rectangle in the example above).\nThe subclass automatically has access to all non-private properties and methods in the superclass.\nLines 7-9\nDeclares that the Square class constructor use the Rectangle parent class constructor-\nsuper keyword gives you access to aspects of the superclass. The super method references the constructor of the parent class- For example, super.methodName references the method declaration in the parent class.\nLines 29-33\noverride keyword lets you override methods declared in the super class or interface. In the example above, override the Rectangle class calculateArea method which returns (Height * Width), with an alternate method: (Width * Width).\nSubclasses may override individual property accessors (the get and set methods used to set property values).",
      "notes": "Extending a class\nCode example\nLine 5\nAdd extends keyword to the superclass name in the class declaration.\nWhen one class extends another, the extending class (Square in the example above) is said to be a subclass of the extended class (Rectangle in the example above).\nThe subclass automatically has access to all non-private properties and methods in the superclass.\nLines 7-9\nDeclares that the Square class constructor use the Rectangle parent class constructor-\nsuper keyword gives you access to aspects of the superclass. The super method references the constructor of the parent class- For example, super.methodName references the method declaration in the parent class.\nLines 29-33\noverride keyword lets you override methods declared in the super class or interface. In the example above, override the Rectangle class calculateArea method which returns (Height * Width), with an alternate method: (Width * Width).\nSubclasses may override individual property accessors (the get and set methods used to set property values).",
      "narration": "",
      "ocrText": "i Extending a class Gi\n\n@©squere.gs x\nclass Square extends Rectangle implements ILineAndFill {\n\n9 construct () {\n\nsuper ()\n9 4}\n\n260\n29.1 Q override function calculateArea() : int {\n30, 's\n\nAccess to\ninherited\nproperties\n\naa return (4 * Width)\n42, }\n\nThe subclass can access to all non-private properties and methods declared in the\nsuperclass",
      "ocrWordCount": 58,
      "ocrConfidence": 82.14,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 9,
      "title": "i Gosu methods",
      "bodyParagraphs": [],
      "originalNotes": "Gosu methods\nCode example\nLines 33-39\nClass Rectangle includes two methods\ncalculateArea accepts no parameters and returns an integer\naddToWidth accepts an integer parameter and does not return any value\nNeither include an access modifier\n\nBest practices\nGosu requires that you provide the return type in the method definition, unless the return type is void (no return value). For clarity, add the void return type.\nThe recommended capitalization convention for methods is to use Camel Case- In Camel Case, the first letter of an identifier is lowercase and the first letter of each subsequent concatenated word is capitalized. Examples include calculateArea or addToWidth.\n\nMethods\nA method is a set of one or more lines of code that can be executed from instances of a class.\nSimilar to properties, methods can also be private which means that they available only to other methods in the defining class. Access to Gosu methods can be controlled using access keywords (public, protected, internal, private). However, the defaults for Java and Gosu are not the same. In Gosu, the default access for a method is public.\nA method that has input parameters is typically a method that has been abstracted to work in a variety of situations. It is not unusual to see strings, numerics, booleans, and objects as input parameters.\nAny return statement must return a type that matches the declared method return type. A missing return type or a mismatched return value generates a compiler error.\nThe this keyword refers to the instance of the class from which the method is called. For example, if you had an instance of Rectangle named myRectangle and you executed myRectangIe.addToWidth( 3), then the code as shown above on line 38 would logically be equivalent to myRectangle._width = myRectangle._width + 3.",
      "notes": "Gosu methods\nCode example\nLines 33-39\nClass Rectangle includes two methods\ncalculateArea accepts no parameters and returns an integer\naddToWidth accepts an integer parameter and does not return any value\nNeither include an access modifier\n\nBest practices\nGosu requires that you provide the return type in the method definition, unless the return type is void (no return value). For clarity, add the void return type.\nThe recommended capitalization convention for methods is to use Camel Case- In Camel Case, the first letter of an identifier is lowercase and the first letter of each subsequent concatenated word is capitalized. Examples include calculateArea or addToWidth.\n\nMethods\nA method is a set of one or more lines of code that can be executed from instances of a class.\nSimilar to properties, methods can also be private which means that they available only to other methods in the defining class. Access to Gosu methods can be controlled using access keywords (public, protected, internal, private). However, the defaults for Java and Gosu are not the same. In Gosu, the default access for a method is public.\nA method that has input parameters is typically a method that has been abstracted to work in a variety of situations. It is not unusual to see strings, numerics, booleans, and objects as input parameters.\nAny return statement must return a type that matches the declared method return type. A missing return type or a mismatched return value generates a compiler error.\nThe this keyword refers to the instance of the class from which the method is called. For example, if you had an instance of Rectangle named myRectangle and you executed myRectangIe.addToWidth( 3), then the code as shown above on line 38 would logically be equivalent to myRectangle._width = myRectangle._width + 3.",
      "narration": "",
      "ocrText": "i Gosu methods\n\n* Declare a method using the function\nkeyword\n\n* Methods describe object behavior and\nfeatures\n\n* Optionally include access modifier as\nrequired/desired\n\n+ Access is public by default\n« Method name in Camel Case\n\n* Optionally describe parameters and return type\n(String, int, etc)\n\n* The this keyword refers to the instance of\nthe class from which the method is called\n\n| @©pectangle.os x |\n\n1\n2\n\n3\n\n33\n34\n35\n36\n37\n38\n39\n\npackage acme.ta.classes\n\nclass Rectangle {\n\nfunction calculateArea(): int {\nreturn (width * height)\n}\n\nfunction addToWidth(valueToAdd: int): void {\nthis. width = this. width + valueToAdd\n}",
      "ocrWordCount": 105,
      "ocrConfidence": 88.16,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 10,
      "title": "i Block argument expression",
      "bodyParagraphs": [],
      "originalNotes": "Block argument expression\nIn some situations, a method can be abstracted to work in a variety of situations. But the value that varies from each situation is an algorithm or a set of logic. For example, the where method on an array returns all items in the array that match a given criteria. In this case, it is the criteria that needs to be supplied to the method.\n\nBlocks are used in many situations where a method requires an expression as an input parameter, such as in arrays, queries, and Transaction bundles for database transactions.",
      "notes": "Block argument expression\nIn some situations, a method can be abstracted to work in a variety of situations. But the value that varies from each situation is an algorithm or a set of logic. For example, the where method on an array returns all items in the array that match a given criteria. In this case, it is the criteria that needs to be supplied to the method.\n\nBlocks are used in many situations where a method requires an expression as an input parameter, such as in arrays, queries, and Transaction bundles for database transactions.",
      "narration": "",
      "ocrText": "i Block argument expression Ga\n\n> F @\n\nuses trainingapp.base.QueryUtil\n\n• Ablock is an\nexpression BIE var axanccotact ~\nof logic passed to |“ sPanecouts =\namethodasan © eee |\nargument a\n\noar (a\n& | Debugger] [EI console +*| )= wx 2 |e\n\nACME Credit Union\nNational Bank\n\n* The block | | Block part | Description\n\nconsists of four 1 \\ Identifies that the following is a block\n\nparts: 2 elementname A name representing each element of the array\n3 > Identifies the start of the condition\n4 condition A condition, which relates to the element",
      "ocrWordCount": 98,
      "ocrConfidence": 79.23,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 11,
      "title": "Declaring",
      "bodyParagraphs": [],
      "originalNotes": "Declaring Gosu properties\nProperties enable object- oriented encapsulation- Gosu properties are similar to Java properties.\nA property can be thought of as a value associated with an object. A property has a type and its value can be retrievedor set There are two approaches to having instance-specific values that can be manipulated:\nYou can create a field and explicitly set its access to public. This lets any method in any other class access and modify the value. However, this violates the idea of encapsulation and is not recommended.\nYou can create a private variable that methods of the class can access, but methods of other classes cannot access- Setting the variable to private ensures that only the class’s methods are allowed to directly modify the variable's value.\n\nIn Gosu, the recommended naming convention is to:\nName private variables with an initial underscore followed by a lower case letter and otherwise using camel case, such as _aPrivateVariable.\nName a non-public property with an initial capital letter, such as APublicVariable. (This is unlike Java naming conventions, where properties are implied from the get and set methods, and considered to have lowercase names, such as aPublicProperty.)\n\nAccess to Gosu variables and properties can be controlled using access keywords (public, protected, internal, private). In Gosu:\nThe default access for a variable is private.\nThe default access for a property is public.\nProperties can be declared as static.\nThis creates a class-level property that is accessible from the class itself (You can access a static property even when you do not have any instance of the class)\n\nAn Accessor method is commonly known as a get method or simply a getter. A property of the object is returned by the accessor method. They are declared as public. A naming scheme is followed by accessors, in other words they add the word get in front of the method name. They are used to return the value of a private field- The same data type is returned by these methods depending on their private field.\nA Mutator method is commonly known as a set method or simply a setter. A Mutator method mutates things, in other words change things. It shows us the principle of encapsulation. They are also known as modifiers. They are easily spotted because they start with the word set. They are declared as public. Mutator methods do not have any return type and they also accept a parameter of the same data type depending on their private field. After that it is used to set the value of the private field.",
      "notes": "Declaring Gosu properties\nProperties enable object- oriented encapsulation- Gosu properties are similar to Java properties.\nA property can be thought of as a value associated with an object. A property has a type and its value can be retrievedor set There are two approaches to having instance-specific values that can be manipulated:\nYou can create a field and explicitly set its access to public. This lets any method in any other class access and modify the value. However, this violates the idea of encapsulation and is not recommended.\nYou can create a private variable that methods of the class can access, but methods of other classes cannot access- Setting the variable to private ensures that only the class’s methods are allowed to directly modify the variable's value.\n\nIn Gosu, the recommended naming convention is to:\nName private variables with an initial underscore followed by a lower case letter and otherwise using camel case, such as _aPrivateVariable.\nName a non-public property with an initial capital letter, such as APublicVariable. (This is unlike Java naming conventions, where properties are implied from the get and set methods, and considered to have lowercase names, such as aPublicProperty.)\n\nAccess to Gosu variables and properties can be controlled using access keywords (public, protected, internal, private). In Gosu:\nThe default access for a variable is private.\nThe default access for a property is public.\nProperties can be declared as static.\nThis creates a class-level property that is accessible from the class itself (You can access a static property even when you do not have any instance of the class)\n\nAn Accessor method is commonly known as a get method or simply a getter. A property of the object is returned by the accessor method. They are declared as public. A naming scheme is followed by accessors, in other words they add the word get in front of the method name. They are used to return the value of a private field- The same data type is returned by these methods depending on their private field.\nA Mutator method is commonly known as a set method or simply a setter. A Mutator method mutates things, in other words change things. It shows us the principle of encapsulation. They are also known as modifiers. They are easily spotted because they start with the word set. They are declared as public. Mutator methods do not have any return type and they also accept a parameter of the same data type depending on their private field. After that it is used to set the value of the private field.",
      "narration": "",
      "ocrText": "Declaring Gosu properties\n\n• Approach 1: Define getter and\nsetter methods\n\n• Best practice has variable names begin\nwith an underscore “_”\n\n• Approach 2: Use shorthand syntax\ne Use as keyword\n\n* Getter and setter are automatically\ncreated for you\n\n* They do not appear in the class\n\n• Both approaches are essentially\nequivalent, but developerhas more\n\ncontrol with the first approach ===>\n\n=:\n\nclass UserPreferen\n\n//1) Bepreach\nvar _heightInleters : BigDecimal\n\nreturn (this. heightInMeters / 0.0254) .round (MathContext.DECIMAL32) as double\n} else {\nreturn 0.0\n\n(height: BigDecimal) {\n\nif (this. heightInMeters != null) {\nthis. heightInMeters = (height * 0.0254) as double\n} else {\nthis. heightInMeters = 0\ny\n1\n//// epecach 2: Use syntax ////\nvar weight : BigDecimal as Weight",
      "ocrWordCount": 125,
      "ocrConfidence": 81.6,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 12,
      "title": "Property initialization",
      "bodyParagraphs": [],
      "originalNotes": "Property initialization\nObject initializers let you set properties on newly created objects immediately after new expressions. Use object initializers for compact and clear object declarations. They are especially useful if combined with data structure syntax and nested objects",
      "notes": "Property initialization\nObject initializers let you set properties on newly created objects immediately after new expressions. Use object initializers for compact and clear object declarations. They are especially useful if combined with data structure syntax and nested objects",
      "narration": "",
      "ocrText": "| Property initialization G\n\nGosu enables a standard compact syntax for property initialization during object\ncreation\n\n« For example, suppose you have the following Gosu code:\n\nuses trainingapp.classes.Rectangle\n\nvar myRectangle = new Rectangle()\nmyRectangle.Height = 5\nmyRectangle.Width = 7\nmyRectangle.Label = \"Rectangle Area”\n\n« You can optionally use Gosu object initializers to simplify this code:\n\nuses trainingapp.classes.Rectangle\n\nvar myRectangle = new Rectangle() {\niHeight = 5,\n:Width = 7,\ntLabel = \"Rectangle Area\"\n\n}",
      "ocrWordCount": 74,
      "ocrConfidence": 88.15,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 13,
      "title": "i Feature literals for property reference",
      "bodyParagraphs": [],
      "originalNotes": "Feature literals for property reference\nFeature Literals are a programming language feature of Gosu. You can now refer to features using a statically verified literal syntax with the # (sharp) symbol. Some use cases for feature literals include mapping between properties of tvo types (mapping layer); data-binding (data layer); and specifying type- safe bean paths (query layer).",
      "notes": "Feature literals for property reference\nFeature Literals are a programming language feature of Gosu. You can now refer to features using a statically verified literal syntax with the # (sharp) symbol. Some use cases for feature literals include mapping between properties of tvo types (mapping layer); data-binding (data layer); and specifying type- safe bean paths (query layer).",
      "narration": "",
      "ocrText": "i Feature literals for property reference Gi\n\n* Statically refer to the features of a given type in the Gosu type system with feature\nliterals\n\n• Various kinds of feature references\n\n« Syntax: type#Feature\n\n« Property: ABContact#Address When it\n\n* Method: ABContact#addContactNote needs to be\n+ Uses type safe,\n\n• Bind argument values in method reference use feature\n\n* Supports chaining literals!",
      "ocrWordCount": 62,
      "ocrConfidence": 89.73,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 14,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 15,
      "title": "i Logging",
      "bodyParagraphs": [],
      "originalNotes": "Logging\nCode example\nLines 3,5\nImport the required logging classes.\nLine 10\nCreates a logger variable that is available in the class and for subtype classes.\nThe logger is of the type org.slf4j. Logger and uses a static logger category for configuration.\nLine 56\nLogger used to log application message.\n\nLogging records information about system behavior that is required for diagnostics, trouble-shooting, and failure recovery. Log files contain various types of application messages saved in a separate files- After a log file has been written, you can view a log file. Guidewire logging uses slf4j log severity levels:\nTrace — Messages about processes that are about to start or that completed. These types of messages provide flow-of-control logging. Trace logging has no or minimal impact on system performance.\nDebug — Messages that test a provable and specific theory intended to reveal some system malfunction- These messages need not be details but include information that would be understandable by an administrator.\nInfo — Messages that convey a sense of correct system operation.\nWarn — Messages that indicate a potential problem.\nError — Messages that indicate a definite problem.\nEach level is considered more severe than the previous.\n\nYou can check the logging using the is<Level>Enabled methods on a Logger instance. For example, if there is some overhead associated to the creation of a debug statement's string, check to see if the logging level is at Debug and avoid the construction of the string if this isn't the case-\nif (logger-isDebugEnabled ) {\n//avoid creating unused\nstrings\nmsg = String.formatC'Logging\nat debug level using objectl\n%s and %s.\",\n{obj 1 , obj2})\nlogger-debug(msg)\n}\nIn a production environment, an administrator is rarely at the console when an important event occurs. For this reason, it is a best practice to always use a logger instead of print statements- For educational purposes, TrainingApp may use print statements instead of loggers so that students can output information conveniently to the console. Logging is controlled from the Logging is controlled from the logging-properties file in the config/logging directory. The file specifies different categories of logging and the logging level for each category- When a logging statement is encountered that is at or above the specified level, the log message is written to the file. By editing the file, an administrator can control how much and when a Guidewire application writes log files without having to change any application code.\n\nXXLoggerCategory where XX is the product code\n• AB, BC, CC, PC, PL",
      "notes": "Logging\nCode example\nLines 3,5\nImport the required logging classes.\nLine 10\nCreates a logger variable that is available in the class and for subtype classes.\nThe logger is of the type org.slf4j. Logger and uses a static logger category for configuration.\nLine 56\nLogger used to log application message.\n\nLogging records information about system behavior that is required for diagnostics, trouble-shooting, and failure recovery. Log files contain various types of application messages saved in a separate files- After a log file has been written, you can view a log file. Guidewire logging uses slf4j log severity levels:\nTrace — Messages about processes that are about to start or that completed. These types of messages provide flow-of-control logging. Trace logging has no or minimal impact on system performance.\nDebug — Messages that test a provable and specific theory intended to reveal some system malfunction- These messages need not be details but include information that would be understandable by an administrator.\nInfo — Messages that convey a sense of correct system operation.\nWarn — Messages that indicate a potential problem.\nError — Messages that indicate a definite problem.\nEach level is considered more severe than the previous.\n\nYou can check the logging using the is<Level>Enabled methods on a Logger instance. For example, if there is some overhead associated to the creation of a debug statement's string, check to see if the logging level is at Debug and avoid the construction of the string if this isn't the case-\nif (logger-isDebugEnabled ) {\n//avoid creating unused\nstrings\nmsg = String.formatC'Logging\nat debug level using objectl\n%s and %s.\",\n{obj 1 , obj2})\nlogger-debug(msg)\n}\nIn a production environment, an administrator is rarely at the console when an important event occurs. For this reason, it is a best practice to always use a logger instead of print statements- For educational purposes, TrainingApp may use print statements instead of loggers so that students can output information conveniently to the console. Logging is controlled from the Logging is controlled from the logging-properties file in the config/logging directory. The file specifies different categories of logging and the logging level for each category- When a logging statement is encountered that is at or above the specified level, the log message is written to the file. By editing the file, an administrator can control how much and when a Guidewire application writes log files without having to change any application code.\n\nXXLoggerCategory where XX is the product code\n• AB, BC, CC, PC, PL",
      "narration": "",
      "ocrText": "i Logging\n\n>\n\n4 44\n\n“1\n\npackage trainingapp.classes [5\n\nuses gw.api.system.PLLoggerCategory\nuses gw.api.util.DisplayableException\nuses org.sif4).Logger\n\nclass Rectangle {\nconstruct () {\n}\nprotected var logger : Logger= PLLoggerCategory. CO!\n\nfunction enlarge(factor: int): String {\nif (factor <= 0) {\nlogger. info(\"Rectangel.enlarge() invalid factor \" + factor)\nthrow new DisplayableException (\"Requires a factor greater than 0\")\n)\n\nUses the slf4j API, in conjunction with Apache log4j-2 libraries and internal Guidewire libraries\n\n+ Itis possible for both internal Guidewire code or custom integration code to define additional logging\ncategories that do not show in the logging configuration file\n\n+ Itis also possible for third-party components, such as Apache, to provide their own logging categories\n\n* Each Guidewire application has its own unique categories as well",
      "ocrWordCount": 123,
      "ocrConfidence": 85.97,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 16,
      "title": "i Exception handling",
      "bodyParagraphs": [],
      "originalNotes": "Exception handling\nThe try.-.catch.-.finally blocks provides a way to handle some or all of the possible errors that may occur in a given block of code runtime. If errors occur that the code does not handle, Gosu simply provides its normal error message, as if there were no error handling. The try block contains code where an error can occur, while the catch block contains the code to handle any error that does occur. If an error occurs in the try block, Gosu passes program control to the catch block for processing. The initial value of the error- identifier is the value of the error that occurred in the try block.\n\nIf an error is thrown from Java code, the value is the exception or error that was thrown. Otherwise, the value is an exception thrown elsewhere in Gosu code.\n\nIf no error occurs, Gosu does not execute the catch block. If the error cannot be handled in the catch block associated with the try block where the error occurred, use the throw statement. The throw statement throws the exception (again) to a higher- level error handler.\n\nAfter all statements in the try block have been executed and any error handling has occurred in the catch block, the finally block is unconditionally executed.\n\nGosu executes the code inside the finally block, even if a return statement occursinside the try or catch blocks, or if an error is thrown from a catch block. Thus, Gosu guarantees that the finally block executes-",
      "notes": "Exception handling\nThe try.-.catch.-.finally blocks provides a way to handle some or all of the possible errors that may occur in a given block of code runtime. If errors occur that the code does not handle, Gosu simply provides its normal error message, as if there were no error handling. The try block contains code where an error can occur, while the catch block contains the code to handle any error that does occur. If an error occurs in the try block, Gosu passes program control to the catch block for processing. The initial value of the error- identifier is the value of the error that occurred in the try block.\n\nIf an error is thrown from Java code, the value is the exception or error that was thrown. Otherwise, the value is an exception thrown elsewhere in Gosu code.\n\nIf no error occurs, Gosu does not execute the catch block. If the error cannot be handled in the catch block associated with the try block where the error occurred, use the throw statement. The throw statement throws the exception (again) to a higher- level error handler.\n\nAfter all statements in the try block have been executed and any error handling has occurred in the catch block, the finally block is unconditionally executed.\n\nGosu executes the code inside the finally block, even if a return statement occursinside the try or catch blocks, or if an error is thrown from a catch block. Thus, Gosu guarantees that the finally block executes-",
      "narration": "",
      "ocrText": "i Exception handling\n\n* Gosu supports the full feature set for Java\nexception handling, including try/catch/finally\n\n5 * function hendleAnExceptionExemple(parml : int) (\nblocks E acti\n+ Exceptions are unchecked in Gosu 2 var x = 100\n2 var 2 =x / perm\n* You should add exception handling as —> } cate semelasrmenczacestion) {\nnecessary —> ) finany {\n4 }\n5 1\n\n+ Handle catch exceptions with try...catch...finally\n\nblocks\nu\n\n* Behavior is identical to Java exception handling 1s fence handleAnExceptionExample(parml : int) {\n16\n\n; i g f(permi == 0)(\nUnhandled exceptions are passed up the stack phe fo ow lege nctxcepeion ( as 0%)\n. 19 }\n* You can also throw exceptions as necessary 20 var x = 100\n\n2. var z =x / parm\n22 }",
      "ocrWordCount": 132,
      "ocrConfidence": 77.76,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 17,
      "title": "i Annotation support =",
      "bodyParagraphs": [],
      "originalNotes": "Annotation support\nCode example\nLine 50\n@Param\nDescription — Specifies the documentation of a parameter\nUsage limits — Methods only\nArguments — (1) The name of the parameter; (2) Documentation in Javadoc format for the method's parameter\nLine 51\n@Returns\nDescription — Specifies the documentation for the return result of the method\nUsage limits — Only once per method\nArguments — (1) Documentation in Javadoc format for the method's return value\nLine 52\n@Throws\nDescription — Specifies what exception might be thrown by the method Usage limits — Methods only; it can be used multiple times, typically once for each exception thrown\nArguments — (1) An exception type; (2) A description in Javadoc format of the circumstances when it would throw that exception, and how to interpret that exception.\nLine 53\n@Deprecated\nDescription — Specifies not to use a class, method constructor or property.\nUsage limits — Can appear anywhere, but only once for any specific class, method, constructor, property, or method argument\nArguments — (1) A warning string to display if this deprecated class, method, or constructor is used\n\nInternal Annotations\nThere are annotations that are reserved for internal use. You may see the following in built-in Gosu code. These are unsupported for you to write- The following table lists these internal annotations so that you understand their role in built-in classes:\n@Export\nDescription — Let a class be visible and editable in Studio\nUsage limits — Classes only\n@ReadOnly\nDescription — Let a class be visible in Studio but non-editable- This means it does not permit copying it into the configuration module for you to modify.\nUsage limits — Classes only\n\nAnnotations on supertypes are inherited by all subtypes. They are directly available via IType reflection on the subtype. Customers can also create custom annotations- Refer to documentation about how to create your own custom annotations.",
      "notes": "Annotation support\nCode example\nLine 50\n@Param\nDescription — Specifies the documentation of a parameter\nUsage limits — Methods only\nArguments — (1) The name of the parameter; (2) Documentation in Javadoc format for the method's parameter\nLine 51\n@Returns\nDescription — Specifies the documentation for the return result of the method\nUsage limits — Only once per method\nArguments — (1) Documentation in Javadoc format for the method's return value\nLine 52\n@Throws\nDescription — Specifies what exception might be thrown by the method Usage limits — Methods only; it can be used multiple times, typically once for each exception thrown\nArguments — (1) An exception type; (2) A description in Javadoc format of the circumstances when it would throw that exception, and how to interpret that exception.\nLine 53\n@Deprecated\nDescription — Specifies not to use a class, method constructor or property.\nUsage limits — Can appear anywhere, but only once for any specific class, method, constructor, property, or method argument\nArguments — (1) A warning string to display if this deprecated class, method, or constructor is used\n\nInternal Annotations\nThere are annotations that are reserved for internal use. You may see the following in built-in Gosu code. These are unsupported for you to write- The following table lists these internal annotations so that you understand their role in built-in classes:\n@Export\nDescription — Let a class be visible and editable in Studio\nUsage limits — Classes only\n@ReadOnly\nDescription — Let a class be visible in Studio but non-editable- This means it does not permit copying it into the configuration module for you to modify.\nUsage limits — Classes only\n\nAnnotations on supertypes are inherited by all subtypes. They are directly available via IType reflection on the subtype. Customers can also create custom annotations- Refer to documentation about how to create your own custom annotations.",
      "narration": "",
      "ocrText": "i Annotation support = G\n\npackage trainingapp.classes\n\nuses...\n\n1 class Rectangle {\nconstruct () {\n\nGosu annotations are a simple syntax to provide metadata or behavior to a class,\nconstructor, method, or property\n\n+ Use the @ symbol followed by the annotation name\n* Often, an argument list within parentheses follows an annotation",
      "ocrWordCount": 53,
      "ocrConfidence": 85.83,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 18,
      "title": "i Sequence utility",
      "bodyParagraphs": [],
      "originalNotes": "Sequence utility\nSyntax notes:\nseqKey is the sequence key. It is a string of up to 26 characters that uniquely identifies the sequence.\nminVal is the minimum value, of type Long, for the sequence. It specifies the value to use if this is the first request for a number in the specified sequence. On all requests beyond the first one, this value is ignored.\nThe return value is the next number in the sequence and is of datatype long.\n\nWhen a sequence is started, it will issue the provided minValue as its first value- After that, the returned value is simply the most recently returned value plus one- The next method is designed to be consistent across different database products.\n\nNote that if a request for the next sequence value blocks for a long period, due to waiting for the update lock, there may be an exception thrown from elsewhere, such as from the database Connection object. JDBC connection implementations typically throw an exception if no reply is received through the connection after a certain timeout period. Therefore implementations using the SequenceUtil should be prepared for an exception throw from calls to next. The next implementation itself will not directly throw a new exception.",
      "notes": "Sequence utility\nSyntax notes:\nseqKey is the sequence key. It is a string of up to 26 characters that uniquely identifies the sequence.\nminVal is the minimum value, of type Long, for the sequence. It specifies the value to use if this is the first request for a number in the specified sequence. On all requests beyond the first one, this value is ignored.\nThe return value is the next number in the sequence and is of datatype long.\n\nWhen a sequence is started, it will issue the provided minValue as its first value- After that, the returned value is simply the most recently returned value plus one- The next method is designed to be consistent across different database products.\n\nNote that if a request for the next sequence value blocks for a long period, due to waiting for the update lock, there may be an exception thrown from elsewhere, such as from the database Connection object. JDBC connection implementations typically throw an exception if no reply is received through the connection after a certain timeout period. Therefore implementations using the SequenceUtil should be prepared for an exception throw from calls to next. The next implementation itself will not directly throw a new exception.",
      "narration": "",
      "ocrText": "i Sequence utility\n\n• A Guidewire class that is used to generate unique, sequential numbers\n• Useful for business cases requiring numbers that are sequential or unique\n\n* Guidewire database stores sequence information\n* For each sequence, it maintains a record of the last number provided\n\n* The database provides the next number in the given sequence",
      "ocrWordCount": 57,
      "ocrConfidence": 86.77,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 19,
      "title": "i Sequence utility syntax",
      "bodyParagraphs": [],
      "originalNotes": "Sequence utility syntax\nSyntax notes:\nseqKey is the sequence key. It is a string of up to 26 characters that uniquely identifies the sequence.\nminVal is the minimum value, of type Long, for the sequence. It specifies the value to use if this is the first request for a number in the specified sequence. On all requests beyond the first one, this value is ignored.\nThe return value is the next number in the sequence and is of datatype long.\n\nWhen a sequence is started, it will issue the provided minValue as its first value- After that, the returned value is simply the most recently returned value plus one- The next method is designed to be consistent across different database products.\n\nNote that if a request for the next sequence value blocks for a long period, due to waiting for the update lock, there may be an exception thrown from elsewhere, such as from the database Connection object. JDBC connection implementations typically throw an exception if no reply is received through the connection after a certain timeout period. Therefore implementations using the SequenceUtil should be prepared for an exception throw from calls to next. The next implementation itself will not directly throw a new exception.",
      "notes": "Sequence utility syntax\nSyntax notes:\nseqKey is the sequence key. It is a string of up to 26 characters that uniquely identifies the sequence.\nminVal is the minimum value, of type Long, for the sequence. It specifies the value to use if this is the first request for a number in the specified sequence. On all requests beyond the first one, this value is ignored.\nThe return value is the next number in the sequence and is of datatype long.\n\nWhen a sequence is started, it will issue the provided minValue as its first value- After that, the returned value is simply the most recently returned value plus one- The next method is designed to be consistent across different database products.\n\nNote that if a request for the next sequence value blocks for a long period, due to waiting for the update lock, there may be an exception thrown from elsewhere, such as from the database Connection object. JDBC connection implementations typically throw an exception if no reply is received through the connection after a certain timeout period. Therefore implementations using the SequenceUtil should be prepared for an exception throw from calls to next. The next implementation itself will not directly throw a new exception.",
      "narration": "",
      "ocrText": "i Sequence utility syntax G\n\ngw.api.system.database.SequenceUtil.next(minVal, seqKey)\n* next method is used to request numbers\n* minVal is the minimum value for the first number in the sequence\n* seqKey is a unique name for the sequence\n© sequenceUtiltyExamples.gs\n\npackage trainingapp.demo.gosu\nuses gw.api.system.database.SequenceUtil\n\nclass SequenceUtilityE\n\npublic static function print Numbers (seqString : String) : void {\nvar firstNum = SequenceUtil.next(1, seqString)\nprint (seqString + \"-\" + firstNum)\nvar nextNum = SequenceUtil.next(1, seqString)\nprint (seqString + \"-\" + nexcium)",
      "ocrWordCount": 78,
      "ocrConfidence": 85.79,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 20,
      "title": "Sequence utility in action",
      "bodyParagraphs": [],
      "originalNotes": "Sequence utility in action\nCode example\nLine 4\nIn Gosu Scratchpad, is a call to the printTwoSequenceNumbers method for a sequence whose key is abc. In the printTwoSequenceNumbe rs method, there are two calls to next. Line 7 is the first call- Because there have been no previous calls for the abc sequence, the minimum value of 1 is returned. Line 8 prints the sequence key followed by a hyphen and the number returned. On line 9 a second call ismade to next. Because this is not the first call using the \"abc\" sequence, the minimum value is ignored and the method returns the next number in the sequence — in this case, it is 2.\nLine 5\nIn Gosu Scratchpad, is a second call to the printTwoSequenceNumbe rs method for sequence abc. In the printTwoSequenceNumbe rs method, lines 7 and 9 call the next method- Neither of these calls are the first call for sequence abc, so the next numbers in the sequence (3 and then 4) are retumed.\n Line 6\nIn Gosu Scratchpad, is a third call to the printTwoSequenceNumbe rs method- This time, sequence xyz is specified. Because this is a new sequence, the first call to next Uses the minimum value of 1, followed by 2.\n\nSequenceUtil reads information from the Guidewire database and writes information to it. Therefore, in order to test SequenceUtil code from Studio:\nThe application must be running.\nStudio must be connected to the application.\n\nIf either of these conditions is not true, then calls to SequenceUtil-next throw a null-pointer exception.\n\nWhile the above is true in H2 (and other light-weight databases), sequences are usually handled by designated Sequence objects in more robust databases (Oracle, SQL Server)",
      "notes": "Sequence utility in action\nCode example\nLine 4\nIn Gosu Scratchpad, is a call to the printTwoSequenceNumbers method for a sequence whose key is abc. In the printTwoSequenceNumbe rs method, there are two calls to next. Line 7 is the first call- Because there have been no previous calls for the abc sequence, the minimum value of 1 is returned. Line 8 prints the sequence key followed by a hyphen and the number returned. On line 9 a second call ismade to next. Because this is not the first call using the \"abc\" sequence, the minimum value is ignored and the method returns the next number in the sequence — in this case, it is 2.\nLine 5\nIn Gosu Scratchpad, is a second call to the printTwoSequenceNumbe rs method for sequence abc. In the printTwoSequenceNumbe rs method, lines 7 and 9 call the next method- Neither of these calls are the first call for sequence abc, so the next numbers in the sequence (3 and then 4) are retumed.\n Line 6\nIn Gosu Scratchpad, is a third call to the printTwoSequenceNumbe rs method- This time, sequence xyz is specified. Because this is a new sequence, the first call to next Uses the minimum value of 1, followed by 2.\n\nSequenceUtil reads information from the Guidewire database and writes information to it. Therefore, in order to test SequenceUtil code from Studio:\nThe application must be running.\nStudio must be connected to the application.\n\nIf either of these conditions is not true, then calls to SequenceUtil-next throw a null-pointer exception.\n\nWhile the above is true in H2 (and other light-weight databases), sequences are usually handled by designated Sequence objects in more robust databases (Oracle, SQL Server)",
      "narration": "",
      "ocrText": "Sequence utility in action\n\nGosu Scratchpad\nI\n\n=:\n\npublic static function\n\nvar firstilum = SequenceUtil.next(1, seqString)\nprint (seqString + \"-\" + firstiium)\nvar nextilum = SequenceUtil.next(1, seqString)\nprint (seqString + \"-\" + nexttium)\n\niB\n\n(seqString : String) : void {\n\n> ¥F 8\n\nWt\n\nVv\n\nDebugger| [E] Console +\"\n\nuses trainingapp.demo.gosu.SequenceUtilityExamples\n\nvar seqUtil = SequenceUtilityExamples\nseqUtil.printTvoSequenceNumbers (\"abc\")\nseqUtil.printTvoSequenceNumbers (\"abc\")\nseqUtil.printTvoSequenceNumbers (\"xy2\")\n\nv\n\nH2 database view\n\nas\n\nx\n\n2\n\neet} cattnabe\"\n\nabe-3 1»\nae\" ean ‘abc’\n\nxye-1 yo\"\nxyz-2 } cat xyz’\n\nFun | Run eleded | Ato compete | Cea Sat statement\n\n‘SELECT*\n\nFROM AB_SEQUENCE\n\n‘SELECT*\n\nFROM AB_SEQUENCE:\n\nPUBLICID |BEANVERSION |SEQUENCENUMBER |ID |SEQUENCEKEY\nabt 3 4 1 abe\n‘ab2 1 2 2 me\n\n(2 rows, 16 ms)\n\nGi",
      "ocrWordCount": 118,
      "ocrConfidence": 71.58,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 21,
      "title": "Demonstration",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "i Demonstration G\n\nCreate a custom class\n\nclick here\n\nNote: The demonstration opens a new tab in your browser. When the demonstration ends, the\noriginal course launch window appears. Return to this window to continue this presentation.",
      "ocrWordCount": 37,
      "ocrConfidence": 93.97,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_instruction",
      "demoVideoIndex": 0
    },
    {
      "slideNumber": 22,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": false,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_video"
    },
    {
      "slideNumber": 23,
      "title": "Knowledge Check",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question\nan What is a package?",
      "ocrWordCount": 14,
      "ocrConfidence": 66.27,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "An What is a package?",
        "answer": "What is a package? A package is a group of classes gathered together either because they execute a common business task, or because access to the classes must be limited only to the classes in the package, or both. SS eee ene ee soe Sse"
      }
    },
    {
      "slideNumber": 24,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer\nWhat is a package?\n•\nA package is a group of classes gathered together either because they execute a\ncommon business task, or because access to the classes must be limited only to the\nclasses in the package, or both.\nSS eee ene ee soe Sse",
      "ocrWordCount": 49,
      "ocrConfidence": 86.46,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 25,
      "title": "Knowledge Check",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question\nAGosu class is named Circle. Each instance must have a property for\nthe circle's radius. This value can be accessed and conditionally\nmodified by methods in the Circle class and by methods in other classes.\nHow many elements must you create to implement this?\nGi",
      "ocrWordCount": 55,
      "ocrConfidence": 86.77,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "AGosu class is named Circle. Each instance must have a property for",
        "answer": "The circle's radius. This value can be accessed and conditionally modified by methods in the Circle class and by methods in other classes. How many elements must you create to implement this? Three. 1. Aprivate variable named _ radius. 2. Aget method that retrieves the value of _radius. 3. A set method that sets the value of _radius. SS eee ene ee soe Sse"
      }
    },
    {
      "slideNumber": 26,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer Gi\n_- — AGosu class is named Circle. Each instance must have a property for\nthe circle's radius. This value can be accessed and conditionally\nmodified by methods in the Circle class and by methods in other classes.\nHow many elements must you create to implement this?\nThree.\n1. Aprivate variable named _ radius.\n2. Aget method that retrieves the value of _radius.\n3. A set method that sets the value of _radius.\nSS eee ene ee soe Sse",
      "ocrWordCount": 80,
      "ocrConfidence": 87.77,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 27,
      "title": "Knowledge Check",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question\nThe Circle class extends the Oval class and implements the ICurveLine\ninterface.\n1. Can Circle override methods from Oval?\n2. Can Circle override methods from |CurveLine?\nGi",
      "ocrWordCount": 36,
      "ocrConfidence": 80.46,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "The Circle class extends the Oval class and implements the ICurveLine",
        "answer": "7 interface. ? 1. Can Circle override methods from Oval? 2. Can Circle override methods from ICurveLine? 1. Yes From a keyword standpoint, yes. If Circle implements the ICurveLine interface, then Circle must implement all the methods of the ICurveLine interface using the keyword \"override\". However, because |CurveLine is an interface, the Circle class is actually just declaring the implementations of the methods. There are no method implementations in an interface, so there is nothing to \"override\" from an OOP standpoint."
      }
    },
    {
      "slideNumber": 28,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer Gi\nThe Circle class extends the Oval class and implements the ICurveLine\ninterface.\n? 1. Can Circle override methods from Oval?\n2. Can Circle override methods from ICurveLine?\n1. Yes\nFrom a keyword standpoint, yes. If Circle implements the ICurveLine interface,\nthen Circle must implement all the methods of the ICurveLine interface using the\nkeyword \"override\". However, because |CurveLine is an interface, the Circle class\nis actually just declaring the implementations of the methods. There are no\nmethod implementations in an interface, so there is nothing to \"override\" from an\nOOP standpoint.\nSee eseeseeseseeseses\nNh",
      "ocrWordCount": 97,
      "ocrConfidence": 92.08,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 29,
      "title": "Knowledge Check",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question\nWhat is the purpose of an annotation?\n•\n•",
      "ocrWordCount": 18,
      "ocrConfidence": 68.37,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "What is the purpose of an annotation?",
        "answer": "An annotation provides metadata about the element being annotated. SS eee ene ee soe Sse"
      }
    },
    {
      "slideNumber": 30,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer\n_- — What is the purpose of an annotation?\n•\n•\nAn annotation provides metadata about the element being annotated.\nSS eee ene ee soe Sse",
      "ocrWordCount": 27,
      "ocrConfidence": 76.18,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 31,
      "title": "Knowledge Check",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question\nHow do you calla static method from a class?\n•\n•",
      "ocrWordCount": 19,
      "ocrConfidence": 70.35,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "How do you calla static method from a class?",
        "answer": "You call a static method by referencing the method name from the class. You must either reference the fully qualified name of the class or import the class using the uses keyword followed by the reference to the package path. SS eee ene ee soe Sse"
      }
    },
    {
      "slideNumber": 32,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer Gi\nHow do you calla static method from a class?\n•\n•\nYou call a static method by referencing the method name from the class. You must\neither reference the fully qualified name of the class or import the class using the uses\nkeyword followed by the reference to the package path.\nSS eee ene ee soe Sse",
      "ocrWordCount": 60,
      "ocrConfidence": 86.61,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 33,
      "title": "Question",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question G\n_- — Why put logic in a Gosu class as opposed to an entity enhancement?\n•\n•",
      "ocrWordCount": 26,
      "ocrConfidence": 74.26,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "Why put logic in a Gosu class as opposed to an entity enhancement?",
        "answer": "Logic that is reusable and generic must be in a Gosu class. Logic that is intrinsically connected with an entity must be inserted into an Enhancement. SS eee ene ee soe Sse"
      }
    },
    {
      "slideNumber": 34,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer Gi\nWhy put logic in a Gosu class as opposed to an entity enhancement?\n•\nLogic that is reusable and generic must be in a Gosu class.\nLogic that is intrinsically connected with an entity must be inserted into an\nEnhancement.\nSS eee ene ee soe Sse",
      "ocrWordCount": 50,
      "ocrConfidence": 84.69,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 35,
      "title": "Key Takeaways",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Lesson\nobjectives * Describe the general capabilities of a Gosu\nreview class and its properties\n\n* Describe common Gosu features used for\nintegration, such as:\n+ Logging\n+ Exception handling\n+ Annotations\n\n+ Sequence utility",
      "ocrWordCount": 35,
      "ocrConfidence": 88.2,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives_review"
    },
    {
      "slideNumber": 36,
      "title": "Student Exercise",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "i Student exercise\n\nCreate a custom class",
      "ocrWordCount": 7,
      "ocrConfidence": 88.62,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "exercise"
    }
  ],
  "videos": [
    {
      "index": 1,
      "filename": "In_02_01.mp4",
      "path": "/academy/guidewire/videos/ch11/In_02_01.mp4"
    }
  ],
  "hasNotes": true,
  "hasTables": false,
  "hasImages": true,
  "ocrMetadata": {
    "totalWords": 2191,
    "avgConfidence": 83.68,
    "extractedAt": "2026-02-15T18:19:14.910499"
  }
}
