{
  "lessonId": "ch11-l13",
  "chapterId": 11,
  "chapterSlug": "ch11",
  "lessonNumber": 13,
  "title": "Creating Messages",
  "sourceFile": "Creating Messages.pptx",
  "sourceFolder": "In_Integration_13",
  "totalSlides": 20,
  "estimatedMinutes": 60,
  "slides": [
    {
      "slideNumber": 1,
      "title": "Creating Messages",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Creating Messages",
      "ocrWordCount": 2,
      "ocrConfidence": 95.67,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "title"
    },
    {
      "slideNumber": 2,
      "title": "Learning Objectives",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Lesson\nobjectives\n\n• Create messages in Event Fired rules\n• Describe the role that message payloads play\nin messaging",
      "ocrWordCount": 19,
      "ocrConfidence": 90.37,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives"
    },
    {
      "slideNumber": 3,
      "title": "Use case",
      "bodyParagraphs": [],
      "originalNotes": "Use case\nThe bank account message is triggered when a checking or savings bank account is added or modified. The message is created by the bank account verification event fired rules.",
      "notes": "Use case\nThe bank account message is triggered when a checking or savings bank account is added or modified. The message is created by the bank account verification event fired rules.",
      "narration": "",
      "ocrText": "Use case\n\n* Create a message when a bank\naccount is added or modified\n\n• Ifthe bank account type is savings,\nthe string message payload must\nhave a placeholder field called\nageOfMessagelnSeconds that will\nbe calculated and replaced later\n\n* Generate XML message payload for\nother bank account types\n\nGi\nDesign approach\n\n1. Create Event Fired rules\n2. Create payload mechanism\n\n3. Deploy changes",
      "ocrWordCount": 64,
      "ocrConfidence": 89.61,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 4,
      "title": "Guidewire servers and messaging transactions",
      "bodyParagraphs": [],
      "originalNotes": "Guidewire servers and messaging transactions\nThe servers involved at each point of the process are important because they determine where payload work should occur. The majority of payload generation should be done in Event Fired rules on the ui role server that manages the given user's session. However, if some portion of payload generation must be done immediately before the message is sent, that portion of the payload can be generated on the messaging role server.\nA message is always processed in at least two an as many as four transactions:\nTransaction 1 — Creates the message and generates the payload. This transaction always occurs.\nTransaction 2 — Prior to sending the message, an optional transaction may transform the message payload. This is usually done when the message must include information that can only be known immediately before sending the message.\nTransaction 3 — The sending of the message to the external system occurs in its own transaction- This transaction always occurs. If the external system acknowledges the message synchronously, then the acknowledgement is included in this transaction.\nTransaction 4 — If the external system acknowledges the message asynchronously, then a separate transaction processes the acknowledgement. This transaction does not occur for messages that are acknowledged synchronously.\nThe transaction structure is important because this determines the work that is rolled back if an error occurs.",
      "notes": "Guidewire servers and messaging transactions\nThe servers involved at each point of the process are important because they determine where payload work should occur. The majority of payload generation should be done in Event Fired rules on the ui role server that manages the given user's session. However, if some portion of payload generation must be done immediately before the message is sent, that portion of the payload can be generated on the messaging role server.\nA message is always processed in at least two an as many as four transactions:\nTransaction 1 — Creates the message and generates the payload. This transaction always occurs.\nTransaction 2 — Prior to sending the message, an optional transaction may transform the message payload. This is usually done when the message must include information that can only be known immediately before sending the message.\nTransaction 3 — The sending of the message to the external system occurs in its own transaction- This transaction always occurs. If the external system acknowledges the message synchronously, then the acknowledgement is included in this transaction.\nTransaction 4 — If the external system acknowledges the message asynchronously, then a separate transaction processes the acknowledgement. This transaction does not occur for messages that are acknowledged synchronously.\nThe transaction structure is important because this determines the work that is rolled back if an error occurs.",
      "narration": "",
      "ocrText": "| Guidewire servers and messaging transactions\n\njotneeaneneeneeeeeeseeeeeseseeseeeseeeeeeseeeeseseeeeees prteeeeeeeeneenseeeeeeeeeseesseeeeessesessesseeeeeeseesesseeseseesers\nH Application Context > Integration Context\n: Event triggering & ¥ Sending message &\nMessage generation . Payload Process synchronous\ne ») (event fired rules) Message Transformation acknowledgment (transport\n(request plugin) plugin)\n\nG transaction 2 transaction 3\n\nProcess asynchronous\nacknowledgement\n(reply plugin or API)\n\n• All activity from message generation takes place in transaction 1\n• Messaging occurs across multiple transactions\n\n• If an exception is thrown, work in the current transaction is rolled back\n\n: External\n\n: System\n\n—",
      "ocrWordCount": 88,
      "ocrConfidence": 85.13,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 5,
      "title": "Event Fired rules",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Event Fired rules",
      "ocrWordCount": 3,
      "ocrConfidence": 95.33,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 6,
      "title": "Guidewire business rules",
      "bodyParagraphs": [],
      "originalNotes": "Guidewire business rules\nBusiness rules are covered in the Configuration Fundamentals course.\n\nA rule set combines many individual rules into a useful set to consider as a group. A rule set is a collection of rules that share the same root entity and share common triggers. In the example above, one rule set is Event Fired. By selecting the rule set, the editor displays the rule set description and details of the root entity. In this example, the root entity is entity. MessageContext.",
      "notes": "Guidewire business rules\nBusiness rules are covered in the Configuration Fundamentals course.\n\nA rule set combines many individual rules into a useful set to consider as a group. A rule set is a collection of rules that share the same root entity and share common triggers. In the example above, one rule set is Event Fired. By selecting the rule set, the editor displays the rule set description and details of the root entity. In this example, the root entity is entity. MessageContext.",
      "narration": "",
      "ocrText": "| Guidewire business rules Gi\n\n• Abusiness rule written in Gosu accomplishes some task for a Melbolest : Onsale\ngiven entity Vee senees\nwe we > CO eEntity Names\n* Three base types of rule set categories in TrainingApp > EY Bitensions\n\n> [2 Localizations\n\n> Messaging\n\n> DY Metadata\n\n> [&lPage Configuration\n> PW Plugin:\n\n+ EventMessage\n\n+ One rule set called EventFired\n\n+ Root entity is MessageContext\n\n+ Rules execute when an integration event is triggered\n\n‘#) EventFired\n‘VD Preupdate\n« Preupdate #8) aBcontactContactPreupdate\n#) ABContactPreupdate\n+ Four rule sets #) AddressPreupdate\n*#) PendingContactChangePreupdate\n+ Rules execute when an update has occurred on a root entity ¥ Voldston oS\nwage @) ABContactValidationRules\n\n+ Validation ) ContactValidationRules\n\n+ Fourrule sets @) PersonValidationRules\n\n#) RegionValidationRules\n+ Rules check for missing information or invalid data on a root entity",
      "ocrWordCount": 138,
      "ocrConfidence": 75.67,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 7,
      "title": "Rule set execution",
      "bodyParagraphs": [],
      "originalNotes": "Rule set execution\nIn a rule set, a Guidewire application evaluates the individual rules recursively in the hierarchy, unless an exit action isencountered. The process starts with the first direct child of the root and then evaluates all children and siblings. All rules in a rule set are processed unless an explicit exit is encountered. If a rule has child rules and the parent rule condition is false, neither the parent action nor the child rules are executed.",
      "notes": "Rule set execution\nIn a rule set, a Guidewire application evaluates the individual rules recursively in the hierarchy, unless an exit action isencountered. The process starts with the first direct child of the root and then evaluates all children and siblings. All rules in a rule set are processed unless an explicit exit is encountered. If a rule has child rules and the parent rule condition is false, neither the parent action nor the child rules are executed.",
      "narration": "",
      "ocrText": "| Rule set execution Gi\n\n: TE Project = + © | H- It | €) EventFired.\n* Rule execution follows ee Tt\n. . . “configuration C:\\GW10\\Trainin J ad Event Fired)\nthe order listed in Studio v Creonfig > @) © ABEF1000 - Vendor Recommendation\n> (QD Entity Names & @) D aser2000 - Fraud Check\n• Per node, rules execute > DY Extensions v @) © BAEF1000 - Bank Account Verification\nina hierarchy > [YP Localizations Sore BAEF1100 - Bank Account\n> > Messagi ~~ @) H Bacr1110 - Added Changed\n* Rule condition code > Ease Se ee falc anaes\n> (page Configuration a a LREF1000 - Legal Case Report\nresolves to true or false > pW Plugins G , 3 z a MesageGeenter\n+ When condition is true © CB Rate Sets > BS Poticycenter\nf Sti di i\" vil EventMessage > BA ciaimcenter\nrule action code executes, > B) D Billingcenter\n\nand\n* Child rules execute (if any)",
      "ocrWordCount": 163,
      "ocrConfidence": 70.4,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 8,
      "title": "Rule set editor",
      "bodyParagraphs": [],
      "originalNotes": "Rule set editor\nYou can think of a rule set as a logical grouping of rules that are specific to a business function. You typically organize these rules sets into a hierarchy that fits your business model. Guidewire strongly recommends that you implement a rule-naming scheme that is hierarchal in nature. A hierarchal naming convention will reflect the hierarchal structure when you create rules and organize rules into a hierarchy. However, the naming scheme forrules corresponds to the file\nstructure on disk. So, if it has to many levels customers can runinto problems with file names being too long on Windows.\n\nIndividual rule files have the file extension .gr. For each rule, there is a condition and action. The Rule Editor provides overlays to segment the uses, condition and action. When a rule condition evaluates to true, the Guidewire application executes the rule action and child rules, if any.\n\nAn inactive rule is not executed. You can activate and deactivate rules to get the rules engine to selective process and ignore rules. To deactivate a rule, disable the check box that appears to the left of the rule name. Inactive rules appear in gray. To reactivate the rule, enable the check box. To delete or rename a rule, right-click the rule and select the appropriate command from the context menu.",
      "notes": "Rule set editor\nYou can think of a rule set as a logical grouping of rules that are specific to a business function. You typically organize these rules sets into a hierarchy that fits your business model. Guidewire strongly recommends that you implement a rule-naming scheme that is hierarchal in nature. A hierarchal naming convention will reflect the hierarchal structure when you create rules and organize rules into a hierarchy. However, the naming scheme forrules corresponds to the file\nstructure on disk. So, if it has to many levels customers can runinto problems with file names being too long on Windows.\n\nIndividual rule files have the file extension .gr. For each rule, there is a condition and action. The Rule Editor provides overlays to segment the uses, condition and action. When a rule condition evaluates to true, the Guidewire application executes the rule action and child rules, if any.\n\nAn inactive rule is not executed. You can activate and deactivate rules to get the rules engine to selective process and ignore rules. To deactivate a rule, disable the check box that appears to the left of the rule name. Inactive rules appear in gray. To reactivate the rule, enable the check box. To delete or rename a rule, right-click the rule and select the appropriate command from the context menu.",
      "narration": "",
      "ocrText": "| Rule set editor\n\nRule Hierarchy\n\nlv CF Event Fired\n> @) © ABer1000 - Vendor Recommendation|\n‘ABEF2000 - Fraud Check\n\n© BAEFII10 - Added Changed\n\n®) © Baeriitt - Field Changed|\nREFI000 - Legal Case Report\n\\GEF1000 - MessageGenerator\n\n• Rule Hierarchy\n* Context menu\n* Activate/Deactivate checkbox\n• Drag-and-drop ordering\n\nRule Editor\n\nACTION (messageContext : entity.MessageContext, actions : gv.rules.Action) :\nprint(\"\\n### Stage 1 -- Triggering the message ***\")\n\"-Bvent Pired rule set: \" + actions.Rule.Displaytiame )\n\nDestination ID is \" + messageContext.DestID)\n\n• Rule Editor\n\n* Overlays segment Uses, Condition, and\nAction\n\n« IMPORTANT\n\n* Do NOT delete the return keyword in\nrule condition",
      "ocrWordCount": 106,
      "ocrConfidence": 80.63,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 9,
      "title": "Event Fired rule set",
      "bodyParagraphs": [],
      "originalNotes": "Event Fired rule set\nThe application calls the Event Fired rules if an entity involved in a bundle commit triggers an event for which a message destination has registered interest. As part of the event processing, the application:\nRuns the rules in the Event Fired rule set once for every event for which a message destination has registered interest.\nCreates a MessageContext entity for every message destination of interest.\nRuns the Event Fired rule set once for each destination that is listening for that particular event It is possible for the application to run the Event Fired rule sets multiple times for each event, once for each destination interested in that event.\n\nFor example, a system has seven destinations that listento a given message event and it has 20 top-level Event Fired rules. Every time suchan event is fired, up to 140 checks may need to be made- Thus, it is critical to keep your Event Fired rulesorganized to avoid unnecessary or duplicate checks.\n\nA message payload contains static and/or dynamically generated data. For example, the payload for bank account message might contain the bank name, routing number, and account number of the given bank account as comma-separated values. The specific values for the bank name, routing number, and account number must be generated dynamically for each bank account message.\n\nThe event fired rule set is not responsible for:\nSending messages (transport plugin)\nAcknowledging messages (transport or reply plugins)",
      "notes": "Event Fired rule set\nThe application calls the Event Fired rules if an entity involved in a bundle commit triggers an event for which a message destination has registered interest. As part of the event processing, the application:\nRuns the rules in the Event Fired rule set once for every event for which a message destination has registered interest.\nCreates a MessageContext entity for every message destination of interest.\nRuns the Event Fired rule set once for each destination that is listening for that particular event It is possible for the application to run the Event Fired rule sets multiple times for each event, once for each destination interested in that event.\n\nFor example, a system has seven destinations that listento a given message event and it has 20 top-level Event Fired rules. Every time suchan event is fired, up to 140 checks may need to be made- Thus, it is critical to keep your Event Fired rulesorganized to avoid unnecessary or duplicate checks.\n\nA message payload contains static and/or dynamically generated data. For example, the payload for bank account message might contain the bank name, routing number, and account number of the given bank account as comma-separated values. The specific values for the bank name, routing number, and account number must be generated dynamically for each bank account message.\n\nThe event fired rule set is not responsible for:\nSending messages (transport plugin)\nAcknowledging messages (transport or reply plugins)",
      "narration": "",
      "ocrText": "| Event Fired rule set Gi\n\nCreates message and payload\nThe payload typically:\n* Contains static and/or dynamically generated data\n\n+ Is formatted based on the needs of the e:\n\nray H Event :\n\\ i Fired :\nF vesination Rules i\nMessage H\ntuent payload :\nEvent rN »), —\n\no • B\n\nEventAware MessageContext Message\nEntity Entitv Entitv.",
      "ocrWordCount": 60,
      "ocrConfidence": 76.74,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 10,
      "title": "Common options for",
      "bodyParagraphs": [],
      "originalNotes": "Common options for generating message payloads\nGosu template, XML modelers, and Integration View are not the only ways for generating a message payload, but they are commonly used. Likewise, message payload generation is not the sole purpose of a Gosu template XML modeler, or Integration View.\n\n Other technologies that can be used to generate payloads include:\nManually creating untyped XML using the XmlElement class\nManually creating stronglytyped XML from an XSD type\nAny logic that creates a string suitable for use as a payload",
      "notes": "Common options for generating message payloads\nGosu template, XML modelers, and Integration View are not the only ways for generating a message payload, but they are commonly used. Likewise, message payload generation is not the sole purpose of a Gosu template XML modeler, or Integration View.\n\n Other technologies that can be used to generate payloads include:\nManually creating untyped XML using the XmlElement class\nManually creating stronglytyped XML from an XSD type\nAny logic that creates a string suitable for use as a payload",
      "narration": "",
      "ocrText": "| Common options for generating message payloads [5\n\nES\n\nMessage\npayload\n\n• Gosu template\n• Formatted strings with entity data\n\n* XML modeler\n* Strongly typed XML with XSD validation\n* Supports object graph\n\na ad\n\n• Integration View Seheee\n+ JSON s\n\n* Strongly typed XML with XSD validation External\n\nView",
      "ocrWordCount": 52,
      "ocrConfidence": 81.94,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 11,
      "title": "Late binding in the payload",
      "bodyParagraphs": [],
      "originalNotes": "Late binding in the payload\nGood candidates for late binding include:\nA send timestamp\nThe message ID and/or its public ID\nAn identifier from the external system that was sent in reply to a previous message\n\nFor example, imagine an integration point in which the first message communicates that a new entity was added- The reply to the first message contains the ID to be used for the new entity on the external system- The second message identifies a change on this new entity. However, the second message is created before the first message has been sent (or before the reply to the first message has been received). The second message must use the ID in the reply to the first message- The only way this ID can be added to the second message is through late binding.\n\nTypically, values that are tobe late bound are added to the message payload using a placeholder marked by special character delimiters, such as <@@ and @@>. In the message request plugin, these placeholders are replaced with the required data. Be careful about what data you set via late binding- Typically, the message payload should reflect a consistent snapshot of the system at the time the Event Fired rule executed. Late binding should not be used to capture entity data after message creation.",
      "notes": "Late binding in the payload\nGood candidates for late binding include:\nA send timestamp\nThe message ID and/or its public ID\nAn identifier from the external system that was sent in reply to a previous message\n\nFor example, imagine an integration point in which the first message communicates that a new entity was added- The reply to the first message contains the ID to be used for the new entity on the external system- The second message identifies a change on this new entity. However, the second message is created before the first message has been sent (or before the reply to the first message has been received). The second message must use the ID in the reply to the first message- The only way this ID can be added to the second message is through late binding.\n\nTypically, values that are tobe late bound are added to the message payload using a placeholder marked by special character delimiters, such as <@@ and @@>. In the message request plugin, these placeholders are replaced with the required data. Be careful about what data you set via late binding- Typically, the message payload should reflect a consistent snapshot of the system at the time the Event Fired rule executed. Late binding should not be used to capture entity data after message creation.",
      "narration": "",
      "ocrText": "| Late binding in the payload G\n\nTEI Console | Debugger | | |S |\n***k Stage 3(a) -- Transforming the message payload with\nlate binding ***\n\n. co. . Message\nRequest plugin: BankAccountVerificationRequest —\n\npayload\nbeforeSend()\n\nMes 630\nReplaced token <@@ageOfMessageInSeconds@@> with value 3\n\nReturning payload string\n\nra i\n\nA late binding value is a message payload value that cannot be determined until\nright before the message is sent\n\n« Use placeholders (tokens) during payload generation in the Event Fired business rules action\nlogic (event-time)\n\nMessage Request plugin (send-time) may search for and replace such late binding\ntokens with the data values immediately before the message is sent out",
      "ocrWordCount": 110,
      "ocrConfidence": 87.03,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 12,
      "title": "Event Fired rule set hierarchy structure",
      "bodyParagraphs": [],
      "originalNotes": "Event Fired rule set hierarchy structure\nBest practice:\nEvery MessageContext is processed by the entire Event Fired rule set. However, each istypically of interest to a small subset of rules. Therefore, you should create a hierarchy to filter MessageContext objects whenever possible.",
      "notes": "Event Fired rule set hierarchy structure\nBest practice:\nEvery MessageContext is processed by the entire Event Fired rule set. However, each istypically of interest to a small subset of rules. Therefore, you should create a hierarchy to filter MessageContext objects whenever possible.",
      "narration": "",
      "ocrText": "| Event Fired rule set hierarchy structure Gi\n\nvo\n\n>a\n\n>\n\na\n\nEver\n\n- CONDITION (nes:\nnt Fired coun\n\nABEF1000 - Vendor Recommendation return messageContext.DestID ==\n‘ABEF2000 - Fraud Check\n\nCONDITION (messageContext : entity.MessageContext):\n\niseeee8\n\nA\n@\nei\nyj\nA\n\n@) © Baerit10 - Added ‘Changed . -\n4) EZ] Baeri111- Field Changed = ____._,_.__\n\nLREF1000 - Legal Case Report nessageContext.Eventllane == \"BankAccountChanged”\n\nMGEF1000 - MessageGenerator\n\nSafe Ordering Demo CONDITION (messageContext : entity.MessageContext) :\n\nPolicyCenter return (messageContext.Root as BankAccount) .isFieldChanged(\"BankName\") or\n(meszageContext.Root as BankAccount) .ieFieldChanged (\"Routingtiumber\") oF\n(messageContext.Root as BankRccount) .isFieldChanged (\"Accountthmber\") oF\n\n(messageContext.Root as BankAccount) .isFieldChanged(\"AccountType\")\n\n* Create a rule hierarchy to filter MessageContext objects\n\n+ First, by destination ID...\n\n* Then, by root entity type...\n\n* Then, by event name...\n\n« Finally, by any other relevant logic, such as fields of interest changed",
      "ocrWordCount": 135,
      "ocrConfidence": 79.68,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 13,
      "title": "Creating a message from MessageContext",
      "bodyParagraphs": [],
      "originalNotes": "Creating a message from MessageContext\nCode example\nLine 25\nmessageContext. Root field is of type Object.\nTo extract information from it, cast object to the appropriate type.\nLine 29\nString payload created using a Gosu template for savings account.\nLine 30\nCreates the message and the rule returns a message object.\n\nXML Modeler and Integration Views could also be used to generate XML or JSON string payloads.",
      "notes": "Creating a message from MessageContext\nCode example\nLine 25\nmessageContext. Root field is of type Object.\nTo extract information from it, cast object to the appropriate type.\nLine 29\nString payload created using a Gosu template for savings account.\nLine 30\nCreates the message and the rule returns a message object.\n\nXML Modeler and Integration Views could also be used to generate XML or JSON string payloads.",
      "narration": "",
      "ocrText": "| Creating a message from MessageContext Gi\n\nACTION (messageContext entity .MessageContext, actions : gw.rules.Action):\n\nmessageContext.Root as BankAccount\n\n—>: var aBankAccount\nvar msg : Message\n\nif (aBankAccount.AccountType == BankAccountType.TC_ SAVINGS) {\nvar payload = BankAccountDataTemplate. renderToString(aBankAccount.ABContact.PublicID, aBankAccount)\n\n—P2s\n—> msg = messageContext.createMessage (payload)\n\n• Be extremely careful about modifying entity data in Event Fired rules and\nmessaging plugin implementations\n« Entity changes in these code locations do not cause the application to run or re-run validation\nor preupdate rules\n• Use rules to perform only the minimal data changes necessary for integration code\n* Only change fields that are not modifiable from the user interface\n\n+ For example, you might set custom data model extension flags only used by messaging code",
      "ocrWordCount": 120,
      "ocrConfidence": 88.73,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 14,
      "title": "Deploy code changes",
      "bodyParagraphs": [],
      "originalNotes": "Deploy code changes\nYou can restart the server from Studio by stopping a running server and after the server stops, then starting the server again in either Run or Debug mode (preferred for training).",
      "notes": "Deploy code changes\nYou can restart the server from Studio by stopping a running server and after the server stops, then starting the server again in either Run or Debug mode (preferred for training).",
      "narration": "",
      "ocrText": "| Deploy code changes Gi\n_—RestartServer Reload Changed Classes\n\n• Create a rule hierarchy (parent rule • Newly created and modified event\nand then children rules) fired rules\n\nTools VCS Window Help\nD Run ‘Server’\n\nEYE Tools VCS Window Help W Debug ‘Server’\n\nD> Run ‘Server’ Shift+F10 fe aeuneSesveeguath Coveraae)\n\nbe Run ‘Server’ with Coverage WE Debus...\n\nD Run... Alt+Shift+F10 yy Attach to Local Process...\n\nWE Debug... Alt+Shift+F9 [> Edit Configurations...\n\nAy Attach to Local Process... 2B] Import Test Results\n\n[> Edit Configurations... Il Stop ‘Server’\n\n] Import Test Results > EF Show Running List\n| Stop ‘Server’ Ctrl+ F2 Stop B P",
      "ocrWordCount": 103,
      "ocrConfidence": 79.14,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 15,
      "title": "Demonstration",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "| Demonstration G\n\nExamine event fired rules\n\nclick here\n\nNote: The demonstration opens a new tab in your browser. When the demonstration ends, the\noriginal course launch window appears. Return to this window to continue this presentation.",
      "ocrWordCount": 37,
      "ocrConfidence": 95.68,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_instruction",
      "demoVideoIndex": 0
    },
    {
      "slideNumber": 16,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": false,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_video"
    },
    {
      "slideNumber": 17,
      "title": "Question",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question G\n_- — Why must an Event Fired rule cast the MessageContext Root object?\n•\nSe Soe Se sees esse ese",
      "ocrWordCount": 24,
      "ocrConfidence": 69.18,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "Why must an Event Fired rule cast the MessageContext Root object?",
        "answer": "MessageContext.Root is of type Object, but message payloads typically need to work\nwith the MessageContext.Root as the type of entity that triggered the message event.\nTherefore, the MessageContext.Root entity must be cast to be of that type."
      }
    },
    {
      "slideNumber": 18,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer Gi\n_- — Why must an Event Fired rule cast the MessageContext Root object?\n•\n•\nMessageContext.Root is of type Object, but message payloads typically need to work\nwith the MessageContext.Root as the type of entity that triggered the message event.\nTherefore, the MessageContext.Root entity must be cast to be of that type.\nSoo eS oe ese Sse ese",
      "ocrWordCount": 61,
      "ocrConfidence": 84.78,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 19,
      "title": "Key Takeaways",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Lesson\nobjectives • Create messages in Event Fired rules\n\nreview • Describe the role that message payloads play\nin messaging",
      "ocrWordCount": 20,
      "ocrConfidence": 90.6,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives_review"
    },
    {
      "slideNumber": 20,
      "title": "Student Exercise",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "| Student exercise\n\nConfigure event fired rules",
      "ocrWordCount": 7,
      "ocrConfidence": 95.62,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "exercise"
    }
  ],
  "videos": [
    {
      "index": 1,
      "filename": "In_13_01.mp4",
      "path": "/academy/guidewire/videos/ch11/In_13_01.mp4"
    }
  ],
  "hasNotes": true,
  "hasTables": false,
  "hasImages": true,
  "ocrMetadata": {
    "totalWords": 1312,
    "avgConfidence": 84.84,
    "extractedAt": "2026-02-15T18:21:43.383095"
  }
}
