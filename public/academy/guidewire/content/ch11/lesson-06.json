{
  "lessonId": "ch11-l06",
  "chapterId": 11,
  "chapterSlug": "ch11",
  "lessonNumber": 6,
  "title": "XML Modeler and Strongly Typed XML",
  "sourceFile": "XML Modeler and Strongly Typed XML.pptx",
  "sourceFolder": "In_Integration_06",
  "totalSlides": 33,
  "estimatedMinutes": 99,
  "slides": [
    {
      "slideNumber": 1,
      "title": "XML Modeler and Strongly Typed XML",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "XML Modeler and Strongly Typed XML",
      "ocrWordCount": 6,
      "ocrConfidence": 95.71,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "title"
    },
    {
      "slideNumber": 2,
      "title": "Learning Objectives",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Lesson\nobjectives • Describe key XML concepts— XML elements,\n\nXSD, and Serialization\n\n• Import and export strongly typed XML using\nGosu and an XSD\n\n« Use XML models to extract data in XML\nformat\n\n« Use XML Modeler to create XML models",
      "ocrWordCount": 42,
      "ocrConfidence": 90.29,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives"
    },
    {
      "slideNumber": 3,
      "title": "XML Review",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "XML Review",
      "ocrWordCount": 2,
      "ocrConfidence": 95.5,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 4,
      "title": "XML: Review",
      "bodyParagraphs": [],
      "originalNotes": "XML: Review\nExtensible Markup Language (XML) is a hierarchy data structure designed to transportand store data In XML, it is illegal to omit the closing tag. All elements must have a closing tag, except for the XML declaration tag.\n\nXML tags are case sensitive. Opening and closing tags mustbe written with the same case. Another word for tags is elements. All XML elements must be properly nested within each other. XML must contain one element that is the parent of all other elements. This element is called the root element. XML elements can have attributes in name/value pairs. The attribute values must always be quoted.\n\nIn XML, there are five predefined entities representing special characters. XML requires that you replace these characters with a named references. The five characters are:\n\" — double quotation mark\n& — ampersand\n' — apostrophe\n< — less than sign\n> — greater\n\nFor more information on the Extensible Markup Language, refer to the World Wide Web Consortium web page http://www.w3-orgD(ML-",
      "notes": "XML: Review\nExtensible Markup Language (XML) is a hierarchy data structure designed to transportand store data In XML, it is illegal to omit the closing tag. All elements must have a closing tag, except for the XML declaration tag.\n\nXML tags are case sensitive. Opening and closing tags mustbe written with the same case. Another word for tags is elements. All XML elements must be properly nested within each other. XML must contain one element that is the parent of all other elements. This element is called the root element. XML elements can have attributes in name/value pairs. The attribute values must always be quoted.\n\nIn XML, there are five predefined entities representing special characters. XML requires that you replace these characters with a named references. The five characters are:\n\" — double quotation mark\n& — ampersand\n' — apostrophe\n< — less than sign\n> — greater\n\nFor more information on the Extensible Markup Language, refer to the World Wide Web Consortium web page http://www.w3-orgD(ML-",
      "narration": "",
      "ocrText": "| XML: Review\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n636\n\n<?xml version=\"1.0\"?>\n\n<config xmlns=\"http://guidewire.com/config\">\n<param name=\"CurrencyURL\" value=\"\">http://acme.x.com</param>\n<database name=\"TADatabase\" dbtype=\"h2\" autoupgrade=\"true\">\n<param name=\"jdbcURL\" value=\"jdbce:h2:file:ta/db/ta\"/>\n<param name=\"jdbcURLtest\" value=\"jdbc:h2:file:ta/db/test\"/>\n<param name=\"stmtPool.enabled\" value=\" false\"/>\n</database>\n<security sessiontimeoutsecs=\"10800\"/>\n\n</config>\n\nExtensible Markup Language (XML) is a hierarchy\ndata structure designed to transport and store data",
      "ocrWordCount": 53,
      "ocrConfidence": 89.92,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 5,
      "title": "XML elements",
      "bodyParagraphs": [],
      "originalNotes": "XML elements\nAs discussed on the previous slide, another word for XML tags is elements.\nXML elements have:\nA case sensitive name\nAn opening and closing declaration\nOne or more optional attribute namefvalue pairs\nContents can be Empty, have Text, and/or Child elements\nLine 3 is Text\nLine 4 is Children (5-\n7)\nLine 10 is Empty.\n\nBelow, you will find some more examples of the various types of contents that an XML element can contain:\n1. Simple value — The contents of the following <greeting 1> element is the simple text value \"Hello\": <greeting>He110</greeting>\n2. One or more child elements — The contents of the following <greeting />element is two <greetingText\n/>elements:\n<greeting>\n<greetingText\ngText>\n<greetingText\nlang=\"fr_FR\">Bonjour</greeti\nngText>\n</greeting>\n3. Mixed complex content - There is both text and an inner <custom 1> element within the <greetingText element\n<greetingText\nlang=\"fr_FR\">Bonjour<custom>kiss on each side of face<custom></greetingText> 4. Nothing — The following \"greeting\" element has no contents (even though it has attribute): <greeting (Latin)\"/>",
      "notes": "XML elements\nAs discussed on the previous slide, another word for XML tags is elements.\nXML elements have:\nA case sensitive name\nAn opening and closing declaration\nOne or more optional attribute namefvalue pairs\nContents can be Empty, have Text, and/or Child elements\nLine 3 is Text\nLine 4 is Children (5-\n7)\nLine 10 is Empty.\n\nBelow, you will find some more examples of the various types of contents that an XML element can contain:\n1. Simple value — The contents of the following <greeting 1> element is the simple text value \"Hello\": <greeting>He110</greeting>\n2. One or more child elements — The contents of the following <greeting />element is two <greetingText\n/>elements:\n<greeting>\n<greetingText\ngText>\n<greetingText\nlang=\"fr_FR\">Bonjour</greeti\nngText>\n</greeting>\n3. Mixed complex content - There is both text and an inner <custom 1> element within the <greetingText element\n<greetingText\nlang=\"fr_FR\">Bonjour<custom>kiss on each side of face<custom></greetingText> 4. Nothing — The following \"greeting\" element has no contents (even though it has attribute): <greeting (Latin)\"/>",
      "narration": "",
      "ocrText": "| XML elements\n\nOI HUVsrwW\n\n10\n\n<param name=\"CurrencyURL\" value=\"\">http://acme.x.com</param>\n<database name=\"TADatabase\" dbtype=\"h2\" autoupgrade=\"true\">\n<param name=\"jdbcURL\" value=\"jdbc:h2:file:ta/db/ta\"/>\n<param name=\"jdbcURLtest\" value=\"jdbc:h2:file:ta/db/test\"/>\n<param name=\"stmtPool.enabled\" value=\" false\"/>\n</database>\n\n<security sessiontimeoutsecs=\"10800\"/>\n\nXML elements have:\n\n« Acase sensitive name\n\n* An opening and closing declaration\n\n* One or more optional attribute name/value pairs\n\nContents can be Empty, have Text, and/or Child elements\n• Line 3 is Text\n\n• Line 4 is Children (5-7)\n\n* Line 10 is Empty",
      "ocrWordCount": 72,
      "ocrConfidence": 85.08,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 6,
      "title": "XML element class",
      "bodyParagraphs": [],
      "originalNotes": "XML element class\nThe XmlElement class lets developers interact with XML inan object-oriented manner. Instead of modifying text data in an XML file, developers can simply manipulate XmlElement objects\n\nYou can read in XML data from a file or other sources and parse it into a graph of XML elements. Other sources include data that is of the type java.io.lnputStream , java.lang. String, an array of bytes, java.io. Reader, and java.net.URL.\n\nYou can export a graph of XML elements as standard XML, for example as an array of bytes containing XML data.",
      "notes": "XML element class\nThe XmlElement class lets developers interact with XML inan object-oriented manner. Instead of modifying text data in an XML file, developers can simply manipulate XmlElement objects\n\nYou can read in XML data from a file or other sources and parse it into a graph of XML elements. Other sources include data that is of the type java.io.lnputStream , java.lang. String, an array of bytes, java.io. Reader, and java.net.URL.\n\nYou can export a graph of XML elements as standard XML, for example as an array of bytes containing XML data.",
      "narration": "",
      "ocrText": "| XML element class\n\n1\n2\n3\n4\n\n<?xml version=\"1.0\"?>\n\n<config xmlns=\"http://guidewire.com/config\">\n<param name=\"CurrencyURL\" value=\"\">http://acme.x.com</param>\n<database name=\"TADatabase\" dbtype=\"h2\" autoupgrade=\"true\">\n\nv\n\n<config...>\n\n<param...>\n\n<database...>\n\nRepresent elements from XML\nImport XML\n\nGet information about each\nelement\n\nCreate and modify elements\nExport XML",
      "ocrWordCount": 40,
      "ocrConfidence": 92.32,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 7,
      "title": "XSD (XML Schema Definition)",
      "bodyParagraphs": [],
      "originalNotes": "XSD (XML Schema Definition)\nXSD is a file format that defines the structure for XML, in an XML- like format.",
      "notes": "XSD (XML Schema Definition)\nXSD is a file format that defines the structure for XML, in an XML- like format.",
      "narration": "",
      "ocrText": "| XSD (XML Schema Definition) G\n\n1\n2\n\n4\n5\n6\n8\n\n12\n13\n14\n90\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<xsd:schema xmlns:xsd=\"http: //www.w3.org/2001/XMLSchema\" ... >\n<xsd:element name=\"config\" >\n<xsd:complexType>\n<xsd:choice minOccurs=\"1\" maxOccurs=\"unbounded\">\n<xsd:element name=\"param\"\nminOccurs=\"0\" maxOccurs=\"unbounded\"/>\n</xsd:choice>\n</xsd:complexType>\n</xsd:element>\n<xsd:schema/>\n\nAn XSD (XML Schema Definition) describes\n\nthe structure for elements in one or more\n\nXML documents\n\n• Informs how an XML document can be structured ell\n• Used to validate the structure of a document",
      "ocrWordCount": 75,
      "ocrConfidence": 88.37,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 8,
      "title": "Serialization",
      "bodyParagraphs": [],
      "originalNotes": "Serialization\nSerialization is the process of converting a data structure orobject into a sequence of bits sothat it can be stored in a file or memory buffer, or transmitted across a netvork connection link to be reconstructed later. When the resulting series of bits is reread according to the serialization format, it can be used to create a semantically identical clone of the original object.\n\nSerializing an object is also called deflating or marshaling an object. Deserialization is the opposite operation and refers to extracting a data structure from a series of bytes. Deserializing an object is often called inflating or unmarshaling.\n\nFor some types of values such as integers and strings, the logic needed to serialize the value is fairly straight forward. For types of values such as dates, hexadecimals, and images, the logic can be much more complicated. When working with XML in Gosu, Guidewire makes use of simple value objects. These objects store the value in question and the logic needed to serialize the value. Simple value objects make it easier to work with values that require complex serialization logic.",
      "notes": "Serialization\nSerialization is the process of converting a data structure orobject into a sequence of bits sothat it can be stored in a file or memory buffer, or transmitted across a netvork connection link to be reconstructed later. When the resulting series of bits is reread according to the serialization format, it can be used to create a semantically identical clone of the original object.\n\nSerializing an object is also called deflating or marshaling an object. Deserialization is the opposite operation and refers to extracting a data structure from a series of bytes. Deserializing an object is often called inflating or unmarshaling.\n\nFor some types of values such as integers and strings, the logic needed to serialize the value is fairly straight forward. For types of values such as dates, hexadecimals, and images, the logic can be much more complicated. When working with XML in Gosu, Guidewire makes use of simple value objects. These objects store the value in question and the logic needed to serialize the value. Simple value objects make it easier to work with values that require complex serialization logic.",
      "narration": "",
      "ocrText": "| Serialization G\n\nTOU 01010010 TN\n11001001\n——_—| ——_—\n\nfile.xml 01100100\n\nfile-clone.xml\n\n• XML serialization converts XML elements into a sequence of bits to be later\ndeserialized\n\n• Serialization logic can be complex for certain data types such as hexadecimal\nvalues or images",
      "ocrWordCount": 43,
      "ocrConfidence": 85.57,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 9,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 10,
      "title": "Untyped and strongly typed XML",
      "bodyParagraphs": [],
      "originalNotes": "Untyped and strongly typed XML\nAn XML document can be imported into Guidewire in isolation or through an XSD.\n\nWhen an XML document is imported in isolation, the imported XML is untyped\n\nWhen an XML document is imported through an XSD, the imported XML is strongly typed.\n\nIt is the responsibility of the import code to use the XSD appropriate to a given XML document.",
      "notes": "Untyped and strongly typed XML\nAn XML document can be imported into Guidewire in isolation or through an XSD.\n\nWhen an XML document is imported in isolation, the imported XML is untyped\n\nWhen an XML document is imported through an XSD, the imported XML is strongly typed.\n\nIt is the responsibility of the import code to use the XSD appropriate to a given XML document.",
      "narration": "",
      "ocrText": "| Untyped and strongly typed XML G\n— Untyped = Strongly typed\n\nIf no XSD exists, then the parsed\n\nIf an existing XSD validates and\nXML is untyped\n\ninforms the XML, then the parsed\nXML is strongly typed\n\nIe)\n\n| |\nxso <>,",
      "ocrWordCount": 43,
      "ocrConfidence": 84.62,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 11,
      "title": "Strongly Typed XML",
      "bodyParagraphs": [],
      "originalNotes": "Strongly Typed XML\nIf the XML has an XML Schema Definition (XSD) file, you can create, manipulate, or search data with statically-typed nodes that correspond to legal attributes and child elements One can work with XML documents even when there is no XSD. As we saw earlier, this is Untyped XML. However, using Strongly Typed XML is highly recommended.. If you can provide an XSD file, it dramatically reduces errors due to incorrect types or incorrect structure.\n\nThere is no way to inject an XSD into the type system at run time. The XSD must be known to the application during startup. We will look at how to make an XSD available to Guidewire in the next slide.",
      "notes": "Strongly Typed XML\nIf the XML has an XML Schema Definition (XSD) file, you can create, manipulate, or search data with statically-typed nodes that correspond to legal attributes and child elements One can work with XML documents even when there is no XSD. As we saw earlier, this is Untyped XML. However, using Strongly Typed XML is highly recommended.. If you can provide an XSD file, it dramatically reduces errors due to incorrect types or incorrect structure.\n\nThere is no way to inject an XSD into the type system at run time. The XSD must be known to the application during startup. We will look at how to make an XSD available to Guidewire in the next slide.",
      "narration": "",
      "ocrText": "| Strongly Typed XML G\n\nmy cy\nfile.xsd file.xml\n\n• [fan existing XSD validates and informs the XML, then the parsed XML is strongly\ntyped\n* XML is validated against the XSD during import and export\n* XSD must be known to Guidewire\n* XSD parses the XML document",
      "ocrWordCount": 49,
      "ocrConfidence": 84.9,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 12,
      "title": "Making an XSD available to",
      "bodyParagraphs": [],
      "originalNotes": "Making an XSD available to Guidewire\nAll the types from the XSD become native Gosu types, including element types and attributes. All these types appear naturally in the namespace defined by the part of the class hierarchy that you place the XSD im In other words, you put your XSDs side-by-side next to your Gosu classes and Gosu programs.",
      "notes": "Making an XSD available to Guidewire\nAll the types from the XSD become native Gosu types, including element types and attributes. All these types appear naturally in the namespace defined by the part of the class hierarchy that you place the XSD im In other words, you put your XSDs side-by-side next to your Gosu classes and Gosu programs.",
      "narration": "",
      "ocrText": "| Making an XSD available to Guidewire Gi\n\n. : : [ilProject |\nconfiguration.gsre Soa vation\n« Put the XSD file in any subdirectory of gsrc & Epconfig\n&@- Ei deploy\n• Subdirectories become part of the package name - Diete\n@- Bgsre\n• There is no way to inject an XSD into the El acme\ntype system at run time ° ames\n* The XSD must be known to the application during Oe es\nstartup be\n. . Pry @- [y TestesP\nVarious definitions cause Gosu ae | N\nto create new types i) [Ey base XSD\n= FE] demo\n+ <xsd:element /> bpd el\n* <xsd:complexType /> SE\n\n* <xsd:attribute />",
      "ocrWordCount": 113,
      "ocrConfidence": 71.61,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 13,
      "title": "Parsing a strongly typed XML file",
      "bodyParagraphs": [],
      "originalNotes": "Parsing a strongly typed XML file\nCode example\nLine 6\n• The XML file is parsed.\nLines 10-11\nAn example of a Child element vs an XmlElement property.\nLine 14\nArrays are represented as a collection of Entry elements.\n\nFor XSD-based XML elements, Gosu checks how well-formed is the XML in terms of structural errors and validates the XML using theXSD. If the XML is not valid or well formed, Gosu will throw an XmlExceptiom\n\nThe main class that represents an XML element is the class XmlElement. An XmlElement object encapsulates the following core:\nThe element name as a qualified name (QName)\nA backing type instance\nThe nillness of the element\n\nGosu prevents ambiguity by requiring the special properties of the XmlElement class to have a dollar sign prefix only if the element is XSD-based- To access the children of an XSD-based element, use the syntax element.SChildren for the Children property- To access a custom child element named Children as defined by the XSD, use the syntax element. Children.\nIt is important to understand that property names on anXML element include a dollar sign prefix only if the XML element is an XSD type- If you create an XmlElement element directly, it is not an XSD type- It is an untypednode that uses the default type instance which is an instance of the type Any Type. For non-XSD type, there is no need to use the dollar sign prefix because there is no ambiguity between properties that are really part of the type instance, rather than on the XSD type.\nThe following are\nXmlElement property names\nthat appear with S.\n$AttributeNames\n$Children\n$lass\n$omment\n$DeclaredNamespace\n$lntrinsicType\n$MixedContent - only for\nelements with an XSD-\ndefined mixed content (tags\nwithin text and tags)\n$Namespace\n$NamespaceContext\n$Nil - only for XSD-defined\nnillable elements-\n$QName\n$impleVaIue\n$Text\n$Typelnstance\n$Value - only for elements\nwith an XSD-defined simple\ncontent",
      "notes": "Parsing a strongly typed XML file\nCode example\nLine 6\n• The XML file is parsed.\nLines 10-11\nAn example of a Child element vs an XmlElement property.\nLine 14\nArrays are represented as a collection of Entry elements.\n\nFor XSD-based XML elements, Gosu checks how well-formed is the XML in terms of structural errors and validates the XML using theXSD. If the XML is not valid or well formed, Gosu will throw an XmlExceptiom\n\nThe main class that represents an XML element is the class XmlElement. An XmlElement object encapsulates the following core:\nThe element name as a qualified name (QName)\nA backing type instance\nThe nillness of the element\n\nGosu prevents ambiguity by requiring the special properties of the XmlElement class to have a dollar sign prefix only if the element is XSD-based- To access the children of an XSD-based element, use the syntax element.SChildren for the Children property- To access a custom child element named Children as defined by the XSD, use the syntax element. Children.\nIt is important to understand that property names on anXML element include a dollar sign prefix only if the XML element is an XSD type- If you create an XmlElement element directly, it is not an XSD type- It is an untypednode that uses the default type instance which is an instance of the type Any Type. For non-XSD type, there is no need to use the dollar sign prefix because there is no ambiguity between properties that are really part of the type instance, rather than on the XSD type.\nThe following are\nXmlElement property names\nthat appear with S.\n$AttributeNames\n$Children\n$lass\n$omment\n$DeclaredNamespace\n$lntrinsicType\n$MixedContent - only for\nelements with an XSD-\ndefined mixed content (tags\nwithin text and tags)\n$Namespace\n$NamespaceContext\n$Nil - only for XSD-defined\nnillable elements-\n$QName\n$impleVaIue\n$Text\n$Typelnstance\n$Value - only for elements\nwith an XSD-defined simple\ncontent",
      "narration": "",
      "ocrText": "| Parsing a strongly typed XML file\n\nPaul Monroe [Sj\n\nHas Children? = false\nHas Child Elements? = true\n\n* Syntax to call the parse method on the XSD type: i sy ane ta conade cr\n\n2121 W. Camden Drive Suite 17 Los Angeles CA\n\n* xsdFileName.rootElement.parse (xmlToParse) A\n\n+ xsdFileName: fully qualified name\n+ rootElement: the XSD root element\nDeclared elements and\n\nattributes in the XSD are\navailable as Gosu types\n\n+ Use dot notation to reference the\nelement types and attributes\n\nuses java.io.File\nuses demo.ta.xml.policyholder.PolicyHolder\n\nvar file = new File(\"./training/policyholder.xml\")\nvar xml = PolicyHolder.parse(file)\n\nprint (xml. FullName +\n+ \"Has Children? = \" + xml.Children + \"\\n\"\n+ \"Has Child Elements? = \" + xml.$Children.HasElements\n\nss entry\nvar addresses = xml.AllAddresses.Entry\naddresses.each(\\addr -> print (addr.AddressLine1\n+ (addr.AddressLine2 == null 2? \"\" : \" \" + addr.AddressLine2)\n+\" \" + addr.city\n+\" \" + addr. State)",
      "ocrWordCount": 147,
      "ocrConfidence": 85.24,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 14,
      "title": "Generate XML using an XSD",
      "bodyParagraphs": [],
      "originalNotes": "Generate XML using an XSD\nCode example\nLine 4\nFully qualified name and root element.\nLine 10\nCreate XML object using an XSD.\nLine 14\nConfigure serialization options.",
      "notes": "Generate XML using an XSD\nCode example\nLine 4\nFully qualified name and root element.\nLine 10\nCreate XML object using an XSD.\nLine 14\nConfigure serialization options.",
      "narration": "",
      "ocrText": "| Generate XML using an XSD Gi\n\n• Syntax to use an XSD to generate XML:\n\n1 uses gw.api.database.Query\n2 uses gw.api.database.Relop\n\n« xsdFileName: fully qualified name 3 uses gw.xml.XmlSerializationOptions\n—> < uses trainingapp.demo.xsd.policyholder.PolicyHolder\n\n* new xsdFileName.rootElement\n\n+ rootElement: the XSD root element\nvar queryObj = Query.make(ABPerson)\n\n• Declared elements and attributes 7 queryOb}.compare (ABPerson#PublicID, Relop.Equals, \"ab:98\")\n. . -ryObj. select () .AtMostOneRow\nin the XSD are available as a\n\nGosu types —pit0 ;\n11 xml.FullName = targetPerson.DisplayName\n\n+ Use dot notation to reference the 12 ym) .EmailAddressi = targetPerson.EmailAddressi\nelement types and attributes —p var sOpts = new XnlSerializationOptions() {\n\n:Sort = false,\n16 :Validate = false\n\n<?xml version=\"1.0\"2>\n<PolicyHolder xmlns=\"http: //acmePolicyPerson/ab/gx/sa.\n\n<fullName>Eric Andy</FullName> a7 }\n<EmailAddress1>eandy@albertsons.com</EmailAddress1> 8 //\n</Policy#older> 19 var payload = xml.asUIFString(sOpts)\n\n20 print (payload)",
      "ocrWordCount": 129,
      "ocrConfidence": 81.13,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 15,
      "title": "XML Modeler",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "XML Modeler",
      "ocrWordCount": 2,
      "ocrConfidence": 95.5,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 16,
      "title": "XML model",
      "bodyParagraphs": [],
      "originalNotes": "XML model\nXML models offer an easy and powerful way to serialize a datamodel entity instance, or certain Gosu or Java objects into an XML Document. It's cheap, easy, configurable, and performs quite well (with some minor tweaks) making XML models an excellent tool for generating XML for messaging integrations. The diagram above represents the input and output for an XML model. The input is a single entity, and the output is XML with values from the entity or entities related to it.\n\nThere are several benefits to using a Guidewire XML modelincluding the following:\nNo need to manually create\n XML\nReduces potential for error\nEasy to change XSD when requirements change\nPublishes XSD under a URL\nDefinitions are formalized\nConcrete artifact produced beyond documentation Allows for parallel development with same understanding\nObject model created from your definitions\nCan be used at runtime to automatically generate a message payload\nOptionally generate only if entity fields have changed\nMaps Gosu data entities, Gosu classes, and Javaclasses",
      "notes": "XML model\nXML models offer an easy and powerful way to serialize a datamodel entity instance, or certain Gosu or Java objects into an XML Document. It's cheap, easy, configurable, and performs quite well (with some minor tweaks) making XML models an excellent tool for generating XML for messaging integrations. The diagram above represents the input and output for an XML model. The input is a single entity, and the output is XML with values from the entity or entities related to it.\n\nThere are several benefits to using a Guidewire XML modelincluding the following:\nNo need to manually create\n XML\nReduces potential for error\nEasy to change XSD when requirements change\nPublishes XSD under a URL\nDefinitions are formalized\nConcrete artifact produced beyond documentation Allows for parallel development with same understanding\nObject model created from your definitions\nCan be used at runtime to automatically generate a message payload\nOptionally generate only if entity fields have changed\nMaps Gosu data entities, Gosu classes, and Javaclasses",
      "narration": "",
      "ocrText": "| XML model\n\nmnt vereione\"1.0°2>\n‘BankAccount. mminse\"hetp://guidevire,con/ab/qn/trainingapp nessaging bank, bankaccountuminodel”>\nR < > <AecountType>\n\n<Description>Checking</Description>\n\n</aecountType>\n<Bankllane>ROME Credit Union</Bankliane>\ncta| ‘<Routingliumber>123-939•/Routinglfumber>\n\n<aBContact>\n\n<PublicID>ab: 98</PublicID>\n</aBContact>\n\n« An XML (GX) model generates dynamic XML based on an input object\n• Accepts a single input object and can specify:\n* XML-formatted values from that object\n* XML-formatted values from related objects\n• Use model anytime XML must be generated\n\n+ Message payload, web service data, etc",
      "ocrWordCount": 74,
      "ocrConfidence": 76.89,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 17,
      "title": "XML model base types",
      "bodyParagraphs": [],
      "originalNotes": "XML model base types\nIt is possible to export business data entities, Gosu class data, and other types to a standard Guidewire XML format. It is also possible to select which properties to map in your XML model. For more information, see the topic, \"The Guidewire XML Model\" in the product documentation.",
      "notes": "XML model base types\nIt is possible to export business data entities, Gosu class data, and other types to a standard Guidewire XML format. It is also possible to select which properties to map in your XML model. For more information, see the topic, \"The Guidewire XML Model\" in the product documentation.",
      "narration": "",
      "ocrText": "| XML model base types\n\n« Each model has a base type, which determines:\n* The type of object you must pass to the model\n\n* The data you can include in the model\n\n* Properties ° Properties ° Properties\ne Virtual e Seen as\ne Database getProperty\nbacked method\ne Related\n\nentities",
      "ocrWordCount": 53,
      "ocrConfidence": 86.57,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 18,
      "title": "XML Modeler editor",
      "bodyParagraphs": [],
      "originalNotes": "XML Modeler editor\nAutomatic Publishing of the\nGenerated XSD\nYou can view the model's XSD from the schema tab. When the Guidewire application is running, the application publishes the XSDat the following URL:http://<hostname>:\naratedPackagePathToModel>/<M odelName>.gx- For example, the bank account XML model is named \"BankAccountModel\" andit is stored in the trainingapp.xmlmodels package. Therefore, the URL to access the model's XSD is: http://localhost:8880/ab/ws/trai ningapp/xmlmodels/BankAcco untModel.gx Other applications can import this XSD and validate any generated XML against this XSD\n\nFor more information, see the topic, The Guidewire XML (GX)Modeler in the product documentation.",
      "notes": "XML Modeler editor\nAutomatic Publishing of the\nGenerated XSD\nYou can view the model's XSD from the schema tab. When the Guidewire application is running, the application publishes the XSDat the following URL:http://<hostname>:\naratedPackagePathToModel>/<M odelName>.gx- For example, the bank account XML model is named \"BankAccountModel\" andit is stored in the trainingapp.xmlmodels package. Therefore, the URL to access the model's XSD is: http://localhost:8880/ab/ws/trai ningapp/xmlmodels/BankAcco untModel.gx Other applications can import this XSD and validate any generated XML against this XSD\n\nFor more information, see the topic, The Guidewire XML (GX)Modeler in the product documentation.",
      "narration": "",
      "ocrText": "| XML Modeler editor G\n\n@ BankAccountModel.gx * |\n\n• XML Modeler editor = mon\ncreates XML models gL Asa\n\n> ABContac - enti. ASContact\n• File extension is .gx\n\n* Steps to create\n\n1. Create XML model Fields to add, based on input entity\n\n<2 version=\"1.0\"2>\n<BankAccount xmins=\"trainingapp.xmlmodels.bankaccountmodel\">\n\n2. Add fields to the model ~PublictD-javalang Strings PublelD~\n<BankName>java.lang.String</BankName>\n\n3. Use the model to <AccountType>typekey. BankAccountType</AccountType>\ngenerate the XML output “RontingNombersjve ang Sting RowtngNomber>\n<ABContact>\n« Sample XML tab shows <PublicID>java.lang String<PublicID>\n<EmailAddress1>java.lang.String</EmailAddress1>\ngenerated model output <Active>java ang. Boolean</Active>\n\n</ABContact>\n</BankAccount> Sample XM Schema\n([SanpERWE) Scheme |",
      "ocrWordCount": 97,
      "ocrConfidence": 76.41,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 19,
      "title": "Create the XML model",
      "bodyParagraphs": [],
      "originalNotes": "Create the XML model\nIt is common for the list to include multiple types with identical names but different packages. Be sure to choose the correct type in the list during this step. Initially, the model has no fields in it.",
      "notes": "Create the XML model\nIt is common for the list to include multiple types with identical names but different packages. Be sure to choose the correct type in the list during this step. Initially, the model has no fields in it.",
      "narration": "",
      "ocrText": "| Create the XML model G\n\n5 eee * To create a new XML\nGosu Program\nOGneram 5 Model:\n\n‘emmiplate =i GX Model x | |\nSo = 1. Right-click the parent\n[SE GxModel Class to model: k\nD& Web Service Collection _| Search by Name | Project package\n\nInclude non-project classes 2. Select New > GX\nQ BankAccount x Model\n\n3. Specify the Entity\n\n(© = BankAccountDataTemplate (\n(© BankAccountDataTemplate (\n\n+ System will automatically\n\n© & BankAccountEnhancement (t filter\n© % BankAccountEnhancement (trai 3. .\nene 4. Specify a model name\n\nBankAccountModel « Automatic naming is:\n\n[ox] Cancel <entity>Model",
      "ocrWordCount": 101,
      "ocrConfidence": 73.83,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 20,
      "title": "Add fields to the XML model",
      "bodyParagraphs": [],
      "originalNotes": "Add fields to the XML model\nOnly bolded fields can be added to the model including black and green. Typically, unbolded fields represent complex types (such as entities) that cannot be added, but that have subfields that can be added. Green fields are database- backed fields. Black fields are virtual fields. Underlined fields have already been added. Entity fields can be omitted from model, thus they are not defined in the XSD and they are not exported to XML.\nNote that an XML model will make what was once an unbolded field, bold. In the example above, the ABContact field was originally not bold; however, anABContactModel was created and now the ABContact field is bold.\n\nThe field is added to the list of the fields in the right pane and appears in the sample XML in the bottom pane. You can also re-categorize a field (from Key to Normal or vice versa) or remove it. To re- categorize a field, select it in the right pane, click the Recategorize menu button, and select the new category To remove a field, select it in the right pane and click the Remove button. Fields are listed in alphabetic order.\n\nA key property\nDefines a unique identifier for an entity represented in the XML\nAlways exports if that type exports due to changes to that object or a subobject\nTypically used to maintain parent/child relationships of Guidewire entities as represented in the exported XML\nA normal property\nBy default, exported when containing instance is exported\nBy default, null values are not exported\nDefault behavior can be configured (see GXOptions slide in this lesson)\n\nIncluding an XML Model Within Another XML Model\nWhen adding a property to an XML model, you can reference other XML models if the model already exist for that type- For example, suppose there is a type called ABContact, and you have already created an XML model for this type called ABContactModel. Now suppose there is a type BankAccount that includes a property of ABContact, and you want to use ABContactModel to model that data for sending to an external system- As you are editing a new XML model for the type BankAccount, browse to a property on BankAccount where the property type is ABContact. Click Add, then click Normal Property. Studio opens a special dialog box that lets you select among multiple XML models that exist for type ABContact- In this case, click ABContactModel, then click In TrainingApp, the ABContactModel can be found at trainingapp.xmlmodels package.\n\nAfter you add all properties for an XML model, you must generate code that lets you use this XML model in any Gosu code to convert an entity into an XML representation.",
      "notes": "Add fields to the XML model\nOnly bolded fields can be added to the model including black and green. Typically, unbolded fields represent complex types (such as entities) that cannot be added, but that have subfields that can be added. Green fields are database- backed fields. Black fields are virtual fields. Underlined fields have already been added. Entity fields can be omitted from model, thus they are not defined in the XSD and they are not exported to XML.\nNote that an XML model will make what was once an unbolded field, bold. In the example above, the ABContact field was originally not bold; however, anABContactModel was created and now the ABContact field is bold.\n\nThe field is added to the list of the fields in the right pane and appears in the sample XML in the bottom pane. You can also re-categorize a field (from Key to Normal or vice versa) or remove it. To re- categorize a field, select it in the right pane, click the Recategorize menu button, and select the new category To remove a field, select it in the right pane and click the Remove button. Fields are listed in alphabetic order.\n\nA key property\nDefines a unique identifier for an entity represented in the XML\nAlways exports if that type exports due to changes to that object or a subobject\nTypically used to maintain parent/child relationships of Guidewire entities as represented in the exported XML\nA normal property\nBy default, exported when containing instance is exported\nBy default, null values are not exported\nDefault behavior can be configured (see GXOptions slide in this lesson)\n\nIncluding an XML Model Within Another XML Model\nWhen adding a property to an XML model, you can reference other XML models if the model already exist for that type- For example, suppose there is a type called ABContact, and you have already created an XML model for this type called ABContactModel. Now suppose there is a type BankAccount that includes a property of ABContact, and you want to use ABContactModel to model that data for sending to an external system- As you are editing a new XML model for the type BankAccount, browse to a property on BankAccount where the property type is ABContact. Click Add, then click Normal Property. Studio opens a special dialog box that lets you select among multiple XML models that exist for type ABContact- In this case, click ABContactModel, then click In TrainingApp, the ABContactModel can be found at trainingapp.xmlmodels package.\n\nAfter you add all properties for an XML model, you must generate code that lets you use this XML model in any Gosu code to convert an entity into an XML representation.",
      "narration": "",
      "ocrText": "| Add fields to the XML model\n\n(& BankAccountModel.gx\n\n2. Click Add\n\n1. Select field\n\n* Steps to add fields:\n\nFilter Depth: 2\n\nPubliciD - jov\n\nAdd >>\n\n1. Select field remeron nc ver\n\n2. Click Add >> button pene .\n\n3. Select property type\n\n4. Select XML model (if applicable) sbES Esta Lanes\n\n+ Avoid selecting fields multiple levels\n\ndown in an XML model\n\n+ ABContact.AssignedUser.Credential.Active <PublicID>java.lang.String</PublicID>\n. <BankName>java.lang.String</BankName> Co]\n* Create a separate model for the entity <Accounttype>typekey.BankAccountType</AccountType> (Foxe) [He\n\n<AccountNumber>java.lang.String</AccountNumber>\n\n* Sub-object field appear as nested Atzcane Rome\n\n<PublicID>java.lang.String</PublicID>\n\nelement in sample XML <EmailAddress1>java lang String-/EmailAddress1>\n\n<Active>java.lang.Boolean</Active>\n</ABContact>\n\n• Restart the server <BankAccount>",
      "ocrWordCount": 106,
      "ocrConfidence": 81.15,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 21,
      "title": "Generating XML output using XML model",
      "bodyParagraphs": [],
      "originalNotes": "Generating XML output using XML model\nCode example\nLine 10\nXML model instance created.\nLine 11\nString payload created.\n\nAn XML model can format its output as a UTF string or as bytes. In most cases, a UTF string is appropriate. There may be some situations where bytes is preferable, but this is an issue that is complex, implementation- dependent, and beyond the scope of this course. For more information on whether a given XML model should format its output as bytes, consult with your Guidewire technical representative.\n\nNote that the ABContact. EmailAddress1 field did not export because it is null.",
      "notes": "Generating XML output using XML model\nCode example\nLine 10\nXML model instance created.\nLine 11\nString payload created.\n\nAn XML model can format its output as a UTF string or as bytes. In most cases, a UTF string is appropriate. There may be some situations where bytes is preferable, but this is an issue that is complex, implementation- dependent, and beyond the scope of this course. For more information on whether a given XML model should format its output as bytes, consult with your Guidewire technical representative.\n\nNote that the ABContact. EmailAddress1 field did not export because it is null.",
      "narration": "",
      "ocrText": "Generating XML output using XML model Gi\n\n<?xml version=\"1.0\"2>\n<BankAccount. xnlns=\"http: //guidewire.con/al\n\n* Syntax crotictipanecrheniat\n<BankName>First Savings Bank</BankName>\n= <hecountTypereavinge</RecountType>\n* var xml = new modelName.modelType (param1) rere henecsesaasasoie noceetunber>\n. -<Routingliunber>225-998•/Routinglunber>\n* modelName: fully qualified name <aBContact>\n<PublicID mnlns=\"netp://guidewize.con/:\n+ i 3: ‘ss as=\"nvtp://guidewire.:\n* modelType: the XML model input type ‘ie\n‘<Activeptruec/Active>\n* var payload = xml.asUTFString aaa\n</aconvact>\n+ Serializes the generated xml object as UTF-encoded </BankAccount>\nstring uses gw.api.database.Query\n\nuses gw.api.database.Relop\nuses trainingapp. xmlmodels.bankaccountmodel.BankAccount\n\nvar queryObj = Query.make(ABPerson)\nqueryOb}. compare (ABPerson#PublicID, Relop.fquals, \"ab:98\")\nvar targetPerson\n\nfor(bankAce in targetPerson.BankAccounts) {\nvar xml = new BankAccount (bankAcc)\nvar payload = xml.asUTFString()\n\nprint (payload)\n,",
      "ocrWordCount": 106,
      "ocrConfidence": 76.1,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 22,
      "title": "Customizing XML model output with",
      "bodyParagraphs": [],
      "originalNotes": "Customizing XML model output with GXOptions\nCode example\nLine 13\nGXOptions are set.\nOutput includes null EmailAddress1 field because Verbose is true.\n\nCustomizing Guidewire Model XML Output (GXOptions)\nEvery XML model has a default one-argument constructor, which is the object on which the model is based- You can use an alternate constructor to add additional options that change XML export behavior- The altemate constructor takes an additional argument of type GXOptions, which stands for Guidewire XML model options. A GXOptions object has these Boolean properties:\nIncremental\nFor normal properties backed by database columns, export properties only if they change.\nWhen the Incremental option is enabled, special behavior exists for key properties (as opposed to normal properties) on the root entity.\nKey properties on the root entity that have not changed are still exported to the GX model. The reason for this behavior is because key properties rarely change value- However, this behavior applies only to the root entity.\nIf a key property in a subobject of the root entity has not changed, the property is not exported to the GX model.\nDetermining whether a property has changed is not always possible- Virtual properties and enhancement properties are not defined in the data configuration file and, as a result, they are not stored in the database- This condition prevents Gosu from determining whether a virtual or enhancement property has changed- In such situations, the setting of the Incremental option is ignored for the property, and the property is exported to the GX model.\nGosu cannot determine whether a property in subobjects of virtual and enhancement properties has changed- Therefore, the Incremental option is ignored for the subobjects and all appropriate properties in the subobjects are exported to the GX model- Default is false.\n Verbose\nExport an XML element for a property even if the value for that property is null.\no Default is false.\n SuppressExceptions\nWhen you use your model to generate XML from an instance of the type, exceptions can occur in some cases. Exceptions can occur because some properties are actually backed by Gosu enhancement property get methods or backed by internal Java code (virtual properties). You can tell Gosu to suppress exceptions during XML generation using the GXOptions option called SuppressException s. After generating XML, you can check whether exceptions occurred using the SHasExceptions property (discussed in a later slide) on the root XML object (the result of the constructor of the type using your model).\nIf you want details of each exception, call the each Exception method, which takes a Gosu block- Your block must take one argument, which is the exception. Gosu calls this block once for each exception. Default is false.",
      "notes": "Customizing XML model output with GXOptions\nCode example\nLine 13\nGXOptions are set.\nOutput includes null EmailAddress1 field because Verbose is true.\n\nCustomizing Guidewire Model XML Output (GXOptions)\nEvery XML model has a default one-argument constructor, which is the object on which the model is based- You can use an alternate constructor to add additional options that change XML export behavior- The altemate constructor takes an additional argument of type GXOptions, which stands for Guidewire XML model options. A GXOptions object has these Boolean properties:\nIncremental\nFor normal properties backed by database columns, export properties only if they change.\nWhen the Incremental option is enabled, special behavior exists for key properties (as opposed to normal properties) on the root entity.\nKey properties on the root entity that have not changed are still exported to the GX model. The reason for this behavior is because key properties rarely change value- However, this behavior applies only to the root entity.\nIf a key property in a subobject of the root entity has not changed, the property is not exported to the GX model.\nDetermining whether a property has changed is not always possible- Virtual properties and enhancement properties are not defined in the data configuration file and, as a result, they are not stored in the database- This condition prevents Gosu from determining whether a virtual or enhancement property has changed- In such situations, the setting of the Incremental option is ignored for the property, and the property is exported to the GX model.\nGosu cannot determine whether a property in subobjects of virtual and enhancement properties has changed- Therefore, the Incremental option is ignored for the subobjects and all appropriate properties in the subobjects are exported to the GX model- Default is false.\n Verbose\nExport an XML element for a property even if the value for that property is null.\no Default is false.\n SuppressExceptions\nWhen you use your model to generate XML from an instance of the type, exceptions can occur in some cases. Exceptions can occur because some properties are actually backed by Gosu enhancement property get methods or backed by internal Java code (virtual properties). You can tell Gosu to suppress exceptions during XML generation using the GXOptions option called SuppressException s. After generating XML, you can check whether exceptions occurred using the SHasExceptions property (discussed in a later slide) on the root XML object (the result of the constructor of the type using your model).\nIf you want details of each exception, call the each Exception method, which takes a Gosu block- Your block must take one argument, which is the exception. Gosu calls this block once for each exception. Default is false.",
      "narration": "",
      "ocrText": "| Customizing XML model output with GXOptions Gi\n\nSyntax\n\n<oxml version=\"1.0\"2>\n\n<BankAccount xnlns=\"http: //guidewire.com/al\n<PublicID>ab: 4</PublicID>\n<Bankllame>First Savings Bank</Bankllame>\n\n* var xml = new modelName.modelType “<hecountType>savings</AccountType>\n\n<Accountitunber>$54433221</AccountNunber>\n\n(param1,new GXOptions() {:optionl = value}) <Routingliunber>225-999•/RoutingMunber>\n\nAlternate constructor can be used to:\n\n* Incremental: export only those\n\nproperties that have changed\n\n* Verbose: export properties, even\n\nif their value is null\n\n• SuppressExceptions: suppress\n\nexceptions thrown during XML\nconstruction\n\nen\n\n<aBContace>\n<PublicID xmlns=\"hetp://guidewire.cow/é\nsemen <EmailAddresst xsi:nil=\"true” mmlns=\"ht\nnecp://quidewire.\n\n1 uses gw.api.database. Query <Activertrue</Active>\nuses gw.api.database.Relop </Credential>\nuses gw.api.gx.GXOptions </Aasigneddser>\n: <yaBContact>\n4 uses trainingapp.xmlmodels.bankaccount </:,tyxcccunts\n\nvar queryObj = Query.make(ABPerson)\nqueryObj.compare (ABPerson#PublicID, Relop.quels, \"ab:98\")\nvar targetPerson = queryObj.select() .AtMostOneRow\n10 for(bankAcc in targetPerson.BankAccounts) {\nvar xml = new BankAccount (\nbankAcc,\nnew GXOptions() {:Incremental = false, :Verbose = true})\na var payload = xml.asUIFString()\n15 print (payload)\n}",
      "ocrWordCount": 134,
      "ocrConfidence": 78.51,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 23,
      "title": "Optimizing XML model output performance",
      "bodyParagraphs": [],
      "originalNotes": "Optimizing XML model output performance\nCode example\nLines 13-17 and 23\nWhen generating the XML based on a model include GXOptions object.\nOutput only includes the Key property because Incremental is true.\nLines 18-21 and 24\naslJTFString accepts a parameter of type XmlSerializationOptions.\nCreate an instance and set its properties.\nThen call aslJTFString with the options.\nReduces unnecessary caching and sorting of XML models.\n\nSort\nThe element sorting serialization feature ensures that the order of children elements of each element match the XSD. This is particularly important for sequences.\nFor large XML objects with many nested layers, sorting requires a lot of computer resources.\nIf you create your XML objects in the order specified by their sequence definitions, then you can safely turn off sorting during serialization.\nDefault is true.\nValidation\nValidates the XML document against the associated XSD. This feature only has an effect on an element if it is based on an XSD type. If the entire graph of XmlElement objects contains no XSD-based elements, this property has no effect.\nDefault is true.\n\nWhat is Serialization?\nBroadly speaking, serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later- When the resulting series of bits is reread according to the serialization format, it can be used to create a semantically identical clone of the original object.\nSerializing an object is also called deflating or marshaling an object. Deserialization is the opposite operation and refers to extracting a data structure from a series of bytes. Deserializing an object is often called inflating or unmarshaling.\nFor some types of values such as integers and strings, the logic needed to serialize the value is fairly straight fonvard. For other types of values such as dates, hexadecimals, and images, the logic can be much more complicated- When working with XML in Gosu, Guidewire makes use of simple value objects- These objects store the value in question and the logic needed to serialize the value. Simple value objects make it easier to work with values that require complex serialization logic.\n\nFor more information, see the topic, XML Serialization Options Reference and Examples in the Gosu Reference Guide.",
      "notes": "Optimizing XML model output performance\nCode example\nLines 13-17 and 23\nWhen generating the XML based on a model include GXOptions object.\nOutput only includes the Key property because Incremental is true.\nLines 18-21 and 24\naslJTFString accepts a parameter of type XmlSerializationOptions.\nCreate an instance and set its properties.\nThen call aslJTFString with the options.\nReduces unnecessary caching and sorting of XML models.\n\nSort\nThe element sorting serialization feature ensures that the order of children elements of each element match the XSD. This is particularly important for sequences.\nFor large XML objects with many nested layers, sorting requires a lot of computer resources.\nIf you create your XML objects in the order specified by their sequence definitions, then you can safely turn off sorting during serialization.\nDefault is true.\nValidation\nValidates the XML document against the associated XSD. This feature only has an effect on an element if it is based on an XSD type. If the entire graph of XmlElement objects contains no XSD-based elements, this property has no effect.\nDefault is true.\n\nWhat is Serialization?\nBroadly speaking, serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later- When the resulting series of bits is reread according to the serialization format, it can be used to create a semantically identical clone of the original object.\nSerializing an object is also called deflating or marshaling an object. Deserialization is the opposite operation and refers to extracting a data structure from a series of bytes. Deserializing an object is often called inflating or unmarshaling.\nFor some types of values such as integers and strings, the logic needed to serialize the value is fairly straight fonvard. For other types of values such as dates, hexadecimals, and images, the logic can be much more complicated- When working with XML in Gosu, Guidewire makes use of simple value objects- These objects store the value in question and the logic needed to serialize the value. Simple value objects make it easier to work with values that require complex serialization logic.\n\nFor more information, see the topic, XML Serialization Options Reference and Examples in the Gosu Reference Guide.",
      "narration": "",
      "ocrText": "| Optimizing XML model output performance\n\n* To achieve the best performance,\n\nmake sure you use an\n\nXMLSerializationOptions object to turn\n\noff sorting and validation\n\n* Serialization is noticeably faster with\n\nthese options set\n\n<oxml version=\"1.0\"2>\n\n<BankAccount xmlns=\"http://g\n<PublicID>ab: 4</PublicID>\n\n</BankAccount>\n\n3\n\nWir\n\nGi\n\nuses gw.api.database.Query\n\nuses gw.api.database.Relop\n\nuses gw.api.gx.GxOptions\n\nuses gw.xml.XmlSerializationOptions\n\nuses trainingapp. xmlmodels.bankaccountmodel.BankAccount\n\nvar qu -make(ABPerson)\nqueryObj.compare (ABPerson#PublicID, Relop. Equals,\nvar targetPerson = queryObj.select () .AtMostOneRow\n\n\"ab:98\")\n\nvar gx0pts = new GXOptions() {\nIncremental = true,\nhose = true,\n\n:SuppressExceptions = true\n\n}\n\nvar sOpts = new XmlSerializationOptions() {\n:Sort = false,\n:Validate = false\n\n}\n\nvar xml = new BankAccount (bankAcc, gx0pts)\nvar payload = xml.asUTFString(sOpts)\nprint (payload)",
      "ocrWordCount": 111,
      "ocrConfidence": 83.61,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 24,
      "title": "XML models labels",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "| XML models labels\n\nLabels enable an XML model's properties\n\nto be filtered\n\n+ When an instance of the model is created only a\nsubset of its properties are converted to XML\n\n+ Different properties can be included based on context\n\nUse case:\n\n+ System A needs to include the key property and the\n\nABContact normal property called SysA\n\n+ System B needs to include the key property and the four\nBankAccount normal properties called SysB\n\n+ With labels a single XML model can be used\n\nProperties can be assigned multiple labels\n\nMultiple systems use the same property\n\nGi\n\n1. Select field\nKey Property\n\n<< Remove\nRecategorize\n\nEdit Labels\n\n3. Add label(s)\n\nOK Cancel",
      "ocrWordCount": 114,
      "ocrConfidence": 91.15,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 25,
      "title": "Using XML model labels",
      "bodyParagraphs": [],
      "originalNotes": "Using XML model labels\nCode example\nLines 13-23\nCreate variables for GXOptions, serialization options, and labels.\nLines 25-26\nInstantiate the models for both systems using GXOptions and labels.\nLines 27-28\nCreate payloads.\n\nMultiple labels can be combined in a single instance of a GX Model. Referencing the example in the slide, the code for multiple labels would be:\nvar modelAB = new\nBankAccount(bankAccou\nnt, gxOpt, {sysALabels,\nsysBLabels})\n\nThe code for all labels would be:\nvar labelsSysAll =\nBankAccount. Label.defau\nIt label\nvar xmlSysAll = new\nBankAccount(bankAccou\nnt, gxOpt, {sysAllLabels})",
      "notes": "Using XML model labels\nCode example\nLines 13-23\nCreate variables for GXOptions, serialization options, and labels.\nLines 25-26\nInstantiate the models for both systems using GXOptions and labels.\nLines 27-28\nCreate payloads.\n\nMultiple labels can be combined in a single instance of a GX Model. Referencing the example in the slide, the code for multiple labels would be:\nvar modelAB = new\nBankAccount(bankAccou\nnt, gxOpt, {sysALabels,\nsysBLabels})\n\nThe code for all labels would be:\nvar labelsSysAll =\nBankAccount. Label.defau\nIt label\nvar xmlSysAll = new\nBankAccount(bankAccou\nnt, gxOpt, {sysAllLabels})",
      "narration": "",
      "ocrText": "| Using XML model labels G\n\n© Andy\n\n• Add labels to the properties inthe XML = »= ierj0b3 = query. naze B78)\n\nqueryOb}. compare (ABPersonéPublicID, Relop.=quals, \"ab:98\")\nmodel\n\nvar targetPerson = queryObj-Seléct ()-AtiostineRow\n// Output eaci\nfor (bankAce in targetPerson.BankAccounts) {\n\nrialization options, and labels\n\nnsole\n\n• Pass label parameter to the constructor\n\nvar oxopts = new GxOptions() {\n:Incremental = false,\n:Verbose = true,\n:SuppressExceptions = false\n}\n\nvar sOpts = new XmlSerializationOptions() {\n\n<BankAccount xmins=\"http: //guidewire.com/ab,\n<PublicID>ab: 4</PublicID>\n<aBContact>\n<PublicID xnins=\"!\n<EmailAddressi xsi\n\n<Credential>\n<Active>true</Active> Sort = false,\n</Credenvial> :Validate = false\n</AssignedUser> }\nvar labelSysA = BankAccount.Label.Sysa\n\n</aBContact>\n</BankAccount> SysA\n\n<BankAccount xnlns=\"http: //guidewize.com/ab/\n<Accountiumber>S54433221</AccountNumber>\n<AccountType>savings</AccountType>\n<Bankllame>First Savings Bank</BankName>\n<RoutingNumber>225-999</Routinglumber>\n\n<PublictD>ab: 4</PublicID>\n</BankAccount> SysB\n\nvar labelSysB = BankAccount.Label.SysB\n// Create payload and display to console\n\nvar xmlSysA = new BankAccount(bankAcc, gx0pts, {labelSysA})\nvar xmlSysB = new BankAccount(bankAcc, gxOpts, {lebelSysB})\nvar payloadSysA = xmlSysA.asUTFString(s0pts)\n\nvar payloadSysB = xmlSysB.asUTFString(s0pts)\n\nprint (payloadsysA)\n\nprint (payloadSysB)",
      "ocrWordCount": 154,
      "ocrConfidence": 75.73,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 26,
      "title": "XML model properties",
      "bodyParagraphs": [],
      "originalNotes": "XML model properties\nCode example\nLine 12\nA bundle is created in order to demonstrate SShouldSend property. Incremental GXOption and ShouldSend property only evaluate within the context of a\nTransaction.\nLine 15\nThe bank account type was changed to checking so that at least one normal field is changed.\nLine 19\nIncremental GXOption set to true.\nOnly changed field and Key Property are exported.\nLine 26\nXML model properties are evaluated before generating payload.\nXML model properties\nSShouldSend — The ShouldSend property returns true if and only if at least one mapped data model field changed in thelocal database bundle- Although SShouldSend is often associated with using a model in Incremental mode, the behavior of ShouldSend does not change based on the value of the Verbose option or the Incremental option. Also note that SShouldSend can be evaluated only if all properties in the model are data-backed; inclusion of any virtual propertiesof any virtual properties (any black in the model editor) in the model will cause SShouldSend to always be false- When Gosu checks for mapped data model properties that changed, Gosu checks both normal and key properties- Generally speaking, since a key property is supposed to uniquely identify an\nobject, it should never change.\n$HasExceptions — After generating XML, you can check whether exceptions occurred using the SHasExceptions property on the root XML object (the result of the constructor of the type using your model). If you want details of each exception, call the eachException method, which takes a Gosu block- Your block must take one argument, which is the exception. Gosu calls this block once for each exception.",
      "notes": "XML model properties\nCode example\nLine 12\nA bundle is created in order to demonstrate SShouldSend property. Incremental GXOption and ShouldSend property only evaluate within the context of a\nTransaction.\nLine 15\nThe bank account type was changed to checking so that at least one normal field is changed.\nLine 19\nIncremental GXOption set to true.\nOnly changed field and Key Property are exported.\nLine 26\nXML model properties are evaluated before generating payload.\nXML model properties\nSShouldSend — The ShouldSend property returns true if and only if at least one mapped data model field changed in thelocal database bundle- Although SShouldSend is often associated with using a model in Incremental mode, the behavior of ShouldSend does not change based on the value of the Verbose option or the Incremental option. Also note that SShouldSend can be evaluated only if all properties in the model are data-backed; inclusion of any virtual propertiesof any virtual properties (any black in the model editor) in the model will cause SShouldSend to always be false- When Gosu checks for mapped data model properties that changed, Gosu checks both normal and key properties- Generally speaking, since a key property is supposed to uniquely identify an\nobject, it should never change.\n$HasExceptions — After generating XML, you can check whether exceptions occurred using the SHasExceptions property on the root XML object (the result of the constructor of the type using your model). If you want details of each exception, call the eachException method, which takes a Gosu block- Your block must take one argument, which is the exception. Gosu calls this block once for each exception.",
      "narration": "",
      "ocrText": "| XML model properties\n\n• Every model has boolean properties\nspecific to XML models\n\n* $ShouldSend: has at least one Normal\nproperty in the model changed?\n\n+ $HasExceptions: were any exceptions\nthrown while generating the XML?\n\n+ True, even if GXOption SuppressExceptions\nis set to true\n\n<BankAccount xmlns=\"http://guidewire.c\n\n<AccountType>checking</AccountType> <——\n\n<PublicID>ab:4</PublicID>\n</BankAccount>\n\n|\n\nvar queryOb} = Query.make(ABPerson)\nqueryOb}.compare (ABPerson•PublicID, Relop. Equals, \"ab:98\")\nvar targetPerson = queryObj.select () .AtMostOneRow\n\n‘Transaction. run¥#ithNevBundle(\\newBundle -> {\ntargetPerson = newBundle.add(targetPerson)\n\n:SuppressExceptions = false\n\n}\nvar labelSysAl:\n\nBankAccount.Label.default_label\nvar xmlSysAll = new BankAccount(bankAcc, gxOpts, {labelSysAl1})\nif (xmlSysA11.$ShouldSend •• !xmlSysAll.$HasExceptions) {\nvar sOpts = new XmlSerializationOptions() {\n:Sort = false,\n:Validate = false\n,\nvar payloadSysAll = xmlSysAll.asUTFString(sOpts)\nprint (payloadSysAll)",
      "ocrWordCount": 113,
      "ocrConfidence": 82.21,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 27,
      "title": "Deploy code changes",
      "bodyParagraphs": [],
      "originalNotes": "Deploy code changes\nYou can restart the server from Studio by stopping a running server and after the server stops, then starting the server again in either Run or Debug mode (preferred for training).",
      "notes": "Deploy code changes\nYou can restart the server from Studio by stopping a running server and after the server stops, then starting the server again in either Run or Debug mode (preferred for training).",
      "narration": "",
      "ocrText": "| Deploy code changes Gi\n_—RestartServer. Generate XmiClasses\n\nNew XML Model Modified XML Model\n\nTools VCS Window Help Codegen Analyze Refactor Build Run T\nD> Run ‘Server’ Shifts F10 JA. Generate Metadata Classes\nIW, Debug ‘Server’ Shift+F9\n\nGenerate Page Configuration Classes\n\nBea Serre Covers {Generate Permission Classes\nD Run... Alt+Shift+F10 -\n\nG Local Classes\nWE Debug... Alt+ Shift+F9\n\n7m Attach to Local Process...\n[> Edit Configurations...\n\n2] Import Test Results >\n| Stop ‘Server’ Ctrl+F2\n\n® Generate Everything",
      "ocrWordCount": 78,
      "ocrConfidence": 77.46,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 28,
      "title": "Demonstration",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "| Demonstration G\n\nCreate an XML model\n\nclick here\n\nNote: The demonstration opens a new tab in your browser. When the demonstration ends, the\noriginal course launch window appears. Return to this window to continue this presentation.",
      "ocrWordCount": 37,
      "ocrConfidence": 95.62,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_instruction",
      "demoVideoIndex": 0
    },
    {
      "slideNumber": 29,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": false,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_video"
    },
    {
      "slideNumber": 30,
      "title": "Question",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question G\n|dentify if each statement about an XML model is True or False.\n“ A)\nB)\n©)\nD)\nE)\nSe Soe Se sees esse ese\nIt can take any number of input values.\nIt has a published XSD.\nIt can make use of conditional statements and for loops.\nIt can include values from both the object that triggered the message event and objects\nrelated to the triggering object.\nIt can be used only for payload generation",
      "ocrWordCount": 79,
      "ocrConfidence": 89.29,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "|dentify if each statement about an XML model is True or False.",
        "answer": "Aa Identify if each statement about an XML model is True or False. c A) It can take any number of input values. False — XML models always have a single input, which is the object upon which to base the XML to be generated. B) Ithasapublished XSD. True C) It can make use of conditional statements and forloops. False D)_ It can include values from both the object that triggered the message event and objects related to the triggering object. True — XML models can do this by including fields from the related objects in the XML model. E) It can be used only for payload generation False — XML models can be used anywhere."
      }
    },
    {
      "slideNumber": 31,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer Gi\naa Identify if each statement about an XML model is True or False.\nc A) It can take any number of input values. False — XML models always have a single input,\nwhich is the object upon which to base the XML to be generated.\nB) Ithasapublished XSD. True\nC) It can make use of conditional statements and forloops. False\nD)_ It can include values from both the object that triggered the message event and objects\nrelated to the triggering object. True — XML models can do this by including fields from the\nrelated objects in the XML model.\nE) It can be used only for payload generation False — XML models can be used anywhere.\nSoo eS oe ese Sse ese",
      "ocrWordCount": 120,
      "ocrConfidence": 88.55,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 32,
      "title": "Key Takeaways",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Lesson\nobjectives • Describe key XML concepts— XML elements,\nreview XSD, and Serialization\n\n• Import and export strongly typed XML using\nGosu and an XSD\n\n« Use XML models to extract data in XML\nformat\n\n« Use XML Modeler to create XML models",
      "ocrWordCount": 43,
      "ocrConfidence": 90.31,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives_review"
    },
    {
      "slideNumber": 33,
      "title": "Student Exercise",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "| Student exercise G\n\nUse an XML model to generate an XML\nmessage payload\n\nGenerate an XML message payload\nusing an XSD",
      "ocrWordCount": 22,
      "ocrConfidence": 94.57,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "exercise"
    }
  ],
  "videos": [
    {
      "index": 1,
      "filename": "In_06_01.mp4",
      "path": "/academy/guidewire/videos/ch11/In_06_01.mp4"
    }
  ],
  "hasNotes": true,
  "hasTables": false,
  "hasImages": true,
  "ocrMetadata": {
    "totalWords": 2358,
    "avgConfidence": 85.28,
    "extractedAt": "2026-02-15T18:20:12.209904"
  }
}
