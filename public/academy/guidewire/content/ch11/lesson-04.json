{
  "lessonId": "ch11-l04",
  "chapterId": 11,
  "chapterSlug": "ch11",
  "lessonNumber": 4,
  "title": "Bundles and Database Transactions",
  "sourceFile": "Bundles and Database Transactions.pptx",
  "sourceFolder": "In_Integration_04",
  "totalSlides": 54,
  "estimatedMinutes": 162,
  "slides": [
    {
      "slideNumber": 1,
      "title": "Bundles and Database Transactions",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Bundles and Database Transactions",
      "ocrWordCount": 4,
      "ocrConfidence": 95.6,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "title"
    },
    {
      "slideNumber": 2,
      "title": "Learning Objectives",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Lesson\nobjectives\n\n• Describe bundle context\n\nDifferentiate between read-only and writable\nbundles\n\nUtilize API methods for creating and\ncommitting bundles\n\nAdd and/or edit entity instances in a bundle\nReference original values for edited entity\ninstance fields\n\nUnderstand bundle best practices for\nintegration",
      "ocrWordCount": 42,
      "ocrConfidence": 94.86,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives"
    },
    {
      "slideNumber": 3,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 95.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 4,
      "title": "Bundles",
      "bodyParagraphs": [],
      "originalNotes": "Bundles\nIn object-oriented programming, an instance of a class is an object. In database design and modeling, an instance of an entity is a row of data in a database table. In the Guidewire paradigm for integration and configuration, the term entity can express duality of both being a class and a database table. For example, when you create a new instance of a Contact entity using the keyword new in Gosu or Java, not only does the Guidewire application create unique object of the type Contact in memory, but it also allows for the possibility for the object in memory to be inserted as a new row in a database table.\n\nGuidewire configurators and integrators may refer to an entity in a bundle as a database-backed entity, an entity of type entity. KeyableBean, and/or a an entity that implements the KeyableBean delegate- This simply means that the entity is to be inserted into the database when the application commits the bundle.\n\nGosu represents a bundle with the class gw-transaction-Bundle. The Bundle class is a Guidewire class that implements the entity BundleProvider. The Bundle class maintains a graph of objects for the convenience of application code. Bundles can be used to group together a number of entities for transmission to the database. The add method add beans to the bundle. The delete method marks a bean for removal- The commit method invokes a complex procedure that tries to the save the entities in the bundle to the database.",
      "notes": "Bundles\nIn object-oriented programming, an instance of a class is an object. In database design and modeling, an instance of an entity is a row of data in a database table. In the Guidewire paradigm for integration and configuration, the term entity can express duality of both being a class and a database table. For example, when you create a new instance of a Contact entity using the keyword new in Gosu or Java, not only does the Guidewire application create unique object of the type Contact in memory, but it also allows for the possibility for the object in memory to be inserted as a new row in a database table.\n\nGuidewire configurators and integrators may refer to an entity in a bundle as a database-backed entity, an entity of type entity. KeyableBean, and/or a an entity that implements the KeyableBean delegate- This simply means that the entity is to be inserted into the database when the application commits the bundle.\n\nGosu represents a bundle with the class gw-transaction-Bundle. The Bundle class is a Guidewire class that implements the entity BundleProvider. The Bundle class maintains a graph of objects for the convenience of application code. Bundles can be used to group together a number of entities for transmission to the database. The add method add beans to the bundle. The delete method marks a bean for removal- The commit method invokes a complex procedure that tries to the save the entities in the bundle to the database.",
      "narration": "",
      "ocrText": "| Bundles Gi\n\ng\n\naBankAcount\n\naFlagEntry\n\nXN\n\naLegalCase\n\n* To manage database transactions, Guidewire applications group entity instances\nin groups called bundles\n\n• A bundle is an in-memory container for entity instances that represent rows in the\ndatabase\n\n« Includes new entity instances, changed entity instances, and retired entity instances",
      "ocrWordCount": 50,
      "ocrConfidence": 86.57,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 5,
      "title": "Entity instances",
      "bodyParagraphs": [],
      "originalNotes": "Entity instances\nTo view existing entity instances, TrainingApp performs the following steps:\n1) First the system creates an instance from the appropriate generated Java class. The system knows that from the database table.\n2) The data from the row will be loaded into the object instance. Remember, for every column in the database table, there is a field in the corresponding generated\n Java class.\n3) The system will load the entity instance into a bundle.\n4) The system may modify the entity instance if possible. (More on this later)\n5) The system will commit the bundle of changes back to the database.",
      "notes": "Entity instances\nTo view existing entity instances, TrainingApp performs the following steps:\n1) First the system creates an instance from the appropriate generated Java class. The system knows that from the database table.\n2) The data from the row will be loaded into the object instance. Remember, for every column in the database table, there is a field in the corresponding generated\n Java class.\n3) The system will load the entity instance into a bundle.\n4) The system may modify the entity instance if possible. (More on this later)\n5) The system will commit the bundle of changes back to the database.",
      "narration": "",
      "ocrText": "| Entity instances\n\n• Java objects that represent\n\n• To view an existing entity instance —eon\n\nDatabase\n\nab_abcontact\n\ndatabase rows\n\nthe application must read data from —Butingsmeseab_abi78\nthe database and place the entity “®t as\ninstance into a bundle\n\nHealth South ab:73 56\n\n* To modify an existing entity instance the application must:\n\n1.\n\nRead entity instance from the database into the application\nserver\n\nPut them in a bundle\nModify them in the bundle\n\n. Commit the bundle of changes back to the database\n\nGi\n\nApplication Server\n\n= +g\n\nt\n\nGenerated Java class\n\nlo",
      "ocrWordCount": 94,
      "ocrConfidence": 89.11,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 6,
      "title": "How are entity instances read? a",
      "bodyParagraphs": [],
      "originalNotes": "How are entity instances read?\nAccessors are usually much more frequent than queries — a single IJI page may call thousands of accessors.\n\nNote, in the slide above, the term accessor means that there is underlying application code that accesses entity instances from the database.",
      "notes": "How are entity instances read?\nAccessors are usually much more frequent than queries — a single IJI page may call thousands of accessors.\n\nNote, in the slide above, the term accessor means that there is underlying application code that accesses entity instances from the database.",
      "narration": "",
      "ocrText": "| How are entity instances read? a\n\n« Viaa query Database Application Server\nb\n+ Via accessors from an existing entity\ninstance a @S,\n* aBContact.PrimaryAddress Burlingame Saab ab:78 134 > [sz\n+ Returns a single address entity instance “”*\"*°\"* oben ad\nHealth South ab:73 56\n* aBContact.BankAccounts t\n\n+ Returns an array of bank account entity instances\n• But performing a query for every accessor would be far too\n\nexpensive | y\n* Each one is cheap but they add up @\n* The solution is two levels of caching\n\n• The first level is the bundle which represents local cache\n* The second level is the application server global cache\n\nGenerated Java class",
      "ocrWordCount": 115,
      "ocrConfidence": 85.38,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 7,
      "title": "Accessor Flow — claim. Policy",
      "bodyParagraphs": [],
      "originalNotes": "Accessor Flow — claim. Policy\nLet's look at an example. Let’s say we try to access the policy associated with a claim.",
      "notes": "Accessor Flow — claim. Policy\nLet's look at an example. Let’s say we try to access the policy associated with a claim.",
      "narration": "",
      "ocrText": "| Accessor Flow — claim.Policy\nBundle\n(local)\nApp Server\n(global)\n\nNetwork Boundary\n\nDatabase",
      "ocrWordCount": 13,
      "ocrConfidence": 92.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 8,
      "title": "Accessor Flow — claim. Policy (continued)",
      "bodyParagraphs": [],
      "originalNotes": "Accessor Flow — claim. Policy (continued)\nWhen claim. Policy is executed, the local bundle is checked first to see if the Policy entity exists there.",
      "notes": "Accessor Flow — claim. Policy (continued)\nWhen claim. Policy is executed, the local bundle is checked first to see if the Policy entity exists there.",
      "narration": "",
      "ocrText": "| Accessor Flow — claim.Policy (continued)\nBundle\n(local)\nApp Server\n(global)\n\nNetwork Boundary\n\n-_ - lessscsscscsses, |",
      "ocrWordCount": 17,
      "ocrConfidence": 88.31,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 9,
      "title": "Accessor Flow — claim. Policy (continued)",
      "bodyParagraphs": [],
      "originalNotes": "Accessor Flow — claim. Policy (continued)\nIf the Policy is not found in the local bundle, the global cache is checked for that Policy.",
      "notes": "Accessor Flow — claim. Policy (continued)\nIf the Policy is not found in the local bundle, the global cache is checked for that Policy.",
      "narration": "",
      "ocrText": "| Accessor Flow — claim.Policy (continued)\n\nBundle\n(local)\n\nSS\n\nApp Server\n(global)\n\nNetwork Boundary\n\nDatabase",
      "ocrWordCount": 15,
      "ocrConfidence": 92.31,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 10,
      "title": "Accessor Flow — claim. Policy (continued)",
      "bodyParagraphs": [],
      "originalNotes": "Accessor Flow — claim. Policy (continued)\nIf the Policy is still not found, the database is searched for the Policy entity.",
      "notes": "Accessor Flow — claim. Policy (continued)\nIf the Policy is still not found, the database is searched for the Policy entity.",
      "narration": "",
      "ocrText": "| Accessor Flow — claim.Policy (continued)\n\nBundle\n(local)\n\nApp Server\n(global)\n\nNetwork Boundary\n\nDatabase",
      "ocrWordCount": 14,
      "ocrConfidence": 93.47,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 11,
      "title": "Accessor Flow — claim. Policy (continued)",
      "bodyParagraphs": [],
      "originalNotes": "Accessor Flow — claim. Policy (continued)\nIf the Policy is found in the database, it is retrieved back up through the Global cache",
      "notes": "Accessor Flow — claim. Policy (continued)\nIf the Policy is found in the database, it is retrieved back up through the Global cache",
      "narration": "",
      "ocrText": "| Accessor Flow — claim.Policy (continued)\nBundle\n(local)\nApp Server -——\n(global)\n\nNetwork Boundary\n\nDatabase",
      "ocrWordCount": 15,
      "ocrConfidence": 88.56,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 12,
      "title": "Accessor Flow — claim. Policy (continued)",
      "bodyParagraphs": [],
      "originalNotes": "Accessor Flow — claim. Policy (continued)\nand finally into the local cache or bundle.",
      "notes": "Accessor Flow — claim. Policy (continued)\nand finally into the local cache or bundle.",
      "narration": "",
      "ocrText": "| Accessor Flow — claim.Policy (continued)\n\nBundle\n(local)\n\nSN\nAS\n\nApp Server\n(global)\n\nNetwork Boundary\n\nDatabase",
      "ocrWordCount": 16,
      "ocrConfidence": 86.59,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 13,
      "title": "Accessor Flow — claim. Policy (continued)",
      "bodyParagraphs": [],
      "originalNotes": "Accessor Flow — claim. Policy (continued)\nLet's assume another request is made for this same claim-Policy, but from a new bundle.",
      "notes": "Accessor Flow — claim. Policy (continued)\nLet's assume another request is made for this same claim-Policy, but from a new bundle.",
      "narration": "",
      "ocrText": "| Accessor Flow — claim.Policy (continued)\nBundle\n(local)\nApp Server\n(global)\n\nNetwork Boundary\n\n-_ - lessscsscscsso: |",
      "ocrWordCount": 17,
      "ocrConfidence": 87.62,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 14,
      "title": "Accessor Flow — claim. Policy (continued)",
      "bodyParagraphs": [],
      "originalNotes": "Accessor Flow — claim. Policy (continued)\nThe Policy does not exist in the new bundle, but it is found when the global cache is checked.",
      "notes": "Accessor Flow — claim. Policy (continued)\nThe Policy does not exist in the new bundle, but it is found when the global cache is checked.",
      "narration": "",
      "ocrText": "| Accessor Flow — claim.Policy (continued)\n\nBundle\n(local)\n7\n•\nApp Server\n(global)\n\nNetwork Boundary\n\n- - essscoscssess: |",
      "ocrWordCount": 19,
      "ocrConfidence": 83.67,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 15,
      "title": "Accessor Flow — claim. Policy (continued)",
      "bodyParagraphs": [],
      "originalNotes": "Accessor Flow — claim. Policy (continued)\nThen the Policy entity is retrieved up into the local bundle from which the request was made.\n\nUsing and tuning the global cache is out of the scope for the current course. Refer to the product documentation if you need more information about how caching works.",
      "notes": "Accessor Flow — claim. Policy (continued)\nThen the Policy entity is retrieved up into the local bundle from which the request was made.\n\nUsing and tuning the global cache is out of the scope for the current course. Refer to the product documentation if you need more information about how caching works.",
      "narration": "",
      "ocrText": "| Accessor Flow — claim.Policy (continued)\n\nBundle\n(local)\nRl\n4\nApp Server\n(global)\n\nNetwork Boundary\n\n-_ - lessscsscscsso: |",
      "ocrWordCount": 19,
      "ocrConfidence": 82.22,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 16,
      "title": "Bundle types",
      "bodyParagraphs": [],
      "originalNotes": "Bundle types\nA read-only bundle is a bundle that contains entity instances retrieved from the database. This includes both entity instances returned as the result of a query, and entity instances referenced by the foreign key of a related entity when the related entity is in a read-only bundle. The entity instances in a read-only bundle cannot be modified- However, you can copy entity instances from a read-only bundle into a writable bundle. You must copy entity instances to a writable bundle to change entity instances or delete entity instances. In most programming contexts, there is a current bundle that the application has already prepared- Not all writable bundles eventually commit to the database. For example:\nA user might start to make data changes in the user interface but abandon the task\nA user might start to make data changes in the user interface, try to save them, but errors prevent completion; eventually, the user might cancel the action before fixing and completing the action\nA batch process might attempt a database change, but errors prevent completing the action\nA web service call might attempt a database change, but errors prevent completing the action\nA batch process might attempt a database change, but errors prevent\ncompleting the action A web service call might attempt a database change, but errors prevent completing the action\n\nYou can add a read-only entity instance to a writable bundle. You can also add an entity instance to a writable bundle even if the original entity instance is in a writable bundle already. For this action to succeed, the original entity instance must be unmodified- The entity instance must not be newly added, changed, or deleted in its existing bundle. If you try to add a modified entity instance to a new bundle, Gosu throws the exception IllegalBundleTransf erException. To avoid this, be careful not to let the entity instance be modified in more than one bundle.\n\nReferences from a parent to a foreign key or array key cause the referenced entity instance (or entity instances in the case of array keys) to be loaded into the same bundle as the parent. Remember that entity instances need to be in a writable bundle if you intend to change them and persist those changes to the database",
      "notes": "Bundle types\nA read-only bundle is a bundle that contains entity instances retrieved from the database. This includes both entity instances returned as the result of a query, and entity instances referenced by the foreign key of a related entity when the related entity is in a read-only bundle. The entity instances in a read-only bundle cannot be modified- However, you can copy entity instances from a read-only bundle into a writable bundle. You must copy entity instances to a writable bundle to change entity instances or delete entity instances. In most programming contexts, there is a current bundle that the application has already prepared- Not all writable bundles eventually commit to the database. For example:\nA user might start to make data changes in the user interface but abandon the task\nA user might start to make data changes in the user interface, try to save them, but errors prevent completion; eventually, the user might cancel the action before fixing and completing the action\nA batch process might attempt a database change, but errors prevent completing the action\nA web service call might attempt a database change, but errors prevent completing the action\nA batch process might attempt a database change, but errors prevent\ncompleting the action A web service call might attempt a database change, but errors prevent completing the action\n\nYou can add a read-only entity instance to a writable bundle. You can also add an entity instance to a writable bundle even if the original entity instance is in a writable bundle already. For this action to succeed, the original entity instance must be unmodified- The entity instance must not be newly added, changed, or deleted in its existing bundle. If you try to add a modified entity instance to a new bundle, Gosu throws the exception IllegalBundleTransf erException. To avoid this, be careful not to let the entity instance be modified in more than one bundle.\n\nReferences from a parent to a foreign key or array key cause the referenced entity instance (or entity instances in the case of array keys) to be loaded into the same bundle as the parent. Remember that entity instances need to be in a writable bundle if you intend to change them and persist those changes to the database",
      "narration": "",
      "ocrText": "| Bundle types\n\n• Entity instances retrieved from a database\nquery\n\n* Foreign key entity or array key entities\nreferenced by an entity instance in a read-\nonly bundle\n\nr\n\n—>\n=>\n\nJ\n%\n\nGi\n\nEntity instances that are being edited or\nretired in the user interface, an application\nprocess, or in code\n\nEntity instances you intend to create or\nmodify in the database must first exist or be\nadded in a writable bundle\n\nForeign key entity or array key entities\nreferenced by an entity instance already ina\nwritable bundle G mo\n\nv\ng-5",
      "ocrWordCount": 94,
      "ocrConfidence": 90.38,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 17,
      "title": "Bundle context",
      "bodyParagraphs": [],
      "originalNotes": "Bundle context\nA current bundle contains entity instances available to the current code context. The current context includes, but is not limited to, the user interface and plugins. The Guidewire application automatically creates the current bundle in order to create, read, update, and delete data. A current bundle is either read-only or writable depending on the context.\nFor example, the current bundle in the user interface is often read- only until a user edits the page. When a user edits data on the page, the bundle becomes writable. When the user updates or cancels edits to the page, the bundle returns to read-only. A current bundle can be either read-only or writable. Integration developers can reference entities in the current bundle using the API:\ngw.transaction. Transaction.getCurrent.\n\nA new bundle is a bundle created explicitly by integration code. Unlike a read-only bundle, you can modify and commit data in a new bundle. Unlike a current bundle, you can commit a new bundle without having to worry about later interaction occurring in the bundle as might occur in a user interface.",
      "notes": "Bundle context\nA current bundle contains entity instances available to the current code context. The current context includes, but is not limited to, the user interface and plugins. The Guidewire application automatically creates the current bundle in order to create, read, update, and delete data. A current bundle is either read-only or writable depending on the context.\nFor example, the current bundle in the user interface is often read- only until a user edits the page. When a user edits data on the page, the bundle becomes writable. When the user updates or cancels edits to the page, the bundle returns to read-only. A current bundle can be either read-only or writable. Integration developers can reference entities in the current bundle using the API:\ngw.transaction. Transaction.getCurrent.\n\nA new bundle is a bundle created explicitly by integration code. Unlike a read-only bundle, you can modify and commit data in a new bundle. Unlike a current bundle, you can commit a new bundle without having to worry about later interaction occurring in the bundle as might occur in a user interface.",
      "narration": "",
      "ocrText": "| Bundle context Gi\n\n• Application creates current bundle to —*_— Integration code creates bundle\ncreate, read, update, and/or retire explicitly\ndata\n\n* Contains entity instances available\nto the current code context\n\n* Code determines bundle contents\n• New bundles are writable\n\n• Read-only or writable\n\nmm lgrY",
      "ocrWordCount": 48,
      "ocrConfidence": 83.31,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 18,
      "title": "Committing a bundle",
      "bodyParagraphs": [],
      "originalNotes": "Committing a bundle\nGuidewire refers to the process of sending the entities to the database as committing the bundle to the database. If a bundle commit attempt completely succeeds, all database changes happen in a single database transactiom Ifthe commit attempt fails in any way, the entire database update fails and Gosu throws an exception.",
      "notes": "Committing a bundle\nGuidewire refers to the process of sending the entities to the database as committing the bundle to the database. If a bundle commit attempt completely succeeds, all database changes happen in a single database transactiom Ifthe commit attempt fails in any way, the entire database update fails and Gosu throws an exception.",
      "narration": "",
      "ocrText": "| Committing a bundle\n\nBundle\n\n* Commits are transactional\n+ All DB changes occur in a transaction, and succeed or fail as a group\n\n+ A failure of any entity instance in the bundle to successfully commit will cause changes or additions to\nany entity instance in the bundle to be rolled back\n\n+ In most situations bundle commits are automatic unless you are controlling the bundle\n+ Because you created the bundle\n\n* Or you've taken over control of the Current bundle",
      "ocrWordCount": 83,
      "ocrConfidence": 92.56,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 19,
      "title": "Automatic bundle processing",
      "bodyParagraphs": [],
      "originalNotes": "Automatic bundle processing\nA plugin implements an interface with one or more methods. Guidewire application code may invoke the interface methods. The situation in which the plugin is called determine whether the plugin needs to explicitly manipulate a bundle.\n\nFor example, in ClaimCenter, at the end of the first step of the New Claim wizard , the claim number generator plugin is called. There is an explicit commit before the application moves on to the second step. Thus, the claim number generator plugin code does not need to explicitly manipulate any bundle.",
      "notes": "Automatic bundle processing\nA plugin implements an interface with one or more methods. Guidewire application code may invoke the interface methods. The situation in which the plugin is called determine whether the plugin needs to explicitly manipulate a bundle.\n\nFor example, in ClaimCenter, at the end of the first step of the New Claim wizard , the claim number generator plugin is called. There is an explicit commit before the application moves on to the second step. Thus, the claim number generator plugin code does not need to explicitly manipulate any bundle.",
      "narration": "",
      "ocrText": "| Automatic bundle processing\n\nExplicit bundle manipulation is not required\nIn:\n\nBusiness rules\n\nWorkflows\n\nCertain plugins\n\nChanges made through the user Interface\n\nIn the above contexts, bundle manipulation On\nis handled by the application ny\nChanges, Additions, Retires are committed\n\nto the database at an appropriate time\ndepending on context",
      "ocrWordCount": 50,
      "ocrConfidence": 94.1,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 20,
      "title": "Manual bundle processing",
      "bodyParagraphs": [],
      "originalNotes": "Manual bundle processing\nThere are special bundle issues pertaining to web services, batch processes, and certain plugins. These issues are discussed later in the course.",
      "notes": "Manual bundle processing\nThere are special bundle issues pertaining to web services, batch processes, and certain plugins. These issues are discussed later in the course.",
      "narration": "",
      "ocrText": "| Manual bundle processing\n\n* Your code must explicitly manage\nbundles for:\n\n« Web services that make DB changes\n* Batch processes that make DB changes\n\n* Modifications to entities returned from\nqueries\n\n* Certain plugins",
      "ocrWordCount": 36,
      "ocrConfidence": 88.83,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 21,
      "title": "Gosu capabilities with bundles",
      "bodyParagraphs": [],
      "originalNotes": "Gosu capabilities with bundles\nOnly database-backed entities (entities of type entity. KeyableBean) can be added to a bundle. The entity's bundle is available in the Bundle property of the given entity.",
      "notes": "Gosu capabilities with bundles\nOnly database-backed entities (entities of type entity. KeyableBean) can be added to a bundle. The entity's bundle is available in the Bundle property of the given entity.",
      "narration": "",
      "ocrText": "| Gosu capabilities with bundles Gi\n\nCreate new bundles « Remove an entity instance from a bundle\nModify entity instances in writable * Modify entity instances in a read-only\nbundles bundle\n\nIdentify whether an entity instance in a * Copy a newly created entity instance\nbundle has changed since it was read from one bundle to another\n\nfrom the DB + From a bundle perspective new entity\n\nCopy unchanged entity instances from instances are treated as “changed”\n\none bundle to another\n\nCommit a bundle",
      "ocrWordCount": 84,
      "ocrConfidence": 92.31,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 22,
      "title": "Working with bundles",
      "bodyParagraphs": [],
      "originalNotes": "Working with bundles\nAs an Integration developer, you need to be familiar with the coding constructs and syntax of bundles.",
      "notes": "Working with bundles\nAs an Integration developer, you need to be familiar with the coding constructs and syntax of bundles.",
      "narration": "",
      "ocrText": "Working with bundles",
      "ocrWordCount": 3,
      "ocrConfidence": 95.67,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 23,
      "title": "Committing the current bundle",
      "bodyParagraphs": [],
      "originalNotes": "Committing the current bundle\nOften, the current bundle references data that is in the User Interface or the entity instance being used by a plugin. Guidewire web services and batch processes do not have current bundles. If either of these mechanisms needs to create or modify data, then a new bundle must be created.\n\nEvery entity has a bundle property that you can use to access the bundle containing the entity (entity. Bundle).\n\nOnly commit a bundle if you are sure it is appropriate for that programming context. Otherwise you could causes data integrity problems. For example, in Rule sets or PCF code, it is typically dangerous to commit a bundle explicitly. Contact Customer Support if you have questions.",
      "notes": "Committing the current bundle\nOften, the current bundle references data that is in the User Interface or the entity instance being used by a plugin. Guidewire web services and batch processes do not have current bundles. If either of these mechanisms needs to create or modify data, then a new bundle must be created.\n\nEvery entity has a bundle property that you can use to access the bundle containing the entity (entity. Bundle).\n\nOnly commit a bundle if you are sure it is appropriate for that programming context. Otherwise you could causes data integrity problems. For example, in Rule sets or PCF code, it is typically dangerous to commit a bundle explicitly. Contact Customer Support if you have questions.",
      "narration": "",
      "ocrText": "| Committing the current bundle\n\n* gw.transaction.Transaction.getCurrent ()\n* Gets current bundle\n\n* bundle.commit ()\n* Commits every entity instance in the bundle\n\n• Make sure that the Commit is appropriate for the\nprogramming context\n• The Current bundle contains data known to the current context,\n\nsuch as entity instances being presented/changed in the user\ninterface\n\n* Committing data inappropriately can cause data integrity problems\n\nLAY\n\nPLL /\n\nOYG\n\nWR\n\nXY\n\nWA\nWw\n\n9\n\nVY \\",
      "ocrWordCount": 76,
      "ocrConfidence": 85.82,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 24,
      "title": "Create a new bundle: runWithNewBundle",
      "bodyParagraphs": [],
      "originalNotes": "Create a new bundle: runWithNewBundle\nIn some situations, when creating a new bundle there is an inherent user. For example:\nIf bundle code is executed from the IJI, it is executed as the user who triggered the IJI event that runs the code\nIf bundle code is executed from a web service, it is executed as the user specified by the web service call\n\nIn other situations, when creating a new bundle there is no inherent user. For example:\nA web service that requires no authentication and where there may be no user specified in the web service call\nA batch process\n\nIn these situations, you must use the second signature above and specify a user to associate the bundle to.\n\nIn either case, commits in the bundle are limited to what the associated user has permission to do. If the user lacks the needed permissions, then an InsufficientPermissionExcepti on is thrown. For example, if the bundle attempts to commit changes to admin data, but the associated user lacks permission to change admin data, then the commit will fail.\n\nThe runWithNewBundle method inherently commits the bundle at the end of the method. There is no need to explicitly commit data within the runWithNewBundle block.\nNote, if an entity instance exists in a modified form in more than one bundle and both bundles commit, the second commit fails with a concurrent data modification exception.",
      "notes": "Create a new bundle: runWithNewBundle\nIn some situations, when creating a new bundle there is an inherent user. For example:\nIf bundle code is executed from the IJI, it is executed as the user who triggered the IJI event that runs the code\nIf bundle code is executed from a web service, it is executed as the user specified by the web service call\n\nIn other situations, when creating a new bundle there is no inherent user. For example:\nA web service that requires no authentication and where there may be no user specified in the web service call\nA batch process\n\nIn these situations, you must use the second signature above and specify a user to associate the bundle to.\n\nIn either case, commits in the bundle are limited to what the associated user has permission to do. If the user lacks the needed permissions, then an InsufficientPermissionExcepti on is thrown. For example, if the bundle attempts to commit changes to admin data, but the associated user lacks permission to change admin data, then the commit will fail.\n\nThe runWithNewBundle method inherently commits the bundle at the end of the method. There is no need to explicitly commit data within the runWithNewBundle block.\nNote, if an entity instance exists in a modified form in more than one bundle and both bundles commit, the second commit fails with a concurrent data modification exception.",
      "narration": "",
      "ocrText": "| Create a new bundle: runWithNewBundle Gi\n\n* gw.transaction.Transaction.runWithNewBundle(\\ newBundle -> {\n\nodeBloc: Nol\n\n* Create a new bundle, no user specified\n« Requires permissive user credential context\n\n* gw.transaction.Transaction.runWithNewBundle(\\ newBundle -> {\n\nCodeBlock } , user ) <>\nAy\n\n* Create a new bundle with specified user\n• New bundles are always writable\n* tis not necessary or desirable to commit the bundle\n\n« runWithNewBundle block automatically commits the bundle at the end of the method by\ndesign",
      "ocrWordCount": 79,
      "ocrConfidence": 83.81,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 25,
      "title": "runWithNewBundle and new entity instance",
      "bodyParagraphs": [],
      "originalNotes": "runWithNewBundle and new entity instance\nCode example\nLine 4\nNew ABPerson entity instance is created.\n\nFor more information, search using the term, runWithNewBundle in the product documentation.",
      "notes": "runWithNewBundle and new entity instance\nCode example\nLine 4\nNew ABPerson entity instance is created.\n\nFor more information, search using the term, runWithNewBundle in the product documentation.",
      "narration": "",
      "ocrText": "| runWithNewBundle and new entity instance Gi\n\n• Any entity instantiated within the block\ncontext will automatically be added to <+. Ss\nthe bundle belonging to the block, and =>\npersisted to the database at the eé.\nconclusion of the block @\n\ngw. transaction. Transaction. runWithNewBundle(\\ newBundle -> {\n— var newEntity = new ABPerson()\nnewEntity.LastName = \"Jones\"\n}, username)",
      "ocrWordCount": 60,
      "ocrConfidence": 88.05,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 26,
      "title": "Create a new bundle: newBundle",
      "bodyParagraphs": [],
      "originalNotes": "Create a new bundle: newBundle\nCode example\nLine 5\nNew bundle is created\nLine 8\nBundle is saved\nRequires user session context to commit\n\nFor some developers, the block- based API and the implicit commit can be awkward to use. There is a simple method to create a new bundle: var bundle = gw.transactiomTransaction.newB undle\n\nWith this usage, the caller is responsible for committing the bundle (or not), depending on need.",
      "notes": "Create a new bundle: newBundle\nCode example\nLine 5\nNew bundle is created\nLine 8\nBundle is saved\nRequires user session context to commit\n\nFor some developers, the block- based API and the implicit commit can be awkward to use. There is a simple method to create a new bundle: var bundle = gw.transactiomTransaction.newB undle\n\nWith this usage, the caller is responsible for committing the bundle (or not), depending on need.",
      "narration": "",
      "ocrText": "| Create a new bundle: newBundle Gi\n\n* gw.transaction.Transaction.newBundle () <S\n\n* Creates a new bundle\n\nNo code block\n\n« No user, so requires permissive user credential context\n\n« Commit is not automatic\nbundle. commit ()\n\n* Call commit to save a new\nentity instance or changed\nentity instance\n\n>\n\nuses trainingapp.base.QueryUtil\nuses gw.transaction.Transaction\n\nvar targetPerson = QueryUtil.findPerson(\"ab:5\")\nvar newBundle = Transaction. nevBundle()\ntargetPerson = newBundle.add(targetPerson)\ntargetPerson.MiddleName = \"John\"\n\nnewBundle. commit ()",
      "ocrWordCount": 72,
      "ocrConfidence": 86.49,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 27,
      "title": "Copying an entity instance",
      "bodyParagraphs": [],
      "originalNotes": "Copying an entity instance\nCode example\nLine 6\nThe add method returns a handle on the entity as it exists in the new bundle.\nStandard convention is to assign the return value of the bundle.add method to the parameter passed to the add method.\n\nThe entity you copy using the add method can be a read-only or writable entity. The add method is always used to copy an entity instance into a writable or new bundle. Because you must explicitly copy entity instances into the bundle, you have control over which instances get copied and, in turn, which instances get committed to the database.\n\nThe add method returns a handle on the entity as it exists in the new bundle. Standard convention is to assign the return value of the bundle-add method to the parameter passed to the add method. This technique is known as a reference replace. For example: company = currentBundle.add(company). You will no longer have a handle on the entity in the read-only bundle. In the vast majority of cases, this is the preferred method because it's unlikely that you'd want to reference the read- only copy of the entity, and leaving the old handle around can be confusing not to mention a waste of memory.",
      "notes": "Copying an entity instance\nCode example\nLine 6\nThe add method returns a handle on the entity as it exists in the new bundle.\nStandard convention is to assign the return value of the bundle.add method to the parameter passed to the add method.\n\nThe entity you copy using the add method can be a read-only or writable entity. The add method is always used to copy an entity instance into a writable or new bundle. Because you must explicitly copy entity instances into the bundle, you have control over which instances get copied and, in turn, which instances get committed to the database.\n\nThe add method returns a handle on the entity as it exists in the new bundle. Standard convention is to assign the return value of the bundle-add method to the parameter passed to the add method. This technique is known as a reference replace. For example: company = currentBundle.add(company). You will no longer have a handle on the entity in the read-only bundle. In the vast majority of cases, this is the preferred method because it's unlikely that you'd want to reference the read- only copy of the entity, and leaving the old handle around can be confusing not to mention a waste of memory.",
      "narration": "",
      "ocrText": "| Copying an entity instance\n\nol\n\n* Copying entity instance from read-only to writable bundle:\n* origEntity = writableBundle.add(origEntity)\n\n* Copying entity instance into a new bundle: NI YZ <\n\n* origEntity = newBundle.add(origEntity)\n\nto, LEW,\nOe ROY\nSN\n\ncd\n\nWAU\n\nPL Li\nP77\nmam\nq\n-\n\n1 uses trainingapp.base.QueryUtil\n2 uses gw.transaction.Transaction\n\nvar targetPerson = QueryUtil. findPerson(\"ab:5\")\nvar newBundle = Transaction. newBundle()\n——> 6 targetPerson = newBundle.add(targetPerson)\n7 targetPerson.MiddleName = \"John\"\nnewBundle.commit ()",
      "ocrWordCount": 74,
      "ocrConfidence": 77.34,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 28,
      "title": "Query results and Bundles",
      "bodyParagraphs": [],
      "originalNotes": "Query results and Bundles\nThe code example in this screenshot performs three tasks: first, it loads the company called Albertson’s from the database. Then it sets the InspectionRequired field to true, and finally, it sets the InspectionDate field to the current date.\n\nIn line 3, we create a new bundle called newBundle- As you can see, this example uses the block syntax and the block ends in line 19. When the execution reaches this line, the platform will execute an implicit commit with the permissions of the specified user- Notice that the username is not hardcoded in the bundle code. It is best not to hardcode the username in Gosu code - make it configurable instead- Since the transaction will be executed with the permissions of the specified user, it is also best not to use su as the username because super user has all the permissions in the default configuration- Guidewire recommends setting up specific integration users instead who only have permissions to perform specific tasks- This can prevent misuse and security issues later.\n\nLet's look inside the bundle block. In lines 5 through 7,the query loads Albertson’s from the database. Remember that the query results are ALWAYS returned in a read-onty bundle by the Query API. It does not matter where the query is written. In this case the query happens to be inside the bundle block, but that does not make a difference- The result will still be in a read-only bundle. That is why we add the targetCompany to the bundle in line 11- Remember that the add() function makes a copy of the read-only entity instance, puts the copy of the entity in the writable bundle and then returns a reference to the new writable instance. Notice that the code reassigns the targetCompany variable, and after line 11 targetCompany will reference the writable instance instead of the read-only instance.",
      "notes": "Query results and Bundles\nThe code example in this screenshot performs three tasks: first, it loads the company called Albertson’s from the database. Then it sets the InspectionRequired field to true, and finally, it sets the InspectionDate field to the current date.\n\nIn line 3, we create a new bundle called newBundle- As you can see, this example uses the block syntax and the block ends in line 19. When the execution reaches this line, the platform will execute an implicit commit with the permissions of the specified user- Notice that the username is not hardcoded in the bundle code. It is best not to hardcode the username in Gosu code - make it configurable instead- Since the transaction will be executed with the permissions of the specified user, it is also best not to use su as the username because super user has all the permissions in the default configuration- Guidewire recommends setting up specific integration users instead who only have permissions to perform specific tasks- This can prevent misuse and security issues later.\n\nLet's look inside the bundle block. In lines 5 through 7,the query loads Albertson’s from the database. Remember that the query results are ALWAYS returned in a read-onty bundle by the Query API. It does not matter where the query is written. In this case the query happens to be inside the bundle block, but that does not make a difference- The result will still be in a read-only bundle. That is why we add the targetCompany to the bundle in line 11- Remember that the add() function makes a copy of the read-only entity instance, puts the copy of the entity in the writable bundle and then returns a reference to the new writable instance. Notice that the code reassigns the targetCompany variable, and after line 11 targetCompany will reference the writable instance instead of the read-only instance.",
      "narration": "",
      "ocrText": "Query results and Bundles G\n\n——p 3\n\nODIKHUKMS\n\n10\nii\n12\n13\n14\n15\n16\n17\n18s\nme 19\n\ngw.transaction.Transaction. runWithNewBundle(\\newBundle -> {\n\nvar query0bj = gw.api.database.Query.make(ABCompany)\nqueryObj.compare (ABCompany#Name, Equals, \"Albertson's\")\nvar targetCompany = queryOb}.select () .AtMostOneRow\n\n// targetCompany must be copied from read-only bundle\n// to\ntargetCompany = newBundle.add(targetCompany)\n\new bundle\n\n// Set the Inspection fields as appropriate\ntargetCompany.InspectionRequired = true\ntargetCompany.InspectionDate = gw.api.util.DateUtil.currentDate()\n\n// runWithNewBundle() executes an implicit commit; user ca\n// is requ\n\next\n\ned wh\n\nyn none is supplied\n}, username)",
      "ocrWordCount": 85,
      "ocrConfidence": 84.85,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 29,
      "title": "Query results and Bundles (alternative syntax)",
      "bodyParagraphs": [],
      "originalNotes": "Query results and Bundles (alternative syntax)\nLet's look at the same code example using the alternative syntax.\n\nAs you can see, there is no block in the screenshot for the alternative syntax. In line 21, the code creates a writable new bundle using the newBundle() function and stores a reference to the bundle in the newBundle variable. The code uses this variable name in line 29 to copy the target company from the read-only bundle to the writable new bundle. Since there is no block, developers must explicitly commit the bundle. This happens in line 37, by invoking the commit() functiom Remember, when you use this syntax, you cannot specify a user. This code must be executed within a user context, otherwise it will fail. The rest of the code is the same as in the previous example.",
      "notes": "Query results and Bundles (alternative syntax)\nLet's look at the same code example using the alternative syntax.\n\nAs you can see, there is no block in the screenshot for the alternative syntax. In line 21, the code creates a writable new bundle using the newBundle() function and stores a reference to the bundle in the newBundle variable. The code uses this variable name in line 29 to copy the target company from the read-only bundle to the writable new bundle. Since there is no block, developers must explicitly commit the bundle. This happens in line 37, by invoking the commit() functiom Remember, when you use this syntax, you cannot specify a user. This code must be executed within a user context, otherwise it will fail. The rest of the code is the same as in the previous example.",
      "narration": "",
      "ocrText": "Query results and Bundles (alternative syntax) Gi\n\np> 21 var newBundle = gw.transaction.Transaction. newBundle()\n22\n23 var queryObj = gw.api.database.Query.make(ABCompany)\n24 queryObj.compare (ABCompany#Name, Equals, \"Albertson's\")\nyay var targetCompany = queryObj.select () .AtMostOneRow\n26\n27 // targetCompany must be copied from read-only bundle\n28 // to new bundle\n\nmm 29 targetCompany = newBundle.add(targetCompany)\n30\n31 Inspection fields as appropriate\n32 targetCompany.InspectionRequired = true\n33 targetCompany.InspectionDate = gw.api.util.DateUtil.currentDate()\n34\n35 // requires an explicit commit; user c\n\n36 // so it req\n=> 37 newBundle.commit ()\n\nres a service",
      "ocrWordCount": 87,
      "ocrConfidence": 88.63,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 30,
      "title": "Foreign keys and array keys",
      "bodyParagraphs": [],
      "originalNotes": "Foreign keys and array keys\nReferences from a parent entity to a foreign key will cause the referenced entity instances to be loaded into the same bundle as the parent entity instance. If the parent entity instance is in a read-only bundle, the referenced entity instance will be added to the same read-only bundle. If the parent entity instance is in a writable bundle, the referenced entity instance will be added to the same writable bundle. This is also true for array key fields.\n\nIn line 17, the code accesses the primary contact of the target company using the foreign key property. Since we copied targetCompany to the writable bundle in line 11, the primary contact will automatically be added to the same writable bundle, so there is no need to copy it to the bundle.",
      "notes": "Foreign keys and array keys\nReferences from a parent entity to a foreign key will cause the referenced entity instances to be loaded into the same bundle as the parent entity instance. If the parent entity instance is in a read-only bundle, the referenced entity instance will be added to the same read-only bundle. If the parent entity instance is in a writable bundle, the referenced entity instance will be added to the same writable bundle. This is also true for array key fields.\n\nIn line 17, the code accesses the primary contact of the target company using the foreign key property. Since we copied targetCompany to the writable bundle in line 11, the primary contact will automatically be added to the same writable bundle, so there is no need to copy it to the bundle.",
      "narration": "",
      "ocrText": "| Foreign keys and array keys Gi\n\n* References from a parent to a foreign key or array key cause the referenced entity\ninstance(s) to be loaded into the same bundle as the parent\n\nworgVHsYH\n\ngw.transaction. Transaction. runWithNewBundle(\\newBundle -> {\nvar queryObj = gw.api.database.Query.make(ABCompany)\nquery0bj.compare (ABCompany#Name, Equals, \"Albertson's\")\n\nvar targetCompany = query0bj.select () .AtMostOneRow\n\nW/\n\n// to new bundle\ntargetCompany = newBundle.add(targetCompany)\n// Set the In fields as ar ate\n\ntargetCompany.InspectionRequired = true\ntargetCompany.InspectionDate = gw.api.util.DateUtil.currentDate()\n\nvar primaryContactPerson = targetCompany.PrimaryContact\nprimaryContactPerson.Emailaddress1 = \"inspectors@albertsons.com\"\n\n}, username)",
      "ocrWordCount": 85,
      "ocrConfidence": 87.2,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 31,
      "title": "Example: new entity instances",
      "bodyParagraphs": [],
      "originalNotes": "Example: new entity instances\nIn the previous examples we saw how we can modify existing data. Now let's see how we can create new entity instances and insert them into the database. Remember what we discussed earlier: newly created entities cannot be copied between bundles, and they should always be created in the correct bundle. Creating new entities is slightly different depending on whether you use the block or the alternative syntax. For the block syntax, you must instantiate the entity within the block. In this example, the code instantiates a new address in line 4. Notice the constructor call is within the bundle block. This means thenew address entity will be added to the writable new bundle.\n\nIn the second example, we use the alternative syntax. Somehow, we must specify which bundle the entity instance should be associated with. This is important because there is no block, and there could be multiple bundle contexts available. Every entity has a second constructor signature that takes a bundle as an input parameter. In line 10, we use this second constructor and pass in the writable new bundle to make sure that the platform puts the entity instance in this bundle after instantiation",
      "notes": "Example: new entity instances\nIn the previous examples we saw how we can modify existing data. Now let's see how we can create new entity instances and insert them into the database. Remember what we discussed earlier: newly created entities cannot be copied between bundles, and they should always be created in the correct bundle. Creating new entities is slightly different depending on whether you use the block or the alternative syntax. For the block syntax, you must instantiate the entity within the block. In this example, the code instantiates a new address in line 4. Notice the constructor call is within the bundle block. This means thenew address entity will be added to the writable new bundle.\n\nIn the second example, we use the alternative syntax. Somehow, we must specify which bundle the entity instance should be associated with. This is important because there is no block, and there could be multiple bundle contexts available. Every entity has a second constructor signature that takes a bundle as an input parameter. In line 10, we use this second constructor and pass in the writable new bundle to make sure that the platform puts the entity instance in this bundle after instantiation",
      "narration": "",
      "ocrText": "| Example: new entity instances Gi\n\n« Any entity (keyable bean) instantiated within the block context will automatically\nbe added to the bundle belonging to the block, and persisted to the database at\nthe conclusion of the block\n\n3 gw. transaction. Transaction. runWithNewBundle(\\ newBundle -> {\n> 4 var newAddress = new Address ()\n\n5 newAddress.City = \"Marina Del Rey\"\n\n6 newAddress.State = State.TC•_CA\n\n7 }, username)\n\n• lf you use the alternative syntax, you'll have to pass in the bundle to the\nconstructor of the entity, so the entity will be created in the new bundle\n\n8 var newBundle = gw.transaction.Transaction.newBundle()\n9\nmmm i0 var newAddress = new Address (newBundle)\n11 newAddress.City = \"Marina Del Rey\"\n12 newAddress.State = State.TC_CA\n13\n\n14 newBundle. commit ()",
      "ocrWordCount": 126,
      "ocrConfidence": 84.93,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 32,
      "title": "Copying entity instances to bundle restrictions",
      "bodyParagraphs": [],
      "originalNotes": "Copying entity instances to bundle restrictions\nU nmodified\nYou can copy an entity instance from one bundle to another only if the entity has not yet been modified. In other words, if you need to change and commit some but not all of the entity instances in a bundle, copy the relevant entity instances to a new bundle before you make any changes to them. If you need to create and commit new entity instances, ab,vays create them in the bundle from which they will be committed.\n\nModified\nYou cannot copy an entity instance from one bundle to another if the entity instance has been marked as changed. This means:\nModified entity instances cannot be copied to a new bundle.\nNew entity instances which are inherently marked as changed upon creation cannot be copied to a new bundle.\n\nNew\nYou cannot move a new entity instance from one bundle to another. Move implies the entity instance is deleted from the original bundle, and you cannot delete a new entity instance from a bundle.",
      "notes": "Copying entity instances to bundle restrictions\nU nmodified\nYou can copy an entity instance from one bundle to another only if the entity has not yet been modified. In other words, if you need to change and commit some but not all of the entity instances in a bundle, copy the relevant entity instances to a new bundle before you make any changes to them. If you need to create and commit new entity instances, ab,vays create them in the bundle from which they will be committed.\n\nModified\nYou cannot copy an entity instance from one bundle to another if the entity instance has been marked as changed. This means:\nModified entity instances cannot be copied to a new bundle.\nNew entity instances which are inherently marked as changed upon creation cannot be copied to a new bundle.\n\nNew\nYou cannot move a new entity instance from one bundle to another. Move implies the entity instance is deleted from the original bundle, and you cannot delete a new entity instance from a bundle.",
      "narration": "",
      "ocrText": "| Copying entity instances to bundle restrictions Gi\n\nse te\nwy wy\nNI r a Sd a\nUnmodified i i Unmodified\noO : i\n\nG—o\n\nModified H\n\nNew in First\n\nNew in Second",
      "ocrWordCount": 33,
      "ocrConfidence": 72.38,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 33,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 34,
      "title": "Original values",
      "bodyParagraphs": [],
      "originalNotes": "Original values\nThe getOriginalValue method takes in a string input parameter that names the property whose value must be retrieved or takes a reference to an entity instance property- It returns the value of that property. Keep in mind that the data type of the method depends on the named property- It could return an integer, string, Boolean, date, typekey (for typekey properties), or entity references (for foreign key properties).\n\nFor typekeys, getOriginaIValue returns theoriginal typekey. You may want to access the typekey’s name- For example, you might want to write a history event that says Status changed from Pending to Closed. Pending is the typekey's name- To do this, use the following syntax: (entity-getOriginaIValue(entity #typekeyProperty) as typelistName).\n\nFor foreign keys, getOriginaIValue returns theID of the original entityinstance. You may want to access data from that entity instance, such as an entity instance's display name- For example, you might want to write a history event that says Assigned user changed from Alice Applegate to Ben Baker, where Alice Applegate is the display name of the original assigned user entity instance. To do user entity Instance.this, use the following syntax: II This retrieves the entity instance that the foreign key previously referenced. var previousForeignKey = changedObject.getOriginalValue(\"foreignKeyField\")",
      "notes": "Original values\nThe getOriginalValue method takes in a string input parameter that names the property whose value must be retrieved or takes a reference to an entity instance property- It returns the value of that property. Keep in mind that the data type of the method depends on the named property- It could return an integer, string, Boolean, date, typekey (for typekey properties), or entity references (for foreign key properties).\n\nFor typekeys, getOriginaIValue returns theoriginal typekey. You may want to access the typekey’s name- For example, you might want to write a history event that says Status changed from Pending to Closed. Pending is the typekey's name- To do this, use the following syntax: (entity-getOriginaIValue(entity #typekeyProperty) as typelistName).\n\nFor foreign keys, getOriginaIValue returns theID of the original entityinstance. You may want to access data from that entity instance, such as an entity instance's display name- For example, you might want to write a history event that says Assigned user changed from Alice Applegate to Ben Baker, where Alice Applegate is the display name of the original assigned user entity instance. To do user entity Instance.this, use the following syntax: II This retrieves the entity instance that the foreign key previously referenced. var previousForeignKey = changedObject.getOriginalValue(\"foreignKeyField\")",
      "narration": "",
      "ocrText": "| Original values Gi\n\n• Prior to the commit, Gosu retains a copy of each entity instance read from the\ndatabase\n\n• Several properties and methods let you work with the original data in the entity\ninstance\n* entityName.Changed\n+ Returns true if any property on the entity instance has changed\n* entityName. isFieldChanged (Entity#FieldName)\n+ Returns true if a property has changed since the entity instance was read from database\n\n* entityName.getOriginalValue (Entity#FieldName.getPropertyInfo()as\nIEntityPropertyInfo)\n\n+ Returns property value read from database",
      "ocrWordCount": 82,
      "ocrConfidence": 88.85,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 35,
      "title": "Using original values example",
      "bodyParagraphs": [],
      "originalNotes": "Using original values example\nCode example\nLine 172\nChecks if original field has changed.\nLine 177\nGets original value on inspection date field.\n\nSince this method is being called from the IJI, the current IJI bundle will commit the changes made in the method.",
      "notes": "Using original values example\nCode example\nLine 172\nChecks if original field has changed.\nLine 177\nGets original value on inspection date field.\n\nSince this method is being called from the IJI, the current IJI bundle will commit the changes made in the method.",
      "narration": "",
      "ocrText": "| Using original values example Gi\n\nprivate static function createABCompanyNoteForInspection(targetCompany: ABCompany, inspectionDat\nvar hasInspectionDateChanged = targetCompany. isFieldChanged (ABCompanyéInspectionDate)\nif (nasInspectionDateChanged) {\nvar newNote = new ContactNote ()\nnewllote. Subject = \"Change to inspection date”\nnewNlote.ContactNoteType = typekey.ContactNlotelype. 7•_DATA_UPDATE\nvar originalInspectionDate = targetCompany.getOriginalValue (ABCompany#InspectionDate.getPropertyInfo() as IEntityPropertyInfo)\nnewNote.Body = String. format(\"Inspection date updated from #s to #s \", {originalInspectionDate, targetCompany.InspectionDate})\nreturn newNote\n} else\nreturn null\n\nContactNote {\n\nEdit Note\n\nContact Note Type Update Contact Data a\nConfidential? Yes (•) No\n\nSubject Change to inspection date\nBody Inspection date updated\n\nfrom 2014-12-12 to 2015-01-\n1",
      "ocrWordCount": 93,
      "ocrConfidence": 80.9,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 36,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 37,
      "title": "Updating the Database",
      "bodyParagraphs": [],
      "originalNotes": "Updating the Database\nAs we discussed earlier, there is no current bundle in web services, batch processes and certain integration plugins. This is because these integration resources typically deal with a huge number of entities or complex tasks to perform a single action. You will have to use the block or the alternative bundle syntax in your code to correctly manage bundle sizes. Unfortunately, there is no single recommendation for the ideal bundle size, because large number of entities is a relative term. You will have to do your own performance testing to determine the optimal size. However, here are a few points to consider: Consider using paging with regular commits when working with queries. Keep bundle sizes as small as practicable. Be careful about how you use accessors, and follow query best practices.\n\nWatch the Guidewire Query API lesson to learn more about accessors and query best practices.",
      "notes": "Updating the Database\nAs we discussed earlier, there is no current bundle in web services, batch processes and certain integration plugins. This is because these integration resources typically deal with a huge number of entities or complex tasks to perform a single action. You will have to use the block or the alternative bundle syntax in your code to correctly manage bundle sizes. Unfortunately, there is no single recommendation for the ideal bundle size, because large number of entities is a relative term. You will have to do your own performance testing to determine the optimal size. However, here are a few points to consider: Consider using paging with regular commits when working with queries. Keep bundle sizes as small as practicable. Be careful about how you use accessors, and follow query best practices.\n\nWatch the Guidewire Query API lesson to learn more about accessors and query best practices.",
      "narration": "",
      "ocrText": "| Updating the Database Gi\n\nNo Current Bundle for integration resources\nUse Transaction. runWithNewBundle(/ bundle ->{}) or\nTransaction.newBundle ()\nIf you expect to update large numbers of entities:\n“Large number of entities” is a relative term\nConsider using paging with regular commits\nKeep bundle sizes as small as practicable\nBe careful about how you use accessors\n\nUse Query best practices\n+ Do filtering at the database rather than in memory — Let the DB do what it’s good at\n\n+ See “Guidewire Query API” lesson for more information",
      "ocrWordCount": 88,
      "ocrConfidence": 93.08,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 38,
      "title": "Updating the Database in a Batch Process",
      "bodyParagraphs": [],
      "originalNotes": "Updating the Database in a Batch Process\nHere's an example of a simple- minded approach to updating the database in a Batch Process. The two main problems with this approach are memory and bundle performance. Imagine the query returns 500,000 entities. In this case, all 500,000 entities will be loaded into memory and added to the same bundle. If the code uses the dot notation to access foreign keys or array keys of the entities in the bundle, then the application will load those referenced objects into the same bundle, resulting in a growing bundle size. This means that by the time we reach the commit, there could 1 million or more entities in the bundle. Worse still, all these entities will be in a single transaction, which can affect performance.",
      "notes": "Updating the Database in a Batch Process\nHere's an example of a simple- minded approach to updating the database in a Batch Process. The two main problems with this approach are memory and bundle performance. Imagine the query returns 500,000 entities. In this case, all 500,000 entities will be loaded into memory and added to the same bundle. If the code uses the dot notation to access foreign keys or array keys of the entities in the bundle, then the application will load those referenced objects into the same bundle, resulting in a growing bundle size. This means that by the time we reach the commit, there could 1 million or more entities in the bundle. Worse still, all these entities will be in a single transaction, which can affect performance.",
      "narration": "",
      "ocrText": "| Updating the Database in a Batch Process\n\n• Simple minded approach:\n\n6 gw.transaction.Transaction. runWithNewBundle(\\ newBundle -> {\n7 queryResults.each(\\ oneResult -> {\n\n8 var tyToM = newBundle.add(oneResult)\n\n9 //\n\n10 )\n\n11 }, username)\n\n* Two main problems:\n\n« Memory\n\n• Bundle performance\n\nEvery new accessor retrieves an entity into the bundle\nUsing accessors from those entities retrieves more entities\n\nBundles can grow very large",
      "ocrWordCount": 66,
      "ocrConfidence": 89.33,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 39,
      "title": "A Better Approach: Paging Plus Regular Commits",
      "bodyParagraphs": [],
      "originalNotes": "A Better Approach: Paging Plus Regular Commits\nHere is a potentially better approach that uses paging and regular commits. In line 6, we set the page size to 10,000, and then in line 7, we set the chunck size to 250. In line 11, we use the Google Iterables API to partition every page into chunks. Now we will review how this code will work. Using the same example as before, let's assume the query returns 500,000 entities.\n\nThe page size is 10,000, which means the application will only load 10,000 entities into memory for each page and process those entities before loading the next 10,000 entities. This will happen 50 times since there will be 50pages. For each page, the application will partition the page into chunks of 250 and process each chunk in its own bundle. So the bundle size will essentially be 250 plus any entities retrieved by the accessors. This means the code is going to perform 40 commits for each page. That is a total of 2000 commits to process the 500,000 thousand entities. This could perform better than the previous approach because it uses less memory and the bundle size for each individual commit is smaller.",
      "notes": "A Better Approach: Paging Plus Regular Commits\nHere is a potentially better approach that uses paging and regular commits. In line 6, we set the page size to 10,000, and then in line 7, we set the chunck size to 250. In line 11, we use the Google Iterables API to partition every page into chunks. Now we will review how this code will work. Using the same example as before, let's assume the query returns 500,000 entities.\n\nThe page size is 10,000, which means the application will only load 10,000 entities into memory for each page and process those entities before loading the next 10,000 entities. This will happen 50 times since there will be 50pages. For each page, the application will partition the page into chunks of 250 and process each chunk in its own bundle. So the bundle size will essentially be 250 plus any entities retrieved by the accessors. This means the code is going to perform 40 commits for each page. That is a total of 2000 commits to process the 500,000 thousand entities. This could perform better than the previous approach because it uses less memory and the bundle size for each individual commit is smaller.",
      "narration": "",
      "ocrText": "| A Better Approach: Paging Plus Regular Commits\n\n• Better approach:\n\n— var pageSize = 10000\n—> var chunkSize = 250\nresults. set PageSize (pageSize)\nfor( entities in com.google.common.collect.Iterables.partition(results, chunkSize) )\ngw.transaction.Transaction. runWithNewBundle( \\ bundle -> {\nfor( e in entities) {\n\nvar Modify = bundle.add(e)\n\n}\n}, username )\n\n• Page size: 10,000\n• Bundle size: 250\n\n{",
      "ocrWordCount": 59,
      "ocrConfidence": 85.26,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 40,
      "title": "Paging Plus Regular Commits — Considerations",
      "bodyParagraphs": [],
      "originalNotes": "Paging Plus Regular Commits — Considerations\nUnfortunately, there is no one size that is optimal for all scenarios. Optimal page and bundle sizes will vary with specific tables, queries, databases and environments. You will have to do performance testing and adjust these parameters to find the optimal size. Keep in mind that certain solutions can introduce new problems. For example, paging does not work well with some types of modifications.",
      "notes": "Paging Plus Regular Commits — Considerations\nUnfortunately, there is no one size that is optimal for all scenarios. Optimal page and bundle sizes will vary with specific tables, queries, databases and environments. You will have to do performance testing and adjust these parameters to find the optimal size. Keep in mind that certain solutions can introduce new problems. For example, paging does not work well with some types of modifications.",
      "narration": "",
      "ocrText": "| Paging Plus Regular Commits — Considerations Gi\n\n• Optimal page and bundle sizes will vary with specific tables, queries, DB’s, and\nenvironments\n\n* There is no one size fits all\n* Performance testing can be very revealing\n• Still likely to be slow for big queries\n« Paging doesn’t work well with some types of modification\n\n* Modifying columns you queried on repositions the cursor",
      "ocrWordCount": 66,
      "ocrConfidence": 87.06,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 41,
      "title": "Paging with Modifications",
      "bodyParagraphs": [],
      "originalNotes": "Paging with Modifications\nHere is an example of paging with modifications to the data. When you use paging, be aware that if you change any of the properties that were part of the query, you reposition the cursor.",
      "notes": "Paging with Modifications\nHere is an example of paging with modifications to the data. When you use paging, be aware that if you change any of the properties that were part of the query, you reposition the cursor.",
      "narration": "",
      "ocrText": "| Paging with Modifications\n\nApp\nserver",
      "ocrWordCount": 6,
      "ocrConfidence": 95.5,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 42,
      "title": "Paging with Modifications (continues",
      "bodyParagraphs": [],
      "originalNotes": "Paging with Modifications (continued)\nIn this example, the code uses paging to retrieve the first 2 rows in the result set",
      "notes": "Paging with Modifications (continued)\nIn this example, the code uses paging to retrieve the first 2 rows in the result set",
      "narration": "",
      "ocrText": "| Paging with Modifications (continues\n\nApp\nserver\n\n|\nI\nI",
      "ocrWordCount": 10,
      "ocrConfidence": 81.11,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 43,
      "title": "Paging with Modifications (continues",
      "bodyParagraphs": [],
      "originalNotes": "Paging with Modifications (continued)\nand then changes a property that was part of the query.",
      "notes": "Paging with Modifications (continued)\nand then changes a property that was part of the query.",
      "narration": "",
      "ocrText": "| Paging with Modifications (continues\n\nApp\nserver\n\n|\nI",
      "ocrWordCount": 9,
      "ocrConfidence": 85.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 44,
      "title": "Paging with Modifications (continues",
      "bodyParagraphs": [],
      "originalNotes": "Paging with Modifications (continued)\nThat change repositions the cursor to what it thinks are the next 2 rows. This results in skipping the rows that should have been next. Refer to the product documentation or post a question to AnswerHub for more information.",
      "notes": "Paging with Modifications (continued)\nThat change repositions the cursor to what it thinks are the next 2 rows. This results in skipping the rows that should have been next. Refer to the product documentation or post a question to AnswerHub for more information.",
      "narration": "",
      "ocrText": "| Paging with Modifications (continues G\n\nApp\nserver\n1\n\nDatabase\n\nSkipped\nrows",
      "ocrWordCount": 12,
      "ocrConfidence": 89.55,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 45,
      "title": "Demonstration",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "| Demonstration G\nGosu bundles\n\nclick here\n\nNote: The demonstration opens a new tab in your browser. When the demonstration ends, the\noriginal course launch window appears. Return to this window to continue this presentation.",
      "ocrWordCount": 35,
      "ocrConfidence": 95.34,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_instruction",
      "demoVideoIndex": 0
    },
    {
      "slideNumber": 46,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": false,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_video"
    },
    {
      "slideNumber": 47,
      "title": "Knowledge Check",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question\n_- — What is a bundle?\n•\n•\n•\nSeo e Soe esses see see",
      "ocrWordCount": 15,
      "ocrConfidence": 73.83,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "What is a bundle?",
        "answer": "_- — What is a bundle? A Guidewire bundle is a set of in-memory entities that are saved to the database as a unit. Each bundle corresponds to one database transaction."
      }
    },
    {
      "slideNumber": 48,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer\n_- — What is a bundle?\n•\n•\n•\nA Guidewire bundle is a set of in-memory entities that are saved to the database as a\nunit. Each bundle corresponds to one database transaction.\nSoo eS eee soe ese ese",
      "ocrWordCount": 41,
      "ocrConfidence": 81.59,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 49,
      "title": "Question",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question G\nFor each of the following, identify if its an example of auto commit or\n7’ manual commit?\n, A) Queried entities that must be modified\nB) Code executed from the UI in edit mode\nC) Code executed in business rules\nD) Code executed from the UI in read-only mode\nSeo e Soe esses see see",
      "ocrWordCount": 59,
      "ocrConfidence": 90.87,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "For each of the following, identify if its an example of auto commit or",
        "answer": "7’ manual commit? • A) Queried entities that must be modified Code executed from the Ul in edit mode Code executed in business rules Code executed from the UI in read-only mode Manual commit Auto commit Auto commit Manual commit"
      }
    },
    {
      "slideNumber": 50,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer Gi\nFor each of the following, identify if its an example of auto commit or\n7’ manual commit?\n• A) Queried entities that must be modified\nB\nCc\nD\nCode executed from the Ul in edit mode\nCode executed in business rules\nSwv\nCode executed from the UI in read-only mode\n&\nManual commit\nwy\nAuto commit\nCc\nD\nAuto commit\nwv\nManual commit\n=\nSoo eS eee soe ese ese",
      "ocrWordCount": 74,
      "ocrConfidence": 83.71,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 51,
      "title": "Question",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question G\n_- — What kind of entities are initially put into read-only bundles?\nUnder what circumstance would you need to copy one of those entities\nto a writable bundle and how is this done?\nSeo e Soe esses see see",
      "ocrWordCount": 43,
      "ocrConfidence": 87.38,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "What kind of entities are initially put into read-only bundles?",
        "answer": "Under what circumstance would you need to copy one of those entities : to a writable bundle and how is this done? Entities that are the result of a query are put into read-only bundles, and entities referenced by foreign key are put into a read-only bundle if the referencing entity is also in a read-only bundle. You need to copy these entities to a writable bundle if you need to modify them, which is done via the bundle's add method."
      }
    },
    {
      "slideNumber": 52,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer Gi\nWhat kind of entities are initially put into read-only bundles?\nUnder what circumstance would you need to copy one of those entities\nto a writable bundle and how is this done?\nEntities that are the result of a query are put into read-only bundles, and entities\nreferenced by foreign key are put into a read-only bundle if the referencing entity is\nalso in a read-only bundle.\nYou need to copy these entities to a writable bundle if you need to modify them, which\nis done via the bundle's add method.\nSoo eS eee soe ese ese",
      "ocrWordCount": 102,
      "ocrConfidence": 89.72,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 53,
      "title": "Key Takeaways",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Lesson\nobjectives\nreview\n\n• Describe bundle context\n\nDifferentiate between read-only and writable\nbundles\n\nUtilize API methods for creating and\ncommitting bundles\n\nAdd and/or edit entity instances in a bundle\nReference original values for edited entity\ninstance fields",
      "ocrWordCount": 37,
      "ocrConfidence": 94.73,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives_review"
    },
    {
      "slideNumber": 54,
      "title": "Student Exercise",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "| Student exercise\n\nCreate a contact summary note",
      "ocrWordCount": 8,
      "ocrConfidence": 95.89,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "exercise"
    }
  ],
  "videos": [
    {
      "index": 1,
      "filename": "In_04_01.mp4",
      "path": "/academy/guidewire/videos/ch11/In_04_01.mp4"
    }
  ],
  "hasNotes": true,
  "hasTables": false,
  "hasImages": true,
  "ocrMetadata": {
    "totalWords": 2530,
    "avgConfidence": 87.97,
    "extractedAt": "2026-02-15T18:19:49.996923"
  }
}
