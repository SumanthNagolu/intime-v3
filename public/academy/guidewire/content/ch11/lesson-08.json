{
  "lessonId": "ch11-l08",
  "chapterId": 11,
  "chapterSlug": "ch11",
  "lessonNumber": 8,
  "title": "RESTful Web Services",
  "sourceFile": "RESTful Web Services.pptx",
  "sourceFolder": "In_Integration_08",
  "totalSlides": 38,
  "estimatedMinutes": 114,
  "slides": [
    {
      "slideNumber": 1,
      "title": "RESTful Web Services",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "RESTful Web Services",
      "ocrWordCount": 3,
      "ocrConfidence": 95.5,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "title"
    },
    {
      "slideNumber": 2,
      "title": "Learning Objectives",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Lesson\nobjectives\n\n* Create a swagger schema to define an API\n\n• Reference an existing Integration View in the\nAPI\n\n* Create an API handler class\n\n• Publish an API\n\n« Use swagger-ui to test an API",
      "ocrWordCount": 37,
      "ocrConfidence": 86.32,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives"
    },
    {
      "slideNumber": 3,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 4,
      "title": "What is the InsuranceSuite REST framework?",
      "bodyParagraphs": [],
      "originalNotes": "What is the InsuranceSuite REST framework?\nA RESTful API is an application program interface (API) that uses HTTP request to GET, PUT, PATCH, POST and DELETE data. A RESTful API — also referred to as a RESTful web service — is based on representational state transfer (REST) technology.\n\nREST is the idea of using the hypertext transport protocol (HTTP) to view and manipulate resources. Following this protocol, the primary allowable actions are GET, PUT, PATCH, POST and DELETE. Unique resource locators (URLs) are the means for referencing exposed entities, and HTTP response codes are used to understand the state of the interaction. In its full form, REST employs media types that define the available resources and allowable payloads, and links are provided to facilitate auto- discovery of resources and Actions.\n\nPATCH vs PUT\nPATCH requests that a set of changes described in the request entity be applied to the resource identified by the Request- URI. (Preferred verb for an update).\nPUT requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server — the entire entity will be replaced. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.\n\nWhy not use JAX-RS?\nCode-first APIs don’t compose or extend cleanly — becomes difficult-to-impossible to ship OOTB APIs that you can extend without just modifying all the classes in place and \"owning“ everything\nJAX-RS doesn't work consistently across our supported application servers\nLots of other work needed on top of the basic dispatch and (de)serialization layers anyway — authentication, logging, standard error formats, localization, etc.\n\nWhat is Swagger?\nSwagger is a specification for documenting REST APIs that has become the closest thing to an industry standard that you'll find, with a growing ecosystem of tools that can understand Swagger schemas- The InsuranceSuite REST Framework uses Swagger version 2.0 schemas to define the APIs themselves, including the available resources (i.e. the paths), the verbs that can be used with those resources (i.e. the operations), what parameters each operation accepts, and the schema for any payload or response if those are specified in JSON- Swagger is designed for schema-first development of APIs, meaning that you can develop the API specification before starting implementation, and as such is intended to be a file format that humans can read and write directly, with minimal editor support The official Swagger 2.0 spec is available at https:/fgithub.com/OAl/Open API_Specification/blob/master/versions/2.0-md.",
      "notes": "What is the InsuranceSuite REST framework?\nA RESTful API is an application program interface (API) that uses HTTP request to GET, PUT, PATCH, POST and DELETE data. A RESTful API — also referred to as a RESTful web service — is based on representational state transfer (REST) technology.\n\nREST is the idea of using the hypertext transport protocol (HTTP) to view and manipulate resources. Following this protocol, the primary allowable actions are GET, PUT, PATCH, POST and DELETE. Unique resource locators (URLs) are the means for referencing exposed entities, and HTTP response codes are used to understand the state of the interaction. In its full form, REST employs media types that define the available resources and allowable payloads, and links are provided to facilitate auto- discovery of resources and Actions.\n\nPATCH vs PUT\nPATCH requests that a set of changes described in the request entity be applied to the resource identified by the Request- URI. (Preferred verb for an update).\nPUT requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server — the entire entity will be replaced. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.\n\nWhy not use JAX-RS?\nCode-first APIs don’t compose or extend cleanly — becomes difficult-to-impossible to ship OOTB APIs that you can extend without just modifying all the classes in place and \"owning“ everything\nJAX-RS doesn't work consistently across our supported application servers\nLots of other work needed on top of the basic dispatch and (de)serialization layers anyway — authentication, logging, standard error formats, localization, etc.\n\nWhat is Swagger?\nSwagger is a specification for documenting REST APIs that has become the closest thing to an industry standard that you'll find, with a growing ecosystem of tools that can understand Swagger schemas- The InsuranceSuite REST Framework uses Swagger version 2.0 schemas to define the APIs themselves, including the available resources (i.e. the paths), the verbs that can be used with those resources (i.e. the operations), what parameters each operation accepts, and the schema for any payload or response if those are specified in JSON- Swagger is designed for schema-first development of APIs, meaning that you can develop the API specification before starting implementation, and as such is intended to be a file format that humans can read and write directly, with minimal editor support The official Swagger 2.0 spec is available at https:/fgithub.com/OAl/Open API_Specification/blob/master/versions/2.0-md.",
      "narration": "",
      "ocrText": "| What is the InsuranceSuite REST framework? Gi\n\n• A framework for defining\nRESTful web services\n\n• Publishing only\n\n* No client toolkit for\ninvoking APIs\n\n• Design approach is\nschema-first rather than\ncode-first\n\n* Based on Swagger\nschemas\n\n« Not based on JAX-RS\n\nRest API Basics\n\nTypical HTTP Verbs:\n\nGET -> Read from Database\n\nPUT -> Update/Replace row in Database\nPATCH -> Update/Modify row in Database\nPOST -> Create a new record in the database\nDELETE -> Delete from the database\n\nDatabase\n\nHTTP\nGET\nIS ee\n\nHTTP POST\n\nOo\n+ /newUser >\ns\nUi HTTP.\nPATCH\n/updateUsey,\n\nwaAzm-rg\n\nRest API\n\nRecieves HTTP\nrequests from\nClients and does\nwhatever request\nneeds. i.e create\nusers\n\n—\n\nOur Rest API queries the\ndatabase for what it needs\n\nk\n\nOur Clients, send HTTP Requests\nand wait for responses\n\nResponse: When the Rest API has what it\nneeds, it sends back a response to the\nclients. This would typically be in JSON\nor XML format.",
      "ocrWordCount": 161,
      "ocrConfidence": 88.09,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 5,
      "title": "REST framework components",
      "bodyParagraphs": [],
      "originalNotes": "REST framework components\nThe InsuranceSuite RESTAPI Framework uses Swagger 2.0 schema files to define the structure of a given API, and JSON Schema files to define the schema for API inputs and outputs. Integration Mapping files and Integration Filters can optionally be used to implement GET methods within the API. Together, the Swagger schema and JSON Schema pieces are used to determine:\nThe set of resources exposed by the API; each resource is called a \"path\"or \"path item\" in Swagger, and can have variables interposed for things like resource ids. For example, sses might define aresource for the addresses associated witha specific contact.\nThe set of HTTP verbs that can be used to operate on a particular resource. Swagger calls these the \"operations.\" For example, the sses resource might define a GET operation that returns the addresses for the specified contact and a POST operation for adding a new address to the contact- Updates and deletions of addresses might be done via PATCH and DELETE operations on Icontact/{contactld)/addresses/{addressld)\nThe set of path parameters, query parameters, and custom headers applicable to each operation- In the above example, \"contactld\" and\n \"addressld\" are path parameters. At runtime, the framework will match the request URL against the defined path and extract out those path parameters for use by the implementation code. Query parameters are the bits after the ? in the URL and are often used for additional parameters to an operation.\nThe schema for the payload passed to an operation, if any. In the above example, a POST to sses might specify a JSON Schema definition that defines the format for the body of the POST request.\nThe schema for the response returned by an operation, if any, as well as possible HTTP codes that will be returned- A GET request tosses might specify a json schema for the list of addresses, and that the default success code is 200.\nValidation and serialization/deserialization n for those parameters, inputs, and outputs. A parameter might be declared as required, or with a specified min and max value, or as an integer versus a string; the framework can then use that information to automatically validate the inputs and return an appropriate HTTP response if the input is invalid, and can deserialize the data into appropriate POJOs for use by the implementation code\n\nEvery operation defined within the Swagger schema is then bound to a specific handler class and method, which will be invoked to process the request whenever a request is made against the appropriate URL and HTTP request method. A single configuration file, published-apis.yaml, is used to control which Swagger schemas are actually exposed via the REST servlet.\n\nWhy not DTOs? (Data Transfer Object)\nWrappers allow for clean extension — no need to subclass, overwrite OOTB classes, create runtime proxies, etc.\nWrappers allow code re- use across API versions\nWrappers allow for \"late- binding\" of code to the schema, which helps modularity\ni.e. base application code can execute without knowing if it’s being called by an customer extension API\nWrappers can be optional\nDon't like them? Too slow to compile? Your code is mostly reflective/meta anyway? Then don’t generate them.\nWrappers are module- specific\nSince extension schemas are in a different namespace, so are the wrappers\nWrappers are a module-specific implementation detail",
      "notes": "REST framework components\nThe InsuranceSuite RESTAPI Framework uses Swagger 2.0 schema files to define the structure of a given API, and JSON Schema files to define the schema for API inputs and outputs. Integration Mapping files and Integration Filters can optionally be used to implement GET methods within the API. Together, the Swagger schema and JSON Schema pieces are used to determine:\nThe set of resources exposed by the API; each resource is called a \"path\"or \"path item\" in Swagger, and can have variables interposed for things like resource ids. For example, sses might define aresource for the addresses associated witha specific contact.\nThe set of HTTP verbs that can be used to operate on a particular resource. Swagger calls these the \"operations.\" For example, the sses resource might define a GET operation that returns the addresses for the specified contact and a POST operation for adding a new address to the contact- Updates and deletions of addresses might be done via PATCH and DELETE operations on Icontact/{contactld)/addresses/{addressld)\nThe set of path parameters, query parameters, and custom headers applicable to each operation- In the above example, \"contactld\" and\n \"addressld\" are path parameters. At runtime, the framework will match the request URL against the defined path and extract out those path parameters for use by the implementation code. Query parameters are the bits after the ? in the URL and are often used for additional parameters to an operation.\nThe schema for the payload passed to an operation, if any. In the above example, a POST to sses might specify a JSON Schema definition that defines the format for the body of the POST request.\nThe schema for the response returned by an operation, if any, as well as possible HTTP codes that will be returned- A GET request tosses might specify a json schema for the list of addresses, and that the default success code is 200.\nValidation and serialization/deserialization n for those parameters, inputs, and outputs. A parameter might be declared as required, or with a specified min and max value, or as an integer versus a string; the framework can then use that information to automatically validate the inputs and return an appropriate HTTP response if the input is invalid, and can deserialize the data into appropriate POJOs for use by the implementation code\n\nEvery operation defined within the Swagger schema is then bound to a specific handler class and method, which will be invoked to process the request whenever a request is made against the appropriate URL and HTTP request method. A single configuration file, published-apis.yaml, is used to control which Swagger schemas are actually exposed via the REST servlet.\n\nWhy not DTOs? (Data Transfer Object)\nWrappers allow for clean extension — no need to subclass, overwrite OOTB classes, create runtime proxies, etc.\nWrappers allow code re- use across API versions\nWrappers allow for \"late- binding\" of code to the schema, which helps modularity\ni.e. base application code can execute without knowing if it’s being called by an customer extension API\nWrappers can be optional\nDon't like them? Too slow to compile? Your code is mostly reflective/meta anyway? Then don’t generate them.\nWrappers are module- specific\nSince extension schemas are in a different namespace, so are the wrappers\nWrappers are a module-specific implementation detail",
      "narration": "",
      "ocrText": "| REST framework components\n\n* Swagger schema\n\n* Swagger 2.0 schema definitions to define APIs\nlew\n• Integration View\n\n« JSON Schema draft 4 to define the input/output schemas\n\n* Can use the same schemas for integration views and/or\nREST APIs\n\n* Schema files drive request routing, validation, and\n(de)serialization\n\n+ Framework also handles standardized error codes and error\nformats, localization, pluggable authentication, pluggable Ln\nlogging, content negotiation, etc\n\nSwagger\nSchema\n\nPublish\n\n&:\n\nExternal\nRequest\n\n+ \"1980-06-20T04:00:00.0002\",\n\niilliam Andy\",\n\n“primaryAddress™ : {\n\n• Gosu classes “eddreastype\" + “hose”\n\n}\n\nd\negg ar 4s",
      "ocrWordCount": 93,
      "ocrConfidence": 83.29,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 6,
      "title": "Use case",
      "bodyParagraphs": [],
      "originalNotes": "Use case\nSome simple conventions to keep in mind are:\nTry to structure things as operations on resources rather than as RPC calls, i.e.instead of calling addContact you're POSTing to Icontacts\nGET should never mutate a resource\nUse PUT to replace an existing resource, PATCH to partially update it (i.e. only updating specified fields),DELETE to remove objects, and POST to create new resources under an existing container\nUse plurals for resource paths where there are multiple sub- resources, i.e. 'contacts/{contactld} rather than Icontact/{contactld}",
      "notes": "Use case\nSome simple conventions to keep in mind are:\nTry to structure things as operations on resources rather than as RPC calls, i.e.instead of calling addContact you're POSTing to Icontacts\nGET should never mutate a resource\nUse PUT to replace an existing resource, PATCH to partially update it (i.e. only updating specified fields),DELETE to remove objects, and POST to create new resources under an existing container\nUse plurals for resource paths where there are multiple sub- resources, i.e. 'contacts/{contactld} rather than Icontact/{contactld}",
      "narration": "",
      "ocrText": "| Use case\n\nCreate an API that will allow external\nresources to:\n\nView a contact\nView a list of contact notes\nUpdate a contact\n\nAdd a note to a contact\n\nGi\nDesign approach\n\n1. Define the API schema\n\n* Create the Swagger schema for the\nAPI paths and operations\n\n2. Define the API Integration View\n\n* Create an integration view for any\ninputs and outputs\n\n3. Define the API handler class\n\n• Implement the API by creating a\nhandler class and its methods\n\n4. Publish and test the API\n\ne Ad it tn nithlichad sanic vam! filo",
      "ocrWordCount": 97,
      "ocrConfidence": 90.15,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 7,
      "title": "Define API schema",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Define API schema",
      "ocrWordCount": 3,
      "ocrConfidence": 96.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 8,
      "title": "Create a new yam file",
      "bodyParagraphs": [],
      "originalNotes": "Create a new yaml file\nYAML (YAML Ain't Markup Language) is a human-readable data serialization standard for all programming languages. It is used for configuration files and in many applications where data is being stored; in the next page you can see an example.",
      "notes": "Create a new yaml file\nYAML (YAML Ain't Markup Language) is a human-readable data serialization standard for all programming languages. It is used for configuration files and in many applications where data is being stored; in the next page you can see an example.",
      "narration": "",
      "ocrText": "| Create a new yam file Gi\n\n* Swagger schemas are written as yaml files\n+ Placed in sub-directories of the config/integration/apis folder\n\n* Swagger schemas can be defined in their own namespace within the apis folder, and can be nested in\narbitrary folders\n\n+ Asa best practice, customer-specific Swagger schemas should be put into a customer-specific namespace:\n\n+ apis/<company_code>/<product_code>\n\n+ Swagger schemas must always have a version attached to their v integration\nname, separated by a '-' character v apis\n* The names should be formed as > gw.pl.framework\n\nv trn.ta\n\nconta wagger.yaml\n\n* config/integration/apis/trn/ta/contact-1.0.swagger.yaml\n\n+ <name>-<version>.swagger.yaml\n\n• For example, for Training:\n\n+ Swagger schema named trn.ta.contact-1.0 within the application",
      "ocrWordCount": 111,
      "ocrConfidence": 88.86,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 9,
      "title": "Define header information",
      "bodyParagraphs": [],
      "originalNotes": "Define header information\nCode example\nLine 1\nMust always specify swagger: '2.0' in the file.\nLine 2\nBasic information about the schema.\nLine 6\nDetermines where the resources are rooted on the REST servlet\nBecomes a prefix to each of the paths: http://localhost:8880/ab/ rest/trn/ta/contact/vl/<re\nsource>\nLines 7-9\nSchema aliases and import paths are defined.\nReference to the imported schema are prefixed with the alias before the # symbol.\nLine 11\nSpecifies the default handler class that will be instantiated for operations.\nLines 13,15\nSpecifies the default input/output file format for operations unless explicitly declared.\nLine 16\nResources/operations are defined under paths.\n\nThe hardest part about defining the API is designing the API, i.e. determining the structure of the resources, what verbs are available, what query parameters, and what the inputs and output should look like- One of the advantages of schema-first API design (at least in theory) is that it forces you to think about those questions up- front, before you start implementing, and to look at your API from the perspective of client systems rather than just thinking about the back- end implementation.\nHeader Template\nswagger: '2.0’ info:\ndescription: \"My API“ version: '1.0’ title: \"My basePath: <basePath> # The base path prepended to every path in this API, generally of the form /<grouping/<version> like 'claims/vl x-gw-schema-import: <alias>: <json schema name> # Can include any number of imports, but you’ll just need one for now produces: # Used as the default for operations that do not explicitly declare - application/json consumes: # Used as the default for operations that do not explicitly declare it - application/json paths:",
      "notes": "Define header information\nCode example\nLine 1\nMust always specify swagger: '2.0' in the file.\nLine 2\nBasic information about the schema.\nLine 6\nDetermines where the resources are rooted on the REST servlet\nBecomes a prefix to each of the paths: http://localhost:8880/ab/ rest/trn/ta/contact/vl/<re\nsource>\nLines 7-9\nSchema aliases and import paths are defined.\nReference to the imported schema are prefixed with the alias before the # symbol.\nLine 11\nSpecifies the default handler class that will be instantiated for operations.\nLines 13,15\nSpecifies the default input/output file format for operations unless explicitly declared.\nLine 16\nResources/operations are defined under paths.\n\nThe hardest part about defining the API is designing the API, i.e. determining the structure of the resources, what verbs are available, what query parameters, and what the inputs and output should look like- One of the advantages of schema-first API design (at least in theory) is that it forces you to think about those questions up- front, before you start implementing, and to look at your API from the perspective of client systems rather than just thinking about the back- end implementation.\nHeader Template\nswagger: '2.0’ info:\ndescription: \"My API“ version: '1.0’ title: \"My basePath: <basePath> # The base path prepended to every path in this API, generally of the form /<grouping/<version> like 'claims/vl x-gw-schema-import: <alias>: <json schema name> # Can include any number of imports, but you’ll just need one for now produces: # Used as the default for operations that do not explicitly declare - application/json consumes: # Used as the default for operations that do not explicitly declare it - application/json paths:",
      "narration": "",
      "ocrText": "| Define header information\n\nbasePath\n\n+ Determines where the resources are rooted on the REST servlet\n\nREST servlet is defined in web.xml file with the default path rest\n\n+ Becomes a prefix to each of the paths\n\n+ The runtime path to the resources will\n\n<scheme>://<server>:<port>/<webapp>/<servlet>/\n<basePath>/<resource>\n\nhttp://localhost:8880/ab/rest/trn/ta/contact/v1/<resource> (resources\nare defined in paths)\n\nInsuranceSuite extensions\n\n+ Any declaration that starts with x-gw are custom InsuranceSuite\nextensions to the schema, for example:\n\nx-gw-schema-import\n\nx-gw-apihandlers\n\n:\n\nswagger: '2.0'\ninfo:\n\nversion: '1.0'\n\ntitle: \"Contact API\"\n\ndescription: \"Contact API\"\nbasePath: /trn/ta/contact/vl\nx-gw-schema-import:\n\ncontact: trn.ta.contact-1.0\ncontactnote: trn.ta.contactnote-1.0\nx-gw-apihandlers:\n- trainingapp. restapi .ContactAPIHandler\nproduces:\n- application/json\nconsumes:\n- application/json\npaths:",
      "ocrWordCount": 104,
      "ocrConfidence": 88.17,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 10,
      "title": "Define",
      "bodyParagraphs": [],
      "originalNotes": "Define get operation to view a contact and its notes\nCode example\nLine 17\nDefines the resource path.\nLine 18\nHTTP verb to read from the database.\nLine 20\nUnique method name the framework will call at runtime.\nLine 21\nInsuranceSuite extension that defines required permission(s) to execute the operation.\nLines 24,65\nRequired parameter is defined and passed in the URL path.\nLine 25\nFilter parameter is defined.\nOptionally used by the mapper query operation to obtain the TransformResult object.\nTwo filters will be available to external resource.\nLine 30\nStandard response code for a successful request.\nLine 33\nReference to the JSON schema definition used for the response returned by the operation, if any.\n\nHTTP response status are divided into the five categories:\nlxx: Informational\nCommunicates transfer protocol-level information\n2xx: Success\nIndicates that the client's request was accepted successfully\n3xx: Redirection\nIndicates that the client must take some additional action in order to complete their request\n4xx: Client Error\nThis category of error status codes points the finger at clients\n5xx: Server Error\nThe server takes responsibility for these error status codes\n\nHTTP response code examples:\n• 200 (0K) — standard response for successful HTTP requests. The actual response will depend on the request method used. In a GET request, the response will contain an entity corresponding to the requested resource. In a POST request, the response will contain an entity describing or containing the result of the action.\n• 201 (Created) — the request has been fulfilled, resulting in the creation of a new resource- The origin server MIJST create the resource before\nreturning the 201 status code.\n• 202 (Accepted) — the request has been accepted for processing, but the processing has not been completed. The request might or might not be eventually acted upon, and may be disallowed when processing occurs. More information on HTTP status codes can be found at https:/fen.wikipedia.org/wikifl-I st of HTTP status codes.\nPaths Template\npaths:\n/<path>:\n<method>: # methods are in lower-case, i.e. get, post, patch, put, delete, options, or head\nsummary: <summary> #\nAny text you like\n description: <description>\n# Any text you like\noperationld.\n<operationld> # Becomes the handler method name, must be unique within this schema parameters: # You can omit this if the method has no parameters. Parameters is a list, so each element is prefixed with '-' to indicate its a list item\n- name: <f00>\nin:\n<query/path/bodytheader> # either query, path, body, or header\nrequired: <true/false> # defaults to false, must be set to 'true' for path parameters\ntype:\n<string/integer/number/boole an> # only for query, path, or an> header parameters\nschema: # Only included\nfor the body parameter\n$ref:\n<alias>#/definitions/<name>\nresponses:\n'<code>': # Make sure it's in single or double quotes. 200 is generic, 201 for \"created\", 204 for responses without a body description:\n<description>\nschema: # Only include\nfora 201 or 204\nSref:\n<alias>#/definitions/<name>\n\nPermissions\nGenerally, permissions should be enforced in the handler, rather than using the x-gw-permissions property in the schema. System permissions can be used in the schema if there's no special application-level logic on that permission Referencing the system permission directly is often not very safe, because you may be bypassing the logic on the associated application permission key, i.e. if you used abview, you'd bypass all the Tag permission logic for ABContact.",
      "notes": "Define get operation to view a contact and its notes\nCode example\nLine 17\nDefines the resource path.\nLine 18\nHTTP verb to read from the database.\nLine 20\nUnique method name the framework will call at runtime.\nLine 21\nInsuranceSuite extension that defines required permission(s) to execute the operation.\nLines 24,65\nRequired parameter is defined and passed in the URL path.\nLine 25\nFilter parameter is defined.\nOptionally used by the mapper query operation to obtain the TransformResult object.\nTwo filters will be available to external resource.\nLine 30\nStandard response code for a successful request.\nLine 33\nReference to the JSON schema definition used for the response returned by the operation, if any.\n\nHTTP response status are divided into the five categories:\nlxx: Informational\nCommunicates transfer protocol-level information\n2xx: Success\nIndicates that the client's request was accepted successfully\n3xx: Redirection\nIndicates that the client must take some additional action in order to complete their request\n4xx: Client Error\nThis category of error status codes points the finger at clients\n5xx: Server Error\nThe server takes responsibility for these error status codes\n\nHTTP response code examples:\n• 200 (0K) — standard response for successful HTTP requests. The actual response will depend on the request method used. In a GET request, the response will contain an entity corresponding to the requested resource. In a POST request, the response will contain an entity describing or containing the result of the action.\n• 201 (Created) — the request has been fulfilled, resulting in the creation of a new resource- The origin server MIJST create the resource before\nreturning the 201 status code.\n• 202 (Accepted) — the request has been accepted for processing, but the processing has not been completed. The request might or might not be eventually acted upon, and may be disallowed when processing occurs. More information on HTTP status codes can be found at https:/fen.wikipedia.org/wikifl-I st of HTTP status codes.\nPaths Template\npaths:\n/<path>:\n<method>: # methods are in lower-case, i.e. get, post, patch, put, delete, options, or head\nsummary: <summary> #\nAny text you like\n description: <description>\n# Any text you like\noperationld.\n<operationld> # Becomes the handler method name, must be unique within this schema parameters: # You can omit this if the method has no parameters. Parameters is a list, so each element is prefixed with '-' to indicate its a list item\n- name: <f00>\nin:\n<query/path/bodytheader> # either query, path, body, or header\nrequired: <true/false> # defaults to false, must be set to 'true' for path parameters\ntype:\n<string/integer/number/boole an> # only for query, path, or an> header parameters\nschema: # Only included\nfor the body parameter\n$ref:\n<alias>#/definitions/<name>\nresponses:\n'<code>': # Make sure it's in single or double quotes. 200 is generic, 201 for \"created\", 204 for responses without a body description:\n<description>\nschema: # Only include\nfora 201 or 204\nSref:\n<alias>#/definitions/<name>\n\nPermissions\nGenerally, permissions should be enforced in the handler, rather than using the x-gw-permissions property in the schema. System permissions can be used in the schema if there's no special application-level logic on that permission Referencing the system permission directly is often not very safe, because you may be bypassing the logic on the associated application permission key, i.e. if you used abview, you'd bypass all the Tag permission logic for ABContact.",
      "narration": "",
      "ocrText": "| Define get operation to view a contact anditsnotes [5\n\n• HTTP GET requests are used to retrieve resource information only\n\n/contacts/{contactId}:\nget:\nsummary: \"Retrieves a contact details”\noperationId: getContact\nx-gw-permissions:\n~ abview\nparameters:\n- $ref: \"#/parameters/contactId\"\n~ name: filter\nin: query\ntype: string\nenum: [\"contact_details\", \"contactnote details\")\nresponses:\n\"200\":\ndescription: \"Contact details returned”\nschema:\n$ref: \"contact#/definitions/ContactDetails”\n\nWH\n\n¥\n\n¥.\n\nv\n\nparameters:\ncontactId:\nname: contactId\nin: path\ntype: string\nrequired: true",
      "ocrWordCount": 71,
      "ocrConfidence": 84.37,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 11,
      "title": "Define patch operation to update a contact",
      "bodyParagraphs": [],
      "originalNotes": "Define patch operation to update a contact\nCode example\nLine 34\nHTTP verb to update a database record.\nLine 36\nUnique method name the framework will call at runtime.\nLine 37\nExplicitly defines what the operation will produce, if any.\nOverrides default setting of application/json.\nLine 40\nRequired parameter is defined and passed in the URL path.\nLines 41-45\nDefines the parameter for the JSON object sent in from the external resource.\nJSON object parameters are defined by the referenced schema.\nLine 47\nStandard response code for successful update.\nLine 50\nSchema definition used for the response returned by the operation, if any.",
      "notes": "Define patch operation to update a contact\nCode example\nLine 34\nHTTP verb to update a database record.\nLine 36\nUnique method name the framework will call at runtime.\nLine 37\nExplicitly defines what the operation will produce, if any.\nOverrides default setting of application/json.\nLine 40\nRequired parameter is defined and passed in the URL path.\nLines 41-45\nDefines the parameter for the JSON object sent in from the external resource.\nJSON object parameters are defined by the referenced schema.\nLine 47\nStandard response code for successful update.\nLine 50\nSchema definition used for the response returned by the operation, if any.",
      "narration": "",
      "ocrText": "| Define patch operation to update a contact Gi\n\n• HTTP PATCH requests are used to make a partial update on a resource\n\n• HTTP PUT requests are used to replace a resource in its entirety\n\n14 Wd\n\npatch:\nsummary: \"Updates a contact\"\noperationId: updateContact\nproduces:\n- text/plain\nparameters:\n- $ref: \"#/parameters/contactId\"\n- name: body\nin: body\nrequired: true\nschema:\n$ref: \"contact#/definitions/ContactUpdate\"\nresponses:\n*200':\ndescription: \"Contact was updated\"\nschema:\ntype: string",
      "ocrWordCount": 71,
      "ocrConfidence": 86.39,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 12,
      "title": "Define post operation to add a note to a contact",
      "bodyParagraphs": [],
      "originalNotes": "Define post operation to add a note to a contact\nCode example\nLine 51\nDefines the resource path.\nLine 52\nHTTP verb to add a database record.\nLine 54\nUnique method name the framework will call at runtime.\nLine 56\nRequired parameter is defined and passed in the URL path.\nLines 57-61\nDefines the parameter for the JSON object sent in from the external resource.\nJSON object parameters are defined by the referenced schema.\nLine 63\nStandard response code for successful update.",
      "notes": "Define post operation to add a note to a contact\nCode example\nLine 51\nDefines the resource path.\nLine 52\nHTTP verb to add a database record.\nLine 54\nUnique method name the framework will call at runtime.\nLine 56\nRequired parameter is defined and passed in the URL path.\nLines 57-61\nDefines the parameter for the JSON object sent in from the external resource.\nJSON object parameters are defined by the referenced schema.\nLine 63\nStandard response code for successful update.",
      "narration": "",
      "ocrText": "| Define post operation to add a note to a contact Gi\n\n•« HTTP POST requests are used to create new resources\n\nLW\n\n/contacts/{contactId} /note:\npost:\nsummary: \"Adds a note to a contact”\noperationId: createContactifote\nparameters:\n- $ref: \"#/parameters/contactIa\"\n~ name: body\nin: body\nrequired: true\nschema:\n$ref: \"contactnote#/definitions/ContactNoteDetails”\nresponses:\n\"201\":\ndescription: \"Note was added to the contact”",
      "ocrWordCount": 58,
      "ocrConfidence": 84.46,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 13,
      "title": "Parameter validation constraints",
      "bodyParagraphs": [],
      "originalNotes": "Parameter validation constraints\nWalking through above example:\nThere are couple of parameters specified for the above resource namely the path parameter destinationld and the query parameter category\nThe path parameter destinationld is required and must be an 32 bit integer value\nThe query parameter category is not required but if specified itmust be a string and it must correspond to a code from one of the typekeys in the ErrorCategory typelist\n\nMore information on swagger schema 2.0 specifications can be found at: https://github.com/OAl/OpenAPl- Specification/blob/master/version s/2.0.md",
      "notes": "Parameter validation constraints\nWalking through above example:\nThere are couple of parameters specified for the above resource namely the path parameter destinationld and the query parameter category\nThe path parameter destinationld is required and must be an 32 bit integer value\nThe query parameter category is not required but if specified itmust be a string and it must correspond to a code from one of the typekeys in the ErrorCategory typelist\n\nMore information on swagger schema 2.0 specifications can be found at: https://github.com/OAl/OpenAPl- Specification/blob/master/version s/2.0.md",
      "narration": "",
      "ocrText": "| Parameter validation constraints Gi\n\n« Aresource may have a parameter in OED\ntheir path, body, header and query\n\n\"/destinations/{destinationId}/retry\":\npost:\n\nDepending on the type of parameter,\nconstraints can be specified to ensure\nthe request conforms to expected\nschema definition\n\nApart from standard swagger schema\n2.0 spec parameter options we also\nsupport:\n\n* x-gw-type for path, query and header\nparameters\n\n* The value of x-gw-type is an InsuranceSuite\ntypekey\n\nsummary: “Retry messages for a destination that had errors”\ndescription: \"\"\noperationid: retryHessages\nx-gw-apihandler: gw.api.rest.pl.system.v10.MessagingToolsaPIHandler\nparameters:\n- ref: “#/parameters/destinationid™\n-]name: category\njin: query\nrequired: false\n\nItype: string\n{x-gu-type:_typekey.ErrorCategory\nparameters:\ndestinationId:\nname: destinationid\nin: path\ndescription: “ID of the destination”\nrequired: true\ntype: integer\nformat: _int32",
      "ocrWordCount": 114,
      "ocrConfidence": 85.1,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 14,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 15,
      "title": "Integration Views and the REST API",
      "bodyParagraphs": [],
      "originalNotes": "Integration Views and the REST API\nJSON schema and mapping configuration is covered in detail in the Integration Views lesson.",
      "notes": "Integration Views and the REST API\nJSON schema and mapping configuration is covered in detail in the Integration Views lesson.",
      "narration": "",
      "ocrText": "| Integration Views and the REST API Gi\n\n• API inputs and outputs can be associated with a\n\nJSON schema definition and its corresponding > =\nmapper file VE filters.trn.ta\n\n= address_minimal-1.0.gql\n& contact_details-1.0.gql\n= contactnote_details-1.0.gql\n\n* The JSON schema and mapping files in\nInsuranceSuite are shared between the Integration\n\nViews framework and the REST API framework mappingstinta\n4) address-1.0.mapping,json\n• Both make use of the same files, with the same rules, and 4) contact-1.0.mapping,json\n\nthe same subset of json schema 4 contactnote-1.0.mapping,json\n\n> gw.pl.framework\n\nv tr.ta\n4) address-1.0.schema,json\n•) contact-1.0.schema,json\n\n5 contactnote-1.0.schema,json",
      "ocrWordCount": 93,
      "ocrConfidence": 85.45,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 16,
      "title": "Integration View files to view a contact and its notes [5",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "| Integration View files to view a contact and its notes [5\n\n*« Schema file\n\n* contact-1.0.schema.json imports address and schemas > Bm apis\n* ContactDetails definition contains properties needed for ¥ En fitters:tm.ta\nresponse object = address_minimal-1.0.gql\n2 contact_details-1.0.gql\n• Mapper file # contactnote_details-1.0.9ql\ncoe . . mappings.tmn.ta\n* contact-1.0.mapping.json imports address and mappings  address-1.0.mapping,json\n* ContactDetails mappers defines paths to data needed for i} contact-1.0.mapping,json\nresponse object properties { contactnote-1.O.mapping,son\n\n• Filter files gw.pl.framework\n\ntna\n\n* contact_details-1.0.gql\n\n4) address-1.0.schema,json\n\n* contactnote_details-1.0.gql () contact-1.0.schema,json\n) contactnote-1.0.schema,json\n\n« Used to return either contact or notes information",
      "ocrWordCount": 96,
      "ocrConfidence": 77.63,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 17,
      "title": "Integration View files used to update a contact",
      "bodyParagraphs": [],
      "originalNotes": "Integration View files used to update a contact\nCode example\nLines 39,43\nBy default, on input, explicitly- null properties are not allowed.\nTo allow this, nulls have to be explicitly defined on the property.\nThe only use case for explicit nulls on inputs is for PATCH requests, where you need to explicitly null out a field.\n\nNote that required fields can not have null values. Reference the data dictionary prior to allowing a null field.",
      "notes": "Integration View files used to update a contact\nCode example\nLines 39,43\nBy default, on input, explicitly- null properties are not allowed.\nTo allow this, nulls have to be explicitly defined on the property.\nThe only use case for explicit nulls on inputs is for PATCH requests, where you need to explicitly null out a field.\n\nNote that required fields can not have null values. Reference the data dictionary prior to allowing a null field.",
      "narration": "",
      "ocrText": "| Integration View files used to update a contact Gi\n\n* Schema file\n\n* ContactUpdate definition is added to the J nemne  wontect\ncontact-1.0.schema.json file \"properties\" : {\n36 \"DateOfBirth\" : {\n* x-gw-nullable = true added to \"type\" : \"string\",\nproperties to allow for null values \"format\" : \"date-time\",\n39 \"x-gw-nullable\" : true\n+ By default, on input, explicitly-null properties\nare not allowed \"DriversLicenseNumber\" : {\n\n\"type\" : \"string\",\n\"x-gw-nullable\" : true\n\n• Mapper file\n\n}\n\n:, . A . \"Dri Li State\" : {\n+ Not required since mapping of the input . “type” t \"etring\",\nproperties ” \"x-gw-type\" : \"typekey. Jurisdiction”\nand domain properties will be handled in the }\n\nAPI handler class } ,",
      "ocrWordCount": 118,
      "ocrConfidence": 84.29,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 18,
      "title": "Integration View files used to add a contact note",
      "bodyParagraphs": [],
      "originalNotes": "Integration View files used to add a contact note\nNote that required fields can not have null values. Reference the data dictionary prior to allowing a null field.",
      "notes": "Integration View files used to add a contact note\nNote that required fields can not have null values. Reference the data dictionary prior to allowing a null field.",
      "narration": "",
      "ocrText": "| Integration View files used to add a contact note\n\nSchema file\n* contactnote-1.0.schema.json file\nMapper file\n\n* Not required since mapping of the input\nproperties and domain properties will be\nhandled in the API handler class\n\nGi\n\n‘} contactnote-1.0.schema,json\n\nt\n\n\"$schema\" :\n\"definitions\" : {\n\n\"http: //json-schema.org/draft-04/schema#\",\n\n\"contactNoteDetails” : {\n\"type\" : \"object\",\n\"properties\" : {\n\"contactNoteType” : {\npe\" : \"string\",\ngw-type\" : \"typekey.ContactNoteType”\n\nim\n\"Confidential\" : {\n\n\"type\" : \"boolean\"\nih\n\"Subject\" : {\n\n\"type\": \"string\"\nh\n\"Body\" = {\n\n\"type\": \"string\"",
      "ocrWordCount": 85,
      "ocrConfidence": 78.24,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 19,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 20,
      "title": "API handler class",
      "bodyParagraphs": [],
      "originalNotes": "API handler class\nLifecycle\nThe handler class itself is created for every single request, so it's important that the handler class's have a no argument public constructor. The handler method is invoked after the request has been authenticated and all inputs have been validated and deserialized; if the input is invalid, the handler method will never be invoked.\nHandler Method Requirements The handler method for a given operation needs to meet the following criteria:\nThe method's name must match the operationld; if the operationld is not a valid identifier, for purposes of determining the expected method name, a leading '_' will be prepended if the first character is not a valid identifier start, and all other illegal characters will be replaced with ‘ ‘\nThe method must be public\nThe method must be non-static\nThe method's parameters must either be of type RequestContext, or must have a name and type that matches a parameter declared on the operation's configuration The method's return type must be either be void, gw-api.rest. Response, or some type that the framework can serialize out\nThe class containing the method must have a no- arg constructor\nIt's not technically a requirement that the handler class be implemented in Gosu rather than Java, but the parameter bindingalgorithm relies on method parameter names, and those parameter names are not currently preserved in Java, so as a practical matter API handler classes must currently be implemented in Gosu. If you wish to implement the handler class in Java, you can create a Gosu class that simply serves to bind method parameters and then delegates all actual logic to a Java helper class.\n\nHandler Binding Algorithm The set of possible handler classes can either be specified directly on the operation, via the x-gw- apihandler property, or the list\nof potential handler classes can be inherited from the x- gw-apihandlers property on the root object. (Note that x- gw-apihandlers is not inherited across files via combination: the defaults there only apply to operations defined in that file.) x-gw- apihandler defined at the operation level will override the value of x-gw-apihandlers on the document root. Methods are bound to operations when the REST servlet is initialized, and for each operation the search algorithm looks like this.\nEach API handler class is considered individually, in order\nFirst, only the explicitly declared methods on that classare considered (i.e. methods inherited from supertypes are ignored)\nIf a method is public, non-static, and has the same name as theoperationld,consider it as a possible handler method\nIf there were two or more possiblemethods, report aconfiguration error\nIf exactly one method matched, assume that's the handler method to use\nIf no methods matched, proceed to looking at all methods on the handler class,not just declared methods\nThe same logic applies: two or more possibilities is an error, a single matching method means we use that method\nIf no matches were found on this handler class, proceed to searching the next handler class\nIf all handler classes have been considered and no matches were found, report a configuration error\nIf a handler method was found, validate its type and arguments according to the requirements mentioned above.",
      "notes": "API handler class\nLifecycle\nThe handler class itself is created for every single request, so it's important that the handler class's have a no argument public constructor. The handler method is invoked after the request has been authenticated and all inputs have been validated and deserialized; if the input is invalid, the handler method will never be invoked.\nHandler Method Requirements The handler method for a given operation needs to meet the following criteria:\nThe method's name must match the operationld; if the operationld is not a valid identifier, for purposes of determining the expected method name, a leading '_' will be prepended if the first character is not a valid identifier start, and all other illegal characters will be replaced with ‘ ‘\nThe method must be public\nThe method must be non-static\nThe method's parameters must either be of type RequestContext, or must have a name and type that matches a parameter declared on the operation's configuration The method's return type must be either be void, gw-api.rest. Response, or some type that the framework can serialize out\nThe class containing the method must have a no- arg constructor\nIt's not technically a requirement that the handler class be implemented in Gosu rather than Java, but the parameter bindingalgorithm relies on method parameter names, and those parameter names are not currently preserved in Java, so as a practical matter API handler classes must currently be implemented in Gosu. If you wish to implement the handler class in Java, you can create a Gosu class that simply serves to bind method parameters and then delegates all actual logic to a Java helper class.\n\nHandler Binding Algorithm The set of possible handler classes can either be specified directly on the operation, via the x-gw- apihandler property, or the list\nof potential handler classes can be inherited from the x- gw-apihandlers property on the root object. (Note that x- gw-apihandlers is not inherited across files via combination: the defaults there only apply to operations defined in that file.) x-gw- apihandler defined at the operation level will override the value of x-gw-apihandlers on the document root. Methods are bound to operations when the REST servlet is initialized, and for each operation the search algorithm looks like this.\nEach API handler class is considered individually, in order\nFirst, only the explicitly declared methods on that classare considered (i.e. methods inherited from supertypes are ignored)\nIf a method is public, non-static, and has the same name as theoperationld,consider it as a possible handler method\nIf there were two or more possiblemethods, report aconfiguration error\nIf exactly one method matched, assume that's the handler method to use\nIf no methods matched, proceed to looking at all methods on the handler class,not just declared methods\nThe same logic applies: two or more possibilities is an error, a single matching method means we use that method\nIf no matches were found on this handler class, proceed to searching the next handler class\nIf all handler classes have been considered and no matches were found, report a configuration error\nIf a handler method was found, validate its type and arguments according to the requirements mentioned above.",
      "narration": "",
      "ocrText": "| API handler class Gi\n\nx-gv-apihandlers:\n\n* Handler classes can be specified at the root level of ~ erainingapp.reevapt .ConcactAPTHandier\nthe document and overridden at the operation level y aepticarianrdaea\n* The root document can provide a list of classes rather than « sppliasion seen\njust one; they'll be considered in order 2 Jeontacts/(contactta)\nget:\n+ Handler classes need to have a no arguments, public constructor : anemone net Seteuist\n\ndeno.restapi .DemoContactAPIHandler\n\nclass Con\n\n* Every operation defined for a published API must have an associated handler method\n\n+ For each operation:\n\nFramework will look for a public method with a name matching the operationld, for each candidate handler class\nDeclared methods are considered first, then all methods\nThere must be exactly one match\n\nMethod names cannot be overloaded",
      "ocrWordCount": 129,
      "ocrConfidence": 87.39,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 21,
      "title": "Parameter binding",
      "bodyParagraphs": [],
      "originalNotes": "Parameter binding\nQuery, Header, and Path Parameters\nQuery parameters, header parameters, and path parameters are all handledsimilarly- All such parameters declared in the schema will be processed as follows:\nIf the parameter is required, but is not present on the request, anerror message will begenerated\nIf the input parameter does not match the defined data type, an error message will be generated\nIf the input parameter does not conform to the declared constraints such as minLength or maximum, an error message will be generated\n\nParameters\nParameter types should match the deserialized type of the parameter\nString, BigDecimal, Date, etc. for scalar values.\nList for array values.\nJsonObject, a JsonWrapperSubcIass, String, or byte[] for the body parameter.\n\nRequestContext Object\nThe RequestContext interface represents information about the current request being processed. Any API handler method can be passed the current RequestContext for the request by having a parameter of type request context. Request on text IS a so use as input to the IRestDispatchPlugin. The RequestContext object serves a number of differentmethods at runtime. It can be used to:\nAccess the original HttpServletRequest to obtain raw requestinformation that might notbe surfaced in other ways.\nAccess headers, query parameters, and path parameters by name, in either deserialized (ifthey're explicitly listed in the schema) or \"raw\"form. This can be helpful when writing common infrastructure shared across multiple API endpoints; for example, if you have several APIs that use a query parameter named \"sort“ that works in a predictable way, you can build common infrastructure that can take the RequestContext and extract the \"sort\" query parameter from it by name, rather than passing the parameter values down directly.\nAccess metadata about the request being served such as theSwaggerOperation object,path template, or API fully-qualified name.\nAccess other information about the request being handled, such as the negotiated response content type.",
      "notes": "Parameter binding\nQuery, Header, and Path Parameters\nQuery parameters, header parameters, and path parameters are all handledsimilarly- All such parameters declared in the schema will be processed as follows:\nIf the parameter is required, but is not present on the request, anerror message will begenerated\nIf the input parameter does not match the defined data type, an error message will be generated\nIf the input parameter does not conform to the declared constraints such as minLength or maximum, an error message will be generated\n\nParameters\nParameter types should match the deserialized type of the parameter\nString, BigDecimal, Date, etc. for scalar values.\nList for array values.\nJsonObject, a JsonWrapperSubcIass, String, or byte[] for the body parameter.\n\nRequestContext Object\nThe RequestContext interface represents information about the current request being processed. Any API handler method can be passed the current RequestContext for the request by having a parameter of type request context. Request on text IS a so use as input to the IRestDispatchPlugin. The RequestContext object serves a number of differentmethods at runtime. It can be used to:\nAccess the original HttpServletRequest to obtain raw requestinformation that might notbe surfaced in other ways.\nAccess headers, query parameters, and path parameters by name, in either deserialized (ifthey're explicitly listed in the schema) or \"raw\"form. This can be helpful when writing common infrastructure shared across multiple API endpoints; for example, if you have several APIs that use a query parameter named \"sort“ that works in a predictable way, you can build common infrastructure that can take the RequestContext and extract the \"sort\" query parameter from it by name, rather than passing the parameter values down directly.\nAccess metadata about the request being served such as theSwaggerOperation object,path template, or API fully-qualified name.\nAccess other information about the request being handled, such as the negotiated response content type.",
      "narration": "",
      "ocrText": "| Parameter binding\n\nEach method parameter must match the name and\ntype of a parameter declared on the Swagger schema\n\n* Order doesn’t matter\n\n+ Don’t have to include all possible parameters\n\nclass Cont\n\nfunction getContact(contactId : String,| fi\n\n|: TransformResult {...}\n\nEach parameter to the API handler method must either be:\n\n+ A parameter declared on the Swagger schema for the associated\noperation, or\n\n* Of type gw.api.rest.RequestContext\n\nRuntime operation parameter values can always be retrieved by name\nfrom the RequestContext if they're not explicit arguments to the handler\nmethod\n\nGi\n\npaths:\n/contacts/(contactId}:\nget:\n\nsummary: \"Retrieves a contact details\"\nx-gw-apihandlers:\n~ deno. restapi .DenoContactAPIHandler\noperationId: getContact\nx-gw-permissions: <1 ites>\n\nters /contactId\"\n\nenum: [\"contact details\", \"contactnote details\")",
      "ocrWordCount": 117,
      "ocrConfidence": 86.37,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 22,
      "title": "Return values",
      "bodyParagraphs": [],
      "originalNotes": "Return values\nThe API Handler method can return either\ngw-api.rest. Response, void, or any type that can be serialized out at runtime. If the Swagger operation defines multiple 2xx response codes, then the handler method must return gw-api.rest. Response, so that the handler method can set the desired status code. It’s also legal for a handler method to return Object and have different possible return values at runtime, so long as those return values are all serializable at runtime by the framework.\n\nSome common return types include:\nvoid - If an operation returns a 204 response code, the method handler can have no return value.\nJsonObject or JsonWrapper subtype – An operation that produces JSON and/or XML can return a JsonObject or any generated schema wrapper type.\nTransformResult – An operation that produces JSON and/or XML and which uses an Integration Mapping to produce that data can return a TransformResult directly.\nResponse - If the method handler needs moreexplicit control over theresponse's status code, or wishes to add custom headers to the response, the method handler can that combines the desired status code, response body, and headers.\nString or byteO – For something other than JSON or XML return data, the handler method can return a String or byte[] that will be written out as- is.\n\nExceptions\nAPI handler methods can throw exceptions that will then be translated into appropriate HTTP status codes and error messages. Any exception that implements the gw-api.exception. HasErrorlnfo interface can be used,including custom exception subtypes, but in general the exception classes defined in the gw.api.rest.exception package should be suitable for mapping to common error cases. For example, NotFoundException can be thrown if an entity ID referenced from a path parameter can not be found in the database, or a BadlnputException can be thrown if the input fails some additional validation performed by the method handler. Any exception thrown by the method handler that does not implement HasErrorlnfo will automatically be mapped to a 500 (Internal Server Error) status code.",
      "notes": "Return values\nThe API Handler method can return either\ngw-api.rest. Response, void, or any type that can be serialized out at runtime. If the Swagger operation defines multiple 2xx response codes, then the handler method must return gw-api.rest. Response, so that the handler method can set the desired status code. It’s also legal for a handler method to return Object and have different possible return values at runtime, so long as those return values are all serializable at runtime by the framework.\n\nSome common return types include:\nvoid - If an operation returns a 204 response code, the method handler can have no return value.\nJsonObject or JsonWrapper subtype – An operation that produces JSON and/or XML can return a JsonObject or any generated schema wrapper type.\nTransformResult – An operation that produces JSON and/or XML and which uses an Integration Mapping to produce that data can return a TransformResult directly.\nResponse - If the method handler needs moreexplicit control over theresponse's status code, or wishes to add custom headers to the response, the method handler can that combines the desired status code, response body, and headers.\nString or byteO – For something other than JSON or XML return data, the handler method can return a String or byte[] that will be written out as- is.\n\nExceptions\nAPI handler methods can throw exceptions that will then be translated into appropriate HTTP status codes and error messages. Any exception that implements the gw-api.exception. HasErrorlnfo interface can be used,including custom exception subtypes, but in general the exception classes defined in the gw.api.rest.exception package should be suitable for mapping to common error cases. For example, NotFoundException can be thrown if an entity ID referenced from a path parameter can not be found in the database, or a BadlnputException can be thrown if the input fails some additional validation performed by the method handler. Any exception thrown by the method handler that does not implement HasErrorlnfo will automatically be mapped to a 500 (Internal Server Error) status code.",
      "narration": "",
      "ocrText": "| Return values Gi\n\n* The API Handler method can return either\ngw.api.rest.Response, void, or any type\nthat can be serialized out at runtime\n\nfunction getContact (contactid : String, filter : String) :{TransformResult (...}\n\nclass ContactAPIHan\n\nfunction updateContact (contactId : String, body : Jsondbjq Sering{...}\n\n* Some common return types include: function «\n\nactilove (contactId : String, body : Jsorpbject) : void (...}\n* void\n\n+ If the operation returns a 204 response code (no content), the method need not return anything at all\n* TransformResult\n\n+ An operation that produces JSON and/or XML and which uses an Integration Mapping to produce that data can\nreturn a TransformResult directly\n\n* String or byte]\n+ Can return a String or byte[] that will be written out as-is.\n+ Response\n\n+ Can return a Response object that explicitly sets the response code, response body, and/or custom headers",
      "ocrWordCount": 145,
      "ocrConfidence": 86.99,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 23,
      "title": "Handler method to view a contact and its notes",
      "bodyParagraphs": [],
      "originalNotes": "Handler method to view a contact and its notes\nCode example\nLines 17,70\nUse private method to retrieve contact object by PubliclD.\nLine 19\nCreate the JsonMapper object.\nDefine the fully qualified path to the mapper file.\nDefine the mapper name.\nLines 2030\nCreate the JsonMappingOptions object.\nBased on the filter argument, set the mapping option.\nLines 31,33\nRetum the TransformResult object.",
      "notes": "Handler method to view a contact and its notes\nCode example\nLines 17,70\nUse private method to retrieve contact object by PubliclD.\nLine 19\nCreate the JsonMapper object.\nDefine the fully qualified path to the mapper file.\nDefine the mapper name.\nLines 2030\nCreate the JsonMappingOptions object.\nBased on the filter argument, set the mapping option.\nLines 31,33\nRetum the TransformResult object.",
      "narration": "",
      "ocrText": "Handler method to view a contact and its notes\n\nfunction getContact(contactId : String, filter : String) : TransformResult (\n\nvar contact = findContactBylId(contactId)\n\n+0\", \"ContactDetails\")\n\nvar mappingOpts = new JsonMappingOptions ()\nswitch (filter) {\ncase \"contact_details\":\nnappingOpts.withFilter(\"trn.ta.contact_details-1.0\")\nbreak\ncase \"contactnote_details\":\nnappingOpts.withFilter(\"trn.ta.contactnote_details-1.0\")\nbreak\n}\nreturn jsonMapper.transformObject (contact, mappingOpts)\n} else {\nreturn jsonMapper.transformdbject (contact)\n}\n)\n\nprivate function findContactByld(contactId : String) : ABContact {\n\nvar query0b} = Query.make(ABContact)\n\nquery0bj..compare (ABContact#PublicID, Relop. Equals, contactId)\nvar target0bj = query0bj.select() .AtMostOneRow\n\nreturn target0bj",
      "ocrWordCount": 79,
      "ocrConfidence": 78.78,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 24,
      "title": "Handler method to update a contact",
      "bodyParagraphs": [],
      "originalNotes": "Handler method to update a contact\nCode example\nLine 38\nReference private method to retrieve the contact object.\nLine 39\nUse ContactlJpdate schema wrapper classes to wrap the JsonObject body argument.\nNote that ContactUpdate schema wrapper classes need to be generated first.\nLine 40\nCreate a new bundle to update the contact.\nCredentials provided by the external resource are used to commit the bundle.\nLines 43-53\nUpdate the contact object if new information is sent.\nLine 55\nRetum a String object.",
      "notes": "Handler method to update a contact\nCode example\nLine 38\nReference private method to retrieve the contact object.\nLine 39\nUse ContactlJpdate schema wrapper classes to wrap the JsonObject body argument.\nNote that ContactUpdate schema wrapper classes need to be generated first.\nLine 40\nCreate a new bundle to update the contact.\nCredentials provided by the external resource are used to commit the bundle.\nLines 43-53\nUpdate the contact object if new information is sent.\nLine 55\nRetum a String object.",
      "narration": "",
      "ocrText": "| Handler method to update a contact Gi\n\nfunction updateContact(contactId : String, body : JsonObject) : String{\nvar contact = findContactById(contactId)\nvar contactUpdate = ContactUpdate.vrap(body)\nTransaction. runW#ithNevBundle(\\b -> {\ncontact = b.add(contact)\n\nif (body.containsKey(\"dateOfBirth\")) {\n(contact as ABPerson) .DateOfBirth = contactUpdate.DateOfBirth\n\nif (body. containsKey(\"driversLicenseNumber\")) {\n(contact as ABPerson).LicenseNumber = contactUpdate.DriversLicenselumber\n\nif (body. containsKey(\"driversLicenseState\")) {\n(contact as ABPerson).LicenseState = contactUpdate.DriversLicenseState\n}\n»\nreturn (\"Contact \" + contact.DisplayName + \" was successfully updated\")",
      "ocrWordCount": 71,
      "ocrConfidence": 84.9,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 25,
      "title": "Handler method to create a contact note",
      "bodyParagraphs": [],
      "originalNotes": "Handler method to create a contact note\nCode example\nLine 59\nReference private method to retrieve contact object by PubliclD.\nLine 60\nUse ContactNoteDetails schema wrapper classes to wrap the JsonObject body argument.\nNote that ContactNoteDetails schema wrapper classes need to be generated first.\nLine 61\nCreate database transaction to update contact.\nExternal resource credentials will be used to commit the transaction.\nLines 62-66\nCreate new ContactNote entity instance.\nMap newNote fields to body fields.\nLine 67\nAdd the new note to the contact.",
      "notes": "Handler method to create a contact note\nCode example\nLine 59\nReference private method to retrieve contact object by PubliclD.\nLine 60\nUse ContactNoteDetails schema wrapper classes to wrap the JsonObject body argument.\nNote that ContactNoteDetails schema wrapper classes need to be generated first.\nLine 61\nCreate database transaction to update contact.\nExternal resource credentials will be used to commit the transaction.\nLines 62-66\nCreate new ContactNote entity instance.\nMap newNote fields to body fields.\nLine 67\nAdd the new note to the contact.",
      "narration": "",
      "ocrText": "| Handler method to create a contact note Gi\n\nfunction c e(contactId : String, body : JsonObject) : void {\nvar contac! ‘indContactById (contactId)\nvar contactNote = ContactNoteDetails.vrap (body)\nTransaction. runW#ithNewBundle(\\b -> {\nvar newNote = new entity.ContactNote()\nnewNote.ContactNoteType = contactNote.ContactloteType\nnewNote.IsConfidential = contactNote.Confidential\nnewNote. Subject = contactNote.Subject\nnewNote.Body = contactNote.Body\ncontact.addToContactNotes (newNote)\n\n* The newNote entity instance (ContactNote) is added to the contact read-only\nentity instance (ABContact) by a foreign key field on newNote itself\n\n• Therefore, the read-only contact entity instance does not need to be added to or\ncommitted in the bundle",
      "ocrWordCount": 95,
      "ocrConfidence": 87.55,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 26,
      "title": "Deploy code changes",
      "bodyParagraphs": [],
      "originalNotes": "Deploy code changes\nYou can restart the server from Studio by stopping a running server and after the server stops, then starting the server again in either Run or Debug mode (preferred for training).",
      "notes": "Deploy code changes\nYou can restart the server from Studio by stopping a running server and after the server stops, then starting the server again in either Run or Debug mode (preferred for training).",
      "narration": "",
      "ocrText": "| Deploy code changes Gi\n\n• New Gosu class * Modified Gosu Class\nD> Run ‘Server’\nTools VCS Window Help 9% Debug Server\nD Run ‘Server’ Shift+F10 W Run ‘Server’ with Coverage\n186 Debug ‘Server’ Shift+F9 D Run...\nE Run ‘Server’ with Coverage W Debus...\n\nAttach to Local Process...\n[> Edit Configurations...\nB] Import Test Results\n\nD Run... Alt+Shift+F10\nWE Debug... Alt+ Shift+F9\n7 Attach to Local Process...\n\n[> Edit Configurations... Il Stop ‘Server’\nImport Test Results > EF show Running List\n\nHE Stop ‘Server’ Ctrl F2 Stop Background Processes...",
      "ocrWordCount": 90,
      "ocrConfidence": 76.88,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 27,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 28,
      "title": "API publishing",
      "bodyParagraphs": [],
      "originalNotes": "API publishing\nDefault URL's\nswagger-ui URLs\n http://localhost:8880/ab/\n resources/swagger-ui/\n apis URL\n http://localhost:8880/ab/\n rest/apis\n\nVerify that you can visit the published API from the swagger-ui URL and that you can request the lapis endpoint from Postman (or any other tool you prefer).",
      "notes": "API publishing\nDefault URL's\nswagger-ui URLs\n http://localhost:8880/ab/\n resources/swagger-ui/\n apis URL\n http://localhost:8880/ab/\n rest/apis\n\nVerify that you can visit the published API from the swagger-ui URL and that you can request the lapis endpoint from Postman (or any other tool you prefer).",
      "narration": "",
      "ocrText": "| API publishing\n\nSchema files do not turn into network endpoints by default —— \"a\n\n* Must opt-in APIs to control what is exposed on the network\n\n.\n\n°\n\npublished-apis.yaml\n\n~ name: gw.pl.£f\n\njev_template-1.0\n\nFiles are added to config/integration/apis/published-apis.yaml\n\nExtension model\n\n* Customers extend the core API and publish their\nextended version, not the core one\n\n« Multiple live versions can be published, all based\non core version\n\nThe default API URL returns a list of APIs\nthat have been published\n\n* http://localhost:8880/ab/rest/apis\n\nic}\n\nJSON Raw Data\n\nSave Copy\nsapis:\nbasePath\ndescription\ndocs:\n\ntitle\n\ndescription\ndocs\ntitle\n\n® locathost:8880/ab/rest,\n\nHeaders\n\n“Dynamically lists the APIs that are available”\n“http://Locathost :8880/ab/rest/opis/swogger. json”\nwAPI List”\n\n“/contact/v1\"\n“Contact API”\n“http://Locathost :8880/ab/rest/contact/v1/swagger. json”\n“Contact API”",
      "ocrWordCount": 120,
      "ocrConfidence": 81.34,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 29,
      "title": "swagger-ui",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "| swagger-ui\n\n« InsuranceSuite bundles a swagger-ui distribution\n+ Default URL is <base servlet url>/resources/swagger-ui/\n+ http://localhost:8880/ab/resources/swagger-ui\n• Every API automatically gets a /swagger.json endpoint\n+ The serviet by default exists at /rest\n+ Returns the default external view of the schema\n• In swagger-ui manually change the endpoint to reference the desired API\n+ <basePath>/swagger.json\n\n+ The basePath declared in the schema is prepended to every path in the schema\n\n{+ swagger http:/localhost:8880/ab/rest/trn/ta/contact/v1/swagger.json\n\nExplore",
      "ocrWordCount": 75,
      "ocrConfidence": 88.25,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 30,
      "title": "Contact API",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Contact API\n\nClick Authorize to enter login credentials\nClick HTTP verb to test each API\n\n1. Click Try it out to test\nEnter parameter(s)\n\n2.\n3. Click Execute\n\nee CT\n\nContact API®\n\nContact API\nITP a\ndefault Vv\n\nParameters\n\nComacad sed\n\nfiter\n\nDescription\n\n_ 200\n\n- —\n\nServer response\n\ncode Details",
      "ocrWordCount": 51,
      "ocrConfidence": 83.57,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 31,
      "title": "Demonstration",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "| Demonstration G\n\nCreate a User REST API\n\nclick here\n\nNote: The demonstration opens a new tab in your browser. When the demonstration ends, the\noriginal course launch window appears. Return to this window to continue this presentation.",
      "ocrWordCount": 38,
      "ocrConfidence": 95.68,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_instruction",
      "demoVideoIndex": 0
    },
    {
      "slideNumber": 32,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": false,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_video"
    },
    {
      "slideNumber": 33,
      "title": "Question",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question G\nMatch the HTTP verb with its description\n•\n[verb answer Description\nif\n| PUT Delete from the database\n| RETRIEVE Update/Replace row in the database\nI GET Create a new record in the database\n| PATCH Read from the database\n| INSERT Update/Modify row in the database\n1 REMOVE Not an HTTP verb\n' POST Not an HTTP verb\n' REPLACE Not an HTTP verb\n|||\nDELETE Not an HTTP verb",
      "ocrWordCount": 77,
      "ocrConfidence": 83.56,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "Match the HTTP verb with its description:\n\nPUT: Delete from the database\nRETRIEVE: Update/Replace row in the database\nGET: Create a new record in the database\nPATCH: Read from the database\nINSERT: Update/Modify row in the database\nREMOVE: Not an HTTP verb\nPOST: Not an HTTP verb\nREPLACE: Not an HTTP verb\nDELETE: Not an HTTP verb",
        "answer": "PUT: Update/Replace row in the database\nRETRIEVE: Not an HTTP verb\nGET: Read from the database\nPATCH: Update/Modify row in the database\nINSERT: Not an HTTP verb\nREMOVE: Not an HTTP verb\nPOST: Create a new record in the database\nREPLACE: Not an HTTP verb\nDELETE: Delete from the database"
      }
    },
    {
      "slideNumber": 34,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer Gi\n_- — Match the HTTP verb with its description\n•\nSve [answer Description\nf\n| PUT Update/Replace row in the database Delete from the database\n| RETRIEVE Not an HTTP verb Update/Replace row in the database\nI GET Read from the database Create a new record in the database\n| PATCH Update/Modify row in the database Read from the database\n| INSERT Not an HTTP verb Update/Modify row in the database\n| REMOVE Not an HTTP verb Not an HTTP verb\ni] POST Create a new record in the database Not an HTTP verb\n| REPLACE Not an HTTP verb Not an HTTP verb\n! DELETE Delete from the database Not an HTTP verb",
      "ocrWordCount": 117,
      "ocrConfidence": 85.17,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 35,
      "title": "Knowledge Check",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question\nWhat file must be updated to publish an API schema?\nA) swagger.yaml\nB) published-schemas.yaml\nC) codegen-schemas.yaml\nD) published-apis.yaml\nE) json-apis.yaml\nSe Soe Se sees esse ese",
      "ocrWordCount": 31,
      "ocrConfidence": 75.97,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "What file must be updated to publish an API schema?\n\nA) swagger.yaml\nB) published-schemas.yaml\nC) codegen-schemas.yaml\nD) published-apis.yaml\nE) json-apis.yaml",
        "answer": "The correct answer is published-apis.yaml"
      }
    },
    {
      "slideNumber": 36,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer\n_- — What file must be updated to publish an API schema?\nook\nB\nc\nD\nE\nswagger.yaml\npublished-schemas.yaml\nwv\ncodegen-schemas.yaml\npublished-apis.yaml\njson-apis.yaml\nThe correct answer is published-apis.yaml\nSoo eS oe ese Sse ese",
      "ocrWordCount": 35,
      "ocrConfidence": 79.18,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 37,
      "title": "Key Takeaways",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Lesson\nobjectives * Create a swagger schema to define an API\n\nreview • Reference an existing Integration View in the\nAPI\n\n* Create an API handler class\n• Publish an API\n« Use swagger-ui to test an API",
      "ocrWordCount": 38,
      "ocrConfidence": 86.53,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives_review"
    },
    {
      "slideNumber": 38,
      "title": "Student Exercise",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "| Student exercise\n\nCreate a Contact REST API",
      "ocrWordCount": 8,
      "ocrConfidence": 95.44,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "exercise"
    }
  ],
  "videos": [
    {
      "index": 1,
      "filename": "In_08_01.mp4",
      "path": "/academy/guidewire/videos/ch11/In_08_01.mp4"
    }
  ],
  "hasNotes": true,
  "hasTables": false,
  "hasImages": true,
  "ocrMetadata": {
    "totalWords": 2631,
    "avgConfidence": 85.63,
    "extractedAt": "2026-02-15T18:20:44.185266"
  }
}
