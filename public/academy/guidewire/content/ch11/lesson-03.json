{
  "lessonId": "ch11-l03",
  "chapterId": 11,
  "chapterSlug": "ch11",
  "lessonNumber": 3,
  "title": "Gosu Queries",
  "sourceFile": "Gosu Queries.pptx",
  "sourceFolder": "In_Integration_03",
  "totalSlides": 41,
  "estimatedMinutes": 123,
  "slides": [
    {
      "slideNumber": 1,
      "title": "Gosu Queries",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Gosu Queries",
      "ocrWordCount": 2,
      "ocrConfidence": 94.5,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "title"
    },
    {
      "slideNumber": 2,
      "title": "Learning Objectives",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Lesson\nobjectives\n\n• Describe a query object\n\n• Identify various types of query restrictions\n\n• Write Gosu queries to retrieve objects from a\nGuidewire application\n\n• lIterate through the results of query",
      "ocrWordCount": 32,
      "ocrConfidence": 86.78,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives"
    },
    {
      "slideNumber": 3,
      "title": "Query basics",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Query basics",
      "ocrWordCount": 2,
      "ocrConfidence": 96.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 4,
      "title": "Query objects",
      "bodyParagraphs": [],
      "originalNotes": "Query objects\nGosu queries are useful when code must work with a set of objects that does not exist as an array, such as all contact notes created by this user. Guidewire recommends that all new queries be written as Gosu queries because Gosu queries have the following advantages:\nThey more readily support the construction of complex queries\nThey use builder patterns, which simplify the creation of search screens\nThey use a syntax more intuitive to people accustomed to writing queries in Structured Query Language (SQL)\n\nResults are fetched from the Guidewire application when they are counted, made iterable, or when one object is retrieved. Depending on the query, the results may be fetched from the Guidewire application cache and/or the Guidewire application database. To learn more, refer to documentation in the Gosu Reference Guide.",
      "notes": "Query objects\nGosu queries are useful when code must work with a set of objects that does not exist as an array, such as all contact notes created by this user. Guidewire recommends that all new queries be written as Gosu queries because Gosu queries have the following advantages:\nThey more readily support the construction of complex queries\nThey use builder patterns, which simplify the creation of search screens\nThey use a syntax more intuitive to people accustomed to writing queries in Structured Query Language (SQL)\n\nResults are fetched from the Guidewire application when they are counted, made iterable, or when one object is retrieved. Depending on the query, the results may be fetched from the Guidewire application cache and/or the Guidewire application database. To learn more, refer to documentation in the Gosu Reference Guide.",
      "narration": "",
      "ocrText": "| Query objects G\n« AGosu query specifies the entity and criteria associated with the entity to retrieve\nfrom the Guidewire application\n« Use Gosu queries to retrieve one or more objects\n+ Referenced by foreign key relationships\n+ NOT in an array relationship <>\n* Query object specifies the query criteria al Ses)\n« Which entity to query\n« What restrictions to apply\n\nab_abcontact\n• Results object is a set of entity instances fetched from te = 1 ot\nGuidewire application\n\ny\n* How many? 0)\n\n« How to order?",
      "ocrWordCount": 91,
      "ocrConfidence": 85.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 5,
      "title": "Steps to execute a basic query",
      "bodyParagraphs": [],
      "originalNotes": "Steps to execute a basic query\nShown here are the steps to execute a basic query.",
      "notes": "Steps to execute a basic query\nShown here are the steps to execute a basic query.",
      "narration": "",
      "ocrText": "| Steps to execute a basic query\n\n1. Create the query object using the make method\n2. Create the results object using the select method\n\n3. Process the results of the query as needed",
      "ocrWordCount": 34,
      "ocrConfidence": 95.79,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 6,
      "title": "Step 1: Create the query object",
      "bodyParagraphs": [],
      "originalNotes": "Step 1: Create the query object\nCode example\nLine 4\nCreates the query object for the ABContact entity type.\nThe query retrieves all inst\nances of ABContact.\nBest practice would dictate that the query above should contain some restrictions, as the ABContact entity maycontain many records. Restrictions are covered later in this lesson.",
      "notes": "Step 1: Create the query object\nCode example\nLine 4\nCreates the query object for the ABContact entity type.\nThe query retrieves all inst\nances of ABContact.\nBest practice would dictate that the query above should contain some restrictions, as the ABContact entity maycontain many records. Restrictions are covered later in this lesson.",
      "narration": "",
      "ocrText": "| Step 1: Create the query object\n\n1 uses gw.api.database.Query\n2\n3 var output =\"\n—> 4 var queryObj = Query.make(entity.ABContact)\n\n* Query is a class in the gw.api.database package\n\n* make (EntityName) is a method that requires a named entity type",
      "ocrWordCount": 42,
      "ocrConfidence": 85.43,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 7,
      "title": "Step 2: Create the results object",
      "bodyParagraphs": [],
      "originalNotes": "Step 2: Create the results object\nCode example\nLine 5\nCreates the results object.\n\nIn the slide example, the results object is a convention the helps distinguish the query object and the results object. The results object is not required. It is not always necessary to create an explicit results object. For example, it is possible to write the above as:\nvar queryObj =\nQuery.make(ABContact).sel\nect()",
      "notes": "Step 2: Create the results object\nCode example\nLine 5\nCreates the results object.\n\nIn the slide example, the results object is a convention the helps distinguish the query object and the results object. The results object is not required. It is not always necessary to create an explicit results object. For example, it is possible to write the above as:\nvar queryObj =\nQuery.make(ABContact).sel\nect()",
      "narration": "",
      "ocrText": "| Step 2: Create the results object Gi\n\n1 uses gw.api.database.Query\n\n2\n\n3 var output = \"\"\n\n4 var queryObj = Query.make(entity.ABContact)\n— 5 var resultsObj = query0bj.select ()\n\n• Create the result object with select method\n\n* However, results are not fetched until they are referenced",
      "ocrWordCount": 47,
      "ocrConfidence": 86.67,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 8,
      "title": "Step 3: Process results",
      "bodyParagraphs": [],
      "originalNotes": "Step 3: Process results\nCode example\nLines 7-9\nFetches the result objects\nLine 10\nPrints to console\nRecall the for-loop syntax in Gosu has an optional indexvariable. Use the index variable to display a number next to each result:\n\nfor(anABContact in resultsObj\nindex i) {\nprint((i+l) +\nanABContact. DisplayName)\n}\n\n. produces the following output...\n1: Stan Newton\n2: Bo Simpson\n3: Bo Simpson\n4: William Weeks",
      "notes": "Step 3: Process results\nCode example\nLines 7-9\nFetches the result objects\nLine 10\nPrints to console\nRecall the for-loop syntax in Gosu has an optional indexvariable. Use the index variable to display a number next to each result:\n\nfor(anABContact in resultsObj\nindex i) {\nprint((i+l) +\nanABContact. DisplayName)\n}\n\n. produces the following output...\n1: Stan Newton\n2: Bo Simpson\n3: Bo Simpson\n4: William Weeks",
      "narration": "",
      "ocrText": "| Step 3: Process results\n\nuses gw.api.database.Query\n\nvar output = \"\"\nvar queryObj = Query.make(entity.ABContact)\nvar resultsObj = queryObj.select()\n\nfor(anABContact in resultsObj) {\n\noutput += anABContact.DisplayName + \"\\n\"\n}\nprint (output)\n\nwODInnswne\n\ni\n\n• Use a for loop to iterate through the result set\n\nStan Newton\n\nBo Simpson\n\nBo Simpson\nWilliam Weeks\nWilliam Andy\nWilliam William\n\n• DisplayName property improves the readability of the console output",
      "ocrWordCount": 66,
      "ocrConfidence": 88.38,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 9,
      "title": "Viewing approximation of SQL query",
      "bodyParagraphs": [],
      "originalNotes": "Viewing approximation of SQL query\nThe query builder APIs provide two ways to preview and record SQL SELECT statements that your Gosu code and the query builder APIs submit to the application database:\n\ntoString — provides an approximation of the SQL Select statement before it is submitted. In the example above:\nThe first line shows square brackets ([]) with list of variables to bind to the query. In this case, there are none.\nThe remaining lines show the SQL statement. Note that the table for the entity type, ab abcontact, has the table aliäs gRoot.\n\nwithLogSQL — displays and records the exact SQL Select statement at the time it is submitted. Writing to the system logs and to standard output does not occur when Gosu sample code calls the withLogSQL method. That logging occurs some time later, when the application submits the query to the relational database. These results are an approximation because the actual SQL may have vendor-dependent variations or vendor-dependent optimizations or both. A given query may have slight syntactic variations depending on whether it is used for an Oracle database or a SQL Server database.",
      "notes": "Viewing approximation of SQL query\nThe query builder APIs provide two ways to preview and record SQL SELECT statements that your Gosu code and the query builder APIs submit to the application database:\n\ntoString — provides an approximation of the SQL Select statement before it is submitted. In the example above:\nThe first line shows square brackets ([]) with list of variables to bind to the query. In this case, there are none.\nThe remaining lines show the SQL statement. Note that the table for the entity type, ab abcontact, has the table aliäs gRoot.\n\nwithLogSQL — displays and records the exact SQL Select statement at the time it is submitted. Writing to the system logs and to standard output does not occur when Gosu sample code calls the withLogSQL method. That logging occurs some time later, when the application submits the query to the relational database. These results are an approximation because the actual SQL may have vendor-dependent variations or vendor-dependent optimizations or both. A given query may have slight syntactic variations depending on whether it is used for an Oracle database or a SQL Server database.",
      "narration": "",
      "ocrText": "| Viewing approximation of SQL query Gi\n\n* toString approach\n\nOutput from console\noO\n\nuses gw.api.database.Query\n\nvar output = \"\"\n\nvar queryObj = Query.nake(entity.ABContact)\noutput += queryObj.tostring()\n\nvar resultsOb} = queryObj. select ()\n\nprint (output)\n\nSELECT /* ab:T:Gosu clase redefiner; */ FROM ab_abcontact gRoot WHERE gRoot.Retired = 0\n\n* withLogSQL approach\n\nOutput from log\n\n2028-05.\nFROM ab abcontact gRoot WHERE gRoot Retired = 0 [\n\nuses gw.api.database. Query\n\nvar output = \"\"\n\nvar queryObj = Query.make (entity. ABContact) .withLogSQL (true)\nvar resultsObj = query0b}. select ()\n\nfor(anaBContact in resultsOb3) {\noutput += anABContact.DisplayName + \"\\n\"\n\nv\n\nprint (output)\n\n18:48:37,836 INFO Executing sql = SELECT /* KeyTable:ab_abcontact; */ gRoot.ID col0, gRoot.Subtype colt",
      "ocrWordCount": 111,
      "ocrConfidence": 77.23,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 10,
      "title": "Query restrictions",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Query restrictions",
      "ocrWordCount": 2,
      "ocrConfidence": 96.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 11,
      "title": "compare method",
      "bodyParagraphs": [],
      "originalNotes": "compare method\nCode example\nLine 6\nString literals require quotes\nLine 15\nUse typekey reference syntax for typecode comparisons\nValid operators include:\nRelop. Equals\nRelop. NotEquals\nRelop. LessThan\nRelop. LessThanOrEquals\nRelop. GreaterThan\nRelop. GreaterThanOrEquals\n\nGosu provides typekey literals that let you specify typelist codes in your programming code. Gosu creates typekey literals at compile time by prefixing typelist codes with TC and converting code values to upper case. Avoid strings for typecode values as this also requires casting to a typekeyc",
      "notes": "compare method\nCode example\nLine 6\nString literals require quotes\nLine 15\nUse typekey reference syntax for typecode comparisons\nValid operators include:\nRelop. Equals\nRelop. NotEquals\nRelop. LessThan\nRelop. LessThanOrEquals\nRelop. GreaterThan\nRelop. GreaterThanOrEquals\n\nGosu provides typekey literals that let you specify typelist codes in your programming code. Gosu creates typekey literals at compile time by prefixing typelist codes with TC and converting code values to upper case. Avoid strings for typecode values as this also requires casting to a typekeyc",
      "narration": "",
      "ocrText": "| compare method Gi\n\n* Comparison predicates are columns in SQL Where clause\n* queryObj.compare (type#Feature, operator, value)\n• When applied to string fields, the values in the field must match exactly the\ncomparison value\n\n* compare method is overloaded, meaning it has one or more method signatures\n\nuses gw.api.database.Query\nuses gw.api.database.Relop\n\nvar queryOb; ery. make (entity.ABPerson)\n\n(ABPersonéLastName, Relop.Zquals, \"Andy\")\n\nrsonélumDependents, Relop. Great:\n\nqueryOb3 (ABPersonéPreferred, Relop.Equals, true)\n\nvar myDate = '01/01/2018' .toDate()\nqueryOb}. compare (ABPersonéCreateTime, Relop. Gre:\n\nrhanOrEquals, myDate)\n\n—P 15 queryOb}.compare (ABPerson#TaxStatus, Relop.£quel",
      "ocrWordCount": 84,
      "ocrConfidence": 80.99,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 12,
      "title": "null values for query restrictions a",
      "bodyParagraphs": [],
      "originalNotes": "null values for query restrictions\nIn Guidewire applications, there are some data model entity elements that specify a nullok attribute. Column, foreignkey, and typekey are elements that have the nullok attribute. When specified as an attribute of an element, you must define the nullok attribute. A null value signifies the absence of or void of a value.\n\nGuidewire applications transform an entity element with a nullok=true attribute to a column definition in a physical database table. Relational databases create database tables using a form of Structure Query Language (SQL) known as Data Definition Language (DDL). With a nullok=false attribute, a Guidewire application executes a SQL / DDL statement to create a column constraint that specifies that the named column cannot contain a null value.",
      "notes": "null values for query restrictions\nIn Guidewire applications, there are some data model entity elements that specify a nullok attribute. Column, foreignkey, and typekey are elements that have the nullok attribute. When specified as an attribute of an element, you must define the nullok attribute. A null value signifies the absence of or void of a value.\n\nGuidewire applications transform an entity element with a nullok=true attribute to a column definition in a physical database table. Relational databases create database tables using a form of Structure Query Language (SQL) known as Data Definition Language (DDL). With a nullok=false attribute, a Guidewire application executes a SQL / DDL statement to create a column constraint that specifies that the named column cannot contain a null value.",
      "narration": "",
      "ocrText": "| null values for query restrictions a\n\nuses gw.api.database.Query\nuses gw.api.database.Relop\n\n1\n\n2\n\n3\n\n4 var queryNull = Query.make(entity.ABPerson)\n\n5 var queryNotNull = Query.make(entity.ABPerson)\n6\n\n7\n\n8\n\n// ABE IS NULL\n—> queryNull.compare (ABPerson#Score, Relop.Equals, null)\n9\n10 // ABPerson where Score IS NOT NULL\n\n—==—11 queryNotNull.compare (ABPerson#Score, Relop.NotEquals, null)\n\n• Entities can have elements that allow for null values\n\n• If there is no value, the database leaves the field as null unless the element\nspecifies a default value\n\n• Restriction queries can compare for null or not null values\n\ngw.api.database.Query ANS! SQL\ncompare(entity.Property, Equals, null) where table.columnName IS NULL\ncompare(entity.Property, NotEquals, null) where table.columnName IS NOT NULL",
      "ocrWordCount": 109,
      "ocrConfidence": 85.9,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 13,
      "title": "Multiple restrictions ANDed together",
      "bodyParagraphs": [],
      "originalNotes": "Multiple restrictions ANDed together\nCode example\nLine 7\nRestricts ABPerson query to last name equal to Andy\nLine 9\nRestricts ABPerson query to first name equal to William\n\nSQL equivalent:\n\nSELECT *\nFROM ABPerson\nWHERE ABPerson. LastName =\n\"Andy\"\nAND ABPerson. FirstName =\n\"William\"\nA query can have as many restrictions as needed.",
      "notes": "Multiple restrictions ANDed together\nCode example\nLine 7\nRestricts ABPerson query to last name equal to Andy\nLine 9\nRestricts ABPerson query to first name equal to William\n\nSQL equivalent:\n\nSELECT *\nFROM ABPerson\nWHERE ABPerson. LastName =\n\"Andy\"\nAND ABPerson. FirstName =\n\"William\"\nA query can have as many restrictions as needed.",
      "narration": "",
      "ocrText": "| Multiple restrictions ANDed together\n\nuses gw.api.database.Query\nuses gw.api.database.Relop\n\nvar output =\"\n\nvar queryObj = Query.make(ABPerson)\n\n// Last name\n\nqueryObj.compare (ABPerson#LastName, Relop.Equals,\n// £\nqueryObj. compare (ABPerson#FirstName, Relop.Equals,\n\nOIHHFwWN HE\n\ntt\n\nRestrictions are inherently ANDed together",
      "ocrWordCount": 36,
      "ocrConfidence": 81.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 14,
      "title": "Multiple restrictions ORed together",
      "bodyParagraphs": [],
      "originalNotes": "Multiple restrictions Ored together\nCode example\nLines 7-10\nor method block consists of a criteria element that represents the query object.\n\nYou can create a query that consists of multiple conditions that are ORed together. To do this, you must use the or method. It takes a block as an input parameter- The block consists of a placeholder that represents the original query object. You can then list multiple criteria, all of which\nare ORed together.\n\nThe block syntax for the or method is:\nqueryObj.or( \\ criteria -> {\ncriteria-compare\ncriteria-compare\nII add as many criteria as\nneeded\n})\n\nYou can also combine conditions with AND and OR logic in complex ways. The following example finds all policy people whose first name is \"John\" or whose name is \"Erica Hinds\" (first name is Erica and last name is Hinds):\npolicyPersonQuery.or(\norCriteria -> {\norCriteria.compare(ABPe\nrson#FirstName,\nRelop. Equals, \"John\")\norCriteria.and( \\\nandCriteria -> {\nandCriteria-compare(ABP\nerson#FirstName,\nRelop. Equals, \"Erica\")\nandCriteria-compare(ABP\nerson#LastName,\nRelop. Equals, \"Hinds\")\n})\n})",
      "notes": "Multiple restrictions Ored together\nCode example\nLines 7-10\nor method block consists of a criteria element that represents the query object.\n\nYou can create a query that consists of multiple conditions that are ORed together. To do this, you must use the or method. It takes a block as an input parameter- The block consists of a placeholder that represents the original query object. You can then list multiple criteria, all of which\nare ORed together.\n\nThe block syntax for the or method is:\nqueryObj.or( \\ criteria -> {\ncriteria-compare\ncriteria-compare\nII add as many criteria as\nneeded\n})\n\nYou can also combine conditions with AND and OR logic in complex ways. The following example finds all policy people whose first name is \"John\" or whose name is \"Erica Hinds\" (first name is Erica and last name is Hinds):\npolicyPersonQuery.or(\norCriteria -> {\norCriteria.compare(ABPe\nrson#FirstName,\nRelop. Equals, \"John\")\norCriteria.and( \\\nandCriteria -> {\nandCriteria-compare(ABP\nerson#FirstName,\nRelop. Equals, \"Erica\")\nandCriteria-compare(ABP\nerson#LastName,\nRelop. Equals, \"Hinds\")\n})\n})",
      "narration": "",
      "ocrText": "| Multiple restrictions ORed together Gi\n\n1 uses gw.api.database.Query\n\n2 uses gw.api.database.Relop\n\n3\n\n4 var output = \"\"\n\n5 var queryObj = Query.make(ABPerson)\n\n6 // Last na or First e\n\n7 queryObj.or(\\ criteria -> {\n\n8 criteria.compare (ABPerson#LastName, Relop.Equals, \"Andy\")\n\n9 criteria.compare (ABPerson#FirstName, Relop.Equals, \"William\")\n10 )\n\nor method requires block that specifies criteria to OR together",
      "ocrWordCount": 57,
      "ocrConfidence": 89.02,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 15,
      "title": "Additional restriction options",
      "bodyParagraphs": [],
      "originalNotes": "Additional restriction options\nThe Gosu Reference Guide contains complete list of all options for restricting queries. In addition, documentation covers how to write aggregate queries, row queries, column value comparison queries, and join queries.",
      "notes": "Additional restriction options\nThe Gosu Reference Guide contains complete list of all options for restricting queries. In addition, documentation covers how to write aggregate queries, row queries, column value comparison queries, and join queries.",
      "narration": "",
      "ocrText": "Additional restriction options Gi\n\n• See the Predicate\nMethods Reference in\nthe Gosu Reference\nGuide:\n\n®\nGuidewire ClaimCenter\n\n* between Gosu Reference Guide\n\n* compareIgnore\n\n* contains\n* subselect\n* startsWith\n\nGicuipewire\nAdapt and succeed",
      "ocrWordCount": 35,
      "ocrConfidence": 86.08,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 16,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 17,
      "title": "Counting results",
      "bodyParagraphs": [],
      "originalNotes": "Counting results\nCode example\nLine 6\nresultsObj. Count identifies the number objects in the result set.\n\nDevelopers should keep in mind that Guidewire does not query the database for the complete result set, however, and does not store a snapshot of the results of a given query. Therefore, the value of Count can vary if the number of rows in the database that meet the query's criteria changes while the query results are being processed. The field is introduced here as it is useful for instructional and debugging purposes, but it can be problematic if used in implementation code as an absolutely accurate reflection of the number of rows in the database that meet the query’s criteria. For a further discussion of this topic, refer to the Gosu Reference Guide. The next slide discusses some alternatives to Count that, depending on the requirement will work equally well and provide superior performance.",
      "notes": "Counting results\nCode example\nLine 6\nresultsObj. Count identifies the number objects in the result set.\n\nDevelopers should keep in mind that Guidewire does not query the database for the complete result set, however, and does not store a snapshot of the results of a given query. Therefore, the value of Count can vary if the number of rows in the database that meet the query's criteria changes while the query results are being processed. The field is introduced here as it is useful for instructional and debugging purposes, but it can be problematic if used in implementation code as an absolutely accurate reflection of the number of rows in the database that meet the query’s criteria. For a further discussion of this topic, refer to the Gosu Reference Guide. The next slide discusses some alternatives to Count that, depending on the requirement will work equally well and provide superior performance.",
      "narration": "",
      "ocrText": "Counting results Gi\n\n1 uses gw.api.database.Query\nZ Result count: 116\n3) var output = \"\"\n4 var queryObj = Query.make(ABPerson)\n5 var resultsOb}j = queryObj.select ()\n—> 6 var count = resultsObj.Count\n7 output += \"Result count: \" + count\n8 print (output)\n\n• Other methods:\n* resultsObj.HasElements (uses Count under the covers)\n\n* resulstsObj.iterator.hasNext (performs very poorly)\n\n* Depending on the requirement, there may be better performing alternatives...",
      "ocrWordCount": 69,
      "ocrConfidence": 86.1,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 18,
      "title": "Taking a peek without retrieving any data a",
      "bodyParagraphs": [],
      "originalNotes": "Taking a peek without retrieving any data\nWill query return anything?\nTo control whether to show/hide IJI element, or proceed with computation\nWill query return too muchl\nTo decide whether to go ahead with something potentially expensive, e.g. search screens, tabs\n\nisEmpty and getCountLimitedBy(x) performbetter and more reliable than .Count- You won't see any difference on H2 but on SQLServer or Oracle they will issue a count query with an extra clause that tells the database only the first n results are relevant (where n is 1 for isEmpty, and the value passed in for getCountLimitedBy(x)). This allows the database query optimizer to only find that number of matching rows before bailing out, which can make a significant difference if a large number of rows are involved.",
      "notes": "Taking a peek without retrieving any data\nWill query return anything?\nTo control whether to show/hide IJI element, or proceed with computation\nWill query return too muchl\nTo decide whether to go ahead with something potentially expensive, e.g. search screens, tabs\n\nisEmpty and getCountLimitedBy(x) performbetter and more reliable than .Count- You won't see any difference on H2 but on SQLServer or Oracle they will issue a count query with an extra clause that tells the database only the first n results are relevant (where n is 1 for isEmpty, and the value passed in for getCountLimitedBy(x)). This allows the database query optimizer to only find that number of matching rows before bailing out, which can make a significant difference if a large number of rows are involved.",
      "narration": "",
      "ocrText": "| Taking a peek without retrieving any data a\n\n* .Count is often used to answer questions such as:\n• Will this query return anything?\n• Will this query return too much?\n* These methods perform better and are more reliable than .count :\n* isEmpty does fast check to see if query has any results\n* getCountLimitedBy (x) returns number if results if less than x, otherwise x\n\n• Peeking is a waste of time and cycles if you intend to process the entire result set",
      "ocrWordCount": 87,
      "ocrConfidence": 91.48,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 19,
      "title": "Querying for one result",
      "bodyParagraphs": [],
      "originalNotes": "Querying for one result\nAtMostOneRow is annotated as a property, but it is just the published name for the getAtMostOneRow method.",
      "notes": "Querying for one result\nAtMostOneRow is annotated as a property, but it is just the published name for the getAtMostOneRow method.",
      "narration": "",
      "ocrText": "| Querying for one result G\n\n1 uses gw.api.database.Query\n\n2 uses gw.api.database.Relop\n\n3\n\n4 var output = \"\"\n\n5 var queryObj = Query.make(ABCompany)\n\n6 queryObj.compare (ABCompany#Name, Relop.Equals, “Albertson's\")\n— 7 var resultsObj = queryObj.select () .AtMostOneRow\n\n8 output += resultsObj.EmailAddress1\n\n9 print (output)\n\nAtMostOneRow is a property that...\n\ninfo@Albertsons.com\n\n+ Ifa single item exists, returns that single row\n* If no item exists, returns null\n\nIf multiple items exist, throws an exception",
      "ocrWordCount": 72,
      "ocrConfidence": 85.53,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 20,
      "title": "Sorting results",
      "bodyParagraphs": [],
      "originalNotes": "Sorting results\nCode example\nLine 8\nPath object traverses foreign key and ends with State property\nIn this case, the foreign key name does not match the entity name\nLines 10,12\nMultiple levels of ordering query results\n\nThe Query builder APIs support the following ordering methods on result objects.\nMETHOD DESCRIPTION\norderBy Clears all previous ordering, then orders results by the specified column in ascending order.\norderByDescending Clears all previous order methods, and orders by the specified column in descending order.\nthenBy Orders by the specified column in ascending order. Does not clear previous ordering. thenByDescending Orders by the specified column in descending order. Does not clear previous ordering.",
      "notes": "Sorting results\nCode example\nLine 8\nPath object traverses foreign key and ends with State property\nIn this case, the foreign key name does not match the entity name\nLines 10,12\nMultiple levels of ordering query results\n\nThe Query builder APIs support the following ordering methods on result objects.\nMETHOD DESCRIPTION\norderBy Clears all previous ordering, then orders results by the specified column in ascending order.\norderByDescending Clears all previous order methods, and orders by the specified column in descending order.\nthenBy Orders by the specified column in ascending order. Does not clear previous ordering. thenByDescending Orders by the specified column in descending order. Does not clear previous ordering.",
      "narration": "",
      "ocrText": "| Sorting results\n\n• Ordering methods all take an object that implements the IquerySelectColumns\ninterface in the package as their one argument\n\nGi\n\n* The Paths .make method yields an object access path from the primary entity to a simple,\nforeign key, database-backed property\n\n« Access path cannot include virtual properties, methods, or calculations\n\nuses gw.api.database.Query\nuses gw.api.database.QuerySelectColumns\nuses gw.api.path. Paths\n\nvar queryObj = Query.make(ABPerson)\nvar resultsObj = queryObj.select()\n\nresultsObj.orderBy (QuerySelectColumns.path(Paths.make(ABPerson#PrimaryAddress, Address#State) ))\n\nresultsOb}. thenBy (QuerySelectColumns. path (Paths.make (ABPersonéLastName) ))\nresultsObj. thenBy (QuerySelectColumns.path (Paths .make (ABPerson#FirstName) ) )\nfor(anPerson in resultsObj) {\n\nprint (anPerson.PrimaryAddress.State +\": \" + anPerson.DisplayName)\n}\n\n2 Marc Lauria\n: Adelle Lynn\n\n2 Lorine Mccallion\n\n1: Alexa Purves\n\n: James Andersen\n\n: Samantha Andrews\n\n3 Eric Andy\nWilliam Andy\n\n1: Stefani Arrowsmith\n: Domonique Dames\n\n: John Dan\n\n: William Dan\nHarper David\n\n: William David",
      "ocrWordCount": 139,
      "ocrConfidence": 76.92,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 21,
      "title": "Demonstration",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "| Demonstration G\n\nQueries with restrictions\n\nclick here\n\nNote: The demonstration opens a new tab in your browser. When the demonstration ends, the\noriginal course launch window appears. Return to this window to continue this presentation.",
      "ocrWordCount": 36,
      "ocrConfidence": 95.47,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_instruction",
      "demoVideoIndex": 0
    },
    {
      "slideNumber": 22,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": false,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_video"
    },
    {
      "slideNumber": 23,
      "title": "Filter entities on database",
      "bodyParagraphs": [],
      "originalNotes": "Filter entities on database\nNext, we are going to focus on a few anti-patterns related to filtering entities. Best practice guidelines:\nRetum only what you need, because entities can use up a lot of memory and processing time.\nAsk the database only for the entities that are essential to the current action.\nLet the database do what it is good at, such as filtering.\nAvoid the methods where(), first(), last(), firstWhere(), and lastWhere().\n\nIt is important to keep in mind that the application can run implicit queries behind the scenes and add related entities to a bundle when developers use dot notation to access foreign key and array fields. Use caution and code carefully when using these fields, because bundle sizes can grow extremely large and negatively affect performance. On the next few slides we will examine these anti-patterns one by one.",
      "notes": "Filter entities on database\nNext, we are going to focus on a few anti-patterns related to filtering entities. Best practice guidelines:\nRetum only what you need, because entities can use up a lot of memory and processing time.\nAsk the database only for the entities that are essential to the current action.\nLet the database do what it is good at, such as filtering.\nAvoid the methods where(), first(), last(), firstWhere(), and lastWhere().\n\nIt is important to keep in mind that the application can run implicit queries behind the scenes and add related entities to a bundle when developers use dot notation to access foreign key and array fields. Use caution and code carefully when using these fields, because bundle sizes can grow extremely large and negatively affect performance. On the next few slides we will examine these anti-patterns one by one.",
      "narration": "",
      "ocrText": "| Filter entities on database\n\nReturn only what you need\n\nEntities can use up memory and processing time\n\nRequest the database only for entities that are essential to the current action\n* Perform filtering at the database rather than in memory\n* Avoid where() method\n• Avoid first(), last(), firstWhere(), and lastWhere() methods\n\nUse dot notation carefully",
      "ocrWordCount": 57,
      "ocrConfidence": 92.41,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 24,
      "title": "Filter at the database rather than in memory",
      "bodyParagraphs": [],
      "originalNotes": "Filter at the database rather than in memory\nThe first anti-pattern in this section is about filtering in memory instead of in the database. The first code example on the slide brings unneeded entities to the application server. It loads every claim into memory and tries to filter the claims based on a target policy. This results in adding every claim to the bundle, which can seriously affect performance because of the potentially large number of claims in the database. Keep in mind that the dot Policy property access in line 9 will also add the policy entities for every claim into the bundle, effectively doubling the number of entities in the bundle. This is clearly an anti- pattern. You should let the database do the filtering and bring back only the entities that you need.\n\nFortunately, the fix for this anti- pattern is easy. In the second screenshot, we add a compare predicate to the query, which restricts the results to only the claims related to the target policy, so the application only adds the target claims to the bundle. Obviously, you can use any other predicate methods, just keep in mind the best practices and recommendations that we discussed earlier.",
      "notes": "Filter at the database rather than in memory\nThe first anti-pattern in this section is about filtering in memory instead of in the database. The first code example on the slide brings unneeded entities to the application server. It loads every claim into memory and tries to filter the claims based on a target policy. This results in adding every claim to the bundle, which can seriously affect performance because of the potentially large number of claims in the database. Keep in mind that the dot Policy property access in line 9 will also add the policy entities for every claim into the bundle, effectively doubling the number of entities in the bundle. This is clearly an anti- pattern. You should let the database do the filtering and bring back only the entities that you need.\n\nFortunately, the fix for this anti- pattern is easy. In the second screenshot, we add a compare predicate to the query, which restricts the results to only the claims related to the target policy, so the application only adds the target claims to the bundle. Obviously, you can use any other predicate methods, just keep in mind the best practices and recommendations that we discussed earlier.",
      "narration": "",
      "ocrText": "| Filter at the database rather than in memory Gi\n\nAnti-Pattern\n\nBest Practice\n\nwor], H®\n\n10\nai\n12\n43\n\nvar targetPoli Policy\n// Performance suffers because\n// the query loads all s\n\nvar claimQuery = Query.make(Claim)\nfor (claim in claimQuery.select()) (\nif (claim.Policy == targetPolicy) {\n\nvar targetPolicy : Policy\n\nvar claimQuery = Query.make(Claim)\n\nclaimQuery.compare (Claim#Policy, Equals, targetPolicy)\nfor (claim in claimQuery.select()) {",
      "ocrWordCount": 63,
      "ocrConfidence": 89.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 25,
      "title": "Avoid where()",
      "bodyParagraphs": [],
      "originalNotes": "Avoid where()\nThis anti-pattern involves a similar problem. The first expression does the filtering on the application server by fetching all addresses into a collection, and then making a second collection with the qualifying addresses. This results in thesame memory, bundle, and processing time issues as in the previous example.\n\nThe second code sample shows the fix for this anti-pattern, which is letting the database filter the results. Instead of loading all the addresses, we use the compare() function in line 12. This limits the results returned from the database. As a best practice, try to avoid where() when you can do the filtering as part of the query",
      "notes": "Avoid where()\nThis anti-pattern involves a similar problem. The first expression does the filtering on the application server by fetching all addresses into a collection, and then making a second collection with the qualifying addresses. This results in thesame memory, bundle, and processing time issues as in the previous example.\n\nThe second code sample shows the fix for this anti-pattern, which is letting the database filter the results. Instead of loading all the addresses, we use the compare() function in line 12. This limits the results returned from the database. As a best practice, try to avoid where() when you can do the filtering as part of the query",
      "narration": "",
      "ocrText": "| Avoid where()\n\nAnti-Pattern\n\nBest Practice\n\n5 var resultContainer = Query.make(Address)\n\n6 «select () .toCollection() .where(\n\n7 \\ elt -> elt.Postalcode == \"90292-6043\" )\n\n10 var queryObject = Query.make (Address)\n\n11 // Apply qualifying where clause\n\n12 queryObject. compare (Address#PostalCode, Equals, \"90292-6043\")\n13 var selectObject = queryObject.select ()\n\n14 var resultIterator = selectObject.iterator()\n\nis for (address in resultIterator) {\n\n16 // do something with each address\n\n17",
      "ocrWordCount": 67,
      "ocrConfidence": 86.46,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 26,
      "title": "Avoid first(), last(), firstWhere(), and lastWhere() [Fj",
      "bodyParagraphs": [],
      "originalNotes": "Avoid first(), last(), firstWhere(), and lastWhere()\nTwo examples are provided for this next filtering anti-pattern. The expression on the top does the filtering on the application server, needlessly fetching all addresses into a collection and creating a second collection with the qualifying addresses, just to get one of those qualifying addresses.\n\nThe expression on the bottom does some filtering on the database, but still brings back an entire array of results to get just one of the qualifying addresses.",
      "notes": "Avoid first(), last(), firstWhere(), and lastWhere()\nTwo examples are provided for this next filtering anti-pattern. The expression on the top does the filtering on the application server, needlessly fetching all addresses into a collection and creating a second collection with the qualifying addresses, just to get one of those qualifying addresses.\n\nThe expression on the bottom does some filtering on the database, but still brings back an entire array of results to get just one of the qualifying addresses.",
      "narration": "",
      "ocrText": "| Avoid first(), last(), firstWhere(), and lastWhere() [Fj\n\nvar queryAddresses = Query.make (Address)\n\nvar selectAddressesList = queryAddresses.select () .toList ()\n\n. selectAddressesList.sortBy(\\ addr -> addr.PostalCode)\n• Anti-Pattern\n\nss = selectAddressesList.firstWhere(\\ addr -> addr.City\n\n\"Chicago\"\n\nFOR lastWh\n\nQ: Sort by Postal Code in ndi\n\nselectAddressesList .sortByDescending(\\ addr -> addr.PostalCode)\n\n1 vax lasta\n\nselectAddressesList.lastwhere(\\ addr -> addr.City\n\nQuery for addre.\n\nvar queryAddresses = Query.make (Address)\nqueryAddresses.compare ( Address#CityDenerm, Equals, \"Chicago\")\nvar selectAddressesList = queryAddresses.select() .toList ()\n\n• Anti-Pattern\n\nselectAddressesList.sortBy( \\ addr -> addr. PostalCode)\n\nss = selectAddressesList. first ()\n\nselectAddressesList.sortByDescending(\\ addr -> addr.PostalCode)",
      "ocrWordCount": 91,
      "ocrConfidence": 79.37,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 27,
      "title": "Avoid first(), last(), firstWhere(), and",
      "bodyParagraphs": [],
      "originalNotes": "Avoid first(), last(), firstWhere(), and lastWhere() (continued)\nThe fix for this anti-pattern employs three best practices:\n\nFirst, use the compare() predicate to filter the addresses in the database. Second, when sorting, database- side ordering methods including orderBy and orderByDescending() to sort the data in the database instead of sort(), which has more overhead and does not perform as well. For a full list of ordering methods, refer to the Gosu Reference Guide in the InsuranceSuite product documentation. Finally, access the FirstResu/t property of the select object, which returns just the first entry in the result set.\n\nDo not use the first() and last()methods to check for the existence of entities in the database. The best practice for checking for existence is covered in a later slide.",
      "notes": "Avoid first(), last(), firstWhere(), and lastWhere() (continued)\nThe fix for this anti-pattern employs three best practices:\n\nFirst, use the compare() predicate to filter the addresses in the database. Second, when sorting, database- side ordering methods including orderBy and orderByDescending() to sort the data in the database instead of sort(), which has more overhead and does not perform as well. For a full list of ordering methods, refer to the Gosu Reference Guide in the InsuranceSuite product documentation. Finally, access the FirstResu/t property of the select object, which returns just the first entry in the result set.\n\nDo not use the first() and last()methods to check for the existence of entities in the database. The best practice for checking for existence is covered in a later slide.",
      "narration": "",
      "ocrText": "Avoid first(), last(), firstWhere(), and Gi\nlastWhere() (continued)\n\nuses gw.api.database.Query\nuses gw.api.database.QuerySelectColumns\nuses gw.api.path. Paths\n\n• Best Practice var queryAddresses = Query.make (Address)\nqueryAddresses.compare( Address#CityDenexzm, Equals, \"Chicago\")\nvar selectAddresses = queryAddresses.select ()\n\nvar fix selectAddresses.orderBy (QuerySelectColumns. path (\nPaths.make(Address#PostalCode) )) .FirstResult\nvar la = selectAddresses.orderByDescending (QuerySelectColumns. path (\n\nPaths.make (Address#PostalCode) )) .FirstResult",
      "ocrWordCount": 52,
      "ocrConfidence": 78.8,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 28,
      "title": "Count entities on database",
      "bodyParagraphs": [],
      "originalNotes": "Count entities on database\nNext, we are going to focus on a few anti-patterns related to counting entities. Just as was stated for filtering entities, let the database do what it is good at, which includes counting. Avoid the methods count Where(), to Collectjon(), and select()-Count. Also avoid iterating over entities from the database to count the mand counting before accessing entities. On the next few slides we will examine these anti- patterns one by one.",
      "notes": "Count entities on database\nNext, we are going to focus on a few anti-patterns related to counting entities. Just as was stated for filtering entities, let the database do what it is good at, which includes counting. Avoid the methods count Where(), to Collectjon(), and select()-Count. Also avoid iterating over entities from the database to count the mand counting before accessing entities. On the next few slides we will examine these anti- patterns one by one.",
      "narration": "",
      "ocrText": "| Count entities on database\n\n• Let the database count entities\n* Avoid countWhere()\n• Avoid toCollection()\n\n« Avoid iteration over entities from database to count",
      "ocrWordCount": 26,
      "ocrConfidence": 86.04,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 29,
      "title": "Avoid countWhere() Fi",
      "bodyParagraphs": [],
      "originalNotes": "Avoid countWhere()\nLet's look at another example. The first code sample implicitly brings back the entire activity array and counts the results that meet the criteria. You do not need any of the actual activities; you just need to know how many satisfy the where criteria. Instead of accessing the Activities array, you can query the target activities and count them in the database using the Count property of the results object. When the Count property is accessed, the Query API issues a select query, so only the actual count is returned.",
      "notes": "Avoid countWhere()\nLet's look at another example. The first code sample implicitly brings back the entire activity array and counts the results that meet the criteria. You do not need any of the actual activities; you just need to know how many satisfy the where criteria. Instead of accessing the Activities array, you can query the target activities and count them in the database using the Count property of the results object. When the Count property is accessed, the Query API issues a select query, so only the actual count is returned.",
      "narration": "",
      "ocrText": "| Avoid countWhere() Fi\n\n4 var claim : Claim\n5\n• Anti-Pattern 6 claim.Activities.countWhere(\\ a ->\n7 a.ActivityPattern.Code \"notification\"\n8 && a.Status == ActivityStatus.7C_OPEN)\nai var claim : Claim\n12 var actPattern : ActivityPattern\n13\n. 14 var count = Query.make(Activity)\n• Best Practice 1s . compare (Activity#ActivityPattern, Equals, actPattern)\n16 .compare (Activity#Status, Equals, ActivityStatus.TC_OPEN)\n17 «join (Activity#Claim)\n18 -compare (Claim#ClaimNumber, Equals, claim.ClaimNumber)\n\n19 -select () .Count",
      "ocrWordCount": 67,
      "ocrConfidence": 81.49,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 30,
      "title": "Avoid toCollection()",
      "bodyParagraphs": [],
      "originalNotes": "Avoid toCollection()\nThis example is very similar to the previous one. The toList() method explicitly brings all the claims back into a collection and counts them on the application server, even though you do not need the actual entities. You just need to know how many there are.\n\nThe Count property of the select results does the count in the database and is the most performant way to get that value.",
      "notes": "Avoid toCollection()\nThis example is very similar to the previous one. The toList() method explicitly brings all the claims back into a collection and counts them on the application server, even though you do not need the actual entities. You just need to know how many there are.\n\nThe Count property of the select results does the count in the database and is the most performant way to get that value.",
      "narration": "",
      "ocrText": "| Avoid toCollection()\n\n• Anti-Pattern 6 var count = Query.make(Claim) .select () .toList () .count\n\ne Best Practice 4 var count = Query.make(Claim) .select() .Count",
      "ocrWordCount": 25,
      "ocrConfidence": 79.4,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 31,
      "title": "Avoid iteration over entities from database to [,",
      "bodyParagraphs": [],
      "originalNotes": "Avoid iteration over entities from database to count\nHere is another count example. The first code sample returns the query results to the application server and iterates through every claim, using lots of memory and processing time. In the second code sample, the Count property of the select results performs the count in the database and is the most performant way to get that value. Remember the golden rule - bring back only what you actually need.",
      "notes": "Avoid iteration over entities from database to count\nHere is another count example. The first code sample returns the query results to the application server and iterates through every claim, using lots of memory and processing time. In the second code sample, the Count property of the select results performs the count in the database and is the most performant way to get that value. Remember the golden rule - bring back only what you actually need.",
      "narration": "",
      "ocrText": "| Avoid iteration over entities from database to [,\n\ncount\n\n• Anti-Pattern\n\nBOw mI V Ho\n\na\n\n• Best Practice 4\n\nvar results = Query.make(Claim) .select ()\nvar nCount: int = 0\n\nfor (c in results.iterator()) {\nnCount = nCount + 1\n\n}\n\nreturn nCount\n\nvar count = Query.make(Claim) .select() .Count",
      "ocrWordCount": 51,
      "ocrConfidence": 81.02,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 32,
      "title": "Knowledge Check",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question\nWhich approach is used to record a more specific version of the SQL for\nOo” a query?\n“ 1\n. queryObj.toString\n2. queryObj.withLogSQL (true)\nSeo e Soe esses see see\nGi",
      "ocrWordCount": 34,
      "ocrConfidence": 79.93,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "Which approach is used to record a more specific version of the SQL for",
        "answer": "7 a query? , A. queryObj.toString B. queryObj.withLogSQL The correct answer is B. queryObj.withLogSQL (true)"
      }
    },
    {
      "slideNumber": 33,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer\nWhich approach is used to record a more specific version of the SQL for\na query?\n, A. queryObj.toString\nB. queryObj.withLogSQL\nThe correct answer is B. queryObj.withLogSQL (true)\nSoo eS eee soe ese ese\nGi",
      "ocrWordCount": 38,
      "ocrConfidence": 79.08,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 34,
      "title": "Knowledge Check",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question\nWhat is the difference between a query object and results object?\n•\n•\n•\nSeo e Soe esses see see",
      "ocrWordCount": 22,
      "ocrConfidence": 82.63,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "What is the difference between a query object and results object?",
        "answer": "A) Aquery object specifies the entity and the query criteria. B) Aresults object is a set of one or more entity instances fetched from the Guidewire application. C) This distinction is helpful for understanding the concept of a query and of set of results. In practice, query results are fetched from the Guidewire application when they are counted, iterated over, or when one object is retrieved."
      }
    },
    {
      "slideNumber": 35,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer fa\n_- — What is the difference between a query object and results object?\n•\n•\n•\nA) Aquery object specifies the entity and the query criteria.\nB) Aresults object is a set of one or more entity instances fetched from the\nGuidewire application.\nC) This distinction is helpful for understanding the concept of a query and of set of\nresults. In practice, query results are fetched from the Guidewire application when\nthey are counted, iterated over, or when one object is retrieved.\nSoo eS eee soe ese ese",
      "ocrWordCount": 89,
      "ocrConfidence": 89.42,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 36,
      "title": "Knowledge Check",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question\nWhich query restriction uses a block of compare methods?\n•\n•\n•\nSeo e Soe esses see see",
      "ocrWordCount": 21,
      "ocrConfidence": 81.5,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "Which query restriction uses a block of compare methods?",
        "answer": "The OR restriction uses the or method with a block of compare methods such as: var queryObj = Query.make(ABCompany).withLogSQL (true) queryObj.or(\\ criteria -> { criteria.compare(ABCompany#Score, Relop.LessThan, 50 ) criteria.compare(ABCompany#InspectionRequired, Relop.Equals, true)"
      }
    },
    {
      "slideNumber": 37,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer fa\nWhich query restriction uses a block of compare methods?\n•\n•\n•\nThe OR restriction uses the or method with a block of compare methods such as:\nvar queryObj = Query.make(ABCompany).withLogSQL (true)\nqueryObj.or(\\ criteria -> {\ncriteria.compare(ABCompany#Score, Relop.LessThan, 50 )\ncriteria.compare(ABCompany#InspectionRequired, Relop.Equals, true)\nSoo eS eee soe ese ese\n7)",
      "ocrWordCount": 54,
      "ocrConfidence": 80.11,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 38,
      "title": "Knowledge Check",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question\nWhat happens if you use the AtMostOneRow property in a query, and the\nOo” query returns more than one object?\n•\nSeo e Soe esses see see\nGi",
      "ocrWordCount": 31,
      "ocrConfidence": 85.75,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "What happens if you use the AtMostOneRow property in a query, and the",
        "answer": "Query returns more than one object? An exception is thrown when a query that uses the AtMostOneRow property, returns more than one object."
      }
    },
    {
      "slideNumber": 39,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer\nWhat happens if you use the AtMostOneRow property in a query, and the\nquery returns more than one object?\n•\n•\n•\nAn exception is thrown when a query that uses the AtMostOneRow property, returns\nmore than one object.\nSoo eS eee soe ese ese\nGi",
      "ocrWordCount": 49,
      "ocrConfidence": 84.55,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 40,
      "title": "Key Takeaways",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Lesson\n\nobjectives • Describe a query object\nreview • Identify various types of query restrictions\n\n• Write Gosu queries to retrieve objects from a\nGuidewire application\n• lIterate through the results of query",
      "ocrWordCount": 33,
      "ocrConfidence": 86.91,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives_review"
    },
    {
      "slideNumber": 41,
      "title": "Student Exercise",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "| Student exercise\n\nQuery the assigned user contact",
      "ocrWordCount": 8,
      "ocrConfidence": 95.89,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "exercise"
    }
  ],
  "videos": [
    {
      "index": 1,
      "filename": "In_03_01.mp4",
      "path": "/academy/guidewire/videos/ch11/In_03_01.mp4"
    }
  ],
  "hasNotes": true,
  "hasTables": false,
  "hasImages": true,
  "ocrMetadata": {
    "totalWords": 2031,
    "avgConfidence": 85.9,
    "extractedAt": "2026-02-15T18:19:30.301808"
  }
}
