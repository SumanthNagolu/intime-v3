{
  "lessonId": "ch07-l02",
  "chapterId": 7,
  "chapterSlug": "ch07",
  "lessonNumber": 2,
  "title": "Introduction to the Data Model",
  "sourceFile": "IS_Fund_02 - Introduction to the Data Model.pptx",
  "sourceFolder": "IS_Fund_02",
  "totalSlides": 33,
  "estimatedMinutes": 99,
  "slides": [
    {
      "slideNumber": 1,
      "title": "Welcome to the Data Model Lesson",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "Introduction to the Guidewire Data Model.",
      "narration": "Welcome to this lesson on the Guidewire Data Model. As developers, understanding the data model is crucial because it forms the backbone of how data is structured and accessed within Guidewire applications. Today, we'll explore how entities are defined, how data fields work, and how you can extend these models to fit your business needs. Let's dive in and start building a solid foundation for our development work.",
      "ocrText": "Introduction to the Data Model",
      "ocrWordCount": 5,
      "ocrConfidence": 95.5,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "title"
    },
    {
      "slideNumber": 2,
      "title": "Understanding Metadata in Guidewire",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "Guidewire applications use a metadata-driven approach.",
      "narration": "In Guidewire, metadata isn't just a buzzword—it's a powerful tool that drives both database persistence and the Gosu and Java interfaces. This metadata-driven architecture allows us to extend application capabilities seamlessly. By modifying XML files, we can tailor the data model to meet specific business requirements, whether that means adding new fields or creating entirely new entities. It's this flexibility that empowers us to deliver custom solutions that align perfectly with our clients' needs.",
      "ocrText": "Lesson\nobjectives\n\n+ Describe the contents of a Guidewire Data\n\nModel\n\n* Identify information about a given\n\napplication's Data Model\n\n- Use the Data Dictionary",
      "ocrWordCount": 25,
      "ocrConfidence": 89.67,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives"
    },
    {
      "slideNumber": 3,
      "title": "Modifying the Data Model",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "How to change the Guidewire Data Model.",
      "narration": "One of the key strengths of the Guidewire platform is its extensibility. We can modify the data model through XML configuration files, allowing us to add or change entities and fields as needed. These changes are known as extensions and are crucial for adapting the system to specific business contexts, such as adding custom fields to the User entity. Understanding how to effectively manage these extensions is a critical skill for any Guidewire developer.",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 95.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 4,
      "title": "Data Model Foundations",
      "bodyParagraphs": [],
      "originalNotes": "The Guidewire Data Model\nGuidewire applications employ a metadata approach to data objects. A Guidewire application uses metadata about application domain objects to drive both database persistence objects and the Gosu and Java interfaces to these objects. This architecture provides enormous power to extend Guidewire application capabilities.\n\nA Guidewire application lets you change its data model to accommodate your business needs. You make your changes to the Data Model by existing XML files and adding new ones. Guidewire calls changes that you make to the Data Model extensions. For example, you can extend the Data Model by adding new fields to the User entity, or you can declare entirely new entities. The complete data model of your application installation comprises the application model and any Data Model extensions that you make.",
      "notes": "The Guidewire Data Model\nGuidewire applications employ a metadata approach to data objects. A Guidewire application uses metadata about application domain objects to drive both database persistence objects and the Gosu and Java interfaces to these objects. This architecture provides enormous power to extend Guidewire application capabilities.\n\nA Guidewire application lets you change its data model to accommodate your business needs. You make your changes to the Data Model by existing XML files and adding new ones. Guidewire calls changes that you make to the Data Model extensions. For example, you can extend the Data Model by adding new fields to the User entity, or you can declare entirely new entities. The complete data model of your application installation comprises the application model and any Data Model extensions that you make.",
      "narration": "Guidewire applications leverage a metadata approach to define data objects, which drives both database persistence and the interfaces that interact with these objects. This architecture is incredibly powerful, allowing you to extend the application's capabilities by modifying existing XML files or adding new ones. This means you can introduce new fields to entities like User or even create entirely new entities. Extensions enable you to tailor the application model to your organization's specific needs, making your implementation both flexible and robust.",
      "ocrText": "| The Guidewire Data Model G\n\n• The Guidewire data model is a set of\n\nXML-formatted metadata definitions of Database Application Server\nentities and typelists ABContact generated Java class\n* The Guidewire application loads the x2} >atnao mn | 28Contact\n\nName\nPublicID\n\nData Model on start-up Createtime\n\n• The loaded metadata:\n\n« instantiates the Data Model as a collection\n\nCreateTime\n\nof tables in the application database [name | Pubii>] cresterime_| Gosu code\n* injects generated Java and Gosu classes in\n\nthe application server to provide a\n\nprogrammatic interface to entities and ©\n\ntypelists in the database",
      "ocrWordCount": 96,
      "ocrConfidence": 86.58,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 5,
      "title": "Core Data Model Entities",
      "bodyParagraphs": [],
      "originalNotes": "Data Model entities\nGuidewire defines a set of data objects in the base PolicyCenter configuration from which it derives all other objects and entities. For many of the Guidewire base entities, you can also create entity extensions that enhance the base entities and provide additions required to support your particular business needs. In some cases, you can even define entirely new entities.\n\nYou define data entities through XML elements in the entity metadata definition files. The root element of an entity definition specifies the kind of entity and any attributes that apply. Subelements of the entity element define entity components, such as columns, or fields, and foreign keys.",
      "notes": "Data Model entities\nGuidewire defines a set of data objects in the base PolicyCenter configuration from which it derives all other objects and entities. For many of the Guidewire base entities, you can also create entity extensions that enhance the base entities and provide additions required to support your particular business needs. In some cases, you can even define entirely new entities.\n\nYou define data entities through XML elements in the entity metadata definition files. The root element of an entity definition specifies the kind of entity and any attributes that apply. Subelements of the entity element define entity components, such as columns, or fields, and foreign keys.",
      "narration": "At the core of any Guidewire application are the base data entities. These predefined entities serve as the foundation from which all other objects are derived. By using XML elements in entity metadata definition files, you can extend these entities or even define new ones. This involves specifying columns, foreign keys, and other components essential for your business logic. Understanding and managing these entities is crucial for creating a system that meets your business requirements.",
      "ocrText": "| Data Model entities\n\nGi\n\n• Entities are the high-level business objects used by the Guidewire application,\n\nsuch as ABContact, Policy, Account, Invoice, Claim\n\n• Anentity serves as the root object for PCF files, Gosu Rules and other data\n\nrelated areas\n\n« Anentity defines a set of entity fields to store information. You can add the\n\nfollowing kinds of fields to an entity:\n\n+ Data\n+ Column\n\n* Relationship\n+ Foreign key\n+ Array\n+ Type key\n\nentity\nfields\n\nABContact\n\nName\nEmailAddress1\nCreateTime\n\nPrefersContactByEmail\nScore\n\nAssignedUser\nContactNotes\nContactTier",
      "ocrWordCount": 88,
      "ocrConfidence": 89.4,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 6,
      "title": "Defining Data Fields",
      "bodyParagraphs": [],
      "originalNotes": "Data fields\nData fields are defined in XML for an entity file with a <column> element. Therefore, they are sometimes referred to a \"column fields\". There are other types of fields beyond primitive value fields that are stored in database table columns, however. So one should not assume that the only fields that map to database columns are the \"column fields\". This course uses the term \"data fields\" to avoid this possible point of confusion.",
      "notes": "Data fields\nData fields are defined in XML for an entity file with a <column> element. Therefore, they are sometimes referred to a \"column fields\". There are other types of fields beyond primitive value fields that are stored in database table columns, however. So one should not assume that the only fields that map to database columns are the \"column fields\". This course uses the term \"data fields\" to avoid this possible point of confusion.",
      "narration": "When defining data fields in Guidewire, we primarily use the <column> element within XML files. These column fields represent the primitive values stored in database tables. However, not all fields map directly to database columns—virtual fields, for instance, are computed at runtime. By understanding the different types of fields, you can design a data model that efficiently handles the necessary data for your application.",
      "ocrText": "| Data fields\n\nGi\n\n• Adata field stores a single value that does not reference any other object or table\n\n• Typically defined with the <column> element\n\n•« Examples of single values:\n* Name is a varchar\n* CreateTime is a datetime\n* PrefersContactByEmail is a bit\n\n* Score is an integer\n\nentity\nfields\n\nABContact\n\nName\nEmailAddress1\nCreateTime\n\nPrefersContactByEmail\nScore\n\nAssignedUser\nContactNotes\nContactTier",
      "ocrWordCount": 63,
      "ocrConfidence": 88.28,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 7,
      "title": "Working with Foreign Key Fields",
      "bodyParagraphs": [],
      "originalNotes": "Foreign key fields\nNote: At its simplest, the Guidewire data model is a set of XML-formatted metadata definitions of entities and typelists. An entity defines a set of fields for information. You can add a Foreign Key field to an entity.",
      "notes": "Foreign key fields\nNote: At its simplest, the Guidewire data model is a set of XML-formatted metadata definitions of entities and typelists. An entity defines a set of fields for information. You can add a Foreign Key field to an entity.",
      "narration": "Foreign key fields are essential for establishing relationships between entities in the Guidewire data model. These fields allow you to link entities together, creating a cohesive data structure that reflects real-world relationships. By defining foreign keys in your XML entity files, you can ensure that your data model accurately represents these connections, facilitating efficient data retrieval and manipulation.",
      "ocrText": "| Foreign key fields G\n\n• A foreign key field stores a reference to a related object in the Data Model\n• Itdefines a unidirectional relationship\n• AssignedUser in ABContact is the foreign key field for a User\n\nABContact\n\nName Credential\nEmailAddress1 JobTitle\nCreateTime Roles\nPrefersContactByEmail we\n\nScore\nAssignedUser\nContactNotes\nContactTier",
      "ocrWordCount": 51,
      "ocrConfidence": 87.38,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 8,
      "title": "Implementing Array Fields",
      "bodyParagraphs": [],
      "originalNotes": "Array fields\nNote: At its simplest, the Guidewire data model is a set of XML-formatted metadata definitions of entities and typelists- An entity defines a set of fields for information. You can add an Array field to an entity.",
      "notes": "Array fields\nNote: At its simplest, the Guidewire data model is a set of XML-formatted metadata definitions of entities and typelists- An entity defines a set of fields for information. You can add an Array field to an entity.",
      "narration": "Array fields in the Guidewire data model allow you to store collections of related objects. For instance, an ABContact entity might have an array field that stores multiple ContactNote objects. This setup enables efficient querying of related data, as the system can dynamically retrieve all objects linked to a particular parent entity. Understanding how to implement and use array fields is crucial for designing scalable and responsive applications.",
      "ocrText": "| Array fields G\n\n« An array defines a set of additional entities of the same type to associate with the\nmain entity\n\n• For example, ABContact entity includes an array of ContactNote entities. This\nmeans ABContact can have zero, one or more ContactNotes associated to it.\n\nABContact ContactNote\n\nTaxID\nEmailAddress1\n\nContactNotes ABContact",
      "ocrWordCount": 53,
      "ocrConfidence": 88.54,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 9,
      "title": "Typelists and Typekey Fields",
      "bodyParagraphs": [],
      "originalNotes": "Typelists and typekey fields\nNote: At its simplest, the Guidewire data model is a set of XML-formatted metadata definitions of entities and typelists- An entity defines a set of fields for information. You can add a Typekey field to an entity.",
      "notes": "Typelists and typekey fields\nNote: At its simplest, the Guidewire data model is a set of XML-formatted metadata definitions of entities and typelists- An entity defines a set of fields for information. You can add a Typekey field to an entity.",
      "narration": "Typelists are integral to the Guidewire data model, providing a way to define enumerated values that can be reused across your application. Typekey fields reference these typelists, allowing you to maintain consistency and avoid hardcoding values throughout your codebase. This approach not only simplifies data management but also ensures that your application remains flexible and easy to update as business requirements evolve.",
      "ocrText": "| Typelists and typekey fields fa\n\n* Atypelist is a predefined set of possible values that limits the acceptable values for fields\nwithin the application. In most cases a typelist is rendered as a drop-down list in the user\ninterface\n\n- Atypekey field is entity field that is associated with a specific typelist. It can point to exactly\none value in the typelist\n\ntypelist\n\nABContact\n\nContactTier\n\nName\n\ni Platinum\nEmailAddress1\n\" Gold\nCreateTime °\nSilver\n\nPrefersContactByEmail\nScore\n\nAssignedUser\nContactNotes\n\n_ typekey field\n\nUnknown",
      "ocrWordCount": 83,
      "ocrConfidence": 91.76,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 10,
      "title": "Understanding Supertype and Subtype Entities",
      "bodyParagraphs": [],
      "originalNotes": "Supertype (subtyped) entities\nSubtype entities are children entities of a top level supertype (parent) entity. All fields in the parent entity are inherited by the child entity. ABContact is a top level supertype entity. The AB Contact entity is an abstract entity (abstract=true). Abstract entities cannot be instantiated, but they can be subtyped. In other words, this means that you cannot create instances of an AB Contact, but you can create entity instances of its subtypes such as instances of ABPerson, AB Company, AB Person Vendor, AB Policy Person, AB Ajudicator, AB Attorney, and AB Doctor.\n\nNot all top level supertype entities are abstract- It is also possible to have subtype entities that are abstract Another way to describe a supertype entity is to use the term \"subtyped\" entity. In the slide example, there are several subtyped entities including ABContact, ABPerson, and ABPersonVendor. The slide diagram does not reflect all the supertype and subtype entities in TrainingApp.\nSupertype entities in ClaimCenter include Contact, Incident, and Transaction- Contact and Transaction are abstract entities.\nSupertype entities in PolicyCenter include Contact, Job and Workflow- All three entities are abstract.\n\nSupertype entities in BillingCenter include Contact, Activity, Plan, Invoice, and Workflow. Contact, Plan, Invoice, and Workflow are abstractentities-",
      "notes": "Supertype (subtyped) entities\nSubtype entities are children entities of a top level supertype (parent) entity. All fields in the parent entity are inherited by the child entity. ABContact is a top level supertype entity. The AB Contact entity is an abstract entity (abstract=true). Abstract entities cannot be instantiated, but they can be subtyped. In other words, this means that you cannot create instances of an AB Contact, but you can create entity instances of its subtypes such as instances of ABPerson, AB Company, AB Person Vendor, AB Policy Person, AB Ajudicator, AB Attorney, and AB Doctor.\n\nNot all top level supertype entities are abstract- It is also possible to have subtype entities that are abstract Another way to describe a supertype entity is to use the term \"subtyped\" entity. In the slide example, there are several subtyped entities including ABContact, ABPerson, and ABPersonVendor. The slide diagram does not reflect all the supertype and subtype entities in TrainingApp.\nSupertype entities in ClaimCenter include Contact, Incident, and Transaction- Contact and Transaction are abstract entities.\nSupertype entities in PolicyCenter include Contact, Job and Workflow- All three entities are abstract.\n\nSupertype entities in BillingCenter include Contact, Activity, Plan, Invoice, and Workflow. Contact, Plan, Invoice, and Workflow are abstractentities-",
      "narration": "In Guidewire, supertype and subtype entities allow for efficient data modeling by inheriting fields from parent to child entities. For example, ABContact serves as a supertype entity, with subtypes like ABPerson and ABCompany inheriting its fields. This setup avoids duplication and promotes a clean, organized data model. Understanding how to effectively use supertypes and subtypes will help you design a scalable and maintainable data structure that meets complex business needs.",
      "ocrText": "| Supertype (subtyped) entities\n\n• If multiple entities have a common set of fields\nthen they could be organized into a hierarchy\n\nABContact\n\n• The entities in the same hierarchy will use the\nconcept of inheritance\n\n* This means that fields and methods of\nsupertype entities are inherited by subtype\nentities\n\nABAttorney ABDoctor",
      "ocrWordCount": 53,
      "ocrConfidence": 91.41,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 11,
      "title": "Supertype/Subtype Relationships in Practice",
      "bodyParagraphs": [],
      "originalNotes": "Supertype (subtyped) entities example\nLet's say there are two entities:\nAB Person and AB Company to store contact information about persons and companies.\n\n1) After we analyze the entity definitions, we find they b,vo fields in common and the fields have the same business purpose.\n2) To improve the design and avoid defining the same business field multiple times, we could introduce a new entity — AB Contact - to store the common fields.\n3) After defining the fields, we are going to set up a supertype-subtype (parent- child) relationship. Because of this relationship, the children are going to inherit all the fields from the parent.\n4) Thus, we can remove the duplicated fields from the definitions of AB Person and AB Company entities.",
      "notes": "Supertype (subtyped) entities example\nLet's say there are two entities:\nAB Person and AB Company to store contact information about persons and companies.\n\n1) After we analyze the entity definitions, we find they b,vo fields in common and the fields have the same business purpose.\n2) To improve the design and avoid defining the same business field multiple times, we could introduce a new entity — AB Contact - to store the common fields.\n3) After defining the fields, we are going to set up a supertype-subtype (parent- child) relationship. Because of this relationship, the children are going to inherit all the fields from the parent.\n4) Thus, we can remove the duplicated fields from the definitions of AB Person and AB Company entities.",
      "narration": "Let's consider the entities ABPerson and ABCompany, which store contact information. By introducing a supertype entity, ABContact, we can store common fields in one place, allowing ABPerson and ABCompany to inherit these fields. This relationship optimizes the data model by eliminating redundancy and ensuring consistency across related entities. Such design patterns are key to developing efficient and maintainable Guidewire applications.",
      "ocrText": "| Supertype (subtyped) entities example Gi\n\nABContact\n\nTaxID\nEmailAddress1\n\nn 6\nInspectionDate\n\nFirstName\nLastName",
      "ocrWordCount": 14,
      "ocrConfidence": 87.09,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 12,
      "title": "Entity Relationships and Storage",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "Understanding how entities and their relationships are stored in the database.",
      "narration": "In Guidewire, understanding how entities are stored in the database is crucial for effective data management. While most entities are persistent, meaning they are stored in database tables, some entities like virtual or subtype entities behave differently. Virtual entities exist only at runtime and do not persist in the database, while subtype entities share a table with their parent supertype. This nuanced understanding allows developers to optimize database interactions and application performance.",
      "ocrText": "Storage in the database",
      "ocrWordCount": 4,
      "ocrConfidence": 96.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 13,
      "title": "Entities and Database Storage",
      "bodyParagraphs": [],
      "originalNotes": "Entities in the database\nThere are two exceptions to the generalization above: virtual and subtype entities.\nVirtual. Non-persistent entities are entities constructed entirely with code. They exist during run-time, and when the Guidewire application shuts down, the data is not saved to the database. An example of a non-persistent entity is ABContactSearchCriteria in TrainingApp- Guidewire recommends that you do not create non-persistent entities as a general rule\n\nSubtype entities are entities that are children entities of a top level supertype (parent) entity. All fields in the parent entity are inherited by the child entity. A top level supertype entity and all of its child subtypes are stored in a single database table. In this manner, all the entities share the same database table.",
      "notes": "Entities in the database\nThere are two exceptions to the generalization above: virtual and subtype entities.\nVirtual. Non-persistent entities are entities constructed entirely with code. They exist during run-time, and when the Guidewire application shuts down, the data is not saved to the database. An example of a non-persistent entity is ABContactSearchCriteria in TrainingApp- Guidewire recommends that you do not create non-persistent entities as a general rule\n\nSubtype entities are entities that are children entities of a top level supertype (parent) entity. All fields in the parent entity are inherited by the child entity. A top level supertype entity and all of its child subtypes are stored in a single database table. In this manner, all the entities share the same database table.",
      "narration": "Entities in Guidewire can be either persistent or non-persistent. Non-persistent entities, like ABContactSearchCriteria, exist only at runtime and are not saved to the database. On the other hand, subtype entities share a database table with their supertype, allowing them to inherit fields efficiently. This architecture ensures that your application's data model is both powerful and flexible, capable of adapting to various business scenarios.",
      "ocrText": "| Entities in the database\n\nibcontact* ABContact\n1D | Name | CreateTime\nName\n64 United Natural Foods Inc 9/4/2009 1:51:32 PM -\n— if EmailAddress1\n65 aM 94/2009 1:51:32 PM CreateTime\n74 Express Auto 9/4/2009 1:51:32 PM PrefersContactByEmail\n75 European Autoworks 9/4/2009 1:51:32 PM Score\nAssignedUser\n76 MBGarage 9/4/2009 1:51:32 PM\n—— . i ContactNotes\n77 Burlingame Saab 9/4/2009 1:51:32 PM\n\n|__| ContactTier\n\n• Often, an entity stores data in a database table named for the entity:\n« ABContact entity in ab_abcontact table\n\n• Exceptions are...\n* Entities that share the columns in an entity table such as a subtype entity\n\n« Virtual, non-persistent entities do not save data to the database. Guidewire recommends that\nyou do not create non-persistent entities as a general rule",
      "ocrWordCount": 125,
      "ocrConfidence": 83.52,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 14,
      "title": "Virtual Fields and Enhancements",
      "bodyParagraphs": [],
      "originalNotes": "Data fields in the database\nIn the example above, the FullName field is a virtual field or property. FullName concatenates the values of the FirstName, MiddleName, and LastName physical fields.\nVirtual fields are defined as Gosu code in Enhancements. Entity Enhancements are discussed inanother lesson.",
      "notes": "Data fields in the database\nIn the example above, the FullName field is a virtual field or property. FullName concatenates the values of the FirstName, MiddleName, and LastName physical fields.\nVirtual fields are defined as Gosu code in Enhancements. Entity Enhancements are discussed inanother lesson.",
      "narration": "Virtual fields are a unique aspect of the Guidewire data model, allowing you to define fields that are computed at runtime rather than stored in the database. For example, a FullName field might concatenate first, middle, and last name fields. These are implemented using Gosu code in Entity Enhancements. This approach provides flexibility in how data is presented and manipulated without altering the underlying database schema.",
      "ocrText": "| Data fields in the database G\n\n• Data fields can be physical or virtual\n\n* Data model defines physical fields as columns in a database table\n\n* Gosu code defines virtual fields and there is no physical database column\n\n/Table - dbo.ab_abcontact*\nFirstName | MiddleName | LastName\n\nam——]_| ten (| MRAE Newton\nBo MULE Simpson\n\nleName\n\nLastName Willian MULL Weeks\n\nFullName (virtual) ‘william MAE Andy\n\nMichael NAL Simpson\n\nFullName = FirstName + \" \" + MiddleName + \" \" + LastName",
      "ocrWordCount": 82,
      "ocrConfidence": 86.15,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 15,
      "title": "Foreign Key Fields in Practice",
      "bodyParagraphs": [],
      "originalNotes": "Foreign key fields in the database\nIn the slide example, the assigned user (4) for European Autoworks is Alice Applegate. The assigned user (3) for 3M and Express Auto is System User.\nThe assigned user (2) for United Natural Foods lnc is Super User.",
      "notes": "Foreign key fields in the database\nIn the slide example, the assigned user (4) for European Autoworks is Alice Applegate. The assigned user (3) for 3M and Express Auto is System User.\nThe assigned user (2) for United Natural Foods lnc is Super User.",
      "narration": "Foreign key fields play a crucial role in linking entities within the Guidewire data model. For example, the assigned user for a company might be linked through a foreign key. These relationships are vital for navigating between related entities efficiently, enabling complex data queries and operations. Understanding how to define and use foreign keys is essential for building relational data models that reflect real-world scenarios.",
      "ocrText": "| Foreign key fields in the database\n\n• Foreign key fields are stored as foreign key columns\n\n_/ Table - dbo.ab_user*\n\n[1p | FirstNvame LastName\n> it Default Owner\ni 2 Super User\nhs system User\n\n_/ Table - dbo.ab_abcontact*\n\nID | Name | AssignedUser\n64 United Natural Foods Inc\n\ni 65 3M\n\n74 Express Auto\n\n—_ 7S European Autoworks",
      "ocrWordCount": 60,
      "ocrConfidence": 84.08,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 16,
      "title": "Managing Array Fields in the Database",
      "bodyParagraphs": [],
      "originalNotes": "Array fields in the database\nArray keys are managed during run-time by code that queries the database for objects of a given type with foreign keys that point to the array's parent.\n\nFor example, assume you have an ABContact object named ericAndy that stores the ABContact data for Eric Andy Whenever you reference ericAndy. ContactNotes,\n\nGuidewire queries the database for all ContactNote objects whose ABContact field points to Eric Andy and returns those objects in an array.",
      "notes": "Array fields in the database\nArray keys are managed during run-time by code that queries the database for objects of a given type with foreign keys that point to the array's parent.\n\nFor example, assume you have an ABContact object named ericAndy that stores the ABContact data for Eric Andy Whenever you reference ericAndy. ContactNotes,\n\nGuidewire queries the database for all ContactNote objects whose ABContact field points to Eric Andy and returns those objects in an array.",
      "narration": "Array fields are managed dynamically at runtime. Consider an ABContact named Eric Andy; his contact notes are stored as an array. The system queries the database to retrieve all related ContactNote objects for Eric Andy, providing a seamless way to handle collections of related data. This functionality is vital for scenarios where entities can have multiple related entries, such as notes or history logs.",
      "ocrText": "| Array fields in the database G\n\n« Arrays are not stored in the database, but populated at runtime by queries\n\n• Every array on the main entity must have a reverse foreign key pair on the\nassociated additional entity\n\nABContact\nContactNote\nTaxID\nEmailAddress1 Subject\n\nContactNotes Body\non ABContact",
      "ocrWordCount": 49,
      "ocrConfidence": 90.56,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 17,
      "title": "Typelists and Typekeys in the Database",
      "bodyParagraphs": [],
      "originalNotes": "Typelists and typekey fields in the\ndatabase\nTypelist tables are named <applicationcode>tl_<typelistname>\n\nIn this example, the Vendor Type\nof M B Garage and Glass Repair\nis Auto glass shop.",
      "notes": "Typelists and typekey fields in the\ndatabase\nTypelist tables are named <applicationcode>tl_<typelistname>\n\nIn this example, the Vendor Type\nof M B Garage and Glass Repair\nis Auto glass shop.",
      "narration": "Typelists in Guidewire are implemented through database tables prefixed with the application code, like '<applicationcode>tl_<typelistname>'. These tables store the enumerated values that typekey fields reference. For instance, in a vendor management scenario, a typekey might indicate the type of vendor service provided. Typelists ensure data consistency and are a powerful tool for managing enumerated data across your application.",
      "ocrText": "| Typelists and typekey fields in the database G\n\n• Each typelist is stored in its own table\n« This is a predefined, fixed table that does not change during runtime\n\n• Each typekey is a foreign key to a single row in a typelist table\n\n_/ Table - dbo.ab_abcontact*\n\n1D | Name | YendorType 1D,\n10001 Auto glass shop\n\n10002 Auto rental service\n\n74 Express Auto\n\n75 European Autoworks\n\n76 MB Garage and Glass Repair 10003 Auto repair shop\n77 Burlingame Saab 10003 10004 Building contractor\n78 Menlo Park Chevron 10003 10005. Defense attorney\n79 Cupertino's Smog Pro and Auto Repair 10003 10006 Doctor\n\n80 Rent-a-Wreck. 10002 10007 External adjuster\n81 Hertz of Menlo Park 10002 10008 Fire inspector\n\n82 Hollister Muffler and Quick Lube 10003 10009 Government aut...\n\n83 Monterey Beacon Village Motor Works 10003 10010 Hospital",
      "ocrWordCount": 139,
      "ocrConfidence": 84.52,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 18,
      "title": "Subtype Entities and Virtual Typelists",
      "bodyParagraphs": [],
      "originalNotes": "Subtype entities in the database\nWhenever an entity is subtyped, a virtual typelist is automatically created for it. This typelist contains one typecode for every subtype of the parent entity. Typelist tables are prefixed with \"xxtl \", where \"xx\" is the two- letteFapplication code.\n\nThe ab abcontact table is the parent 3r supertype table that stores all instances of ABContact and its subtypes.",
      "notes": "Subtype entities in the database\nWhenever an entity is subtyped, a virtual typelist is automatically created for it. This typelist contains one typecode for every subtype of the parent entity. Typelist tables are prefixed with \"xxtl \", where \"xx\" is the two- letteFapplication code.\n\nThe ab abcontact table is the parent 3r supertype table that stores all instances of ABContact and its subtypes.",
      "narration": "Subtype entities in Guidewire automatically generate a virtual typelist, containing typecodes for each subtype of the parent entity. For example, the 'ab_abcontact' table serves as the parent table for all instances of ABContact and its subtypes. This structure allows for efficient storage and retrieval of subtype data, ensuring that your data model remains organized and scalable.",
      "ocrText": "| Subtype entities in the database\n\nGi\n\n• Supertype parent table stores all instance of itself AND of subtype data\n\n* Contains parent fields and all subtype fields\n\n* Irrelevant fields are null for specific subtypes\n\n* Application automatically creates typelist table of all subtypes\n\n* Subtype column identifies subtype\n\n•« Example: FIRSTNAME and LASTNAME are always null for subtype = 3\n\nSELECT ID, TAXID, NAME, FIRSTNAME, LASTNAME, VENDORTYPE, SUBTYPE FROM AB_ABCONTACT order by SUBTYPE;\nFIRSTNAME |LASTNAME |VENDORTYPE |SUBTYPE\n\n1D\n71\n72\n67\n68\n75\n76\n77\n78\n79\n\nTAXID\n\nNAME\n\n3432-32-431134-23-2343 null\n\nnul\n\n2096542-3113-2456902\n9983200-5335-0023899\n1242577-7777-7752421\n3219251-8888-1529123\n5040392-9999-2930405\n5647382-7777-2837465\n5646372-4444-2736465\n\nnul\n\nnul\n\nnul\n\nExpress Auto\nEuropean Autoworks\nMB Garage\nBurlingame Saab\nMenlo Park Chevron\n\nJames\nPaul\nLily\nJames\nnul\nnul\nnul\nnul\nrut\n\nSmythe\nPeterson\nWatson\nAndersen\nnul\n\nnut\n\nnut\n\naul\n\nnul\n\nSELECT ID. TYPECODE\nFROM ABTL ABCONTACT\n\n\\ID [TYPECODE\n1 |ABAdjudicator\n2__|aBattorne\n\n3 |ABAutoRepairShop\n\npul\nnull\npul\naul\npul\naul\npul\naul\npul",
      "ocrWordCount": 155,
      "ocrConfidence": 81.36,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 19,
      "title": "Exploring the TrainingApp Data Model",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "Overview of the TrainingApp data model and its entities.",
      "narration": "The TrainingApp data model is centered around the ABContact entity, which stores contact information and is subtyped for different contact types. Entities like Address, HistoryEntry, and FlagEntry define relationships and extend functionality. This model demonstrates how entities are interconnected, showcasing the complexity and flexibility of Guidewire's architecture. Understanding these relationships is key to leveraging the full potential of your application's data model.",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 20,
      "title": "TrainingApp Data Model Overview",
      "bodyParagraphs": [],
      "originalNotes": "TrainingApp data model The core of the TrainingApp data model consists of nine entities and a small number of relationships which all center around ABContact.\n\n• The ABContact entity stores contacts. CAB\" stands for \"Address Book\". Many insurance carriers refer to their contact application as an Address Book.) The ABContact entity is subtyped, which is represented in the diagram above by the three small rectangles inside the ABContact rectangle- See the Subtype hierarchy earlier in this presentation.\n\n• The Address entity stores addresses. An ABContact has one to many addresses.\n\n• Each contact has a history, which is a list of important occurrences in the life of that contact. The HistoryEntry entity stores a single entry in the ABContact's history. Given that a history entry is created to note the creation of the contact, every ABContact has one to many history entries.\n\n• The FlagEntry entity stores a flag entry. A flag entry is an issue pertaining to the ABContact which someone should attend to. An ABContact is \"flagged\" when\nit has one or more open flag entries. An ABContact can have zero to many flag entries.\n\n• The ContactNote entity stores notes about the ABContact. A contact note is a free-form text entry used to capture miscellaneous information about the contact. An ABContact can have zero to many contact notes\n\n• The BankAccount entity stores bank account information. An ABContact can have zero to many bank accounts-\n\n• The Service Evaluation entity stores information about a service evaluation, which evaluates the quality of the service provided by the contact and is most appropriate for vendo contacts such as doctors, lawyers, and auto repair shops. An ABContact can have zero to many service evaluations.\n\n• The User entity stores information about TrainingApp users. An ABContact may have zero or one assigned users.\n\n• The FinancialSummary entity stores information about an ABContact’s financial summary. An ABContact may have zero or one financial summaries.",
      "notes": "TrainingApp data model The core of the TrainingApp data model consists of nine entities and a small number of relationships which all center around ABContact.\n\n• The ABContact entity stores contacts. CAB\" stands for \"Address Book\". Many insurance carriers refer to their contact application as an Address Book.) The ABContact entity is subtyped, which is represented in the diagram above by the three small rectangles inside the ABContact rectangle- See the Subtype hierarchy earlier in this presentation.\n\n• The Address entity stores addresses. An ABContact has one to many addresses.\n\n• Each contact has a history, which is a list of important occurrences in the life of that contact. The HistoryEntry entity stores a single entry in the ABContact's history. Given that a history entry is created to note the creation of the contact, every ABContact has one to many history entries.\n\n• The FlagEntry entity stores a flag entry. A flag entry is an issue pertaining to the ABContact which someone should attend to. An ABContact is \"flagged\" when\nit has one or more open flag entries. An ABContact can have zero to many flag entries.\n\n• The ContactNote entity stores notes about the ABContact. A contact note is a free-form text entry used to capture miscellaneous information about the contact. An ABContact can have zero to many contact notes\n\n• The BankAccount entity stores bank account information. An ABContact can have zero to many bank accounts-\n\n• The Service Evaluation entity stores information about a service evaluation, which evaluates the quality of the service provided by the contact and is most appropriate for vendo contacts such as doctors, lawyers, and auto repair shops. An ABContact can have zero to many service evaluations.\n\n• The User entity stores information about TrainingApp users. An ABContact may have zero or one assigned users.\n\n• The FinancialSummary entity stores information about an ABContact’s financial summary. An ABContact may have zero or one financial summaries.",
      "narration": "The TrainingApp data model revolves around the ABContact entity, which is the cornerstone of contact management. This entity, along with its subtypes, interacts with other entities like Address, HistoryEntry, and ContactNote to form a comprehensive data structure. Each entity plays a specific role, such as storing addresses, notes, or flag entries, and they collectively ensure a well-rounded representation of contact-related data. This interconnected model showcases the power of Guidewire's data architecture.",
      "ocrText": "| TrainingApp data model\n\nAssignedUser\n\nABContact\n\nLILILI\n\nFinancial ServiceEvaluations\nSummary\n\nAllAddresses\n\nHistoryEntries\n\nFlagEntries\n\nContactNotes\n\nFinancialSummary\n\nBankAccounts\n\nService\nEvaluation",
      "ocrWordCount": 18,
      "ocrConfidence": 91.65,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 21,
      "title": "Navigating the Data Dictionary",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "Introduction to the Guidewire Data Dictionary and its views.",
      "narration": "The Data Dictionary is a crucial resource for any Guidewire developer, documenting all entities and typelists used within an application. It offers three views: standard, migration, and database, each serving different purposes. Whether you're working on extending the data model or migrating data from a legacy system, the Data Dictionary provides the insights you need to understand and manipulate the application's data structure effectively.",
      "ocrText": "The Data Dictionary",
      "ocrWordCount": 3,
      "ocrConfidence": 95.67,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 22,
      "title": "What is the Data Dictionary?",
      "bodyParagraphs": [],
      "originalNotes": "What is the Data Dictionary?\nThe Data Dictionary documents the entities and typelists in a Guidewire application. The Data Dictionary contains three kinds of data entity views: standard, database, and migration.\n\nThe standard and migration views are similar but not identical. You use each for a different purpose. In general:\n• Use the standard view to view a full set of entities associated with the PolicyCenter application and the columns, typekeys, arrays and foreign keys associated with each entity. \"Using the Data Dictionary\" discusses the standard Data Dictionary view in more detail.\n• Use the migration view to assist you in converting data from a legacy application. This view provides a subset of the information in the standard view of the application entities that is more useful for those working on the conversion of legacy data.\n• The Data Entities (Database View) is just simply the physical database view.\n\nYou would execute the gwb commandif:\n• You have a clean installation of the Guidewire application (Data Dictionary is not pregenerated)\n• You extend the Data Model:\n- To validate your changes\n- To refresh the static HTML\npages",
      "notes": "What is the Data Dictionary?\nThe Data Dictionary documents the entities and typelists in a Guidewire application. The Data Dictionary contains three kinds of data entity views: standard, database, and migration.\n\nThe standard and migration views are similar but not identical. You use each for a different purpose. In general:\n• Use the standard view to view a full set of entities associated with the PolicyCenter application and the columns, typekeys, arrays and foreign keys associated with each entity. \"Using the Data Dictionary\" discusses the standard Data Dictionary view in more detail.\n• Use the migration view to assist you in converting data from a legacy application. This view provides a subset of the information in the standard view of the application entities that is more useful for those working on the conversion of legacy data.\n• The Data Entities (Database View) is just simply the physical database view.\n\nYou would execute the gwb commandif:\n• You have a clean installation of the Guidewire application (Data Dictionary is not pregenerated)\n• You extend the Data Model:\n- To validate your changes\n- To refresh the static HTML\npages",
      "narration": "The Data Dictionary is an invaluable tool that documents the entities and typelists in your Guidewire application. It includes standard, migration, and database views, each tailored to different aspects of data management. The standard view provides a comprehensive overview of entities and their relationships, while the migration view aids in transitioning data from legacy systems. Understanding how to leverage these views is essential for effective data model management and extension.",
      "ocrText": "| What is the Data Dictionary? G\n\n* Documents the entities and typelists in the Guidewire application\n\n* Base application\n\n* Customer extensions © OO fley//C16W07rriningApp/ould/dctonary/dataindex html & 0 6\n* Three main sections G . .\n. Entities uidewire\nContactManager\n. Typelists Data Dictionary\nEnty model vein But on 22,208 a 46.1\n* All fields DanEatien\ntities (Migtation View)\n• Manual (re)generation Toaltn\nAll fields (an index of field names to entities containing them)\n\n• View in browser\n\n+ ..\\build\\dictionary\n\\data\\index.html",
      "ocrWordCount": 82,
      "ocrConfidence": 75.01,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 23,
      "title": "Demonstration: User Story Implementation",
      "bodyParagraphs": [],
      "originalNotes": "Demonstration\nShown here is an example user story requirement requested by a fictional business analyst.",
      "notes": "Demonstration\nShown here is an example user story requirement requested by a fictional business analyst.",
      "narration": "In this demonstration, we'll explore how a user story requirement from a fictional business analyst translates into data model changes. Pay attention to how the requirements drive the creation or extension of entities and fields. This process is a practical example of how real-world needs influence the design and implementation of the Guidewire data model, showcasing the flexibility and adaptability of the platform.",
      "ocrText": "| Demonstration G\n\nWorking with the Data Dictionary\n\naa==D>\nam==D\nap\n• The developers an Insurance company have learned the\nmain concepts of the Data Model and want to see how to\nclick here find more information self-sufficiently\n\nNote: The demonstration opens a new tab in your browser. When the demonstration ends, the\noriginal course launch window appears. Return to this window to continue this presentation.",
      "ocrWordCount": 66,
      "ocrConfidence": 94.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_instruction",
      "demoVideoIndex": 0
    },
    {
      "slideNumber": 24,
      "title": "Hands-On Exercise: Data Model Extensions",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "Exercise for extending the data model based on a user story.",
      "narration": "Now, it's your turn to apply what you've learned. In this hands-on exercise, you'll extend the data model based on a given user story. Focus on defining new entities or fields as needed, and use the Data Dictionary to guide your changes. This practical experience will reinforce your understanding of how data model extensions can meet specific business requirements.",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": false,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_video"
    },
    {
      "slideNumber": 25,
      "title": "Reviewing Data Model Changes",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "Review the changes made during the exercise.",
      "narration": "Let's review the changes you made during the exercise. Consider how your modifications align with the user story and any challenges you encountered. Reflecting on these changes helps solidify your understanding of the data model and prepares you for real-world development scenarios where such adaptations are necessary.",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 95.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 26,
      "title": "Common Pitfalls in Data Model Extensions",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "Discuss common issues faced when extending the data model.",
      "narration": "When extending the data model, it's crucial to be aware of common pitfalls. These can include improperly defined foreign keys, inefficient use of array fields, or overly complex subtype hierarchies. Understanding these potential issues can help you avoid them in your own implementations, ensuring that your data model remains robust and efficient.",
      "ocrText": "Question G\nFor each of the following, identify if it is stored as a database table, as a\n• table column, or not stored in the database at all:\nA) An entity (such as ABContact)\nB) Aphysical data field (such as ABContact.CreateTime)\nC) A virtual data field (such as ABContact.FullName)\nD) A foreign key field (such as ABContact.AssignedUser)\n•\n•\nSooo Oooo oo oa",
      "ocrWordCount": 64,
      "ocrConfidence": 85.5,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "For each of the following, identify if it is stored as a database table, as a table column, or not stored in the database at all:\nA) An entity (such as ABContact)\nB) A physical data field (such as ABContact.CreateTime)\nC) A virtual data field (such as ABContact.FullName)\nD) A foreign key field (such as ABContact.AssignedUser)",
        "answer": "The correct responses are:\nA) A table\nB) A column\nC) Not stored in the database (Technically, the source values are probably stored in the database. But the value of a virtual field itself is not stored as a separate value.)\nD) A column (specifically a foreign key column to the relevant entity's table)"
      }
    },
    {
      "slideNumber": 27,
      "title": "Best Practices for Data Model Design",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "Explore best practices for designing a Guidewire data model.",
      "narration": "Designing a data model in Guidewire requires adhering to best practices to ensure scalability and maintainability. This includes using supertype/subtype hierarchies to eliminate redundancy, leveraging typelists for consistency, and defining clear relationships between entities. By following these guidelines, you can create a data model that not only meets current requirements but is also adaptable to future changes.",
      "ocrText": "Answer Gi\nFor each of the following, identify if it is stored as a database table, as a\n• table column, or not stored in the database at all:\n•\n•\nThe correct responses are:\nA) Atable\nB) Acolumn\nC) Not stored in the database (Technically, the source values are probably stored in\nthe database. But the value of a virtual field itself is not stored as a separate\nvalue.)\nBoo OO oo oo ooo\ngS\nAcolumn (specifically a foreign key column to the relevant entity's table)",
      "ocrWordCount": 88,
      "ocrConfidence": 84.72,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 28,
      "title": "Optimizing Data Model Performance",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "Strategies for optimizing data model performance.",
      "narration": "Optimizing the performance of your data model is key to ensuring your application runs smoothly. Techniques such as indexing frequently queried fields, minimizing the use of non-persistent entities, and effectively managing foreign key relationships can significantly enhance performance. By focusing on these areas, you can create a responsive and efficient application that scales with your business needs.",
      "ocrText": "Question G\nFor each of the following, identify if it is stored as a database table, as a\n• table column, or not stored in the database at all:\nA) Anarray key field (such as ABContact.ContactNotes)\nB) Atypelist (such as VendorType)\nC) Atypekey field (such as ABContact.VendorType)\n•\n•\nSooo Oooo oo oa",
      "ocrWordCount": 54,
      "ocrConfidence": 84.79,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "For each of the following, identify if it is stored as a database table, as a table column, or not stored in the database at all:\nA) An array key field (such as ABContact.ContactNotes)\nB) A typelist (such as VendorType)\nC) A typekey field (such as ABContact.VendorType)",
        "answer": "The correct answers are:\nA) Not stored in the database,\nB) A table,\nC) A column (specifically a foreign key column to the typelist's table)"
      }
    },
    {
      "slideNumber": 29,
      "title": "Case Study: Successful Data Model Extension",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "Real-world example of a successful data model extension.",
      "narration": "Let's look at a case study where a successful data model extension was implemented. In this scenario, a business required additional fields in the Policy entity to capture new underwriting data. By carefully planning the extension and using best practices, the development team was able to deliver a solution that met the business's needs without compromising system performance or maintainability.",
      "ocrText": "Answer Gi\nFor each of the following, identify if it is stored as a database table, as a\n• table column, or not stored in the database at all:\nA) Anarray key field (such as ABContact.ContactNotes)\nB) Atypelist (such as VendorType)\nC) Atypekey field (such as ABContact.VendorType)\n•\n•\nThe correct answers are:\nA) Not stored in the database,\nB) Atable,\nC) Acolumn (specifically a foreign key column to the typelist's table)\nBoo OO oo oo ooo",
      "ocrWordCount": 78,
      "ocrConfidence": 83.69,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 30,
      "title": "Troubleshooting Data Model Issues",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "Approach to troubleshooting common data model issues.",
      "narration": "Troubleshooting data model issues requires a systematic approach. Start by reviewing recent changes in the Data Dictionary, check for errors in XML configurations, and use logging to trace issues in foreign key relationships or subtype hierarchies. This methodical process can help you quickly identify and resolve problems, ensuring your data model remains effective and reliable.",
      "ocrText": "Question G\nName two circumstances in which you would execute the gwb\n• genDataDictionary command.\n•\n•\nSooo Oooo oo oa",
      "ocrWordCount": 23,
      "ocrConfidence": 74.6,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "Name two circumstances in which you would execute the gwb genDataDictionary command.",
        "answer": "Possible answers:\nYou would execute genDataDictionary when you install the application and whenever you extend the Data Model.\nYou could also execute the command when you modify system permissions or some other aspect of access and therefore need to regenerate the Security Dictionary."
      }
    },
    {
      "slideNumber": 31,
      "title": "Preparing for Data Model Extensions",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "Steps to prepare for extending the data model.",
      "narration": "Before extending the data model, it's important to thoroughly understand the current architecture and business requirements. Utilize the Data Dictionary to map out existing entities and relationships, and plan your extensions carefully. By setting a solid foundation, you'll ensure that your modifications integrate smoothly with the existing data model, minimizing potential disruptions.",
      "ocrText": "Answer Gi\nName two circumstances in which you would execute the gwb\n• genDataDictionary command.\n•\n•\nPossible answers:\nYou would execute genDataDictionary when you install the application and whenever\nyou extend the Data Model.\nYou could also execute the command when you modify system permissions or some\nother aspect of access and therefore need to regenerate the Security Dictionary.\nBoo OO oo oo ooo",
      "ocrWordCount": 67,
      "ocrConfidence": 86.43,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 32,
      "title": "Summary and Key Takeaways",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "Recap of the lesson and its key points.",
      "narration": "Today, we've covered the fundamentals of the Guidewire data model, including entity definitions, data fields, and the flexibility of extensions. Remember that understanding these concepts is crucial for building robust applications that meet diverse business needs. As you continue to work with Guidewire, these skills will be instrumental in adapting and extending your applications effectively.",
      "ocrText": "Lesson\nobjectives\nreview\n\n+ Describe the contents of a Guidewire Data\n\nModel\n\n* Identify information about a given\n\napplication's Data Model\n\n+ Use the Data Dictionary",
      "ocrWordCount": 26,
      "ocrConfidence": 89.04,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives_review"
    },
    {
      "slideNumber": 33,
      "title": "Looking Ahead: Extending the Data Model",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "Preview of the next lesson on extending the data model.",
      "narration": "Looking ahead, our next lesson will delve deeper into extending the data model. We'll explore advanced techniques for creating custom entities and fields, as well as best practices for maintaining data integrity and performance. This upcoming session will build on today's foundational knowledge, equipping you with the skills to tackle more complex development challenges in Guidewire.",
      "ocrText": "| Student exercise\n\nIntroduction to the Data Model",
      "ocrWordCount": 8,
      "ocrConfidence": 95.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "exercise"
    }
  ],
  "videos": [
    {
      "index": 1,
      "filename": "IS_Fund_02_01.mp4",
      "path": "/academy/guidewire/videos/ch07/IS_Fund_02_01.mp4"
    }
  ],
  "hasNotes": true,
  "hasTables": false,
  "hasImages": true,
  "ocrMetadata": {
    "totalWords": 1722,
    "avgConfidence": 88.13,
    "extractedAt": "2026-02-13T12:17:06.022256"
  }
}
