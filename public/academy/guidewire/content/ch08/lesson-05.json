{
  "lessonId": "ch08-l05",
  "chapterId": 8,
  "chapterSlug": "ch08",
  "lessonNumber": 5,
  "title": "Concepts of Revisioning",
  "sourceFile": "PP_05_Concepts of Revisioning.pptx",
  "sourceFolder": "PP_05_Configuration",
  "totalSlides": 35,
  "estimatedMinutes": 105,
  "slides": [
    {
      "slideNumber": 1,
      "title": "Concepts of Revisioning",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Concepts of Revisioning",
      "ocrWordCount": 3,
      "ocrConfidence": 94.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "title"
    },
    {
      "slideNumber": 2,
      "title": "Learning Objectives",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Lesson\nobjectives\n\n• Describe policy revisioning and EffDated\nentities\n\n• Describe window mode and slice mode\n\n« Access a policy in window and slice mode\nusing Gosu",
      "ocrWordCount": 27,
      "ocrConfidence": 87.19,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives"
    },
    {
      "slideNumber": 3,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 95.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 4,
      "title": "i EffDated entities",
      "bodyParagraphs": [],
      "originalNotes": "EffDated entities\nEvery entity has a type attribute. Entities with different types behave differently. The possible values for an entity type are editable, effdated, effdatedbranch, retireable etc.\n\nAn effdated entity has effective date fields, meaning a start and end date, used within PolicyCenter. An effdated entity is a member of an effective dated graph, rooted at an effdatedbranch entity.\n\nThe retireable entity is an extension of the editable entity, and is the most common type of entity. Most, but not all, base entities are of this type. It does not keep the state of an entity like the effdated entity.",
      "notes": "EffDated entities\nEvery entity has a type attribute. Entities with different types behave differently. The possible values for an entity type are editable, effdated, effdatedbranch, retireable etc.\n\nAn effdated entity has effective date fields, meaning a start and end date, used within PolicyCenter. An effdated entity is a member of an effective dated graph, rooted at an effdatedbranch entity.\n\nThe retireable entity is an extension of the editable entity, and is the most common type of entity. Most, but not all, base entities are of this type. It does not keep the state of an entity like the effdated entity.",
      "narration": "",
      "ocrText": "i EffDated entities\n\nAre created to track the state of an entity over effective time\n\n* Have EffectiveDate and ExpirationDate columns\n\n« Are members of an effective dated graph, rooted at an effdatedbranch entity.\n\nPersonalVehicle (pc_personalvehicle) (delegates to Modifiable, Coverable,\n\n> Description\nFields\n\nEffectiveDate datetime (wis\n\nEffective date of this row or FNULL in the database if equal to the period start\n\nExpirationDate «\nExpired date of this row: or of NULL Ms inthe ‘database if equal to the period end",
      "ocrWordCount": 81,
      "ocrConfidence": 87.49,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 5,
      "title": "i PolicyPeriod entity",
      "bodyParagraphs": [],
      "originalNotes": "Policy Period entity\nIn the default configuration, Policy Period is the only option for a root object of Eff Dated entities. Policy Period is referred to as the parent object and the EffDated entities on it are often referred to as the child objects or sub- objects\n\nPolicy Period as an entity is not eff dated. A new one is created each time there is any sort of change/update to the policy. PolicyCenter does not •revision“ the Policy Period, the data that comprises the Policy Period i.e. objects on the policy are revisioned.\n\nFor example, think of Policy Period as a box. In that box are all the things that can change. I may remove something, add something, or modify something in that box, and it is these items that are Eff Dated. When this happens, PolicyCenter puts everything in a new box i.e. Policy Period which is cloned from the previous Policy Period box. The box itself is exactly the same, but the stuff in it has changed.",
      "notes": "Policy Period entity\nIn the default configuration, Policy Period is the only option for a root object of Eff Dated entities. Policy Period is referred to as the parent object and the EffDated entities on it are often referred to as the child objects or sub- objects\n\nPolicy Period as an entity is not eff dated. A new one is created each time there is any sort of change/update to the policy. PolicyCenter does not •revision“ the Policy Period, the data that comprises the Policy Period i.e. objects on the policy are revisioned.\n\nFor example, think of Policy Period as a box. In that box are all the things that can change. I may remove something, add something, or modify something in that box, and it is these items that are Eff Dated. When this happens, PolicyCenter puts everything in a new box i.e. Policy Period which is cloned from the previous Policy Period box. The box itself is exactly the same, but the stuff in it has changed.",
      "narration": "",
      "ocrText": "i PolicyPeriod entity G\n\n• PolicyPeriod entity is:\n\n* the root of all EffDated entities on a policy graph\n\n+ not EffDated, but type of effDatedBranch\n• Set relationship between an EffDated entity and PolicyPeriod\n\n* effDatedBranchType=\"PolicyPeriod\" in the eti file\n\n(=) PersonalVehicle.eti\n?xml version=\"1.0\"?>\n\n<entity\n\nxmlins=\"http: //guidewire.com/datamodel\"\ndesc=\"Personal Vehicle\"\n\ndisplayName=\"Personal Vehicle\"\n\nleffDatedBranchType=\"PolicyPeriod\"|\n\nentity=\"PersonalVehicle\"\n\n2\n3\n4\n6",
      "ocrWordCount": 58,
      "ocrConfidence": 82.15,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 6,
      "title": "i EffDated entity columns",
      "bodyParagraphs": [],
      "originalNotes": "EffDated entity columns\nFixedld: Fixedld has no relation to other attributes on the object.\n\nFor example, a vehicle is given a Fixedld of 22, a VIN of 12344 and then when it undergoes a PolicyChange later to correct the VIN number the VIN is 12345 but the Fixedld cannot be changed and will remain as 22. Or you might correct the model on a vehicle but it's still the same vehicle, i.e., it still has the same Fixedld. If the fixed IDs for two vehicles match, they are versions of the same vehicle, not two different vehicles. If the fixed IDs do not match, they represent different vehicles.\n\n Branch. Foreign key to the PolicyPeriod entity that contains this entity Guidewire mandates that all entities within the same branch share the same Branch value. This value cannot be null.",
      "notes": "EffDated entity columns\nFixedld: Fixedld has no relation to other attributes on the object.\n\nFor example, a vehicle is given a Fixedld of 22, a VIN of 12344 and then when it undergoes a PolicyChange later to correct the VIN number the VIN is 12345 but the Fixedld cannot be changed and will remain as 22. Or you might correct the model on a vehicle but it's still the same vehicle, i.e., it still has the same Fixedld. If the fixed IDs for two vehicles match, they are versions of the same vehicle, not two different vehicles. If the fixed IDs do not match, they represent different vehicles.\n\n Branch. Foreign key to the PolicyPeriod entity that contains this entity Guidewire mandates that all entities within the same branch share the same Branch value. This value cannot be null.",
      "narration": "",
      "ocrText": "i EffDated entity columns\n\nEffectiveDate and ExpirationDate\n\n* null value means this entity has same effective and expiration dates as its root (i.e.\nPolicyPeriod.PeriodStart and PolicyPeriod.PeriodEnd)\n\nFixedid — a unique identifier that PolicyCenter generates when a new object is\ncreated\n\n* Cannot be null\n* Stays same for all version of the object\nBranch -— link to the associated PolicyPeriod\n* Cannot be null\nBasedOn — a pointer back to prior version of this entity\n• If this is the first version, BasedOn is null\n* Column on EffDated entity as well as the PolicyPeriod",
      "ocrWordCount": 95,
      "ocrConfidence": 90.65,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 7,
      "title": "i Creating an EffDated entity",
      "bodyParagraphs": [],
      "originalNotes": "Creating an EffDated entity\nSee partial xml from PersonalVehicle.eti <?xml <entity\nxmlns=\"http://guidewire.com/data type=\"effdated“ effDatedBranchType=\"PolicyPeriod\" table=\"personatvehicle\"> <implementslnterface\niface=\"gw.api.copier. EffDatedCop yable“ lob. pa. PersonalVehicle\nEffDatedCopier\"/> <implementslnterface\niface=\"gw.api.logicalmatch. EffDat edLogicalMatcher\"\nimpl=\"gw.lob.pa-PersonalVehicle Matcher\"/>\n<implementsEntity <implementslnterface\niface=\"gw.api.domain. CoverableA dapter“ PersonalVehicle\nAdditionallnterestContainerCover ableModifiableAdapter\"/> <column\ndesc=\"lnternal field for storing the reference date of this entity on bound policy periods.\"\nname=\"ReferenceDatelnternal\"\ntype=\"datetime\"/>\n<column of the\nvehicle. \"\nname=\"Make\"\ntype=\"varchar\">\n<columnParam name=\"size\"\nvalue=\"40\"/>\n</column>",
      "notes": "Creating an EffDated entity\nSee partial xml from PersonalVehicle.eti <?xml <entity\nxmlns=\"http://guidewire.com/data type=\"effdated“ effDatedBranchType=\"PolicyPeriod\" table=\"personatvehicle\"> <implementslnterface\niface=\"gw.api.copier. EffDatedCop yable“ lob. pa. PersonalVehicle\nEffDatedCopier\"/> <implementslnterface\niface=\"gw.api.logicalmatch. EffDat edLogicalMatcher\"\nimpl=\"gw.lob.pa-PersonalVehicle Matcher\"/>\n<implementsEntity <implementslnterface\niface=\"gw.api.domain. CoverableA dapter“ PersonalVehicle\nAdditionallnterestContainerCover ableModifiableAdapter\"/> <column\ndesc=\"lnternal field for storing the reference date of this entity on bound policy periods.\"\nname=\"ReferenceDatelnternal\"\ntype=\"datetime\"/>\n<column of the\nvehicle. \"\nname=\"Make\"\ntype=\"varchar\">\n<columnParam name=\"size\"\nvalue=\"40\"/>\n</column>",
      "narration": "",
      "ocrText": "i Creating an EffDated entity Ga\n\n• First, identify the root entity of type EffDatedBranch, such as PolicyPeriod\n« Next, create the EffDated entity\n\n* Set the entity attributes\n+ type=\"EffDated”\n+ effDatedBranchType=\"PolicyPeriod*\n\n• Follow other rules relevant to the entity (e.g., PolicyLine or Coverage entities have their own\nspecific rules)\n\n• Refer to the existing EffDated entities as examples\n\n« For example, PersonalVehicle.eti, PersonalAutoCov.eti, BOPBuilding.eti, etc.",
      "ocrWordCount": 67,
      "ocrConfidence": 85.3,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 8,
      "title": "i BasedOn example",
      "bodyParagraphs": [],
      "originalNotes": "BasedOn example\nConsider the example where a submission is created on Mar 1 with one driver and one red car. This creates PolicyPeriod1 , Driver 1, and PersonalVehicle1 The BasedOn property for all of them are null at this point since a submission is not based on any prior policy period.\n\nWhen policy change 1 changes the color of the car to green, a new policy period is cloned from PolicyPeriod1 so PolicyPeriod2. BasedOn has the value of PolicyPeriod1. The personal vehicle is modified so it is BasedOn the prior version of the vehicle i.e. PersonalVehicle2. BasedOn = PersonalVehicle1. But there is no change in Driver2 and it is based on Driverl\n\nSimilarly, when another policy change 2, changes the color of the car to blue, a new policy period is cloned from PolicyPeriod2 so PolicyPeriod3. BasedOn has the value of PolicyPeriod2. The personal vehicle is modified so it is BasedOn the prior version of the vehicle i.e. PersonalVehicle3. BasedOn =\nPersonalVehicle2. Driver3. BasedOn is assigned Driver2.\n\nThe numbers 1, 2, and 3 denote the different policy revisions.",
      "notes": "BasedOn example\nConsider the example where a submission is created on Mar 1 with one driver and one red car. This creates PolicyPeriod1 , Driver 1, and PersonalVehicle1 The BasedOn property for all of them are null at this point since a submission is not based on any prior policy period.\n\nWhen policy change 1 changes the color of the car to green, a new policy period is cloned from PolicyPeriod1 so PolicyPeriod2. BasedOn has the value of PolicyPeriod1. The personal vehicle is modified so it is BasedOn the prior version of the vehicle i.e. PersonalVehicle2. BasedOn = PersonalVehicle1. But there is no change in Driver2 and it is based on Driverl\n\nSimilarly, when another policy change 2, changes the color of the car to blue, a new policy period is cloned from PolicyPeriod2 so PolicyPeriod3. BasedOn has the value of PolicyPeriod2. The personal vehicle is modified so it is BasedOn the prior version of the vehicle i.e. PersonalVehicle3. BasedOn =\nPersonalVehicle2. Driver3. BasedOn is assigned Driver2.\n\nThe numbers 1, 2, and 3 denote the different policy revisions.",
      "narration": "",
      "ocrText": "i BasedOn example Gi\n\nDriver and PersonalVehicle EffDated entities have BasedOn properties\n\nMar Dec\nSubmission on Mar 1 (Eff Mar 1 — Dec 31) 1\npolicy with 1 car and 1 driver i |__|\nDriverV1.BasedOn = null id\nPersonalVehicleV1.BasedOn = null CG)\n2\nPolicy Change 1 on Mar 2 (Eff Apr 1 - Dec 31) es\nchange car 1, no change in driver ns\nDriverV2.BasedOn = DriverV1 CG)\nPersonalVehicleV2.BasedOn = PersonalVehicleV1\n3\nPolicy Change 2 on Mar 3 — (Eff May 1 - Dec 31) |\n\nchange car 1, no change in driver\nDriverV3.BasedOn = DriverV2\n\nid\nPersonalVehicleV3.BasedOn = PersonalVehicleV2 | Historical PolicyPeriod\nEnforced PolicyPeriod",
      "ocrWordCount": 105,
      "ocrConfidence": 86.53,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 9,
      "title": "Structure of revisioning across effective",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Structure of revisioning across effective\ntime",
      "ocrWordCount": 6,
      "ocrConfidence": 94.5,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 10,
      "title": "i PolicyPeriod",
      "bodyParagraphs": [],
      "originalNotes": "PolicyPeriod\nThe PolicyPeriod entity contains information about all effective dates within a single Policy Term or period which means that every change in policy is represented by a PolicyPeriod entity at the root of a complex graph of sub- objects such as policy lines, vehicles, coverages, and many others- The entire hierarchy of Guidewire entities are cloned in the database into new rows during policy changes, renewals, or other jobs that result in cloning everything in a branch. The cloned branch is updated with the changes (such as delete a driver or add a new car etc.)- The changes made to this cloned branch will be visible only when a user views policy from that branch's effective date. This cloned branch becomes the base to be cloned for future changes and so forth. (In contrast, a submission job's branch is not cloned from another branch.) Policy term and policy periods:\nPolicy Term A new Policy Term is created whenever the policy contract is completely recreated. This occurs with a new policy (submission), a renewal, or a rewrite of an existing contract. A new Policy Term is not created when you amend a policy contract with a policy change job- There can be one or more o ICY eno SWI In one Policy Term. The length of the Policy Term is determined by the effective and expiration dates (PeriodStart and PeriodEnd) of the latest bound Policy Period in the same term.\n Policy Period\nThe Policy Period entity stores information for a specific revision of the contractual period of a policy. A revision occurs anytime a job occurs on a policy. A creates the first revision. Each additional transaction on the policy (such as a policy change) creates a new revision. Therefore, a policy almost always has multiple revisions, with one Policy Period entity for each revision. During the contractual period, only one Policy Period entity is in effect at a time. A new revision is created when you process a policy change that adds a car to the policy- The Effective Date for the car is several months into period",
      "notes": "PolicyPeriod\nThe PolicyPeriod entity contains information about all effective dates within a single Policy Term or period which means that every change in policy is represented by a PolicyPeriod entity at the root of a complex graph of sub- objects such as policy lines, vehicles, coverages, and many others- The entire hierarchy of Guidewire entities are cloned in the database into new rows during policy changes, renewals, or other jobs that result in cloning everything in a branch. The cloned branch is updated with the changes (such as delete a driver or add a new car etc.)- The changes made to this cloned branch will be visible only when a user views policy from that branch's effective date. This cloned branch becomes the base to be cloned for future changes and so forth. (In contrast, a submission job's branch is not cloned from another branch.) Policy term and policy periods:\nPolicy Term A new Policy Term is created whenever the policy contract is completely recreated. This occurs with a new policy (submission), a renewal, or a rewrite of an existing contract. A new Policy Term is not created when you amend a policy contract with a policy change job- There can be one or more o ICY eno SWI In one Policy Term. The length of the Policy Term is determined by the effective and expiration dates (PeriodStart and PeriodEnd) of the latest bound Policy Period in the same term.\n Policy Period\nThe Policy Period entity stores information for a specific revision of the contractual period of a policy. A revision occurs anytime a job occurs on a policy. A creates the first revision. Each additional transaction on the policy (such as a policy change) creates a new revision. Therefore, a policy almost always has multiple revisions, with one Policy Period entity for each revision. During the contractual period, only one Policy Period entity is in effect at a time. A new revision is created when you process a policy change that adds a car to the policy- The Effective Date for the car is several months into period",
      "narration": "",
      "ocrText": "i PolicyPeriod G\n\nA PolicyPeriod is one \"version\" of the policy\n\n* Has effective and expiration dates (PeriodStart and PeriodEnd) which define the actual term of\n\nthe policy\n• Has an EditEffectiveDate, which is the date at which changes from a job are applied\npolicy second teen driver renewal\ncreated auto added added (premium changed)\n04/20/08 07/20/08 10/20/08 04/20/09\nJ $270 { $450 J $920 J $990\n\n= Ss= 3e=_2)\n1 2 3\n\n3 PolicyPeriods and 1 PolicyPeriod and\n1 PolicyTerm: 1 PolicyTerm:\n04/20/08 — 04/20/09 04/20/09 — 04/20/10",
      "ocrWordCount": 89,
      "ocrConfidence": 88.4,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 11,
      "title": "i Model time and effective time",
      "bodyParagraphs": [],
      "originalNotes": "Model time and effective time\nModel time: This is like tracking the history of previous changes in any online system that has an audit trail. When a branch is bound, PolicyCenter sets its branch model date to match the real-world date it was bound.\n Additionally, PolicyCenter increments the policy revision's model number, which is an integer value that indicates the relative order of multiple versions of the same contractual policy revision. The bound revision with the latest model number is always the currently-active legally-enforced policy revision for that effective time range.\nChanges that happen later supersede earlier versions of the policy for the policy period's effective time range- However, PolicyCenter keeps older branches in the database. Older branches are required to view the policy history- Use this to generate reports of the legally-binding state of the policy at a model date earlier than today.\n\nEffective time: For example, what time range does the policy cover? This dimension of time is unique to a policy system- If the policy period is one year, each PolicyCenter policy period records the policy information for one year of effective time. Some objects on the policy may only exist for some range of effective time, or have different property values for different ranges of effective time-",
      "notes": "Model time and effective time\nModel time: This is like tracking the history of previous changes in any online system that has an audit trail. When a branch is bound, PolicyCenter sets its branch model date to match the real-world date it was bound.\n Additionally, PolicyCenter increments the policy revision's model number, which is an integer value that indicates the relative order of multiple versions of the same contractual policy revision. The bound revision with the latest model number is always the currently-active legally-enforced policy revision for that effective time range.\nChanges that happen later supersede earlier versions of the policy for the policy period's effective time range- However, PolicyCenter keeps older branches in the database. Older branches are required to view the policy history- Use this to generate reports of the legally-binding state of the policy at a model date earlier than today.\n\nEffective time: For example, what time range does the policy cover? This dimension of time is unique to a policy system- If the policy period is one year, each PolicyCenter policy period records the policy information for one year of effective time. Some objects on the policy may only exist for some range of effective time, or have different property values for different ranges of effective time-",
      "narration": "",
      "ocrText": "i Model time and effective time Gi\nTo track policy changes over time, a policy must be considered in two different time\ndimensions:\n\n• Model time is the actual real-world time when policies are created or jobs are\nbound\n\n* Effective time is the time dimension of the policy itself within the policy period",
      "ocrWordCount": 54,
      "ocrConfidence": 91.69,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 12,
      "title": "i Example",
      "bodyParagraphs": [],
      "originalNotes": "Example\nThis example is of a policy revision 1 created on Mar 1 with one car effective from Apr 1 — Dec 31.\nPolicy revision 2 is created by cloning PolicyPeriod 1 when car\n2 is added on Mar 2 effective from May 1 — Dec 31.\nPolicy revision 3 is created by cloning PolicyPeriod 2 when car2 is removed on Mar 3 effective from May 1 — Dec 31.",
      "notes": "Example\nThis example is of a policy revision 1 created on Mar 1 with one car effective from Apr 1 — Dec 31.\nPolicy revision 2 is created by cloning PolicyPeriod 1 when car\n2 is added on Mar 2 effective from May 1 — Dec 31.\nPolicy revision 3 is created by cloning PolicyPeriod 2 when car2 is removed on Mar 3 effective from May 1 — Dec 31.",
      "narration": "",
      "ocrText": "i Example\n\nEffective time\n\n—-\n\nJan1\n\nModel time\n\nEnforced PolicyPeriod\n\nMar\n\nDec 31\n\nMar 1 — policy with 1 car\neffective Apr 1 - Dec 31\nModel date: Mar 1\nEffective date: Apr 1\n\nMar 2 - add car 2\neffective May 1 - Dec 31\nModel date: Mar 2\nEffective date: May 1\n\nMar 3 — Remove car 2\neffective May 1 - Dec 31\nModel date: Mar 3\nEffective date: May 1",
      "ocrWordCount": 74,
      "ocrConfidence": 91.05,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 13,
      "title": "i Sub-objects across effective time (1)",
      "bodyParagraphs": [],
      "originalNotes": "Sub-objects across effective time (1)\nIf one object such as a vehicle does not change across effective time, there will be only one row in the database for that object at that model time. However, if it changes across effective time, the object is cloned into a new row in the database, differing in effective time begin and end dates. The insurance industry calls these begin and end dates i.e. the effective date and expiration date.\n\nFor example, suppose on March 1 a customer requests an auto policy for a red car, effective from March 1 through the end of the year.\n\nPolicyCenter represents this across effective time for the vehicle as a row in the database: A red car with effective date March 1 and expiration date December 1 (typically at 12:01 am).",
      "notes": "Sub-objects across effective time (1)\nIf one object such as a vehicle does not change across effective time, there will be only one row in the database for that object at that model time. However, if it changes across effective time, the object is cloned into a new row in the database, differing in effective time begin and end dates. The insurance industry calls these begin and end dates i.e. the effective date and expiration date.\n\nFor example, suppose on March 1 a customer requests an auto policy for a red car, effective from March 1 through the end of the year.\n\nPolicyCenter represents this across effective time for the vehicle as a row in the database: A red car with effective date March 1 and expiration date December 1 (typically at 12:01 am).",
      "narration": "",
      "ocrText": "i Sub-objects across effective time (1) Ga\n\n• Every policy revision is the root of a complex graph of sub-objects such as drivers,\nvehicles, coverages, and so on\n\n* If one of these objects changes then that object has its own effective and expiration date\n\n* Consider an example, where a personal auto submission is created with one\n\nvehicle\nub-object: Vehicle,\nMar 1 Dec 31 PersonalVehicle\nColor: RED\n\n9} = EffectiveDate: null\n\nExpirationDate: null\nFixedld: 12345\n\nSubmission",
      "ocrWordCount": 77,
      "ocrConfidence": 89.42,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 14,
      "title": "i Sub-objects across effective time (2)",
      "bodyParagraphs": [],
      "originalNotes": "Sub-objects across effective time (2)\nSee the next slide for more details.",
      "notes": "Sub-objects across effective time (2)\nSee the next slide for more details.",
      "narration": "",
      "ocrText": "i Sub-objects across effective time (2) Ga\n\n* On Sep 1, the customer calls and says the car was painted blue today\n\n« Anew policy revision is created by cloning a new row in the database differing in\neffective date and expiration date\n\n• Expiration date of first row is the effective date of second row\n• Arowis effective at a date specified if:\n\n• Effective date <= specified date < expiration date",
      "ocrWordCount": 73,
      "ocrConfidence": 88.92,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 15,
      "title": "i Sub-objects across effective time (3)",
      "bodyParagraphs": [],
      "originalNotes": "Sub-objects across effective time (3)\nOn September 1 the customer calls and says the car was painted today and is now blue.\n\nPolicyCenter represents these changes across effective time for the vehicle as two rows:\nA red car with effective date March 1 and expiration date September 1 (typically at 12:01 am).\nA blue car with effective date September 1 and expiration date December 31\n\nNote that the expiration date of the first row is the same as the effective date of the second. This means the first row is effective up until the exact date and time of expiration, but not including that exact date and time. A row is effective at the date specified date if the following equation is true: effective_dat<= specified_date < expiration_date\n\nEffective and Expiration dates are stored in the EffectiveDate and ExpirationDate property of each PolicyPeriod sub-object respectively. These values can be null in the database, but they will never be null in Gosu. When you access the property using Gosu it automatically returns the correct\ndate.\n\nThe same Fixedld values mean they are the same car with different effective date ranges. If another car was added then the Fixedld would change.",
      "notes": "Sub-objects across effective time (3)\nOn September 1 the customer calls and says the car was painted today and is now blue.\n\nPolicyCenter represents these changes across effective time for the vehicle as two rows:\nA red car with effective date March 1 and expiration date September 1 (typically at 12:01 am).\nA blue car with effective date September 1 and expiration date December 31\n\nNote that the expiration date of the first row is the same as the effective date of the second. This means the first row is effective up until the exact date and time of expiration, but not including that exact date and time. A row is effective at the date specified date if the following equation is true: effective_dat<= specified_date < expiration_date\n\nEffective and Expiration dates are stored in the EffectiveDate and ExpirationDate property of each PolicyPeriod sub-object respectively. These values can be null in the database, but they will never be null in Gosu. When you access the property using Gosu it automatically returns the correct\ndate.\n\nThe same Fixedld values mean they are the same car with different effective date ranges. If another car was added then the Fixedld would change.",
      "narration": "",
      "ocrText": "i Sub-objects across effective time (3)\n\nub-object: Vehicle\nColor: RED\nEffectiveDate: null\nMar 1 Dec 31 /{ ExpirationDate: null\na ——s Fixedld: 12345\n\nSubmission\n\nPersonalVehicle\n\nColor: RED\n| EffectiveDate: null\nxpirationDate: Sept 1\nFixedld: 12345\n\nMar1 Sept1 Dec 31\n\nub-object: Vehicle, f\nPolicy Change \\ Kub-object: =|\n\nColor: BLUE\n\n\\| EffectiveDate: Sep 1\nExpirationDate: null\nFixedld: 12345",
      "ocrWordCount": 57,
      "ocrConfidence": 83.06,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 16,
      "title": "Window mode and slice mode overview",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Window mode and slice mode overview",
      "ocrWordCount": 6,
      "ocrConfidence": 95.83,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 17,
      "title": "i Two modes to access a branch’s objects",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "i Two modes to access a branch’s objects Gi\n\n• Usually, jobs change policy data across effective time\n* Slice mode is viewing policy data as of a specific date in effective time\n\n« When you request objects on the policy in slice mode, PolicyCenter automatically gets the\ncorrect version of each object as of the slice date\n\n• Window mode is viewing all versions of policy data across all dates in effective\ntime\n* For example, you want to get all the costs for a vehicle within a policy term (cost may vary if\ncoverages have changed)\n\n* Or you want to list all the drivers ever assigned to a vehicle (a driver may only be assigned for\nshort period)",
      "ocrWordCount": 121,
      "ocrConfidence": 92.1,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 18,
      "title": "I Example",
      "bodyParagraphs": [],
      "originalNotes": "Example\nConsider a scenario where a policy is created using a submission transaction with one car effective from 04/01 for one year.\n\nA policy change adds another car to the policy effective from 05/01 till the expiration date of the policy.\nAnother policy change removes car 2, effective from 06/01 till the expiration of the policy. Note: This example is used throughout this lesson going forward.",
      "notes": "Example\nConsider a scenario where a policy is created using a submission transaction with one car effective from 04/01 for one year.\n\nA policy change adds another car to the policy effective from 05/01 till the expiration date of the policy.\nAnother policy change removes car 2, effective from 06/01 till the expiration of the policy. Note: This example is used throughout this lesson going forward.",
      "narration": "",
      "ocrText": "I Example\n\nEffective time\n\n+\n\nJan1 Apr MayJune Dec 31\n\n04/01: Submission\ncreates policy\nwith 1 red car\n\nModel time\n\n05/01: Change\nadd a blue car 2\n\n06/01: Change\nremove car 2\n\nEnforced PolicyPeriod",
      "ocrWordCount": 34,
      "ocrConfidence": 91.49,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 19,
      "title": "I Slice mode view as of:",
      "bodyParagraphs": [],
      "originalNotes": "Slice mode view as of:\nWhen you request cars on the policy in slice mode, PolicyCenter automatically gets the correct version of each car as of the slice date. Also, PolicyCenter only returns the cars that are effective at the slice date.",
      "notes": "Slice mode view as of:\nWhen you request cars on the policy in slice mode, PolicyCenter automatically gets the correct version of each car as of the slice date. Also, PolicyCenter only returns the cars that are effective at the slice date.",
      "narration": "",
      "ocrText": "I Slice mode view as of: G\n\nEffective time\n\nJan1 Apr MayJune Dec 31\nModel time 1\nApr 30? —— Policy has one red car\n2\n\nMay 30? © © | Mmmm §=Policy has two cars\n= MEE §=(one red, one blue)\n3\n\nNov 25? © 0 |\n\nxs ——— Policy has one red car\n\nOn any date, you might not see all cars that exist at some point in that policy period",
      "ocrWordCount": 73,
      "ocrConfidence": 84.03,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 20,
      "title": "i Window mode view",
      "bodyParagraphs": [],
      "originalNotes": "Window mode view\nThere is exactly one row in the database for each version of a car. For example, if the car has had three different colors, there are three rows in the database that represent that car. The set of three rows that represent this one car is called a version list. From the version list, you can access every version of the car in the period. In this case, the version list contains three versions of the car, each at some point in effective time.",
      "notes": "Window mode view\nThere is exactly one row in the database for each version of a car. For example, if the car has had three different colors, there are three rows in the database that represent that car. The set of three rows that represent this one car is called a version list. From the version list, you can access every version of the car in the period. In this case, the version list contains three versions of the car, each at some point in effective time.",
      "narration": "",
      "ocrText": "i Window mode view Gi\n\nEffective time\n\nJan1 Apr MayJune Dec 31\n1 2 3\nPage a\neS” S32\n\n* Lists all cars that existed on the policy for any period of time with the effective dates\n+ First, get a list of all cars that were ever on the policy\n+ Next, for each car, you want to iterate across all changes to that car across effective time\n* Obtained by using the VersionList property on a policy period\n• There are two cars in VersionList but there are three versions of the policy\n+ Submission, Policy Change 1, Policy Change 2",
      "ocrWordCount": 103,
      "ocrConfidence": 89.69,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 21,
      "title": "Demonstration",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "i Demonstration G\n\nSlice Mode\n\nclick here\n\nNote: The demonstration opens a new tab in your browser. When the demonstration ends, the\noriginal course launch window appears. Return to this window to continue this presentation.",
      "ocrWordCount": 35,
      "ocrConfidence": 93.51,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_instruction",
      "demoVideoIndex": 0
    },
    {
      "slideNumber": 22,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": false,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_video"
    },
    {
      "slideNumber": 23,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 95.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "demo_video"
    },
    {
      "slideNumber": 24,
      "title": "i Slice mode API:",
      "bodyParagraphs": [],
      "originalNotes": "Slice mode API: get SIice (slice Date)\nIf you get properties on a slice mode object to access other objects, those objects are also automatically in slice mode. In typical code, you can navigate up or down the object graph hierarchy without worrying about the revisioning details. At any time you can get the object. Slice Date property to get the slice date.\n\nIn most cases, it is best to call get Slice on the root Policy Period and navigate down the object graph from there. However, you can call get Slice on an individual revisioned sub-object of Policy Period if necessary.\n\nBe sure that the slice date that you pass to get Slice is in the effective date range for that object. If you try to pass a date outside the required range, then Gosu throws an exception.\n\nFor example, if you removed an auto from an auto policy before the slice date, Gosu throws an exception because that auto is not effective at that date However, if you call get Slice on the Policy Period and navigate down the object graph for that slice, you do not need to worry about unavailable effective dates for sub-objects. This is why it is typically best to call get Slice on the Policy Period and navigate down the object graph from there.",
      "notes": "Slice mode API: get SIice (slice Date)\nIf you get properties on a slice mode object to access other objects, those objects are also automatically in slice mode. In typical code, you can navigate up or down the object graph hierarchy without worrying about the revisioning details. At any time you can get the object. Slice Date property to get the slice date.\n\nIn most cases, it is best to call get Slice on the root Policy Period and navigate down the object graph from there. However, you can call get Slice on an individual revisioned sub-object of Policy Period if necessary.\n\nBe sure that the slice date that you pass to get Slice is in the effective date range for that object. If you try to pass a date outside the required range, then Gosu throws an exception.\n\nFor example, if you removed an auto from an auto policy before the slice date, Gosu throws an exception because that auto is not effective at that date However, if you call get Slice on the Policy Period and navigate down the object graph for that slice, you do not need to worry about unavailable effective dates for sub-objects. This is why it is typically best to call get Slice on the Policy Period and navigate down the object graph from there.",
      "narration": "",
      "ocrText": "i Slice mode API: getSlice(sliceDate)\n\n• Access a slice from a PolicyPeriod\n\n* Syntax: slicedPolicyPeriod = aBranch.getSlice(sliceDate)\n+ Return value is in slice mode\n« Returns sliced PolicyPeriod\n* Displays view of PolicyPeriod as of slice date",
      "ocrWordCount": 37,
      "ocrConfidence": 86.03,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 25,
      "title": "Example:",
      "bodyParagraphs": [],
      "originalNotes": "Example: get SIice using Gosu Tester and verified using date selector in the UI\nTo access the latest Policy Period use the Latest Period property on the find Job By Job Number method. That way you can be sure that you are accessing the latest bound Policy Period. Avoid using other methods such as the find query on a policy number which could return multiple Policy Periods and may not always return the latest bound Policy Period. The sliced policy version can also be seen in the user interface by entering a date in the date selector.",
      "notes": "Example: get SIice using Gosu Tester and verified using date selector in the UI\nTo access the latest Policy Period use the Latest Period property on the find Job By Job Number method. That way you can be sure that you are accessing the latest bound Policy Period. Avoid using other methods such as the find query on a policy number which could return multiple Policy Periods and may not always return the latest bound Policy Period. The sliced policy version can also be seen in the user interface by entering a date in the date selector.",
      "narration": "",
      "ocrText": "Example: getSlice using Gosu Tester and verified using date Gi\nselector in the Ul\n\n®)Gosu Scratchpad\n\n>& ¥ 8\nuses java.text.SimpleDateFormat\nvar branch = Job. finder. findJobByJobNumber (\"47586734721\") .LatestPeriod\nvar dateFormat = new SimpleDateFormat (\"M/dd/yyyy\")\n\nvar i=;\n\nfor (v in sliceView.PersonalAutoLine.Vehicles) {\nprint (\"Vehicle \"+i +\"\n\n\" + v.DisplayName)\n\n[eppolicy File @> Personal auto Ray Newton )\n. Debug \"= server\nVehicles G | Debugger] Eel console =\nVehicle Details Vehicle 1: 2001 Acura RSX in California\nWehicle 2: 2002 Toyota Avalon in California\nVehicle # Vehicle Type Modelvear |/aake =” Model > | Body Type\n\n2 Passenger/Light Truck 2002 Toyota Avalon\n\nVehicle Details | Additional interest\n\nBasic Vehicle Information\n\nfehicle = 1",
      "ocrWordCount": 113,
      "ocrConfidence": 75.97,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 26,
      "title": "",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "",
      "ocrWordCount": 0,
      "ocrConfidence": 95.0,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 27,
      "title": "i Window mode API: VersionList",
      "bodyParagraphs": [],
      "originalNotes": "Window mode API: Version List\nIn window mode, you can use version list to view policy objects across all effective time. If you have a version list, you can get various information about the object. For example, get all versions of the object, or navigate up or down the hierarchy to other entity instances or version lists.",
      "notes": "Window mode API: Version List\nIn window mode, you can use version list to view policy objects across all effective time. If you have a version list, you can get various information about the object. For example, get all versions of the object, or navigate up or down the hierarchy to other entity instances or version lists.",
      "narration": "",
      "ocrText": "i Window mode API: VersionList Gi\n\n• Version list represents all versions of an object in a policy period across effective\ntime\n« Use any object’s VersionList property to get a version list\n* versionList.AllVersions property gets all versions of this object\n* Sorted on effective date for each version\n\n* versionList.AsOf(date) method gets the one version of this object on that date, or\nnull if none were effective on that date",
      "ocrWordCount": 72,
      "ocrConfidence": 90.97,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 28,
      "title": "i Version list examples",
      "bodyParagraphs": [],
      "originalNotes": "Version list examples\nSimilarly, to get the set of all drivers who were ever drivers of this car during this period, use the following Gosu code: var drivers = vehicleVL. Drivers\n\nSample code to check all versions of all cars in a policy period across effective time: var branch = Job.finder.findJobByJobNumber(“ stPeriod for(aVehicleVersionList in branch. PersonalAutoLine. Version List. Vehicles) {\n for(aVehicle in\n aVehicleVersionList.AWersions) {\n print(\"${aVehicle. Make}\n${aVehicle. ModeI}\n${aVehicle. Color}\n${aVehicle. EffectiveDate)\n${aVehicle. ExpirationDate}\n }\n}\n\na) Submission Actions: Add Car#l — Blue. Test results: 1) Blue car\nb) Change#l Actions: Change color of Car#l — Red; and Add Car#2 — Yellow Test results: 1) Blue car, 2) Red car (same fixed id as the blue car); 3) Yellow car\nc) Change#2 Actions: Change color of Car#l – White Test results: 1) Blue car, 2) Red car (same fixed id as the blue car); 3)Yellow car; 4)White car (same fixed id as the blue car)",
      "notes": "Version list examples\nSimilarly, to get the set of all drivers who were ever drivers of this car during this period, use the following Gosu code: var drivers = vehicleVL. Drivers\n\nSample code to check all versions of all cars in a policy period across effective time: var branch = Job.finder.findJobByJobNumber(“ stPeriod for(aVehicleVersionList in branch. PersonalAutoLine. Version List. Vehicles) {\n for(aVehicle in\n aVehicleVersionList.AWersions) {\n print(\"${aVehicle. Make}\n${aVehicle. ModeI}\n${aVehicle. Color}\n${aVehicle. EffectiveDate)\n${aVehicle. ExpirationDate}\n }\n}\n\na) Submission Actions: Add Car#l — Blue. Test results: 1) Blue car\nb) Change#l Actions: Change color of Car#l — Red; and Add Car#2 — Yellow Test results: 1) Blue car, 2) Red car (same fixed id as the blue car); 3) Yellow car\nc) Change#2 Actions: Change color of Car#l – White Test results: 1) Blue car, 2) Red car (same fixed id as the blue car); 3)Yellow car; 4)White car (same fixed id as the blue car)",
      "narration": "",
      "ocrText": "i Version list examples Gi\n\n• Get all versions of a particular car in a policy period across effective time :\n* var val = vehicleVL.AllVersions\n\n+ Ifthe car was added and then removed in a subsequent change transaction (as discussed previously),\nthe car would still be listed\n\n+ It existed on the policy period at some point\n* Get the car version that is effective on ‘date’\n* var vehOnDate = vehicleVL.AsOf(date)\n« Returns\n+ Single car object in window mode\n\n+ Null if no version of the car is effective at that date",
      "ocrWordCount": 95,
      "ocrConfidence": 88.83,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 29,
      "title": "i VersionList examples:",
      "bodyParagraphs": [],
      "originalNotes": "VersionList examples: Get vehicles on a policy\nflatMap(collection) - Maps each element of the Collection to a Collection of values and then flattens them into a single List.",
      "notes": "VersionList examples: Get vehicles on a policy\nflatMap(collection) - Maps each element of the Collection to a Collection of values and then flattens them into a single List.",
      "narration": "",
      "ocrText": "i VersionList examples: Get vehicles on a policy\n\n• All versions of all vehicles that ever existed on the Policy\nGosu Source\n\nvar branch = Job. finder. findJobByJobNumber (“206921”). LatestPeriod\nbranch. PersonalautoLine.VersionList.Vehicles.flatMap(A vl + vl.AllVersions).each(A v > print(v))\n\nRuntime Output\n\n• All vehicles as of specific date\nGosu Source\n\nvar branch = Job. finder. findJobByJobNumber (“206921” ). LatestPeriod\nbranch. PersonalAutoLine. VersionList. VehiclesAs0f (\"2012-06-02\").each(A v + print(v))\n\nRuntime Output",
      "ocrWordCount": 68,
      "ocrConfidence": 84.14,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 30,
      "title": "VersionList examples:",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "VersionList examples: Get costs on a policy\n\nAll costs on a personal auto policy\n\nGosu Source\n\nvar branch = Job. finder. findJobByJobNumber (“206921”). LatestPeriod\nbranch. PersonalautoLine.VersionList. PACosts.flatMap(A cl > cl.AllVersions).each(A c + print(c})\n\nRuntime Output\n\nurban in Calif\n\nJ in California\n\nin California\n\nburban in •\n\n• All costs on a vehicle at a specific date\nGosu Source\n\nvar branch = Job. finder. findJobByJobNumber (“206921” ). LatestPeriod\nbranch. PersonalAutoLine. VersionList. PACostsAs0f (\"2012-04-02\").each({ Ac > print(c))",
      "ocrWordCount": 75,
      "ocrConfidence": 82.83,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "content"
    },
    {
      "slideNumber": 31,
      "title": "Question",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question G\nWhat are EffDated entities?\n•\n•\nSS oe ee oe oe oo",
      "ocrWordCount": 17,
      "ocrConfidence": 56.53,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "What are EffDated entities?",
        "answer": "EffDated entities are created to track the state of an entity over effective time.\nThey have an effective date and an expiration date."
      }
    },
    {
      "slideNumber": 32,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer Gi\nWhat are EffDated entities?\n•\n•\nEffDated entities are created to track the state of an entity over effective time.\nThey have an effective date and an expiration date.\nSS Se ee eee eo",
      "ocrWordCount": 39,
      "ocrConfidence": 78.9,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 33,
      "title": "Question",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Question G\nWhat is the difference between effective time and model time?\n•\n•\nSS oe ee oe oe oo",
      "ocrWordCount": 23,
      "ocrConfidence": 64.04,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "question",
      "questionData": {
        "question": "What is the difference between effective time and model time?",
        "answer": "Model time is the actual real-world time when policies are created or jobs are bound.\nEffective time is the time dimension of the policy itself within the policy period."
      }
    },
    {
      "slideNumber": 34,
      "title": "Answer",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Answer Gi\nWhat is the difference between effective time and model time?\n•\nModel time is the actual real-world time when policies are created or jobs are bound.\nEffective time is the time dimension of the policy itself within the policy period.\nSS Se ee eee eo",
      "ocrWordCount": 51,
      "ocrConfidence": 79.55,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "answer"
    },
    {
      "slideNumber": 35,
      "title": "Key Takeaways",
      "bodyParagraphs": [],
      "originalNotes": "",
      "notes": "",
      "narration": "",
      "ocrText": "Lesson\nobjectives • Describe policy revisioning and EffDated\nreview entities\n\n« Describe window mode and slice mode\n« Access a policy in window and slice mode\nusing Gosu",
      "ocrWordCount": 28,
      "ocrConfidence": 86.82,
      "hasTable": false,
      "hasChart": false,
      "hasImage": true,
      "tableData": null,
      "mediaReferences": [],
      "slideType": "objectives_review"
    }
  ],
  "videos": [
    {
      "index": 1,
      "filename": "PP_05_01.mp4",
      "path": "/academy/guidewire/videos/ch08/PP_05_01.mp4"
    },
    {
      "index": 2,
      "filename": "PP_05_02.mp4",
      "path": "/academy/guidewire/videos/ch08/PP_05_02.mp4"
    }
  ],
  "hasNotes": true,
  "hasTables": false,
  "hasImages": true,
  "ocrMetadata": {
    "totalWords": 1856,
    "avgConfidence": 86.66,
    "extractedAt": "2026-02-13T12:22:27.352380"
  }
}
