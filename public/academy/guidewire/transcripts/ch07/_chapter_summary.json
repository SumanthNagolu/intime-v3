{
  "chapter": "ch07",
  "chapter_title": "InsuranceSuite Developer Fundamentals",
  "domain": "developer core skills",
  "video_count": 29,
  "total_duration_seconds": 11202.7,
  "total_duration_formatted": "03:06:42.700",
  "total_words": 26197,
  "avg_confidence": 0.9355,
  "videos": [
    {
      "filename": "IS_Fund_01_01.mp4",
      "stem": "IS_Fund_01_01",
      "duration": "00:02:44.040",
      "words": 416,
      "confidence": 0.9404
    },
    {
      "filename": "IS_Fund_01_02.mp4",
      "stem": "IS_Fund_01_02",
      "duration": "00:02:53.920",
      "words": 429,
      "confidence": 0.9579
    },
    {
      "filename": "IS_Fund_02_01.mp4",
      "stem": "IS_Fund_02_01",
      "duration": "00:07:08.460",
      "words": 1167,
      "confidence": 0.9597
    },
    {
      "filename": "IS_Fund_03_01.mp4",
      "stem": "IS_Fund_03_01",
      "duration": "00:03:55.220",
      "words": 531,
      "confidence": 0.961
    },
    {
      "filename": "IS_Fund_03_02.mkv",
      "stem": "IS_Fund_03_02",
      "duration": "00:01:35.540",
      "words": 240,
      "confidence": 0.9077
    },
    {
      "filename": "IS_Fund_03_03.mp4",
      "stem": "IS_Fund_03_03",
      "duration": "00:09:10.000",
      "words": 989,
      "confidence": 0.909
    },
    {
      "filename": "IS_Fund_04.mp4",
      "stem": "IS_Fund_04",
      "duration": "00:04:29.420",
      "words": 859,
      "confidence": 0.9506
    },
    {
      "filename": "IS_Fund_05_01.mp4",
      "stem": "IS_Fund_05_01",
      "duration": "00:02:21.240",
      "words": 410,
      "confidence": 0.9407
    },
    {
      "filename": "IS_Fund_05_02.mp4",
      "stem": "IS_Fund_05_02",
      "duration": "00:12:53.900",
      "words": 1505,
      "confidence": 0.9305
    },
    {
      "filename": "IS_Fund_05_03.mp4",
      "stem": "IS_Fund_05_03",
      "duration": "00:01:16.180",
      "words": 286,
      "confidence": 0.8893
    },
    {
      "filename": "IS_Fund_06_01.mp4",
      "stem": "IS_Fund_06_01",
      "duration": "00:01:40.360",
      "words": 403,
      "confidence": 0.9219
    },
    {
      "filename": "IS_Fund_06_02.mp4",
      "stem": "IS_Fund_06_02",
      "duration": "00:08:12.960",
      "words": 1169,
      "confidence": 0.9299
    },
    {
      "filename": "IS_Fund_06_03.mp4",
      "stem": "IS_Fund_06_03",
      "duration": "00:01:44.920",
      "words": 336,
      "confidence": 0.9442
    },
    {
      "filename": "IS_Fund_07.mp4",
      "stem": "IS_Fund_07",
      "duration": "00:05:49.300",
      "words": 855,
      "confidence": 0.9341
    },
    {
      "filename": "IS_Fund_08.mp4",
      "stem": "IS_Fund_08",
      "duration": "00:03:44.300",
      "words": 587,
      "confidence": 0.9338
    },
    {
      "filename": "IS_Fund_09.mp4",
      "stem": "IS_Fund_09",
      "duration": "00:08:24.160",
      "words": 1149,
      "confidence": 0.9395
    },
    {
      "filename": "IS_Fund_10.mp4",
      "stem": "IS_Fund_10",
      "duration": "00:13:23.120",
      "words": 1707,
      "confidence": 0.9368
    },
    {
      "filename": "IS_Fund_11.mp4",
      "stem": "IS_Fund_11",
      "duration": "00:07:49.480",
      "words": 1208,
      "confidence": 0.953
    },
    {
      "filename": "IS_Fund_12.mp4",
      "stem": "IS_Fund_12",
      "duration": "00:11:39.240",
      "words": 1634,
      "confidence": 0.9222
    },
    {
      "filename": "IS_Fund_13.mp4",
      "stem": "IS_Fund_13",
      "duration": "00:08:27.360",
      "words": 1469,
      "confidence": 0.9454
    },
    {
      "filename": "IS_Fund_14.mp4",
      "stem": "IS_Fund_14",
      "duration": "00:07:23.660",
      "words": 1127,
      "confidence": 0.9123
    },
    {
      "filename": "IS_Fund_15.mp4",
      "stem": "IS_Fund_15",
      "duration": "00:10:19.080",
      "words": 1459,
      "confidence": 0.9429
    },
    {
      "filename": "IS_Fund_16.mp4",
      "stem": "IS_Fund_16",
      "duration": "00:11:22.340",
      "words": 1288,
      "confidence": 0.9477
    },
    {
      "filename": "IS_Fund_18.mp4",
      "stem": "IS_Fund_18",
      "duration": "00:07:30.980",
      "words": 898,
      "confidence": 0.9115
    },
    {
      "filename": "IS_Fund_19.mp4",
      "stem": "IS_Fund_19",
      "duration": "00:07:05.680",
      "words": 1055,
      "confidence": 0.9382
    },
    {
      "filename": "IS_Fund_20.mp4",
      "stem": "IS_Fund_20",
      "duration": "00:04:16.980",
      "words": 509,
      "confidence": 0.9169
    },
    {
      "filename": "IS_Fund_21.mp4",
      "stem": "IS_Fund_21",
      "duration": "00:09:07.880",
      "words": 1049,
      "confidence": 0.9234
    },
    {
      "filename": "IS_Fund_22.mp4",
      "stem": "IS_Fund_22",
      "duration": "00:05:32.080",
      "words": 870,
      "confidence": 0.9496
    },
    {
      "filename": "Is_Fund_17 .mp4",
      "stem": "Is_Fund_17",
      "duration": "00:04:40.900",
      "words": 593,
      "confidence": 0.9438
    }
  ],
  "full_text": "--- IS_Fund_01_01 ---\nAll Guidewire applications are typically installed to a c colon backslash guidewire directory. However, the education installers use c colon backslash gwxx to avoid conflict with development installations. We will use the GWB command to execute different Gradle tasks. The GWB command with the tasks parameter allows us to view a list of all the task parameters the GWB command allows. Press Return. The Run Server command lets us start the Guidewire application server. Conversely, the Stop Server command lets us end the server process. The GWB Studio command starts Guidewire Studio, where we configure Guidewire applications. The GWB Gen Data Dictionary and GWB Gosu doc commands generate documentation that we can use to help understand the current configuration of the application. Notice here the different Gradle task sections and Gradle tasks most frequently used in the application. The used by developers, Run Server, Stop Server, Studio, and Gen Data Dictionary. Now let's take a look at Guidewire Studio. Studio has several important components. The menus and toolbars let you carry out various commands. The navigation bar helps navigate through the project and open files for editing. It also shows the physical location of the file on the file system. Entity names and localizations help to control what appears on the screen when the application is viewed in different languages. Extensions and metadata contain the data model the application uses to store and manipulate data. The page configuration files define how the application appears on the user's screen. Plugins are one way the application can interface with other applications. GOSA rule sets allow you to control the application's behavior in a fairly straightforward manner. Field validators provide country-specific formats for things like phone numbers and postal codes. The GSRC node contains programmatic files written in the GOSA language. The editor is where you create and modify the code. The properties editor is where you edit the properties of various objects. In development mode, the database will automatically be upgraded during server startup, incorporating any changes that have been made. The run and debug buttons will always execute the selected configuration. Click the debug button. Seeing insurance suite application ready in the log indicates that the server has been successfully started. Which application that shows started will change according to which insurance suite application you are using for configuration. Even though it says Contact Manager, here in this example, we are using Training App, which is based on Contact Manager. This is the end of this demonstration. \n\n--- IS_Fund_01_02 ---\nIn your browser, navigate to TrainingApp by entering the URL. Press Return. Enter Applegate for the username. Alice is a basic end user, so she doesn't have access to all the functionality available to the super user. For example, she has no access to the Administration tab. Click the Andy Applegate login. Enter GW for the password. Click the login button. Create a new doctor contact. Select Doctor from the Actions menu. There are different contact types that could be created here. Note that TrainingApp needs to store slightly different information about a contact based on the contact type. For example, TrainingApp needs to store the law license of an attorney or the medical specialty of a doctor. Click Update to save the contact and return to the Search tab. If you search for contacts whose name begins with A, you will see that Dr. Appleby has been added to the database. Click Search. Select the doctor that was created. The sidebar on the left side lists the screens you can view in the current tab bar selection in this case, Contact. There can be tabs within a screen, as here on the Summary screen, where we have Basics, Social Media, and Analysis. The latter two we will configure during training. Click Details. On the Details screen, we have basic information about the contact. Note that some of this information is specific to a doctor. We also have tabs for phone and addresses, bank accounts and vendor info. These last two we will configure during training. Click Addresses. Addresses show all the addresses listed for the contact. Click Notes. The Notes screen displays notes associated with the contact. There are no notes associated with this doctor yet. But we can add them using the Actions menu. The note is created in this workspace. We won't go through with creating the note right now. Click History. The history screen shows various things that have happened in the application, with regards to the contact. In this case, there are two entries, its creation, and my viewing the contact right now. Now we will switch to Studio. You can stop the server in three ways after starting it in Studio. The first way is to click the stop button. The second way is to select stop from the run menu. The third is to select the exit button to exit from Studio. You will generally want to stop the server when you exit Studio, because it becomes difficult to stop it once Studio is closed. This is the end of the demonstration.\n\n--- IS_Fund_02_01 ---\nWe are going to use the GWB Gradle command to generate the data dictionary. In Windows Explorer, Shift plus right click on c colon backslash g dot w. 10 backslash training app. Select open command window here from the context menu. A command window opens. You can also use the xcompile flag to tell Gradle not to rebuild the project before generating the dictionary, which cuts the time by about 75 to 80%. The data dictionary does not come pre-generated, so you should generate it immediately after installing any guidewire insurance suite application. You should also regenerate it anytime developers extend the data model. This validates the changes and refreshes the HTML pages of the data dictionary. When the process is complete, it shows the build successful message. Now we'll open the data dictionary. In Windows Explorer, navigate to c colon backslash gw10 backslash training app backslash build backslash dictionary backslash data and double click index dot HTML to open it. Notice that there are three entity views, plus a type lists view and an all fields view. The full data entities view shows both persistent and virtual entities. Virtual entities are not stored in the database but generated as needed. It includes, for each entity, the columns, type keys, arrays, associated for and keys, and subtypes. The database view shows only persistent entities that can be loaded from external sources. It includes the columns, type keys, and subtypes. The data base and migration views are for special purposes. Let's concentrate on the basic data entities view. Let's look at AB contact, the core entity of training app. The header of an entity contains the name of the entity and the name of the database table. It also lists implemented delegates. Delegates are special entities that cannot be instantiated. They are used to define fields and behaviors needed by multiple entities. The header also contains an expandable description of the entity and lists attributes of the entity. Attributes determine some of the behaviors of the entity. To find out what an attribute is, you can see. The object attribute means, click the question mark by its name. For example, the abstract attribute means that the entity cannot be instantiated directly, but only through one of its subtypes. There is an expandable list of foreign keys in the application that point to this entity. For example, the bank account and address entities have foreign keys pointing to AB contact. If an entity has subtypes, there is a subtype list next. The list identifies all the child subtypes of this entity. Their position in the hierarchy is indicated by indenting. The hierarchy builds down from the root. For example, AB law firm is a subtype of AB company vendor, which is a subtype of AB company, which is a subtype of AB contact. Now let's look at the heart of the data entity, its fields. The example we'll look at here is create time, which is a field of type date time. As the description shows, it stores a timestamp of the date and time when the object was created. We also see that it has the non-null attribute, which means that this is a required field. Attempting to save an AB contact without this field populated will result in an error. Fortunately, it is automatically populated when the object is created. Finally, there is an expandable list of places in the user interface where the field is displayed. Create user has some more interesting features. It is a foreign key, which means that it contains a pointer to some other object in the database, in this case, the user, user, who created the AB contact. Also, the database column, create user ID dash is displayed. Note, create time did not require a database column, because creation time is a standard property of all database tables in guide wire applications. Most fields have their names displayed in green. Some, like financial summary, are displayed in blue. This means that they are part of an extension to the entity. For core entities, this means that they can be modified or removed as long as this can be done without causing data problems. Vendor type is a special kind of field called a type key. This means that it refers to a defined list of values and points to one specific value in this list. In this case, it refers to a list of possible types of vendors, such as auto glass shops, doctors, attorneys, and so on. Primary phone value is a derived property, meaning that it is not stored on the database at all, but calculated at runtime. In this case, it looks at the primary phone type type key to determine which of the AB contacts, possibly several, phone numbers as the primary phone number, then returns the phone number of that type as a string. After the fields, the data dictionary shows the arrays associated with an entity. An array is used when more than one of another entity may be associated with this entity. A single AB contact may have many bank accounts, which are stored in the bank account entity. The array includes a link to the other entity, thus, the bank accounts array includes a link to the bank account entity. If an entity has subtypes, each subtype may have fields and arrays unique to that subtype. For example, AB attorney has fields that indicate the attorney's license number and legal specialty. Now let's look at type lists. I can click home to return to the main page of the data dictionary, and then click type lists to navigate to the type lists page. As mentioned, a type list is essentially a list of values that can be referenced by objects. Let's look at activity category. The activity category type list is used by activities to determine what kind of given activity is, for example, an approval activity or a warning. This is used by activity patterns, which store the code value, enabling them to retrieve the name or description for display. Activities can be final. Activity status has the final attribute, meaning that its existing values cannot be changed or deleted. It can, however, be extended, adding new values to the type list. Click home, then all fields. The all fields page is literally that, an alphabetic list of every field declared in the application. Below each field name is a list of the entities that field is declared on. This is useful when you are looking for a field, and you don't know which entity it is declared on. Note that not every instance of a given field name refers to the same value, or even the same value type. For example, the author of a document is not the same as the author of a note. The author of a note is a foreign key to a user, while the author of a document is a string, varchar, storing a name.\n\n--- IS_Fund_03_01 ---\nAn insurance company wants to implement a social media functionality to provide a more personalized experience to customers. Every customer has the option to accept or decline this service. If no response is received from the customer, the default value is false, declined. If they accept the service, then the insurance company will store additional information about each customer. This information also needs to be displayed in the UI, and training app users have to be able to update it easily as needed. This folder contains two types of read-only files, ETI files, which contain base application entity definitions, and EIX files, which contain internal entity extensions. Look for example, at address.eti. This is the definition of address that is used in all Guidewire Insurance Suite applications. But if you look at address.ia, you see that it has many more properties, including fields, than the .eti file. This is because it implements functionality specific to training gap. As mentioned, these files are read-only and cannot be modified by customers. Customer modifications exist in this folder. This folder contains editable files of two types. 1. ETI files, which contain custom entity definitions. 2. ETX files, which contain custom entity extensions. For example, AB Attorney is an entity unique to training app. It extends the AB person vendor entity with information exclusive to attorneys, like an attorney license number and a legal specialty. AB Contact has an ETX file, containing fields which are defined on the base application configuration, but which can be modified by the customer. You can tell the base fields, which are editable, because the ones that are not are grayed out, while the editable custom fields are in black. If the customer wants to extend AB Contact, they should use the existing abcontact.etx. You can't create a new ETX file, because one already exists. You must work within the existing ETX file. The easy way to find and navigate to a configuration file is by typing Ctrl plus Shift plus N. When the dialog appears, begin typing AB Contact. Note that we get a filtered list of a lot of files, which gets more focused as I type. When I finish typing AB Contact, I have not only the files related to the entity, but files related to things like AB Contact address. Notice that here in the base definition of the entity, there is a field called Tax ID. Let's return to abcontact.etx. However, in the custom extensions file, we have a column override of Tax ID, which allows us to change or add to the specifications of the field. In this case, we have added a column parameter, called Encryption, which allows TrainingApp to encrypt the Tax ID file for additional customer security. What does the application do with an entity definition? The application processes the definition and generates a Java class when the code generators run and upgrade the physical database when the application is started. This is the class generated for AB Contact. The properties defined in the entity files are present here, along with a variety of methods. As shown here, some of the properties from the ETIEIXETX files are present in the class.\n\n--- IS_Fund_03_02 ---\nOpen ABContact.it and begin adding the necessary columns, starting with enrolled in social media. Here, you can add a column, or many other elements, by clicking this drop-down menu. You can also add, duplicate, or remove custom elements by right-clicking an element. You cannot duplicate or remove base elements, but you can override them or copy them. If you want to view only the custom elements, you can use this filter. you can also add, duplicate, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or delete, or collapse all the nested elements. With this button, you can navigate easily to all of an entity's sub and super types.\n\n--- IS_Fund_03_03 ---\nAbcontact.etx is already open. So I will begin adding the necessary columns, starting with enrolled in Social Media. From the extension drop-down, select Column. The column's name property is in title case, with the first letter of each word capitalized. It cannot contain spaces or any other characters other than letters and numbers. Also, the column's name property is in title case, with the first letter of each word capitalized. It cannot contain spaces or any other characters other than letters and numbers. So, we'll add the underscore ext suffix. For the name property, enter enrolled in Social Media underscore ext. The type property tells the database what kind of data to store. In this case we want a simple true slash false value, so I will select the bit data type. For the type property, start typing B and select bit. This is a required field, so I will select false for the null ok property, to say that the field is not allowed to be null. Start typing F and select false. This creates a potential problem. What about records already in the database? They don't have any values for this field, but it's required. To avoid this clash, I assign a default value of false to the default property. Start typing F and select false. Next, we'll add the column for the contact's friendbook account. From the extension drop-down, select column param. We'll call it simply friendbook underscore ext. For the name property, enter friendbook underscore ext. The type of this is a string variable, which uses data type varchar. For the type property, select varchar. And this is not a required column. Start typing true. For the null ok property, select true. Varchar columns need to have their size defined. This is done in a column parameter, or column param, sub element. This parameter is required for all varchar columns. From the extension drop-down, select column param. A column parameter defines some special detail of the column, based on the column's type. It consists of a name value pair which places some restriction on the column. There are a number of possible parameters you can add to a varchar column. In this case, we are interested in the size parameter. For the name property, show the possible parameter types, then select size. 100 characters should be enough for a friendbook address. For the value parameter, enter 100. The next column contains the user's average social media activity over the past month. From the extension drop-down, select column. For the name property, enter average activity underscore ext. This is a number, and it might not be a round integer, so we'll use the decimal type. Start typing d. For the type property, select decimal. Start typing t. Start typing t. For the null ok property, select true. This is because it might not have a value if the user doesn't use social media. Decimal is the other type, besides varchar, that has required column parameters. It has two required parameters. Precision is the total number of digits the number can have, both before and after the decimal place. In this case, we want a maximum of four digits. From the extension drop-down, select column parum. Start typing p. For the name property, select precision. For the value property, enter 4. Scale is the number of digits after the decimal place. We only want one digit after the decimal place. We only want one digit after the decimal place. We only want one digit after the decimal place. With precision 4 and scale 1, the possible values of this column will range from 0.0 to 999.9. From the extension drop-down, select column parum. Start typing s. For the name property, select scale. For the value property, enter 1. Last Social Activity. Last Social Activity column will tell the user when the contact last used their social media accounts. From the extension drop-down, select column. For the name property, enter Last Social Activity underscore ext. This column will hold both the date and time of the activity. Start typing d. For the type property, select date time. And, again, there may be no activity, so the column is not required. For the null ok property, select true. Finally, we'll add the column for the contacts chirp account. This will be effectively identical to the friendbook column, of our char with 100 characters. So we'll simply copy the column. Right-click the friendbook underscore ext column and select duplicate. A duplicate of the column was added. Change the value of the name property to chirp underscore ext. All the properties, and even the column parameter, have been copied with it, so we only have to change the name. Now I'm done editing, so I want to check my work. I'll validate the changes by clicking the validate button. This opens the CodeGen window, where any errors will be displayed. The CodeGen window shows no errors. If we had been working on several objects in studio, ewe could validate them all by using the file save all function, or simply type in control plus s. Let's show what happens when an error is introduced. Remove the column parameter for the chirp underscore ext column. With the column parameter removed, click the validate button. Since we introduced an error, when we click the validate button, an error appears in the CodeGen window. Let's fix the error by adding the column parameter back in. Start typing s. Now, looking at the abcontact java class. We can see the columns we added are now present. Switch to Windows Explorer. Open a command window at c colon backslash gw10 backslash training app. Type gwbgen data dictionary dash x compile. Type gwbgen data dictionary dash x compile. Type file colon slash slash slash c colon slash g dot w. 10 slash training app slash build slash dictionary slash data slash columns dot html. Type gwbgen dataogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogyogy                            \n\n--- IS_Fund_04 ---\nAfter reviewing the base UI layout, an insurance company wants to implement a few minor changes on the Details screen's Person Info tab. The details are shown here. In this demo, we are going to open an existing PCF, change the order of the widgets, and add a new input divider. Log in to training app as Alice Applegate. Use the username AApplegate and password GW. We'll navigate to a contact, William Andy. Click Search. In the Company slash Last Name field, enter Andy. Drill down on the William Andy entry in the search results. We need to look at the Details screen. Click Details. We can see a list of everything on the page by typing Alt plus Shift plus W, for widgets. Navigate to the new tab that opens. Expand the page structure entry. This is the widget inspector. It shows all the PCFs and their internal widgets referenced in the active application browser window, except for any workspace area. It also displays all the variables used to display this browser page. Close the tab. By typing Alt plus Shift plus I, for info, I can see a more focused view of the general file structure. This allows me to easily see how the PCF is put together. These combinations only work if the application has internal tools enabled, a simple flag in the configuration file that enables these and many other developer tools. If I want to edit the screen I'm looking at, I can type Alt plus Shift plus E, for edit. This key combination opens the main PCF for the screen in Studio. Here we can see that the widgets are color coded. Widgets shown in gray are defined directly in this PCF. Widgets shown in light blue are defined in a PCF reference by this PCF. Widgets shown in darker blue are referenced indirectly, through another PCF. For example, this main light area is a detail view with lots of widgets in it. But this darker area for license info is actually referenced by the detail view. This shows a hierarchical view of the main files constituting the screen. The page location is the main element and contains the screen. The screen is the top level container. It groups all the other containers. In this case, it contains a card view. Note, you can click on the individual cards in the card view and see the different containers it groups. The card view is a secondary container that groups primary containers, in this case, detail views. We can see some of these containers, but not all of them, in the structure tab. The reason we cannot see them all is because some of them are referenced by other containers. The detail view on the person info card is the one we need. We can open the detail view simply by double clicking it. The screen is the one we need. According to the wireframe, the date of birth widget needs to be below the marital status widget. We can move it by clicking and holding it and dragging it into place. Studio makes it easier to know where I'm putting the widget by showing these green lines. These are places where I can drop the widget into place. The lighter green line is where it will be placed if I release the mouse button. We also need a horizontal line between tax filing status and gender. These lines are called dividers. We can search for them in the toolbox. There are four divider types. Start a search for divider widgets by typing div into the text box. The one we want is the input divider. Click it, and the cursor changes, as before the green lines appear. Put the divider between tax filing status and gender. Place the mouse over the location where we want the divider, and left click. Save your changes by going to the file menu and clicking save all. Alternatively, you can use Ctrl plus S with your keyboard. Return to training app and we can load the changes to the PCFs using one more key combination, Alt plus Shift plus L, for load. If we return to the details screen, the changes can be seen in the user interface, as expected. Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy \n\n--- IS_Fund_05_01 ---\nAn insurance company wants to implement a social media functionality to provide a more personalized experience to customers. Every customer has the option to accept or decline the service. If no response is received from the customer, the default value is false, declined. If they accept the service, then the insurance company will store additional information about each customer. This information also needs to be displayed in the UI, and training app users have to be able to update it easily as needed. See the wireframe for the user. For more information, recall that we have already implemented the required data model changes in a previous demonstration on extending the data model. Now we are going to make the necessary user interface changes to display the new fields. First let's analyze the current PCF configuration to better understand how to implement this. One of the best ways to start implementing a requirement like this is to go to the browser and identify the HTML page that we need to change. Log into training app as aapplegate slash GW. Navigate to the William Andy contact. Click on the Social Media tab. The easiest way to navigate to this screen in Studio is to use Alt plus Shift plus E on your keyboard. We need to get to the definition of the Social Media tab. The easiest way to navigate to it is to double click the Social Media tab on the page definition. This is a card view that contains a detail view and an input column. Remember that we can add atomic widgets only to primary containers. We will talk more about input columns in the next lesson. For now all you need to know is that the input component is the main component of the detail view and it will contain all the atomic widgets. Let's look at the XML definition. Click the Text tab near the button of the screen. After clicking the Text tab, we can see that this is an XML file. Looking at line 4, we can see that this is a SchemaWare file. Specifically, it uses a schema called PCF.XSD. It also supports dot notation as shown in line 17. The Text tab offers a very schema where AutoComplete function. At the end of line 17, if I type a less than sign anywhere, Studio offers a list of elements that might reasonably go here. Type a backspace to remove the less than character.\n\n--- IS_Fund_05_02 ---\nNow we will create atomic widgets, bind some of those widgets to data model fields, so they can display data, and define user-friendly labels. First, let's delete the placeholder label. Right-click the label and select Delete. We'll add the widget to the input column. In the toolbox, search for Label. We'll add the widget to the input column. In the toolbox, click Label and drop it into the input column. The label doesn't have any required properties, but it is a good idea to configure the label property so it can display static text in the UI. We will have two labels that will display the same text. So, instead of hard-coding the same text twice, we will use display keys. This will improve the application's maintainability, because if the text needs to be changed, we only need to update it in one place. Reusability is just one benefit of display keys. Another is that they aid in the international language. The label is also known for the original authorization and localization of the application. Guidewire recommends that PCFs should not contain hard coded text. So, let's define a display key for the label. The recommended naming convention for customer display keys is to use a standard prefix such as ext. In the label property, enter displayKey.getX.lastSocialActivity. By placing the cursor in the red text and hitting Alt plus Return, or depending on your keyboard, Alt plus Enter, we can create the display key. Select Create Display Key. The application suggests text for all languages. Right now, we are concerned with English, so we will correct it. Correct the base, English, entry to read last social activity was at, 0. The syntax with the curly braces is used to define dynamic values and input parameters in the display key. Click OK. Now we see that Studio underlines the display key because we defined a parameter for it. To fix this, we need to pass in a second argument to the get function. This second argument should be the value of the last social activity underscore X field we defined in the database. Let's add the second argument to display the value for the database. Before the right parenthesis in the label field, add a nab contact dot last social activity underscore X. The field has to be referenced relative to the root object of the PCF. The root object is an input parameter that the container receives from its parent. It typically comes from the database and contains the information the container needs to display data. You can see the root object at the top of the PCF by hovering over it. To modify the value of a display key, hold down the control key and click on it. You will be presented with a list of the languages for which the display key is available. Control click the X dot last social activity display key and select English, the first item in the list. This is the display dot properties file, where you can modify any of the many labels in an insurance suite application. Reminder, how can you best deploy these UI changes without restarting the server? Use control plus S to save and alt plus shift plus L in the browser to reload PCFs and display keys. Close the file. To match the layout in the wireframe, we'll add two horizontal lines. In the toolbox, search for input div and drag two input dividers beneath the label. We'll duplicate the label. Right-click the label and select Duplicate. Click Duplicate. Select the bottom label. Place the duplicate label below the two input dividers. Let's add the other fields. We'll add friendbook URL first. For that, we should use a text input widget. In the toolbox, search for a text input by typing text. Select the widget and place it between the two input dividers. The ID is a unique identifier of the widget in the current PCF. It cannot contain spaces or special characters. In the ID field, enter friendbook. The value specifies the data to be displayed. This is typically bound to the root object using the .operator. In the value property, enter an abcontact.friendbook underscore ext using the autocomplete functionality. The editable property is a Boolean expression, whose true slash false value specifies whether the widget value can be changed or not. Note that by Boolean expression we mean any GOSU expression that evaluates to true or false, including the hard-coded values true and false. In the editable property, type or select true. The label property is the user-friendly text that appears before the widget value. Use a display key to specify it. In the label property, enter display key.get x.friendbook. Use the auto-complete functionality to assist you. Finish the statement by typing, x.friendbook. Use the Alt plus Enter key combination to set the display key's value to friendbook URL. Click Create display key. Set the display key's value to friendbook URL. Click OK. If we scroll down we can see that the ValueType property is automatically set to java.lang.string. The ValueType property specifies the data type of the value. The text input widget is used for displaying a number of data types. So depending on the data type you use, you will have to specify the associated GOSU data type in the ValueType property. We can save some time by duplicating the friendbook widget and changing the copy to be the chirp widget. Right-click the friendbook widget. Click Duplicate. Set the ID property to chirp. Set the value property to anabcontact.chirp underscore extension. Change the display key from x.friendbook to x.chirp. Use the Alt plus Enter key combo to set its value to chirp URL. Change the value to chirp URL. Click OK. The required property defaults to false. It is separate from the null OK property on the entity and is relevant to the PCF, not the entity. If null lock is false or required is true, you cannot update an object where the field is null. The effect of this is that, using the PCF, you can require users to enter a value for a field that is not required in the entity. This can be useful sometimes. The correct widget type for the enrolled in social media field is a Boolean radio button. Search for that widget type. Insert the radio button between the first input divider and the friendbook widget. Set the ID property to enrolled in social media. Enter anabcontact.enrolledinsocialmedia underscore ext for the value property. For the label field, type display key dot get and set the value of the display key using Alt plus Enter. Use the autocomplete functionality. Edit the value to be enrolled in social media. Click OK. The value type property should be set to java.lang.boolean. Now let's set up the average social activity field. We'll use a text input widget for this dot in the toolbox search box, type text. Place a text input widget below the chirp widget. Select the newly placed widget. Set the ID property to average social activity. In the label property, enter display key dot get ext underscore average social activity. Use Alt plus Enter to set the display key value. Edit the English value to be average social activity, post slash month. Click OK. Enter anabcontact.averageactivity underscore ext for the value. Notice the value shows an error. It's underlined in red. Let's correct it dot scroll down to the value type. There is a type mismatch between the widget, java.lang.string, and the field, java.math.big decimal. Change the value of value type to java.math.big decimal. Finally, let's set up the last social activity field dot search for a date input widget by typing dat. Place a date input widget below the average social activity widget. Select the newly placed date input widget. In the ID property, enter last social activity. For the value of field, enter anabcontact dot last social activity underscore extension. In the label field, enter display key dot get ext dot last social activity label. Use alt plus enter to set the display key value to last social activity. Set the display key value to last social activity. Click OK. The date format and time format field set the display format for date and time, respectively. Set the date format field to medium. Set the time format to short. Scroll down to the value type. Notice the value type is java.util.date. Ensure all the fields we created are set to editable as true. The editable property should be set to true for all of the widgets between the input dividers. Check each widget and set the editable property to true as necessary. Run the server and log in to training app as obligate slash GW. Locate the William Andy contact. Click the Social Media tab. Click Edit. Enter some test data. Click Update. Click Update. Notice the change in value in the label that indicates when the last social activity occurred. Click Update. Click Update.             Click Update.   Click Update. Click Update.                                                     \n\n--- IS_Fund_05_03 ---\nThe business analysts have sent an email with the following inquiry. We have noticed in the widget reference table that the checkbox input widget can be used to display bit-slash-boolean fields. The insurance company wants to see how the social media screen looks with a checkbox instead of radio buttons for the enrolled in social media field. We've just put some effort into creating this widget, and we don't want to go through it all again unnecessarily. Fortunately, Studio provides a functionality called Change Element Type. In A-B context, we have a function called Change Element Type. Select the Checkbox. Widget-specific configuration will be lost, but the common properties like ID, Value, Required, and so on, will be retained in the new configuration. Click OK. Save the configuration with Control plus S and switch to Training App. Reload the PCFs by using Alt plus Shift plus L. Navigate the PCFs by using Alt plus Shift plus L. Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PCFs for Filad the PC Thank you.\n\n--- IS_Fund_06_01 ---\nRecall the shortcut to open a PCF in Studio from the browser is to use Alt plus Shift plus E. The shading colors, light blue, dark blue, gray, of the containers mean in a PCF have various meanings. Light blue is a reference container defined in another PCF. Dark blue is an indirectly referenced container, that is, a reference container from a reference container. Gray is a container directly defined in this PCF. Shown here are the main elements in the hierarchy. The location is a page. The page is everything you see on the canvas. The top level container is a screen, shown here. There is no secondary container in this design. A secondary container is a container that contains other containers, such as the card view we have already seen and the list detail view we will see in the essentials course. The primary container is a detail view. A primary container is a container which can contain atomic widgets directly. The input column is one of those container widgets. The input column contains several widgets, for example a label widget as shown here. The detail view here is an inline detail view widget. Double click on the detail view. When you click the detail view on the canvas, notice how most of its properties are blank. Switch back to abcontact summary page.pcf. Double click on the social media tab. Looking at the social media tab from the details page, it has all the widgets we need. Filogy of the Filogy of the Filogy of the Filogy of the Filogy of the Filogy of the Filogy of the Filogy of the Filogy of the Filogy of the Filogy of the Filogy of the Filogy of the Filogy of the Filogy of the Filogy of the Filogy of the Filogy of the Filogy of the Filogy of the Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of                            \n\n--- IS_Fund_06_02 ---\nIn this demonstration, we are going to a. Create a reusable DetailView. b. Move the widgets from the Social Media Card to the DetailView. c. Define a root object for the DetailView. d. Reference the new DetailView from both the Social Media Screen and the Social Media Card. e. Add a Toolbar and Edit Buttons. In Studio, the PCFs are located in configuration.config.page.config.pcf. In Studio, navigate to Configuration.config.page.config.pcf. This node contains both PCF folders and PCFs. The folders contain PCFs and, often, more folders. PCF folders organize PCFs into logical groups. Consider organizing your PCFs based on business use case, functional area, or something similar. A PCF folder is not a namespace. This means that no two PCFs can have the same name, even if they are in separate folders. Let's create a PCF for the work we'll do in this course. Right-click on the PCF node. Select New. Select PCF Folder. Enter the name's Exceed Demo and click OK. Note that the folder name cannot contain spaces or special characters. Now we'll create the PCF. Right-click on the Succeed Demo node. Select New. Select PCF File. It is a good practice to select the PCF type first. This will be a DetailView. Be careful to select the right PCF type. It is impossible to change it, so the only thing you can do if you select the wrong type is to delete it and recreate the file. Select the file from scratch. In the file type list, select DetailView. Notice that the dialog automatically creates the DV suffix. These suffixes are required by training app. We will call the file Social Media. In the file name text box, enter Social Media. We do not need the Mode field here. It is a more advanced topic. Click OK. An error message in the CodeGen window appears. The DetailView appears in red. This is because a DetailView must contain at least one child object, either an input column or a table layout. We will move the input column from the Card View to this DetailView. Navigate to the AB Contact Summary QF Social Media card. Use CTRL plus N to locate that PCF. Click the Social Media tab. Click the Social Media tab. There is no ability to select multiple widgets at one time. So we will move the whole input column as one. Right-click on the input column. Click Cut. Switch to the Social Media tab. Switch to the Social Media tab. Right-click in the canvas, and select Paste. Why are the widgets red? Because they reference the in AB Contact Root object, which does not exist on this DetailView. What is the root object? The root object is an input parameter that the container receives from its parent. It typically comes from the database, and contains the information the container needs to display. The root object is displayed at the top of the PCF. Note that there is no root object displayed on this DetailView. There are two Variables tabs. The Variables tab allows you to define local variables in the PCF to store temporary values. For example, you might store the return value of a complex GOSA function call because the value will be needed multiple times in the PCF. That way the app doesn't have to process the GOSA multiple times. The Required Variables tab allows you to define input parameters, or root objects, for the PCF. The parent PCF, which will reference the file, will have to pass in arguments that are instances of the required variable type. Click the Required Variables tab. Let's define the root object for OutDetailView. Click the green plus sign to add a new required variable. The best practice is to name the variable by its type, preceded with an A or N prefix, such as an AB Contact, an address, a bank account, and so on. For the name property, enter an AB Contact. The type, of course, is AB Contact. For the type property, enter AB Contact. This will get the red out of the detail view. Since we added the required variable information, the widgets are no longer red. Next, we'll reference this detail view from the original social media card. Return to the AB Contact Summary social media card. We'll begin by deleting the inline detail view. Click the inline detail view. Press the delete key. We can't put the reference directly in the card. There is no property for that, so we will use a PanelRef widget. A PanelRef can reference and display detail views, list views, card views, and several other objects. In the tool box, search for PanelRef. Select the PanelRef widget and place it on the card. Select the default. An error appears as we are missing some required property values. To reference the detail view, we use the Def property of the PanelRef. The Def property does two things. First, it names, references, the PCF to display. In the Def property of the PanelRef, start typing SocialM and select SocialMediaAdVarg1.abContact. Select an AB Contact. Note that the detail view is currently red. This is because it needs its required variable, which is the second thing the Def property does. Select an AB Contact. Now we'll do the same thing on the Social Media page. Navigate to abcontactsocialmediapage.pcf. You can use Ctrl plus N to locate the file. Start typing abcontactsoci to locate the abcontactsocialmediapage.pcf. Navigate to abcontactsocialmediapage.pcf. We'll delete the inline PanelRef. Right-click the detail view and select Delete. We'll drag a PanelRef into the screen. In the tool box, search for PanelRef and then drag it onto the screen. We'll configure the PanelRef to reference the detail view. In the Def property, enter SocialMediaDB and AB Contact. We'll check our work at this point by saving it. Type Ctrl plus S to save your work. Now we'll switch to Training App. Click the Social Media tab. The Social Media card looks right. In the sidebar, select Social Media. There's only one thing missing, ability to edit the page. To do this, we'll have to add Edit buttons. Switch back to Studio. Edit buttons affect the whole location, no matter where they are placed. For example, if you have several detail views and PanelRefs on one screen, and you put Edit buttons on one of them, clicking Edit will put the whole screen in Edit mode. So we will put the Edit buttons on the screen, not the PanelRef. In the tool box, search for Edit buttons. Drag the Edit buttons to the top of the screen, above the PanelRef. Notice that the buttons appear inside a Toolbar widget. A Toolbar is a container specialized to contain controls like Edit buttons. Save your work using Ctrl plus S and return to Training App. Reload the alterations to the PCF using Alt plus Shift plus L. In the sidebar, select Social Media. Click the Edit button. When you click the Edit button, you can see the Update and Cancel buttons we added.\n\n--- IS_Fund_06_03 ---\nThe business analysts have made a last-minute request. They want the social media data to appear in two columns. We'll make the change in the DetailView. In Studio, we'll open SocialMediaav.PCF. We'll add a new Input Column. In the Toolbox, search for Input Column. Click or drag the Input Column onto the canvas to the right of the existing Input Column. We'll put the two URL objects onto the right-hand column. Click and drag the FriendBook URL widget to the new Input Column. Drag the Chirp URL widget to the new Input Column below it. This looks a little odd, because the widgets are higher on the right than on the left. We'll add a label. Right-click the label at the top of the left-hand input column. Select Copy. Paste the copy at the top of the right-hand input column. We'll also add a divider. Right-click one of the dividers in the left-hand input column. Select Copy. Right-click to paste. Select Paste. Paste the copy between the label and the FriendBook URL widget. It looks pretty good now. Now we will look at it in the application. Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy Thank you.\n\n--- IS_Fund_07 ---\nIn the base configuration, a contact can have a training app user assigned to them. This user is responsible for maintaining the contact's information and resolving any flag entries raised during the lifetime of the contact. The user appears on the Contact Summary screen as shown here. The insurance company's business analysts want to make the assigned user field on this screen navigable, so that when a user with the appropriate permissions, such as SuperUser or the administrator, logs in and clicks on the user name, it can be obtained from the user to make the user field. The system opens a pop-up, and the super user or admin can easily see the user details and, if necessary, make changes. During the initial analysis, the business analyst determined that the pop-up already exists, and is named user detail pop-up.pcf. In this demonstration we are not going to worry about permission control, because it is already implemented on the pop-up. The only thing we have to do is write the code to open the pop-up. We'll begin by looking at the destination PCF in studio. In studio, search, control plus shift plus N, for user detail pop-up.pcf. Start typing user detail pop. Select user detail pop.pcf. This is a pop-up location, containing a single reference screen as the top-level container. The screen contains all the additional PCF elements and widgets. Click the pop-up to select it. Locations are fundamentally different from containers. The purpose of a container is to group displayable UI elements and display them. The purpose of a location is to define navigation. Click the Entry Points tab. Locations don't have required variables to define input parameters. Instead, they have entry points, technically, the signature of the location. The entry point defines the input parameters the location needs. Every location must have at least one entry point. However, a location can have more than one entry point depending on how it is used. For example, suppose a pop-up can be used to either modify or create an account. The layout is the same in both cases. The only difference is that data already exists in the first case, but not in the second case. You can use the same pop-up by defining two entry points. One with a parameter that references the account to be displayed, and one with no parameter, which tells the pop-up to create and initialize the account. In the left-hand panel of the Entry Points Editor, select User Detail Pop-up User User. Next, we have to locate the source widget, the widget that will navigate to this pop-up. We know from past experience that we need the A-B Contact Summary Page. Search, Ctrl-Shift-N, for A-B Contact Summary Page.pcf. Type a B Contact Summary Page. Double-click A-B Contact Summary Page.pcf. Looking at this, we see that the Assigned User widget is shaded dark blue, so I double-click it, opening A-B Contact Summary.pcf. Double-click Assigned User. The widget is a range input. Looking at its advanced properties, we see the action property. This property can be set to a GOSA statement. If it is set, the atomic widget becomes clickable. Clicking on it executes the GOSA statement. The basic code for navigation is pretty simple. You enter the name of the entry point, a method, and any parameters the entry point requires. In this case, the location entry point is User Detail Pop-up. Click the action field to select it. There are three methods available. Go navigates to the location, replacing the current contents of the frame. Go in Workspace opens the location in the workspace frame, at the bottom of the screen. Push opens the location in the current frame, but retains the current location so that it can be returned to. Since this is a pop-up location, we will use the push method to navigate. In the action property, type User Detail Pop-up.push. Finally we need a parameter. The entry point for User Detail Pop-up requires a user, but the only variable defined on AB Contact Summary is a NAB Contact. Fortunately, we know that this very field, Assigned User, displays a user. So we can copy the value property and plug it into the method. Select the contents of the value star property, right-click, and select Copy. Place the cursor between the parentheses of the push method, right-click, and select Paste. Now we'll deploy the changes by saving. Type Control plus S and then switch to Training App. First, reload the PCFs. We'll log in as Super User so we have access to the pop-up. Log in as SU slash GW. Navigate to the WilliamAndy Contact. Click Update. There is no value in the Assigned User widget, so we let it in Assign 1. Click Edit. In the Assigned User dropdown, select Alice Sabblegate. Click Update. Click Alice Sabblegate. When we click on the name, the user summary appears. We could edit it. Click Return to Summary. What if there is no assigned user? Click Edit. In the Assigned User drop-down, select None. Click Update. The application displays nothing in the field, so there is nothing to click on.\n\n--- IS_Fund_08 ---\nBefore beginning the demo, make sure the server is running in debug mode. Click Run. Click Debug. Once the debug server is running, not shown, open Gosu Scratchpad. Click Tools. Click Gosu Scratchpad. We'll paste some comments into Gosu Scratchpad so we can explain the code we'll add to the Scratchpad. Note, to save time throughout this demonstration, instead of typing the code, we'll paste in the code that normally would be typed out. We'll paste in our code for requirement number 1. There are 6 requirements listed in the comments. Also, the QueryUtil functionality has been imported, using a uses statement, to make the coding easier. The first requirement is simple enough. It asks us to define 3 variables. Contacted of type strings. Input, its initial value will be AB, which is William Endy's ID. An AB Person of type AB Person, to store loaded contact data. Minimum Driver Age of type Int, to store the minimum age for a driver's license. Initial value will be 16. To set the value of contacted, we are to use the QueryUtil functionality. Finally, we've printed out the last name of the person contact. Now we'll paste in our code for requirement number 2. In the second requirement, we are to ascertain whether the AB person selected in the first requirement has an age specified. If they do not, we print a warning message. If birth date is specified, and the AB person is old enough to drive, we ascertain whether they have a driver's license number specified. If they do not, we print a message to contact them and ask if they have that information. Let's paste in our code for the third set of requirements. The third requirement asks us to print out a statement telling whether the AB person is or is not an attorney. If they are an attorney, we also are to ascertain whether their attorney license is specified and, if not, to print a warning. We'll paste in our code for the third set of requirements. We'll paste in the code that fulfills the fourth set of requirements. The fourth requirement is very simple. It asks us to print the number of notes associated with this AB person. Now the code for requirements number 5. The fifth requirement asks us to print a numbered list of all the notes associated with the AB contact in a specified format. Finally, the code for the sixth set of requirements. We'll paste in the code used in the for loop implementation first. The final requirement asks that, if at least one of the AB person's notes is associated with a customer problem, a warning message should be printed out. In addition, it asks us to do it using two different forms of syntax. The first is a for loop. Finally, the code for the block implementation. The second version is to use a block. If necessary, bring the debug window in the console into view. Now let's see what happens when we run the code. Click the Run and Debug Process button. Note, as stated at the beginning of this demonstration, you should make sure the server is running in debug mode first. Otherwise, the Run and Debug Process button may be unavailable. We see the output of our print statements from the code we developed previously and can see that the code is working as expected to fulfill the requirements. So, the run of theountounts of theountounts of theountounts of theountounts of theountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountount Thank you.\n\n--- IS_Fund_09 ---\nThe business analysts have determined that every new doctor contact with one or more flag entries should be assigned to the creator, the logged-in user, for further processing. In addition, a note explaining that the contact has been automatically assigned should be associated with the contact. Before beginning this demo, we'll create two display keys, 1, x.contact assigned equals contact automatically assigned 2, x.new contact with flag entries auto assigned equals new contact. The new contact has been automatically assigned to 0, because it has 1, flag entries. Expand the config folder. Expand localizations. Expand resource bundle display. Double-click display.properties. After the x.chirp display key, press return. We'll paste in the code for the new display keys. The code for the new display keys appears. There are already two places in the UI to create a contact in training app, and, since the application is fully configurable, additional contact creation methods could be introduced in the future. For example, contact information could be imported from an external system via an integration point. So, what's the best strategy to implement this requirement? Remember that GOSA rules will be executed when an event happens to an entity. The great thing about GOSA rules is that, is that they don't care what the source of an event is, whether it's from the UI or an integration point. As long as an event happens, we can be sure that the same set of rules will be executed, regardless of the source. That is why a Goza rule is the perfect tool to implement this requirement. A rule set is a collection of rules that have the same root entity type. Rules are organized into hierarchies. Also recall a rule set category is a collection of rule sets that have two things in common. High-level business purpose, triggering event in our business case. The triggering event is the creating of the contact, saving it to the database for the first time. What is the business purpose in our business use case? To set the assigned user field, and end a contact note, technically, last-minute changes before committing the transaction. The rule set category we should use then is pre-update. Expand rule sets. Expand pre-update. As you can see there are four rule sets available in the pre-update rule set category. The type of entity that is triggering is A-B contact, so we'll create a new A-B contact pre-update rule. Double-click A-B contact pre-update to open it. As you can see from the first few rules, the insurance company uses the naming convention for rules. Since we are going to make a rule for new doctor contacts, we'll expand the first pre-update for A-B contact to see the rules within it. Right-click on the A-B contact rule. We'll create a new rule that is triggered when a new doctor contact is created. Click new rule. In the rule name field, we'll give it a unique name using the company's naming convention. We'll use AB for the application name abbreviation, PU for the rule set category abbreviation, and 5000 for the unique rule four-digit code. We'll then add a dash and a user-friendly description of the rule's purpose. Enter the following for the name of the rule, AB for 5000, automatic assignment of new flagged contacts. Click OK. However, if you need to move the rule to a different position, you can simply drag and drop it. We'll return the rule to its original position. The rule has two sections to configure, the condition, and the action. The condition is set to true initially. It has to be a GoSue expression that returns either true or false. The action will only be executed if the condition returns true, otherwise, nothing happens. Click true and change the value. Based on the business requirement, the condition is that the contact must be new, and it must have at least one flag entry. We can use the new property of the entity to test if the contact is new. Every entity has this property, which is only true if the entity is being created in the current transaction. It will be false in case of any subsequent modifications. Type AB contact.new. Press Return. Flag entries is a data model array on the contact, defined in the abcontact.age file. Recall that arrays have a length property that we can use to test how many entities are in the array. Type. And. A bcontact.flag entries.length. equals 0. In the action section, we have to complete two different things. 1. Set the current user as the assigned user of the contact to. Create a new node and associate it with the contact. Recall from the introduction to locations lesson that the contact has the assigned user field. We can use the get current user function to get the currently logged in user. Type. App contract.assign user equals user.util.get current user. Recall from the introduction to Goza lesson that we can create new objects using the new keyword, and then use the dot notation to initialize its fields. I will paste the next section of code in now. Now that we've created the note, we have to associate that with the contact. How would you add a new entity to a data model array? Every parent object has two functions to work with arrays, add to array name entity and remove from array name entity. Press Return to add code to a new line. Type a bcontact.add to contact notes note. Type a new command. We see here the completed Goza rule. You can deploy modified rules using run, reload changed classes. But this is a new rule, so we have to restart the server. Restart the server in debug mode. Click run. Click debug server. We see the server ready message. Login to training app as a apple gate slash gw. Click login. Click actions. Under new person, vendor, click doctor. Enter a first name. Enter a last name. Enter a social security number. Click update. Click update. Now we'll view the contact we just created. Click search. Search for the last name of the contact we created. Click search. Click the name of the contact we created. We see that it is indeed assigned to the user of the system. In this case, we logged in as Alice AppleGate. Let's look at the notes. In the sidebar, click notes. We see there was a note created. Click the subject of the note. We can see the values in the note are set according to the new rule we created. Notice that we didn't do any database transaction management in the rules code. Rules have an implicit transaction that will be committed after the execution of the rules. Keep in mind that if your rule throws an exception, then all the changes done by the other rules will be rolled back too.\n\n--- IS_Fund_10 ---\nWe have just received two new user stories from the business analysts of an insurance company. Both user stories deal with persons and their subtypes only. User Story number 1. For each person, if the age is known, we want to see how many years the person has remaining until retirement. The value should be calculated from the age, and be displayed as a read-only field in the UI, under the date of birth field on the person info card. If the person's age is not known, display unknown. User Story number 2. We also need a toolbar button on the person info card with the label, Suggest Insight Score. This button should be available only if the location is in edit mode, and the contact score field is null. When the user clicks the button, the following logic should execute. 1. If the Employment Info section is filled out completely, the score should be set to 10. 2. If the Employment Info and License Info sections are both filled out completely, the score should be set to 20. 3. Otherwise, nothing happens. First, we will create a new enhancement with a getter property and a function. Then, we will make the necessary user interface configurations. In Studio, the AB Person entity already has an enhancement called AB Person Enhancement in the Training App package. Navigate to Configuration, GSRC, Training App, Entity. Double-click to open AB Person Enhancement.gsx. We could modify the existing enhancement, or create a new one. For the sake of simplicity, the implementation team has decided to create a new insurance company-specific package. We will therefore create a new enhancement, and store it in that package. Recall that a package is a logical group of classes. It is also commonly referred to as a namespace. Right-click on the GSRC package. Click New. Click Package. Remember, all GOSA resources are created under the GSRC node in Studio. GSRC stands for GOSA Source. The recommended naming convention is to use .notation and specify the company name, the app code, and two further specifications delineating the functional area of the package. Enter succeed.ta.enhancements.entity for the name of the package. Click OK. Now we'll create the new enhancement. Right-click the new package. Click New. Click GOSU Enhancement. We search for the entity to enhance using the Search by Name tab. Start typing AB to find AB Person. Select AB Person. We'll give it a name beginning with the entity name and ending with the word enhancement, with a word or two of description between. In the name field, enter AB Person succeed enhancement. Click OK. We are going to create the Years Until Retirement as a virtual property using a getter. Getters have the following syntax requirements. The property Get keyword, the name in Pascal case, no parameters allowed, a return type, may not be void, a getter can have one, and only one, return statement for convenience, will have it return a string value. Inside the enhancement body type, property Get Years Until Retirement string. The easiest way to do this is to return a variable called result. We'll set it to unknown as the default in case the age is not known. Type var result equals unknown. The this keyword refers to the current object, and is used to access other physical and virtual members of the same entity. We'll use an if statement to change the value of result only if the value of this.age is known. Type if this.age. Looking at the source for this.age, you can see that it is a virtual property that returns either a string containing the age of the contact, or unknown. That's why we set the base value of result to unknown. We'll proceed if the user's age is instead known by using logic equivalent to if the age is not unknown. Type does not equal unknown. In the case of the age being known, we will then set the value of result to the difference between retirement age, which will rather arbitrarily set at 65, and their current age. And finally, we'll return the value of result. Type return result. The other requirement is to suggest an insight score. It needs to set a value, but doesn't need to return any value, so we'll implement it as a function. Functions have the following syntax requirements. The function keyword, the name in Pascal case, can have 0, 1, or many parameters declared. A return type, may be void. Type, functions suggest insight score, void. Once again, we can use the this keyword to find the values of properties of the current object. The employment info section has two fields, occupation and employer. If these are both filled in, we want to set score to 10. Type, if, this dot occupation. Equals null and this dot employer. Equals null. This dot score equals 10. Likewise, if the license section is completed, we want to raise the score to 20, but only if the employment section is also completed. We could use a separate if statement, but it is more efficient to nest it in the first if statement, so it will only be evaluated if the first condition is true. The license section has two fields, license number and license state. Type, if this dot license number. Equals null and this dot license state. Equals null. This dot score equals 20. The enhancement is now complete, and displays no syntax errors, so we'll save the work. Press control plus s. Because this is a new package, we can't just reload classes, we have to restart the server. Click run. If the server is running, click stop server, if available. Click run. Click debug server. Now, we'll take a look at the screen we need to modify to hold this information. Log into training app as aapplegate slash gw. Navigate to the details screen of the William Andy contact record. Type Andy for the last name. Click search. Click William Andy. Navigate to the details screen. The best way to open this page in studio is to press Alt plus Shift plus E. Recall that we wanted to put the years until retirement display immediately below the date of birth field. The date of birth field is in a light blue section. Double click it to open the appropriate detail view. Now we'll configure the years until retirement field. From the toolbox, search for the text input widget. Select the text input widget. Insert the text input widget below the date of birth input widget. In the ID star property, enter years until retirement. Note that the root variable of this detail view is an AB contact, but the years until retirement enhancement is on AB person. To use it in the value property, we have to cast an AB contact as AB person, but no special syntax is needed for the property get. We'll just use the usual dot notation to reference it. In the value property, enter. An AB contact is AB person. Years until retirement. I need a label for this field. I'll create a display key using Alt plus Enter. In the label property, enter, display key dot get X dot years until retirement. Place the cursor somewhere in years until retirement and press Alt plus Enter. Click Create display key. Add spaces to the text for readability. Enter years until retirement. Click OK. Notice that we cannot make this widget editable, because it is a virtual property. If we tried to make it editable, we would get a runtime error. The editable property here is, or should be, set to false. Now we'll create a toolbar button to access the Suggest Insight score function. It has to be on the page, not the detail view because the toolbar we need to use exists on the panel ref on the page, not in the detail view. We'll use the toolbar button widget. Navigate to AB person details page dot PCF. From the toolbox, select a toolbar button widget and insert it in the empty toolbar in the panel ref, not the toolbar at the top of the screen. The action of the toolbar button we added is to use the function we defined on the AB person enhancement. Again, we have to cast to AB person. In the action property, enter, an AB contact is AB person. Suggest Insight score. Of course, an ID is required. In the ID property, enter Suggest Insight score. For the label, define a display key called Suggest Insight score. Change the default value to Suggest Insight score. Click OK. Reload the PCFs, and then in the sidebar, select Details. The years until retirement is there, but empty, because the age is not set. The Suggest Insight score button is present, but the Insight score field is zero. If we click the Suggest Insight score button, it remains zero, because the employment and license fields are not fully filled out. Click the Suggest Insight score button. The Insight score remains zero, because the employment and license fields are not fully filled out. Let's edit William Andy and fix this. Click Edit. We'll set William Andy's birthday. In the date of birth field, enter a date about 55 years ago. Scroll the year to 1964. Select 1964. Select Today. Note that the years until retirement field now has a value. We'll give him a job. He's already got Albertsons as his employer. In the occupation field, enter Manager. If we click Suggest Insight score now, the Insight score field changes to 10, or a number close to 10, depending on the Birth Year entered. Click Update. If I click Suggest Insight score now, the Insight score field will change to 10, or a number close to 10, depending on the Birth Year entered. Click Suggest Insight score. The Insight Score field changes to 10, or a number close to 10, depending on the birth year entered. Now we'll add license information. Click Edit. Enter a plausible license number. Select a state. Click Update. The Insight Score is still 10, but if we click Suggest Insight Score we should see a changed value. Click Suggest Insight Score. The Insight Score changes to 20.\n\n--- IS_Fund_11 ---\nWe have just received the following bug report from the testers. On the addresses screen, if I click the delete secondary addresses button, the application removes all the addresses, not only the secondary addresses, but the primary one also. Please fix ASAP. Hi first, we are going to reproduce the issue. Then, we will debug the code to identify the bug. Finally, we will implement and deploy the fix. To reproduce the issue, after logging into training app as Alice Applegate, navigate to a contact with multiple addresses. We'll navigate to the William Andy contact record. From the sidebar, select addresses. Note that one address, home, is selected as the primary address. Let's test the behavior. Click edit. Click delete secondary addresses. All addresses have been deleted. This is not the desired behavior. We'll cancel the deletion so we can continue to use this record for testing. Click cancel. Press ALT plus SHIFT plus E to navigate to the PCF in studio and investigate. The delete secondary addresses button is on a toolbar which is shaded blue. Why? The toolbar is in a referenced PCF. To open it we can double click the PCF in the canvas. Double click the delete secondary addresses button. The AB contact addresses. The AB contact addresses.ldv.pcf file opens with the focus on the delete secondary addresses toolbar button widget. The property we want to investigate is the action property. We can see that the button calls a method, delete AB contact secondary addresses. We can navigate to the function definition by control clicking it. Control plus left click the action property definition. We can see that this is a GOSU method of the PCF file itself, defined on its code tab. This is called a PCF method. GOSU functions are the same regardless of where you define them. However, the semantics are slightly different on a PCF method. The method is local to the PCF file that defines it. Not even referenced files can access it. It cannot be debugged at the place of definition. You have to open the generated PCF file name expressions.g's file after code generation, locate the method, and put a breakpoint there. It is called from a widget property such as action, value, available, editable, and so on. It has direct object to the root objects of the PCF file. The reason we would rewrite code on a PCF file as opposed to an enhancement or a GOSU class is because the logic the function implements is tied to one, or more, widget in that PCF file, and is not needed anywhere else. For example, determining the label for a button based on circumstances. Determining whether a text input widget is editable. Executing some initialization logic after navigating to a location. No special syntax is needed to call a PCF function, just the function name and its arguments. Notice that we can't set a breakpoint here in the PCF file. Click in the gutter beside the deleteABContactSecondaryAddresses function to test this. The function is not actually executed from the PCF file, but from a generated .gs code file. To find it we search for the file name, plus the word expressions. Search for and navigate to abcontactaddressesldvexpressions.gs using ctrl plus n. Type abcontactaddressesldve. Note that this is a read-only file. Nonetheless, we can set a breakpoint here. Scan down to find the deleted contact secondary addresses method, about line 69. Set a breakpoint on the remove address function. A breakpoint appears on the line we selected. Run the application server in debug mode and then click delete secondary addresses. The application turns a light color when the breakpoint is hit. Switch to Studio. The debug toolbar has buttons to perform the following actions. Among these, restart the debug process, resume execution, pause execution, stop the debug process, view breakpoints, mute breakpoints. The stepping toolbar has buttons to step over, into, and out of code. The frames pane shows a list of the threads of the application. You can export this to a text file, and customize frame presentation. For each thread, you can examine the stack frame, examine frames, navigate between frames, and automatically jump to a frame's source code in the editor. You can select a thread via the thread selector drop-down list at the top of the pane. The status and type of a thread are indicated by a special icon and a textual note beside the thread's name. The variables pane is shown here. This is the thread we're interested in, the one for the deleted contact secondary addresses function. In the variables pane, we can see the two variables relevant to the function, this and current address. Expand current address. With current address expanded, we can see all its properties. There are a couple of properties of interest, notably, display name and primary. To make them both easy to view we will add them to the watch list. Right click display name. Click add to watches. Right click primary. Click add to watches. Collapse current address. If it's not open, display the watch pane. In the watches pane, we can evaluate any number of variables or expressions, in the context of the current stack frame. These values are updated with each step through the application, and become visible every time the application is suspended by a break point. If an expression cannot be evaluated, it is displayed with a question mark. Note that the current address display name is 345 furlane, and primary is currently true. Click the resume program button. Notice the values change. This address is not primary. Clicking the resume program button again. Now it shows the third address, which is also not primary. Remember, there can only be one primary address. If we click resume program one more time, the program will continue, and the information in the panes vanishes. This is being because the values can only be shown when the application is suspended by a break point. PCF files support both incremental or bulk code generation. Incremental code generation is triggered on save, and during project make. The expressions.gs file cannot be modified. Let's return to the code tab in the PCF file. To fix this bug, we will put the remove address function into an if statement, so that it will execute only if primary is false. Return to the code. Return to the PCF file. Click the abcontactaddress.pcf tab. On the code tab, select the all code for the deleted contact secondary addresses function. Paste in the revised code over the old code. Switch back to the expressions.gs file. Click the break point to remove it. Press CTRL plus S to save changes. During save, we can watch studio generating the resources, though it takes less than a break point. Then, switch to training app. Let's test the revised code to see if we have fixed the bug. Use ALT plus SHIFT plus L to reload the changes to the PCF. Once the PCFs have been reloaded, click addresses. Click edit. Click delete secondary addresses. Notice the primary address has not been removed. Our bug has been fixed. Now we'll cancel, because we don't need to save the contact without the addresses. Click cancel. so\n\n--- IS_Fund_12 ---\nAn insurance company wants to display policy summaries for contacts. Policy details are stored in the policy administration system, and the integration developers are currently implementing the integration point to retrieve the policy summaries. As configuration developers, we need to configure the data model in the user interface to meet the requirements. We are going to create a new entity called policy underscore ext. Recall that Guidewire recommends using underscore ext or some other unique suffix in the name of new entity. This avoids issues during upgrades to the next version. The entity will have two data fields, policy number, which is a VARCH R10, and premium, which is a monetary amount. Monetary amount is a different type of field from a column, and allows us to store both the amount and the currency type. We will also set up two relationships. First, a policy can have exactly one location associated with it. This is a foreign key relationship. Second, a Navy contact can have zero to many policies associated with any policies associated with it. This is an array relationship. Next, let's implement these changes. The first step is to create the entity. Remember, base application entities are stored in the metadata entity folder, while custom entities are stored in the extensions entity folder. Click extensions. Click Entity. Right-click Entity. Click Entity from the new menu. This is the new entity pop-up. Type policy underscore ext. The Entity type field specifies the kind of entity that will be created. Click the Entity type field to see the options. It can be a top-level entity. It can be a top-level entity, a subtype, a delegate, and so on. We are creating an entity in this lesson, but we will create a subtype in a later lesson. The product documentation describes the other options. Click Entity. The description field documents any information that configuration developers need to know. This information will be displayed in the data dictionary. Type representation of a policy. The table field specifies the name of the database table, which will be created for the use of this entity. The table name is automatically generated to match the entity name, but is all lowercase. The length of the name cannot exceed 25. If the entity name is longer than 25, the table name can be modified to meet the length requirement, including removing the underscore ext suffix if necessary. Naming collision is avoided by the prefix that is added to the application abbreviation. For example, ABX is the prefix that will be added to the table name. The type field specifies how the application will manage the entity. Click the type field to view the options. Retirable means that the entity can be not only logically but also physically deleted. Versionable means that the application will keep the history of the entity. See the product documentation for more details. For this entity, we want to use Retirable, so click that option. The extendable checkbox is for internal usage only, and is not relevant for custom entities. It determines whether an ETX file can be created for this entity. Custom entities cannot be extended, so it doesn't matter whether this checkbox is checked or not. If the exportable checkbox is checked, then the entity supports entity serialization, which is required for the deprecated RCPE web services and the SOAP API. If the final checkbox is checked, you cannot subtype the entity. It defaults to true, but we will uncheck it so that we can subtype the policy underscore ext entity. Click the final checkbox to uncheck it. Click the OK button to create the entity. Now we'll define the policy number. Click the button. Select column. Click the name property. The name is policy number. Note that because this is on a custom entity, we don't need the underscore ext suffix for the individual fields. Type policy number. Click the type field. Type varchar. Select varchar. Should the policy number field be nullable? No. In fact, none of the entity fields should ever be null. We need to set the null OK property to false. Click the null OK property. Click the down arrow. Select false. Do we need default values for these fields? No, because this is a new entity, so there is no danger of an existing record lacking the required fields. What additional information do we need for the policy number? Because it's a varchar field, it needs a size column parameter. Right-click policy number. Select column parameter. Select column parameter. Click the name property. Click the down arrow. Select size. Click the value property. Type 10. Next, we'll define the premium field. This is a special data field that stores both the amount and the currency, called monetary amount. Click the button. Select monetary amount. The monetary amount has two required properties, a name, and the null OK property. Click the name property. Type premium. Click the null OK property. Click the down arrow. Select false. Select false. Finally, we'll add a foreign key for the location. Finally, we'll add a foreign key for the location. Recall from the diagram that this is the policy location. Click the button. Select foreign key. Click the name property. Type policy location. What entity should the foreign key point to? The answer is address. Click the property. Type add. Select address. And what should we select for the null OK property? The null OK property should be false. Click the property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property. Click the column name property property. Type Policy Location ID. Now we need an array for abcontact to policy underscore ext. Let's search for the abcontact entity. Press Ctrl plus Shift plus N. Type, abcontact. What type of entity is abcontact? How do we know? It is a base application entity, because it is represented by an ETI file in the metadata entity folder. How can we add fields to base application entities? By extending them in an ETX file. Select abcontact.etx. Let's define the array. Click the button. Select Array. Type policies underscore ext. It is an array of policies. Type policy. Select policy underscore ext. In the description property type, all policies belonging to the contact. Now we need to go back to the policy entity and add a foreign key. Click the policy underscore ext. Entity tab. Click the button. Select foreign key. Type, owner. Click the foreign key entity property. Type abcon. Select abcontact. Select false for the null property property. Type contact ID for the column name property. Now, we can return to the abcontact entity to set the array field property. Click the abcontact tab. Type, owner. Let's validate and save the changes in studio. Now, there is an error, pointing out that an exportable array cannot use a non-exportable entity. Since we have no need to make policy underscore ext exportable, let's make the needed change on the array. Click the exportable property. Click the down arrow. Select false. Click save. There are no errors. Let's look at the generated code. Press control plus shift plus n. Type policy. Double click policy. Type policy. Double click policy. We can see that all the fields we have defined are here, along with several fields automatically generated by the application. Now, look at abcontact. Press control plus shift plus n. Type abcontact. Select abcontact.java. This is the generated code for abcontact. Let's scroll down to line 124. There is a new property for the array. In addition, there is a method for adding a policy, method for getting a policy, and a method for removing a policy. Now that the data entities are complete, I'll start the server. This also provides a final check that everything I've created has proper syntax and so on. Click run. Click debug server. The server has started successfully. This completes this demo. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run. Click run \n\n--- IS_Fund_13 ---\nThe first thing to do is to create the list view in the PCF folder. Looking at the PCF folder, we have a subfolder called Training. Training contains a folder called ABContact. Here we have folders for each of the child entities of ABContact that appear in their own views. Let's create one for policies. Right-click ABContact. And select PCF folder. We'll call it policies underscore ext. Remember to use the underscore ext suffix. Type policies underscore ext. Click the OK button. Now, we'll put a new PCF file in it. Right-click the folder. Select PCF file. We want to create a list view. Select ListView. Type policy summaries underscore ext. Notice that studio automatically adds the LV suffix to the file name. Click OK. Note that there is an error, indicating that there must be an abstract row in the list view. We will fix that soon, but first we have an abstract row in the list view. We have to set the list view's root object. What is a root object, and what will be the root object for this view? The root object is an input parameter that the container receives from its parent. The root entity for a list view is typically the parent entity of the array being displayed, because it provides the functions needed to make the list view editable. So the root entity for this view will be the ABContact. Where do we identify the root object? Where do we identify the root object? As a required variable. We'll look at the list view's required variables now. Click the list view. Click the required variables tab. So we'll create a new required variable. Click the plus sign. Type in ABContact. Type in ABContact.  Now we'll add a row iterator to fix the error. Click the search PCF elements field. Type in ABContact. Now we'll add a row iterator to fix the error. Click the search PCF elements field. Type in ABContact. Select true. The element name is the object that will appear in each row of the iterator. Each cell will use this name to reference a field of the object in the current row. The naming convention is to prefix current to the name of the entity. In the element name property, enter current policy. The value property tells the row iterator what array to display. In this case, it's the policies underscore EXT array on ABContact. In the value property, enter in ABContact dot policies underscore EXT. Note that the value type field is automatically populated with the goes who type the array references. If necessary, we could cast this to a subtype. The row iterator widget is still displaying red. It needs a row child widget. Drag a row from the toolbox to the row iterator. Notice that the row has no required properties. Editable and visible are optional properties which control the editability and visibility of the cells. If the row is not editable, none of its cells will be editable. As mentioned, we want to be able to edit this view. Click the down arrow. Select true. Now we'll add a text cell to display the policy number. Type text in the toolbar search. Drag and drop a text cell. The text cell is an atomic widget, configured just like a text input. Remember that the current policy variable contains the object from the array, associated with a specific row in the iterator. Make the text cell editable. Click the down arrow. Select true. Set the ID property to policy number. Set the display key for the label property. Set the value property to current policy dot policy number. Now let's add the premium cell. Remember that premium is a monetary amount. Here's a warning. Make sure you drop the cell into the existing row. If you accidentally drop it elsewhere, studio will generate a second row with that single cell. This may result in unexpected and unwanted behavior. So be sure that the light green bar appears in the right place before you let go of the mouse key. In the toolbox, search for monetary amount cell. Type mon. Drag and drop one into the iterator to the right of the text cell. We set the currency property to US dollars. In the other applications, if multi-currency support is enabled, then this will typically be set dynamically. But TradingApp currently supports only US dollars. We'll make it editable. In the editable property, select true. In the ID property, enter premium. Set a display key for the label. And the value is, of course, the premium of the current policy. In the value property enter current policy dot premium. Incidentally, studio always sets the value type based on the widget and value. Notice that the value type property has been automatically set to monetary amount. Finally, we need the policy location. A user should be able to choose from the addresses associated with the contact. To do this, we'll use a range cell. In the toolbox, search for range cell. Drag one and drop it into the row iterator, to the right of the monetary amount cell. There is a special property associated with the range cell. We'll set the value to the policy's location. Enter current policy dot policy location. Note that the value type property is automatically set to entity dot address. The value range is a required field. We want the range to be the addresses associated with the account. There is an array on AB contact called all addresses, which points to these addresses, so we'll use it. In the value range property, enter an AB contact dot all addresses. I'll quickly complete the cell. Notice that the editable, ID, and label properties have been filled in. Now, let's save and validate the changes in Studio. Click the save button. Now, we have switched over to training app. We are on the William Andy contact record. This is the screen where we'll add our new policies list view. So, I'll open it in Studio by pressing Alt plus Shift plus E. Notice that Studio has automatically opened the AB contact summary page dot PCF file. The place we want to put it is on this card view. Double click the card view. I will add a panel ref to the card to hold the policies list view. Enter PIN into the toolbox search. Drag one and drop it below the existing panel ref. The one thing we have to set is the def property. Set the def property to policy summaries underscore ext, LV, with an AB contact parameter. Remember, every list view must have an associated toolbar below it, so that if the number of rows exceeds the page size, the buttons will automatically appear to support page navigation. In the toolbox search, type T. Drag one and drop it at the top of the panel ref. Now, let's switch to training app to check our work. Click the save button. Now we're back in training app, but the list view we added is not visible. To fix this we need to refresh the PCFs. Press Alt plus Shift plus L to reload the PCFs. Notice the message that the PCFs have been reloaded. Also, the policies list view we created is now visible. Of course, there's no data in here yet, and no way to add it. That will be the subject of the next lesson. This concludes the demonstration. Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil \n\n--- IS_Fund_14 ---\nWe know from the previous demo that the ListView we are interested in, is displayed on the AB Contact Summary Card View. Studio is showing this PCF file. Why does this ListView have a toolbar associated with it? Because of the automatic pagination functionality of the ListView. Now we will add the Iterator Buttons widget. Click the Search PCF field. Search for Iterator Buttons. Drag and drop it onto the toolbar associated with the ListView. Why do the Iterator Buttons? Why do the Iterator Buttons appear in red? Because a required property is not completed. In this case, the Iterator property. How do you know it is that property? Because of the message in the CodeGen window. Next, we need to open the properties for the Iterator Buttons. Click the Iterator Buttons. Click the Iterator Buttons. Click the Iterator property. Click the Smart Help button or you can press Ctrl plus space. Note that Smart Help doesn't suggest anything for the Iterator Button. The Row Iterator is encapsulated in the ListView. This is like a private property in a class. User Interface components outside the ListView will be able to access the Row Iterator only if the ListView exposes it. So let's look at the ListView. Double-click on the ListView. On the ListView, we see that there is an Exposes tab. Click the tab. So we will add an entry to it. Click the plus sign to add an Exposes entry. Select Expose Iterator. Click the Widget property. Click the Widget property. Press Ctrl plus space to activate Smart Help. It suggests Policy Summaries underscore EXTLV, so I'll select it. Note that the value type property. Now, return to the Iterator Buttons. Click the Iterator Buttons. Click the Iterator property. Press Ctrl plus space to view Smart Help. Smart Help now provides a suggestion. Select that option. We save to compile the changes. Return to the Iterator. Press Alt plus Shift plus L to reload PCF changes. Click the Edit button. Enter the Iterator.   Why don't the Iterator Buttons appear? Because we haven't configured their actions yet. What actions should we use? The Add To, and, Remove from properties, on the Policies underscore EXT array of AB contact. Where should they be configured? On the Row Iterator. Let's go to the ListView PCF to see how. Now we have returned to Studio. Click the tab for Policy Summaries underscore EXTLV. Click the Row Iterator. Click the Row Iterator. What variable stores the object associated with a given row? The current policy variable stores the object associated with a given row. So we can add the actions now. In the, To Add property, add a call to the AddToPolicies underscore EXT method on the AB contact object. In the, To Remove property, add a call to the Remove from policies underscore EXT method. Now let's configure the checkbox behavior. Recall that the checkboxes should be visible only in Edit Mode. Click the Height checkboxes if Read Only property. Select True.  As a last step, we make sure that we have made all the necessary widgets and containers editable. The editable property for the Row Iterator is set to True. Next, click the Row. Editable is True. Click the ListView. Notice that the editable property is not set. We'll fix that now. Click the property. Click the property. Click the down arrow. Select True. Press Ctrl plus S to save the changes. Switch to Training app and press Alt plus Shift plus L to deploy the changes. The PCFs are now reloaded. Click Edit. The Add and Remove buttons appear. Next, we will add four policies and remove one. Click the Add button. Enter a policy number. Enter a premium amount. Select a location. Click the Add button. Enter a second policy number. Enter a premium amount. Select a location. Click the Add button again. Enter a third policy number. Enter a premium amount. Select a location. Click the Add button. Enter a fourth policy number. Enter a premium amount. Select a location. Click the Add button.    So now we have four policies. However, we need to be sure that the Remove button works. Next, we'll remove one of these policies. Click the checkbox next to the fourth policy. Click the Remove button. Notice, that the fourth policy has been removed from the list. Click the Update button to save the changes. Let's go a step beyond the requirements and define a sorting order for the list view. Return back to Studio. Click the Row Iterator. Click the Sorting tab. We will sort by policy number. Click the plus sign to add a sorting parameter. In the Sort by property, enter current policy.policy number. Enter one in the Sort Order property. We could define additional sort parameters, but since there should never be two policies with the same policy number, they would be relevant. Press Ctrl plus S to save the changes. Now, we've switched back to Training App. Press Alt plus Shift plus L to reload the PCFs. Now that the PCFs are refreshed, we see that the policies are sorted by policy number. Let's summarize what we did in this demonstration. First, the Expose Iterator property is defined on the list view. Second, the To Add, To Remove, checkbox behavior, and sorting are defined on the row iterator. Third, the Iterator buttons widget is associated with the exposed row iterator. This concludes the demonstration. Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil so                                        so                                  \n\n--- IS_Fund_15 ---\nBusiness analysts have decided that the invoicing method for each policy must be stored in TrainingApp. The invoicing method specifies how the premium will be collected for the policy. At this time, the insurance company allows these three invoicing methods. The first is a 10% down payment and 11 installments. Second, is a 30% down payment and 4 installments. Third, is a 50% down payment and 2 installments. Business analysts are still working on the UI requirements, so we need only configure the data model at this time. We will create a new typelist, and then add a typekey field to the existing policy underscore ext entity, to refer to the typelist. As configuration developers, we need the ability to create and modify fixed lists of values to provide and restrict user choices in the UI. Thus, we need to know how to work with typelists in Studio, so we need to know how to work with typelists in Studio. So we can effectively create and modify typelists to implement user stories. First, we will explore where the main typelist resources are located in Studio's project view. The base application typelists are in the metadata slash typelist folder. To navigate to the base application typelists, click metadata. Then click typelist. This folder contains two read-only file types. TTI files are base application typelist statements. TTI files are in the extensions slash typelist folder. Click on extensions. Click on type list. This folder contains two editable file types. These are examples of TTI custom typelist definitions. These are examples of TTI custom typelist definitions. These are examples of TTI custom typelist extensions. If a custom typelist is defined in a TTI file, there is no need to create a TTI file for it, you can simply edit the TTI file as needed. TTI files are used to extend base application type lists. As you can see, the project structure, the resource names, and the naming conventions are very similar to those for entities. The only difference is that the extension begins with a T for type list, rather than an E for extension. Let's take a look at a typical TTI file. Double-click the bank account type dot TTI file. This is a custom type list, because it's in the extensions folder. And it can be modified or extended, because it is not final. Notice that the final property is false. The type list has three type codes, checking, savings, and other, behind-the-scenes, type list definitions, like entity definitions, are XML files. If we click in the text tab, we can see the XML file. Click the text tab. The structure is pretty simple. Each type code has its own listing, with a code, description, name, and priority. The type codes are all enclosed in the type list, which has a few properties of its own. Click the type list tab. Type lists are processed by the code generators in a similar way to the processing of entities. A Java class is generated from the TTI, TIX, and TTX files. Both incremental and bulk code generation are supported. Incremental code generation is triggered by validating or saving. Bulk code generation is triggered by rebuilding the project, including starting the server. Let's look at the generated Java code for the bank account type dot TTI file. Press CTRL plus shift plus N. Enter bank account type into the search field. Double click the bank account type dot Java file. This is the generated Java code for the bank account type type list. Notice the type codes for this type list. Click the scroll from source button to locate this code in the project view. Notice that the generated code location is configuration, generated, type key. Remember that there are four types of type list. Internal type lists are not extendable. Let's open the activity status type list to see this. Press CTRL plus shift plus N. Enter activity status in the search field. Double click on activity status dot TTI file. On activity status, the final property is set to true. Validation level is an extendable type list, meaning that it can be extended, either with a TIX file, or a TTX file. Let's open that type list. Press CTRL plus shift plus N to search for a file. Enter validation level in the search field. Double click the validation level dot TTI file. Its final property is false, but its platform property is true. Any TTI file you find or create in the metadata type lists folder is a custom type list. Let's look at a type list like this. Press CTRL plus shift plus N to search for a file. Enter contact destruction status in the search field. Double click on the type list. Its platform and final properties are both set to false. After reviewing the entity diagram and the requirement, we have identified two tasks. First, create a new type list and define its type codes. Second, add a new type key field to the policy underscore ext entity. First, we will create the new type list. Click on extensions. Right click on type list. In the new menu, select type list. Enter a name and description for this type list. Guidewire recommends that the type list name should be in Pascal case. Guidewire also recommends that custom type lists be created with a unique suffix like underscore ext to distinguish the type list from base application type lists. The description should contain information configuration developers need to know about this type list. Click OK to save the new type list. The only other property you might enter on the type list itself is the table name property. By default, the table name is xxtl underscore type list name, where xx is the application code. You can change this by setting table name, though the xxtl underscore prefix will still be added. Now we will add the required type codes. Click the green plus button to add a type code. Click the code property. Enter 30 down for insts in the code property. The code is an internal reference, and must be unique within the type list. It should be no more than 50 characters. For extensions of base type lists, Guidewire recommends using underscore ext or some other unique prefix. Enter the name. The name property contains the full name of the type code, as it will appear in the UI. Enter the description. Any additional information needed by configuration developers should be placed in the description property. In practice, it is often identical with the name property. Enter the priority. The priority determines the order in which the type codes will appear in the UI. Guidewire recommends numbering type codes with an interval, such as 10, so additional type codes can be added seamlessly. Now I'll quickly add the other two type codes, incrementing the priority by 10. Here are the additional type codes. Incidentally, since type codes don't use display keys, how can we allow them to support multiple languages? By using the localization button at the bottom right-hand corner of the type list. Click a type code. Click the localization button. The localization pane allows us to enter the name and description for each language implemented in the current configuration. Note, only the name and description fields need to be localized. Now, let's validate the type list we've created, and run the code generator. Remember that I can do this by saving or by clicking the validate button. Click the validate button. Now we can look at the generated Java class. Press Ctrl plus Shift plus N to search for a file. Enter invoicing method in the search field. Double-click the invoicing method.java class. Note, three type codes are present as final type keys. The type list class implements the type key interface. Let's add a new type key field to the policy underscore ext entity. Press Ctrl plus Shift plus N and search for a policy. Double-click the policy underscore ext entity. Click the down arrow. Select type key from the menu. Because this is a custom entity, we don't need to add underscore ext to its properties. In the name field, enter invoicing method. We'll select the invoicing method type list. In the type list field, select invoicing method underscore ext. Because there are existing objects in the database, we have to make the null OK property optional or there will be errors when we restart the server. The other option would be to provide a default value. In the null OK field, select true. As the last step, we'll start the server to deploy the data module changes. Click debug server icon to start the server. This concludes the demonstration.\n\n--- IS_Fund_16 ---\nCurrently, users can add, remove, and edit policy details in the Policy ListView panel. However, the editable ListView panel on the page only exposes some of the policy entity fields. In this demonstration, we'll configure a popup that will allow users to view and edit all the fields of a policy. The policy should open when the user clicks the policy number in the ListView. First we will create a popup. Where should we put the popup? In the Policies underscore EXT folder we created in the first demonstration. Click Page Configuration. Click PCF. Click Training. Click AB Contact. Click Policies underscore EXT. Now we'll create the popup. Right-click the Policies underscore EXT folder. Select PCF file in the new menu. Select popup. Remember to select the right file type, because it cannot be changed later. In the file name field, enter policy underscore EXT. Click the OK button. Next, we will specify the entry point. What is an entry point? An entry point is a reference used by widgets to navigate to a given location. An entry point specifies the location name and the parameters required to render the location. Each location must have at least one entry point. Click the popup widget to view the properties. Click the entry point. Click the entry point. Click the entry point. Click the green plus sign. Click theountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountount property, enter true. The title property is required. Add a display key. There's one more property we want to set. This one will let users edit the pop-up contents as soon as the pop-up opens. Scroll down and select the start and edit mode property and select true. The pop-up is still red, because it needs a screen inside it. Now, we'll add some data to the pop-up, starting with the policy number. Remember that is a string, so we'll use a text input. In the toolbox, search for text input. Drag and drop one into the pop-up. The pop-up is no longer indicating an error because studio is smart enough to put the necessary containers around the text input. Notice that the input column, detail view, and screen have been added. Now we want the screen to be editable. Click the screen widget. In the editable property, select true. Click the detail view. In the editable property, select true. Now we'll configure the text input. We want it to be editable. Click the text input. In the editable property, select true. In the ID property, enter policy number. Set the label property using a display key. Set the value property. Next, we'll add fields for the premium. From the toolbox, drag and drop a monetary amount input widget below the policy number. Configure the monetary input. Next, we'll add the range input. The range input is a range and so it may be a little tricky. The value comes from the policy, but how shall we set the value range? From the toolbox, drag and drop a range input below the premium. Configure the range input as shown. Finally, we'll add the new property, the invoicing method. How should we implement it? From the toolbox, drag and drop a type key input below the location. Configure the type key input as shown. Now, let's configure the navigation. Where should we place the navigation? And how shall we implement it? In the action property of the policy number cell, on policy summaries underscore extlv. We will use the popups push function which is provided automatically for every popup we create. Click the policies underscore ext folder. Double click the PCF. What should we use as the argument for the push function? Use the row iterators element, current policy. Click the policy number text cell. Set the action property. To validate these changes in studio, let's save. Remember, when the PCF changes are validated slash saved, the studio also generates other classes and resources using internal code generators. PCF files support both incremental and bulk code generation. If we validate slash save, studio uses incremental code generation. When does studio use bulk code generation for PCF files? During project rebuild. Click code gen. The code gen window shows no validation errors, so let's deploy the changes. Do we need to restart the server? No, because we have only changed PCF files. Switch to training app. Reload PCF files by pressing Alt plus Shift plus L. Navigate to the summary page of the WilliamAndy contact record. Click the field. Type Andy. Click search. Click WilliamAndy. Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Fil Select an invoicing method. There's only one problem. How can we save our changes? Click Return to Summary. This message appears, pointing out that the results haven't been saved. We have no update button. Click OK. So let's add an update button to the pop-up. Switch to Studio. Click the pop-up. In the Toolbox, search for the button. There is no individual update button. So we'll add a set of edit buttons. Drag an Edit Buttons widget to the top of the screen in the pop-up. Now we'll deploy. Save the changes. Switch to Training App. Reload the PCFs. Now we'll open the pop-up again. Click a policy number. Assign the policy and invoicing method. Now, click the Update button. We automatically return to the Summary page, where we can't see whether our work was saved. Click the policy number again. The invoicing method remains in place. Click Cancel. We have received one more user story about the policy pop-up. We need to restrict access to high-value policy details. If the policy premium is over $5,000, then only super user can view the policy details. If it is less than or equal to $5,000, any authenticated user can open the pop-up to view the details. How can we best implement this requirement? By using the CanVisit property. We need to set the CanVisit property so that it allows the user to visit if one of two things is true. Either, the user is logged in as super user or the policy's premium is no more than $5,000. Set the CanVisit property as shown. Save the changes. Reload the PCFs. To test this, we'll begin by logging in as super user. Search for contacts with the last name of Andy. Click on Eric Andy link. Let's give Eric two policies. Click Edit. Click Add. The first policy will have a premium of $3,000. Click Add again. The second policy will have a premium of $6,000. Click Update. Because I'm logged in as super user, I can open the pop-ups for both policies. Click the first policy. Click Cancel. Click the second policy. Click Cancel. Click the second policy.  Log in, as someone else. Click the gear icon. Click logout super user. Log in as Alice Applegate. Search for contacts with last name of Andy. Click Eric Andy. Click the policy number for the second policy. Notice that the pop-up doesn't open for the second policy. This is because it is not hyperlinked. Click the first policy. The policy opens as expected. Click Cancel. This concludes the demonstration.\n\n--- IS_Fund_18 ---\nFirst, let's open the summary page in Studio and analyze the current configuration. We will determine whether we can easily reuse the relevant part of the summary page on the person info card to implement this requirement. Login to Training App. Click the down arrow. Select William & D. Press Alt plus Shift plus C to open this PCF in Studio. The public ID and created on widgets are in a reference detail view. Let's open it. Double-click the detail view. The detail view has two inline input columns. The first input column contains the widgets in question. This means that the smallest reusable container that contains the widgets in question is the whole detail view. Unfortunately, the detail view contains a number of widgets that we don't want to add to the person info. Now, let's analyze the person info card. Now, let's analyze the person info card. In the sidebar, click Details. Press Alt plus Shift plus C to open the PCF in Studio. Again, we have a detail view. Double-click the detail view. Once again, we have two input columns. We need the two widgets to appear at the top of the second input column, above the Employment Info section. One solution to address this situation is to create a reusable input set that contains only the public ID and the created on widgets. This input set can be referenced from the two detail views. We will create a reusable input set. Next, we will replace the two widgets in the contact summary detail view with that input set. Finally, we will reference the same input set from the contact details person detail view. Where should we put the new input set in the PCF? In the new PCF hierarchy. In the training folder, under AB Person. Navigate to the AB Person folder under Page Configuration.PCF.Training. Right-click on AB Person. On the new menu, select PCF file. We need the new PCF file to be an input set. Select input set from the file type list. Enter the file name for the new PCF file. Click OK to save the new PCF file. Next, we will cut the new PCF file. Next, we will cut the widgets from the summary detail view, and paste them into the input set. We have to do this one by one, because multi-selection is not supported for widgets in studio. Click the contact summary detail view PCF. Click the public ID widget. Press CTRL plus X to cut the widget. Click the basic info input set PCF. Click the input set. Click the input set. Click the basic info PCF. Click the input set. Paste the widget. Paste it under the public ID. Note that the widgets appear in red, because they reference the an AB contact variable. Notice that by hovering the mouse over the widgets, Studio shows a tooltip with the error. To resolve these errors, we must define a root object. Click the input set. Click the required variables tab. The name of the variable must be an AB contact to match the widgets. Click the plus sign to create a new required variable. Enter the variable name. Enter the variable type. The input set is still red. Save the changes to trigger code gen. This completes the input set. Now, we will reference it in the contact summary detail view to display the widgets in their original positions. Click the summary detail view. To use an input set, we use an input set ref widget. In the tool box, search for input set. Drag and drop an input set ref widget onto the canvas, between the name and assigned user widgets. Configuring the input set ref widget is similar to configuring a panel ref widget. The difference is that input set widgets are used to include input sets in detail views, while panel ref widgets are used to include detail and list views in secondary containers or screens. In the def property enter basic. Double-click basic info set. We need a variable for the input set. What should it be? An AB contact. Between the parentheses, type an AB contact. Now the input set is no longer red, but the public ID and created on widgets are not showing. To fix this, we just need to refresh the view. Click another tab in studio. Click the summary detail view again. Now the widgets display as expected. We could repeat the process for the Contact Details Person detail view. But this is easier. Select the input set. Right-click the input set ref. Select copy. Select the input set. Click the input set. Right-click on it. Select paste. Place the widget above the employment info widget. The wireframe also calls for a label. From the tool box, drag and drop a label widget above the input set ref. Now let's test our work. We'll save and make sure there are no configuration errors. Press Ctrl plus S to save. There are no errors, so let's switch to training up. Press Alt plus Shift plus L to reload the PCFs. The input set is displaying correctly on the basics card of the summary page, just like the individual widgets did before. Now, let's check the person info card on the details page. Here's the new input set ref. The new label. The new divider. This concludes the demonstration.\n\n--- IS_Fund_19 ---\nFirst, we must implement the business logic to calculate the down payment and installment amounts. We are going to create a new enhancement to the policy entity, and write two new GoTo functions to perform the calculations. First we need to create a new package. Right click the GSRC folder. Select package from the new menu. Enter a name for the new package. Click OK. Next, we create the new enhancement. Right click the package. Click new and then select GoTo enhancement. This is the new GoTo enhancement screen. In the search by name tab, search for policy underscore ext. Select the entity. In the name field, enter policy underscore ext enhancement. Click OK. Click OK. Here is the new enhancement. I have already added the methods. Let's look at the methods. There's one method for the down payment. And one for the installment. Each method returns a monetary amount. Both are calculated using compound if else statements, using the built-in arithmetic functions of the monetary amount type. The calculate down payment method uses the divide function to multiply the premium by the percent down, as a decimal. The calculate installment method subtracts the down payment. It calls the calculate down payment method for this, from the premium, and then divides the remainder by the number of payments. Now I'm going to stop the server. Click debug server. Click debug server to start the server. Server is restarted. Hide the server window. Now let's add two monetary amount widgets to the policy popup. Press CTRL plus SHIFT plus N, and enter policy in the search field. Double click the policy popup. First, we'll add the down payment widget. Drag a monetary amount input from the toolbox to the input column, below the invoicing method field. We'll leave the widget uneditable, because it's a calculated value. In the ID property, enter down payment. In the currency property, enter the currency. The value is the calculate down payment method. What object should call the method? A policy. Enter a call to this method in the value property. And we'll create a display key for the label. Next, we'll add the installment widget in much the same way. Drag a monetary amount input from the toolbox and place it beneath the down payment widget. Configure it as shown here. I'll open a new browser window for training app. No need to reload PCFs this time. Log in as Alice Applegate. I'll look at William Andy's account. I'll create a new policy. Click edit. Click add. Add details. Click update. Now, I'll open the policy popup. The new fields are visible, but not populated. I'll add an invoicing method. Select the invoicing method. The new fields still do not populate. I'll update the popup. Click to reopen the popup. The new fields are populated. Obviously, this is not the desired behavior. We want the fields to automatically update when the invoicing method changes. Click cancel to close the popup. To do this, we have to set the post on change data underscore only widget behavior. Select the invoicing method widget. Click its post on change widget. Click its post on change tab. Then we set this check box. The hardest part is setting the target. We want the new fields to update when invoicing method changes. So this will be the data underscore only widget. In the target property, click the light bulb. Select data underscore only. Now we'll set the post on change functionality for the down payment widget. Click the check box. The difference is that instead of data underscore only. We will set the target of this widget to the invoicing method widget. Select invoicing method. We will configure the install widget similarly. Enable targeted post on change. Click the light bulb. Select invoicing method. Now, we'll save our work. Returning to the application, we'll reload PCFs. Click on a policy. Change its invoicing method. Select an invoicing method. The amounts in the new fields update automatically. This concludes this part of the demonstration. Now we will implement layout re-render dynamic widget behavior. If you recall, the down payment and installment fields should be visible only if an invoicing method is selected. The obvious way to do this is to set the visible property on these two widgets. Click the down payment widget. Click the properties tab. Set the visible property as shown. Repeat for the installment widget. Set the visible property. Save the changes. Now let's check the behavior. Reload the PCFs. Click Edit. Click Add. Add the new policy details. Click Update. Click the policy we just added. Notice that the down payment and installment fields are not visible because the invoicing method field is not set. Click the down arrow. Select an invoicing method. The down payment and installment fields appear, with their values set. Click Cancel. Click to reopen the policy. The fields are not visible again. This fully meets the requirements stated at the beginning of this demonstration. Click the Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Thank you.\n\n--- IS_Fund_20 ---\nWe are going to create two policy subtype entities, so that we can store different information about personal and commercial auto policies. Here is an entity diagram that shows the structure. First, we have to make sure that the parent entity, policy underscore ext, is not final. Click the entity. Remember, final is a property of the entity, and specifies whether the entity can be subtyped or not. Notice that the final property is false. If this was set to true, then we would need to change it before we could create subtypes. First, let's create the personal auto policy subtype. Click extensions. Right-click entity. Select entity from the new menu. In the entity field, enter personalautopolicy underscore ext. Click the entity type field. Select subtype. Enter a description. Click the supertype lookup button. Type po into the lookup field. Select policy underscore ext and click OK. Click OK to save the new entity. Save the changes to trigger code generation to run. There are no errors in the code gen window, so we are ready to proceed. This subtype has two properties. This subtype has two properties, number of vehicles and number of drivers. Both are integers. Let's create them. Click the down arrow. Select column. Set the name property to number of vehicles. Set the name property to number of vehicles. The type is integer. Set null OK to true. Enter a description. Add another column. The new column name is number of drivers. The new column name is number of drivers. The type is integer. Null OK is true. Now let's save and validate the changes. There appear to be no errors. Let's look at the generated Java class. Press CTRL plus N. Search for classes that start with personal auto. Double click the generated Java class for this entity. Here is the generated Java class. Note, this Java class extends the policy underscore ext Java class. This is as expected because of the subtype supertype relationship. And each of the new fields has a related underscore prop as a property of the Java class. Each property has its own getter. And each property has its own setter. Close the Java file. Now, we'll create the commercial auto policy subtype. Right-click entity. Click new and select entity. Complete the entity screen as shown. Then click OK. The first column, size of fleet, is shown. The second column, number of covered locations, is shown. The third column, number of drivers, is shown. Save and validate the changes. The Java class for the commercial auto policy underscore ext subtype will be similar to the one for personal auto policy underscore ext. Search for classes that start with com. Double click the generated Java class. Here is the Java class. Here is the Java class for the new subtype entity. As the last step, we'll restart the server to deploy the data model changes. Stop the server. Start the server. Start the server. The data model changes were deployed successfully and the server has started. This concludes the demonstration.\n\n--- IS_Fund_21 ---\nFirst let's analyze the layout of the policy popup. The popup contains a screen which contains a detail view, which contains an input column, which contains the input widgets. According to the wireframe, we have to add the new widgets between the invoicing method and the calculated amounts. As shown in the presentation, the best way to implement this is using a modal container set. What type of container should be used? Since the only container that can be added into a detail view is an input, the output set, that is what we must use. Let's create a new PCF folder under pageconfiguration.pcf.training.abcontact.policies.ext. Right-click the policies.ext folder. Select PCF folder from the new menu. Enter a name for the new folder. Click OK to save. We'll start with the default mode, which is the easiest. Next, we'll create the personal auto policy mode. Right-click the policy mode. Right-click the policy mode. Right-click the new folder. Select PCF file from the new menu. Select input set as the file type. Enter a name for the new PCF file. In the mode field, enter default, all lowercase. Click OK to save. Next, we'll create the personal auto policy mode. Right-click the policy mode. Right-click the policy mode. Right-click the policy subtypes folder. Select PCF file from the new menu. Select input set as the file type. Enter the same file name as before. Enter the mode. This is the name of the personal auto policy subclass entity. Click OK to save. Finally, we need to create the commercial auto policy mode. Right-click the policy subtypes folder. Right-click the new menu. Select PCF file from the new menu. Select input set as the file type. Enter the same file name again. Enter the name of the commercial auto policy subclass in the mode field. Click OK to save. Now we will configure these input sets. Again, we will start with the default mode. Click the input set to display its configuration tabs. Select the required variables. The only thing needed for this input set is a required variable list, which must be the same number of variables, same name, and same order, for all modes. Select the required variables tab. This modal input set requires only one required variable, a policy. Click the plus sign to add a required variable. Enter a name for this required variable. Define the type. Why did this produce a configuration error, the red in the canvas? Because the required variable list of the default mode does not match the other two modes. So we must set the required variable lists of the other two modes. Open the input set for the personal auto policy. Open the input set for the personal auto policy mode. Click the input set. Click the required variables tab. Add a new required variable. Enter the name and type. Complete the same steps again to configure the input set for the commercial auto policy mode. Now, let's add widgets to the personal auto policy mode. Add triangles to theountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountount that appears at the right of the value property. We get a list of possible solutions. None of these will actually accomplish what we need. Instead, let's look at the value type property. Though it is automatically set to java.lang.string, we can change it. Change the value type property to java.lang.integer. We can configure number of vehicles exactly the same way. Set the desired properties. Change the value type to integer. This completes the personal auto mode. Now, let's configure the three fields for the commercial auto mode. Add the first text input. Set the desired properties. Change the value type to integer. Add the second text input. Set the desired properties. Change the value type. Add the third text input. Set the desired properties. And set the value type. The next step is to reference the modal input set in the policy pop-up. We'll add an input set ref and configure it. We configure the def property of the input set ref the same way as if we were referencing a single input set. This is because all the input sets have the same signature. We need to pass the subtype as the mode. Let's test the changes. Save the changes. In Training App, reload the PCFs. We will create a new policy on WilliamAndy's record. Click Edit. Click Add. Complete the fields for the new policy. Click Update. Click the link for the new policy. We see that the default mode, with no subtype specific fields, is displayed. This is because we originally configured the list view to add policy underscore ext entities to the array. And for the policy underscore ext type, the default mode should be selected. So now we have to modify the list view configuration to create personal auto policy instances for persons, and commercial auto policy instances for companies. Click Cancel. We'll write a GOSU method to do the work in A-B Contact Enhancement. Create a new enhancement in the package. Select GOSU Enhancement from the new menu. Select the new menu. Search for A-B Contact and select the A-B Contact entity. Enter the enhancement name. Click OK to save. I'll paste the code for the createPolicy underscore ext method. Let's open the list view's PCF file. Search for the PCF file. Double-click the list view. We must modify the row iterator configuration to invoke the enhancement method. Click the row iterator. Click the to create and add property. Call the new enhancement method. Remove the contents of the to add property. Save the changes. Deploy the changes. Click Run. Select Reload changed classes. Select Reload changed classes.  Switch to Training App and reload the PCFs. We'll add a new policy to William Andy. Click Add. Complete the new policy fields. Click Update. Click the link to the new policy. Notice that the fields from the Personal Auto Policy Input Set Mode appear. Now let's see what happens for a company. Click the down arrow. Click Search. Enter a company name and click Search. Select the company name. Click Edit. Click Add. Complete the fields for the new policy. Click Update. Click the Policy Number link. Notice that the fields from the Commercial Auto Policy Input Set Mode are displayed. Click Cancel. Click the demonstration.\n\n--- IS_Fund_22 ---\nLet's create the entity name. Entity names are stored in the entity names folder. Click config. Right click entity names. Select entity name from the new menu. We need to find the policy underscore EXD entity, so enter the first few letters of this entity's name. Select the entity. Click OK to save. Here we see the entity name editor. It has two sections, a variable table, and a return value pane, which is a Gosu editor. The variable table is the top pane of the editor. A table variable consists of one unique row in the entity name editor. Five columns define the attributes of a given variable. The name and entity path columns in the variable name generate the entity name. The name column defines the name of the variable, which you can reference in the Gosu editor. The entity path column defines the content of the variable. This must be a property that is an actual column in the database. The sort order and sort path columns are used if you want to define a default sort order for the entity. We will not use these in this example. The use entity name? Column has to do with foreign key columns. If the name property of the variable is a foreign key to an entity, then you must use the entity name of that entity, setting the value of this column to true. For any other value type, the column is meaningless. The return value pane defines a Gosu code expression that specifies the logic for the return value of the entity name. In the Gosu text editor, you can specify an expression that returns a string. You can edit the Gosu code for the default entity name type, internally exposed entity name types, and your own custom entity name types. In order to implement any change to an entity name type, you must restart the server. Now, let's define some variables. What variables, what columns in the database, do we need to build the entity name as defined by the business analysts, the policy number, the subtype of the policy, and the name of the policy owner. Click the green plus sign to add a variable. In the name property, enter policy number. In the entity path property, enter policy underscore ext dot policy number. The policy type variable is similar. Click the green plus sign to add a variable. In the entity path property, enter policy number. In the entity path property, enter policy underscore ext dot subtype. The owner variable is a little different. Why? Because it's a foreign key to a B contact, meaning that the use entity name field has to be checked. Click the green plus sign to add a variable. In the name property, enter policy number. In the entity path property, enter policy underscore ext dot owner. Check the use entity name property. Now, let's implement the actual entity name. We need code that will return the entity name as described by the business analysts. In the return value pane, enter this line of code. The hardest part is getting the text for the name of the policy type. We can't directly use the policy type variable, because that returns the type code, not the name. So we'll create a variable to hold it. There are three possible types of policy, personal auto, commercial auto, and generic policy. The easiest way to do this is with an if-then-else structure based on the policy type. There is a type key automatically created by training app, as a dot gs file only, containing the subtypes of policy underscore ext. The trick here is to compare it to the type code, which involves two deep dot notation, type key, dot, type list name, dot, tc variable. So the if statement for personal auto looks like this. We'll repeat the exact same structure for commercial auto, then, if neither policy subtype matches, we'll use the generic policy type. Then it's just a matter of returning the desired string, which we'll build on the spot by concatenating the parts. We need to change the policy popup to display the entity name. Press CTRL plus SHIFT plus N to search for the policy popup. Enter POL into the search field. Double click the policy popup PCF. Click the popup. Notice that the title is currently using a display key. Change the title property to use the new entity name. Now let's deploy the changes. Stop the server. Start the server.  The server is ready. Let's go to training app. On the William and E contact, we can view two of the options, a personal auto policy and a generic policy. Let's look at a personal auto policy first. Notice that the title of this popup is now displaying the result of the new entity name. Now let's look at another policy. Click cancel. This is a generic policy. Here's a generic policy showing the result of the new entity name. Now, let's go look at a commercial auto policy. Click cancel. Click the down arrow. Select Albertsons. Click the policy number link. Again, it displays as expected. This concludes the demonstration. This concludes the demonstration.\n\n--- Is_Fund_17 ---\nAn insurance company has a very specific policy number format, two letters, a hyphen, and seven digits. We want this format to be enforced when a policy is being saved. The same format will be used when the policy is saved from the UI or through API calls. In the UI, a watermark should be displayed to guide users. If the policy number format a user enters is incorrect, then the following error message should be displayed, Policy Number must be a valid policy number. Example, AA-1234567. First, we need to define the field validator. To do this we will open the field validators.xml file. There are additional field validators files, allowing localization, thus, a phone number can have different validators in different countries. However, the base validator must be defined in this main file. For example, there is a field validator.xml file. To define a new field validator for German. Click the de folder. Click the de folder. Click the de folder. Click the de folder. Click the de folder. validators.xml file. To define a new field validator, we will need to add a new validator def in this file. Field validators are reusable and can be accessed by any entity in the data model. Thus, the same field validator can be associated with multiple entity fields. Add a new validator def. The name of the validator is SI policy number. The value is a regular expression, regex, defining the pattern that must be followed. In this case, the pattern consists of two letters, a hyphen, and seven digits. Regular expressions are not a guidewire specific concept, they are an industry standard. The description is a message that will pop up when the user attempts to save and the field does not match the validator. For localization purposes, we will use a display key. We need to put the closing syntax on the validator, because studio does not do so automatically. Now the XML syntax is valid. Now, we have to define the display key. The Alt plus Enter shortcut does not work from the field validators file, so we will navigate to the appropriate display.properties file. Click localizations. Click resource bundle display. Double click display.properties. We will use a variable so that this display key can be used in multiple places with different labels. Add the display key. Next we will associate the field validator with the entities field. We will add a new column parameter to the policy number field. This will be for the validator. Click the policy number field. Click the down arrow. Click column parameter. The name of the column parameter is validator. Select validator. For value, enter SI policy number. Press ctrl plus s to save and validate the work. To deploy the changes, we have to restart the server. The server is restarted, so let's switch to training app. Login as Alice Applegate. Search for the EricAndy record. Click the search button to search for the contact record. Select the EricAndy link. Click the edit button. Click the add button to add a new policy. Here's the new policy. We'll try a policy number that doesn't fit the validator criteria. Click update. We get the error message we defined as a display key. The same thing is true if we try all numbers, or any other combination except for two letters, hyphen, and seven numbers. Now, we have a policy number that does fit the validator criteria. Click update. Click update. The new policy is saved. The validator works is configured. This concludes the demonstration.",
  "generated_at": "2026-02-13T12:24:35.188902"
}