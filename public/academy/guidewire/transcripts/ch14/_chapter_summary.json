{
  "chapter": "ch14",
  "chapter_title": "Rating Configuration",
  "domain": "rating system configuration",
  "video_count": 5,
  "total_duration_seconds": 1109.94,
  "total_duration_formatted": "00:18:29.940",
  "total_words": 2883,
  "avg_confidence": 0.9375,
  "videos": [
    {
      "filename": "Ra_Conf_01_01.mp4",
      "stem": "Ra_Conf_01_01",
      "duration": "00:02:02.200",
      "words": 494,
      "confidence": 0.9226
    },
    {
      "filename": "Ra_Conf_01_02.mp4",
      "stem": "Ra_Conf_01_02",
      "duration": "00:05:19.480",
      "words": 686,
      "confidence": 0.9359
    },
    {
      "filename": "Ra_Conf_01_03.mp4",
      "stem": "Ra_Conf_01_03",
      "duration": "00:02:15.720",
      "words": 253,
      "confidence": 0.9232
    },
    {
      "filename": "Ra_Conf_02_01.mp4",
      "stem": "Ra_Conf_02_01",
      "duration": "00:05:28.460",
      "words": 902,
      "confidence": 0.9449
    },
    {
      "filename": "Ra_Conf_03_01.mp4",
      "stem": "Ra_Conf_03_01",
      "duration": "00:03:24.080",
      "words": 548,
      "confidence": 0.9473
    }
  ],
  "full_text": "--- Ra_Conf_01_01 ---\nLogin to PolicyCenter is Alice Applegate, an underwriter. Next, we'll find the account for Ray Newton and open a personal auto policy that is in force. Then we'll copy the submission to get a new policy and make it effective today. Click the down arrow. Click Ray Newton. Click the policy number for the enforce policy. Click Actions. Click Copy Submission. Click Policy Info. Click the calendar for the effective date field. Click the Today button. So now we have a new submission. Upon clicking the quote button, PolicyCenter interacts with the rating engine, which calculates the premiums and taxes. The premiums are displayed in the form of the rating engine. Click the defaults and the rating engine. The premiums are displayed on the quote page. In the base application, the personal auto and commercial property lines are enabled using guidewire rating management. The rate books are used to manage the rate factors, rate routines, and parameter sets. Click the defaults and the rate books. Users with sufficient permission can view and edit the rate books through the Administration tab. Click the down arrow. Click Rate Books. Next, we'll look at the rate books for Personal Auto. Click the drop-down. Select Personal Auto. Click the search button results in a list of rate books. Clicking one of the rate books displays the rate tables storing the rate factors and rate routine algorithms. Here is the rate book. The first tab displays the rate tables that are included in this rate book. Click the Rate Routine tab. This tab shows the rate routines that are included in this rate book. This concludes the demonstration. Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil \n\n--- Ra_Conf_01_02 ---\nThe quote page displays costs for individual coverages as well as the total premium and tax for the entire policy. Notice that the cost for the line coverage liability, bodily injury and property damage coverage is calculated per vehicle. The business need for rating the coverages drives the cost structure and cost entity configuration. Next, we'll look at how costs are configured in Guidewire Studio. We'll use Studio to examine examples of the cost entities used to store the monetary amount. All cost entities must implement the cost delegate, cost adapter and cost methods interfaces. They contain the necessary information used for rating or for display purpose. This is the PA cost entity which is the root entity for the costs in Personal Auto. Next, let's look at the cost delegate. Notice that the PA cost is implementing the cost. Next we'll click the implements interface. This cost entity implements the cost adapter interface. The concrete implementation for this interface is the PA cost adapter. Next, we'll look at the fields in the cost entity that are used to store rates and monetary amounts. To do this, we'll switch over to the data dictionary. Here we are viewing the data dictionary for the PA cost entity. Cost entities contain three significant columns, actual, standard, and override, to store rates and monetary amounts. So, the base base column of the base column of the base column. column. The last column in the standard set is the standard amount column. Next, we'll look at the override set of columns. This is the override base rate column. This is the override adjusted rate column. The override term amount column. And, this is the override amount column. Next, we'll look at the set of columns that hold the actual amounts. Actual base rate, actual adjusted rate, actual term amount, And finally, the Actual Amount column. Next, we'll switch back to Studio to look at some more cost entities. All other line-specific cost entities are subtypes of the root cost entity. Generally, there is a cost entity for each coverage entity. For example, the Personal AutoCov cost entity is for the line coverage. Double-click the entity. Click the Foreign Key column. This is the Foreign Key to the coverage entity. In this case, Personal AutoCov. It also has a Foreign Key to the coverable personal vehicle. Because the line coverage for personal auto is rated per vehicle even though the coverable vehicle is not on the line. Next, let's look at the Personal Vehicle Cove Cost entity. This is the cost for the personal vehicle coverages. Click the Foreign Key. This is the Foreign Key from the cost entity to the coverage entity. Next, let's look at a cost for the business owner's line. This is the cost for building coverages. There are cost entities for non-coverage objects that bear costs on the policy. Such as additional insured on the business owner's and general liability lines. This is the business owner's additional insured cost entity. Notice that it has a Foreign Key to the additional insured entity, rather than to a coverage. Next, we'll create a new cost entity. Expand Extensions. Right-click Entity. Click New Entity. This is the new entity screen. Enter the entity name. Notice that the table name is set automatically based on the entity name. Click the Entity Type drop-down. Select Subtype. Enter a description. Click the SuperType Lookup button. This is the SuperType Lookup screen. Type PA and then select PA Cost. Click OK. Click OK. The new entity has been created, but there is an error in the code generation window. Click Save to trigger code generation. Now the error is resolved. Click the button. Select Implements entity. Set the name property to cost. Click the button again. Select Implements interface. Set the interface property to cost adapter. Set the implementation property to PA Cost Adapter. Set the implementation property to PA Cost Methods Imple. Select Implements interface. Set the interface property to PA Cost Methods. Set the implementation property to PA Cost Methods Imple. Click Save to validate the changes. This concludes the demonstration.\n\n--- Ra_Conf_01_03 ---\nFirst, we'll open a personal auto policy that is in force and start a policy change. Click the down arrow. Select Ray Newton. Click the enforce policy. Click the actions button. Click change policy. Click the calendar lookup. Click the today button. Click next. Click PA coverages. Click the drop down. Select the 50-150 package. Click quote. The total change in cost is displayed at the top of the page. It calls the denormalized field transaction cost. It calls the denormalized field transaction cost RPT on policy period. It could be a positive or a negative value depending on the coverage changes. Click the cost change detail tab. This tab shows the cost changes that resulted from this transaction. Next, we'll issue this policy change and then view the financial transactions. Click issue policy. On the confirmation message, click OK. The policy change is bound. View the policy. Click financial transactions. Click transactions by job. The transactions from the policy change are listed on the lower part of the screen. Next, we'll switch to studio to talk about the transaction entities. Each line of business has one LOB transaction entity. Here is the transaction entity for personal auto. The root cost entity is the transaction entity. The transaction entity has an array to this transaction entity. Click PA cost. Click the transactions array. The getter scriptability attribute must be set to does not exist so that users will not try to obtain detailed transaction information from a cost object. This concludes the demonstration.\n\n--- Ra_Conf_02_01 ---\nThe AbstractCostDatabase class provides common financial properties matching the cost delegate. In addition, it provides common methods to be used by the rating engine. There are abstract properties and methods that the subclass must implement accurately. Next, we'll look at a few of the common methods. This class is several hundred lines long, so we'll use the Find feature in Studio to locate the methods we are interested in viewing. Click the Edit menu. Click Find. The first method we are interested in viewing is the MergeIfCostEqual method. Enter the method name into the Find field. This first matches in a code comment, so click the down arrow to find additional matches. To merge two rate scalable cost date and objects together, use the MergeIfCostEqual method. If two cost date and objects are adjacent in effective time and equal, then this method sets the expiration of the earlier cost to the expiration date of the later cost. The color discards the location. The later cost. Costs are equal if the isCostEqual method returns true. It checks that the two costs have the same basis, rates, and term amounts, along with a few other things. Next, let's look at the CopyStandardColumns to ActualColumns method. Enter the first part of the method name into the Find field. Here is the CopyStandardColumns to ActualColumns method. The method copies the standard columns into the actual columns. Next, let's look at the KeyValues property. Enter KeyValues into the Find field and then click the down arrow to find the property. Here is the abstract property for KeyValues. These values are used to determine if this cost data is the same as another cost data. If two cost data objects have the same keys they are considered to be equal and may potentially be merged. Next, we'll look at the set specific fields on cost methods. Here is the set specific fields on cost method. After a line of business creates its cost data objects, the default rating engine creates new cost entities or updates existing cost entities. The root cost data class knows how to copy all the built-in cost properties from the cost data object to the cost object. However, for a cost data subclass, the default rating engine needs help to copy any subclass specific properties to the corresponding new or changed cost entity. To coordinate this with the default rating engine, each cost data subclass must override, implement, the method set specific fields on cost. Next, let's look at the GetVersionCosts method. Here's the GetVersionCosts method. Probably the most complicated method to implement on cost data objects is the GetVersionCosts method. Refer to the Policy Center documentation for more information on implementing this method. For every cost subtype entity, there must be a defined cost data subclass. Let's look at a couple of examples. Press Ctrl-N to search for a class. Search for the Personal Autocove Cost Data class. Double-click the class to open it. Here is the Personal Autocove Cost Data. Next, let's open the corresponding cost entity. Press Ctrl-N. Search for Personal Autocove Cost. Double-click the Personal Autocove Cost entity. Here is the entity. The Cost Data subclass must contain the member variables that match the columns in the corresponding cost subtype entity. Use the key object type and cost data for the four and key columns in the cost entity. Key object stores the fixed ID of the other object. It is also used to set the specific field on cost. Notice that the Vehicle ID is set to the fixed ID of the associated vehicle and the Cove ID is set to the fixed ID of the associated coverage. Next, let's look at the PA Rating Engine class. Search for the class. Open the class. Here is the Rating Engine class for the Personal Autoline. Here is where the cost data and object is created during rating. The Abstract Rating Engine merges cost data and objects for similar costs. Each cost data subclass must implement the Key Values property to help the rating engine to determine whether two cost data and objects are the same costs for the same things. Let's return to the Personal Autocost data. Here is how the Key Values property is implemented for this cost data. The Vehicle ID and Cove ID are returned. This means that if two cost data and objects are for the same vehicle and coverage then they are considered to be equal and they will possibly be merged. Cost data base class takes care of setting general cost data properties, but subclasses must implement the Set Specific Fields on Cost function to set the fields specific to the associated cost. For example, foreign keys. Here is the implementation of the method for the Personal Autocov Cost data class. Notice that the superclass handles setting the general properties, however the foreign keys to the coverage and the vehicle are handled here. Cost data subclasses must implement the GetVersionCosts function in order to find the candidate set of costs to potentially reuse, or clone, when persisting this cost data as a cost. Here is the implementation of the GetVersionCosts method for this cost data. Let's look at another example of this method. Press CTRL-N. Search for classes starting with PA Multi. Double-click the PA Multiple Policy Discount Cost data class. Here is the implementation for this cost data class. This concludes the demonstration.\n\n--- Ra_Conf_03_01 ---\nHere is the AbstractRatingEngine class. In the base application, all LOB rating engines extend AbstractRatingEngine, which extends AbstractRatingEngineBase. Let's look at that class. Here is the AbstractRatingEngineBase class. Let's look at the RateOnly method. The RateOnly method in the AbstractRatingEngineBase class has the core logic for the rating process. First, it gets the policy line versions for all the change dates. Next, it determines whether to rate the slice forward or not. It rates the slices to calculate various premiums. The cost data objects were created and added to an array. Next, it merges and prorates the cost data objects. Last, it rates the policy in window mode to calculate costs such as discounts, taxes, etc. Next, we'll return to the AbstractRatingEngine class. The AbstractRatingEngine class has methods that the subclasses must override. We'll look at these now. The first method is existing slice mode costs. When rating only from the change date forward, this method finds any existing slice mode costs and returns cost data and objects to represent them. Typically, you would omit some costs such as taxes, which policy center treats as costs that the rating creates in window mode not on a per slice basis. This method must return costs currently on the period that correspond to costs that are generated during the RateSlice method. This is the RateSlice method. This method rates a given slice of the policy for this rating line. The method has a policy line argument that already has its slice date set for this slice. The default logic calls this function once for every slice date in the policy. This is the RateWindow method. This is where you would create costs that meet either of the following conditions. 1. It depends on the sum of the previous slice costs or 2. It spans the entire period and you must rate them just once instead of once for each slice date. This is the CreateCostDataForCost method. Given the specified cost entity instance, it creates the appropriate cost data subclass and returns it. Next, let's look at the PersonalAutoRatingEngine class. The PA rating engine has the detailed implementation for each method and it extends the abstract rating engine. The existing sliceModeCost method retrieves the existing cost from the database to be used in rating in slice mode. So costs like taxes, etc. are excluded. The CreateCostDataForCost method creates the cost data and objects for existing cost. The RateSlice method contains the core logic to rate each specific premium, such as line coverage and vehicle coverage. Here is where the line level coverages are rated. And the vehicle level coverages. Next, let's look at the RateLineCoverage method. Hover the mouse pointer over the method and press Ctrl-click. This method determines which rate routine to call for each type of line coverage. Then it creates the parameter setMap and executes the rate routine. Now, let's look at the RateWindow method. This method contains the logic to rate costs in window mode, such as tax. Costs can only be created in slice mode, so even though we are rating in window mode here assert slice mode is called first. Let's look at the RateTaxes method. Here is the RateTaxes method. This concludes the demonstration. So, the RateTaxes method of the RateTaxes method of theountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountount ",
  "generated_at": "2026-02-13T13:01:27.863335"
}