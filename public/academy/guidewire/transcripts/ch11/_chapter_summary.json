{
  "chapter": "ch11",
  "chapter_title": "InsuranceSuite Integration",
  "domain": "system integration",
  "video_count": 18,
  "total_duration_seconds": 4275.18,
  "total_duration_formatted": "01:11:15.180",
  "total_words": 11507,
  "avg_confidence": 0.9336,
  "videos": [
    {
      "filename": "In_02_01.mp4",
      "stem": "In_02_01",
      "duration": "00:03:02.260",
      "words": 571,
      "confidence": 0.9405
    },
    {
      "filename": "In_03_01.mp4",
      "stem": "In_03_01",
      "duration": "00:01:46.500",
      "words": 414,
      "confidence": 0.9399
    },
    {
      "filename": "In_04_01.mp4",
      "stem": "In_04_01",
      "duration": "00:01:40.820",
      "words": 482,
      "confidence": 0.9555
    },
    {
      "filename": "In_05_01.mp4",
      "stem": "In_05_01",
      "duration": "00:01:42.080",
      "words": 244,
      "confidence": 0.9396
    },
    {
      "filename": "In_06_01.mp4",
      "stem": "In_06_01",
      "duration": "00:04:05.780",
      "words": 544,
      "confidence": 0.908
    },
    {
      "filename": "In_08_01.mp4",
      "stem": "In_08_01",
      "duration": "00:04:53.200",
      "words": 874,
      "confidence": 0.9625
    },
    {
      "filename": "In_09_01.mp4",
      "stem": "In_09_01",
      "duration": "00:02:41.880",
      "words": 279,
      "confidence": 0.9359
    },
    {
      "filename": "In_09_02.mp4",
      "stem": "In_09_02",
      "duration": "00:03:53.800",
      "words": 507,
      "confidence": 0.938
    },
    {
      "filename": "In_10_01.mp4",
      "stem": "In_10_01",
      "duration": "00:04:53.860",
      "words": 644,
      "confidence": 0.899
    },
    {
      "filename": "In_11_01.mp4",
      "stem": "In_11_01",
      "duration": "00:04:56.460",
      "words": 703,
      "confidence": 0.9233
    },
    {
      "filename": "In_12_01.mp4",
      "stem": "In_12_01",
      "duration": "00:05:39.720",
      "words": 691,
      "confidence": 0.9252
    },
    {
      "filename": "In_13_01.mp4",
      "stem": "In_13_01",
      "duration": "00:03:46.140",
      "words": 549,
      "confidence": 0.9459
    },
    {
      "filename": "In_14_01.mp4",
      "stem": "In_14_01",
      "duration": "00:04:11.780",
      "words": 746,
      "confidence": 0.9528
    },
    {
      "filename": "In_15_01.mp4",
      "stem": "In_15_01",
      "duration": "00:04:11.320",
      "words": 707,
      "confidence": 0.9216
    },
    {
      "filename": "In_16_01.mp4",
      "stem": "In_16_01",
      "duration": "00:04:17.620",
      "words": 1025,
      "confidence": 0.9573
    },
    {
      "filename": "In_17_01.mp4",
      "stem": "In_17_01",
      "duration": "00:03:55.460",
      "words": 479,
      "confidence": 0.8941
    },
    {
      "filename": "In_18_01.mp4",
      "stem": "In_18_01",
      "duration": "00:07:43.780",
      "words": 1248,
      "confidence": 0.9294
    },
    {
      "filename": "In_19_01.mp4",
      "stem": "In_19_01",
      "duration": "00:03:52.720",
      "words": 800,
      "confidence": 0.9216
    }
  ],
  "full_text": "--- In_02_01 ---\nThis demonstration will illustrate different aspects of Gosu code used for integration. This demonstration will 1. Create a utility class called Rectangle. 2. Enable logging. 3. Throw a displayable exception. 4. Create a method that calculates the area of a rectangle. 5. Create a method that enlarges the area of a rectangle and recalculates the area. This demonstration requires that you use Training App in Guidewire Studio. Click the Debug Server icon to start the server. Create a new package for the utility class using Guidewire's recommended naming convention. For all demo labs, use Demo as the company code and TA as the product code. Right-click on GSRC Package. Select New and then Package. Type the new package name. GoSoo. Click OK to save the new package. Right-click on the new package to create a new Gosu class in the utility package. Select New and then Gosu class. Type the name of the new Gosu class. Click OK to save the new Gosu class. The shell of the new Gosu class is created. Enter code to implement the requirements. Examine the code. Lines 12 to 15. The constructor is used to initialize the width and height variables. Line 17. A logger variable is created. Lines 18 to 20. Private variables are created using shorthand notation. Lines 22 to 24. Method comment is added. Lines 34 to 37. Method annotations are added. Since a new class was created, the server must be restarted. Click the Stop Server button. Click the Debug Server button to start the server. In order to test the rectangle class, open Gosu Scratchpad. Click Tools and then select Gosu Scratchpad. Enter code to test the new rectangle class. Examine the code. Line 3. Code instantiates a new rectangle object, whose width equals 2 and height equals 3. Line 4. Code calls the Calculate Area method. Line 5. The system will display the enlarged rectangle value. Execute the code by clicking the Run and Debug Process icon. Note, this icon is enabled since the server is started in debug mode. The output is in the console. The area of the rectangle increased from 6 to 54. Uncomment the code at line 6. Click the Run and Debug Process icon to execute the code and Gosu Scratchpad. A displayable exception is thrown in the output. The enlarged method will throw a displayable exception if an argument less than or equal to 0 is passed to the method. See line 39 in the rectangle class code. This ends the create a custom class demonstration. Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy \n\n--- In_03_01 ---\nThis demonstration will illustrate two query examples that retrieve contact information based on different criteria. This demonstration requires that you use Training App in Guidewire Studio. Click the Debug Server icon to start the server. In Goza Scratchpad, add code that will query for all AB persons whose last name is Smith. Examine the code. Line 4. Create a query object variable that will query the AB person table. Line 5. Restrict the query using the compare method. The query will search for all AB persons whose last name equals Smith. Line 6. Create a result object variable that will execute the query. Lines 8 to 10. Loop through result object to output each display name. Click the Run and Debug Process icon to execute the query and review the result. The console displays the results of the query. Enter, a query to return all AB persons whose last name is Andy or whose first name is William. Examine the code. Lines 5 to 8. Restrict the query so that it will search for all AB persons whose last name equals Andy or whose first name equals William. Click the Run and Debug Process icon to run the query and review the result. The console output displays the results of the query. A few things to keep in mind. Unrestricted queries should be avoided. Compares accumulate and can impact performance. Rows are read into memory the first time the result set is referenced, not on the select. For large queries, use paging to chunk up the results. This, ends the queries with restrictions demonstration. Filogy of the Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Filogy of Fil Thank you.\n\n--- In_04_01 ---\nThis demonstration will trigger an error when attempting to update a contact from a read-only bundle. Then it will update the bundle code to successfully update the contact. This demonstration requires that you use Training App, Guidewire Studio, and a supported web browser. Open Gosu Scratchpad by clicking on Tools and selecting Gosu Scratchpad. Enter code that returns Samantha Andrews, whose public ID is a, b, sample colon 1 and tries to set the gender field. Examine the code. Line 5, create a new bundle. Line 7 to 8, create a query that searches for an a, b doctor whose public ID equals a, b, sample colon 1. Line 9, set the doctor's gender to female. Line 10, commit the bundle as super user. Click Run and Debug Process icon to execute the code. In the console output, an illegal state exception was thrown. This is because you can't modify a read-only bundle. To fix the code, add the read-only database query bundle to the new bundle, as shown in line 9. Click Run and Debug Process icon to execute the code. Login to Training App and verify that the gender field was updated. Type the username for Alice Applegate. Type the password for Alice Applegate. Click the Login button. Type A in the search field. Click the search button to search for contacts whose last name starts with A. In the search results, select the link for Samantha Andrews. Click the Details link. Note, the gender field was updated to female. This ends the GOSA Bundles demonstration. Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil ... ... ...                               \n\n--- In_05_01 ---\nThis demonstration will utilize an existing Gosu template to output a string payload with bank account information. This demonstration requires that you use Training App and Guidewire Studio. Press CTRL plus SHIFT plus N to search for a file. In the search field, type the file name, and double-click on the bank account data template file in the Gosu templates package. Examine the code. Line 1. The input parameters are declared. Lines 2 to 6. The template static expressions are declared. Line 7. A scriptlet is declared verifying if the bank account type is savings. If true, the age of message expression is added to the output. Open Gosu Scratchpad to test the output of the bank account data template. Click on Tools and then select Gosu Scratchpad. Enter code that will utilize the bank account data template. Examine the code. Line 4. Use the FindContact method to find contact Eric Andy whose public ID is A, B colon 98. Lines 6 to 9. Create a for loop that will evaluate all bank accounts for the contact. Line 7. Create a payload using the bank account data template, passing the public ID and bank account parameters. Click the Run and Debug Process icon to execute the code. Examine the console output. Output. Eric Andy has two bank accounts, one checking and one savings. Note, the output for the savings account includes the age of message expression. This ends, the output a string payload demonstrates.\n\n--- In_06_01 ---\nThis demonstration will export the following user fields in XML format. Full name. Public ID. User name. This demonstration requires that you use Training App and Guidewire Studio. Prior to creating the XML model, create a package to store the new model. In Studio, navigate to the GSRC package and create a new package called XML model. Right click on the GSRC package. Select New and then Package. Type the path and name of the new package. Click OK to save the new package. Create a new GX model in the new package by right clicking on the XML model package. Select New and then GX model. In the search by name field, type the name of the class. In the search results, select User, Entity. Notice that the model name field is auto-populates. Click OK to save changes. Add the key and normal properties for the model. Typically, select the public ID field as the key property since it uniquely identifies the object. Click the Add button. Select Key property. Select the display name property and add it as a normal property. Click the Add button. Select Normal property. The user name field. The user name field is on the credential entity. The credential for an key field is not bold and can't be selected. However, expand credential and select the user name field. Rather than adding the user name field directly, create another XML model on the credential entity to demonstrate how the credential for an key field becomes bold once it is backed by an XML model. Right click on the XML model package. Select New and then GX model. In the Search by Name field, type Credential. In the search results, select Credential . Click OK to save. In the Credential model, select User Name field. Click the Add button. Select Normal property. Click on the User Model tab. Notice that the Credential . Select the Credential . And add it as a Normal property. Click the Add button. Select Normal property. Select Model pop-up window. Select Credential Model. Click OK to save changes. Click on the Sample XML tab. Look at the sample XML and verify that the User Name field is added. Click on the Debug Server icon to start the server. Click on Tools and then select GOSA Scratchpad. Enter code that will test the new XML models. Examine the code. Lines 6 to 9. Add the query. The query is joining two entities. User Entity and User Contact Entity. The foreign key name is Contact. That is why in Line 7, Contact is used as the Join parameter. Enter. These advanced query techniques can be found in the GOSA Reference Guide. Line 12. The XML object is created using the XML model. Note, since XML model is going to be deprecated in the next major release, a deprecated line is shown through the code. Lines 14 to 17. The serialization options are configured. Line 20. The payload is created using serialization options. Click the Run and Debug Process icon to execute the code. As expected, the public ID and display name fields are exported from the user object. The user name field is exported from the credential object. This ends the Create an XML model demonstration.\n\n--- In_08_01 ---\nThis demonstration will create a REST API that will output the following user data in JSON format. First name, last name, job title, username, locked, name of each assigned group. This demonstration requires that you use Training App, Guidewire Studio, and a supported web browser. Begin by creating an API schema file in the APIs package. In Studio, right-click on the APIs package. Select New and then Package. Type the new package name. Click OK to save. Right-click on the new package. Select New and then File. Type the new file name. Click OK to save. Enter the Swagger schema code. Examine the code. Line 6. The base path becomes a prefix to the password. The path of each operation. Lines 7 to 8. Import the schema defined by the integration view that will be used by the API. Lines 9 to 10. Specify the default handler class that will be used by the API. Note that this class has not been created yet. Lines 11 to 14. Specify the default input slash output file format used by operations. Note these defaults can be changed in each operation. Lines 15 to 16. Define resources under paths. Line 17. Start the definition of the HTTP GET operation. This operation will retrieve user details. Line 19. State the name of the method defined in the handler class. Note that this method has not been created yet. Lines 20 to 21. Reference the parameter defined in lines 27 to 32. Lines 22 to 26. Define the HTTP response. Line 23. Standard response code for a successful request. Line 26. Reference the integration view schema created in the integration view demonstration for the JSON response. Lines 27 to 32. Define the last name parameter. The string parameter will be included in the resource path and is required. Create an API handler package in GOSA class. Right click on GSRC.demo.ta package. Select new and then package. Type the new package name. Click OK to save. Right click on the new package. Select new and then GOSA class. Type the new GOSA class name. Click OK to save. The ShellGosa class is created. Add the code for the GetUser method. Examine the code. Lines 10-16, add the GetUser method referenced by the API schema. Lines 18-25, add a private function that finds a user by last name. Line 14, define the JSON mapper object. Argument 1, the fully qualified path to the mapper file. Argument 2, the name of the mapper. Line 15, return a transform result object. The object will automatically be transformed to either JSON or XML based on the API produces slash consumes definition. Publish the new API. In the APIs package, double-click on the publish-apis.yaml file to open. Type the name of the new API file following the same syntax described by the other defined APIs. Restart the server prior to testing the new API. To test the new API, open a browser window and enter the URL to the built-in Swagger UI distribution, HTTP colon slash slash localhost colon 8880 slash ab slash resources slash Swagger UI. In the search field, replace APIs with the base path as defined by the base path property in the API. Type demo slash ta slash user slash v1. Click the Explorer button to view the user API. Add the credentials used by Guidewire to authenticate the API request. Click the Authorize button. Type the username for super user. Type the password for super user. Click the Authorize button. Click X to close the window. Click the GET button to test the GET HTTP operation. Click the Try it out button. Type the last name of the user whose details will be retrieved. Click the Execute button to execute the GET request. In the response, observe that the return code is 200 and the user details are included. This ends the Create a User REST API demonstration. Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil straight.\n\n--- In_09_01 ---\nIn this demonstration, consume an external SOAP web service that publishes a stock quote given a stock symbol. This demonstration requires that you use Training App, External App, and Guidewire Studio. Create a web service collection in the demo.ta package. In Studio, right-click on the demo.ta package. Select New and then Package. Type the name of the new package. Click OK to save. Right-click on the new stocks package. Select New and then Web Service Collection. Type the name of the new web service collection. Click OK to save. Click the Add New Resource icon. Type the resource URL. Right-click on the newountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountount app server is running before executing the fetch. In the WSDL Fetcher Output screen, the return code is 0, which indicates a successful fetch. Click the Fetched Resources tab. Verify the stock API. WSDL and SOAP headers.xsd folders are retrieved. Restart the server to deploy the new resources. Click the Stop Server icon. Click the Debug Server icon to start the server. Open GoSo Scratchpad to test the new web service collection. Click Tools and then select GoSo Scratchpad. Enter code to test the new web service collection. Examine the code. Line 3. Create a new API instance. Lines 5 to 7. Set API properties as necessary. Lines 5 to 6. Set authentication parameters. Line 7. Specify the CallTimeout property to prevent endlessly waiting for a server response. Line 9. Call the API GetQuote method to get the stock quote for Guidewire. Click the Run and Debug Process icon to execute the code. In the console output, the quote for Guidewire was retrieved from the external resource. This ends, the consuming a soap web service demonstration.\n\n--- In_09_02 ---\nThis demonstration will create a SOAP web service that returns the vacation status of a business user. This demonstration requires that you use Training App, Guidewire Studio, a supported web browser, and SOAP UI. Begin by creating a new package for the new SOAP web service. Right-click on the demo.ta package. Select New and then Package. Type the name of the new package. Click OK to save. Click OK to save. In order to return the desired user data, create a return type Gosu class that will be referenced by the API Gosu class. Right-click on the user package. Select New and then Gosu class. Type the name of the new Gosu class. Click OK to save. The Gosu class shell is created. Enter code to implement the requirements. Examine the code. Line 5. Required annotation ensuring that instances of the class are XML serializable. Line 6. Add final keyword ensuring the class can't be subtyped. Line 8. Add a private variable representing the field that will be returned by the SOAP web service. Create a new API Gosu class. Right-click on the user package. Select New and then Gosu class. Type the name of the new Gosu class. Click OK to save. The Gosu class shell is created. Enter code to implement the requirements. Examine the code. Line 10. Required annotation to declare the class as implementing a SOAP web service. Line 11 to 12. Added optional annotations. Lines 15 to 27. Define the getUserInfo method requiring two arguments and returning the user info object. Line 17 to 21. A query joining two entities, user and user contact. The foreign key name is contact. That is why in line 18, contact is used as the join parameter. Line 23 to 24. Create the return user info object. Since a new package and Gosu classes were created, a server restart is required to deploy the resources. Click the stop server icon. Click the debug server icon to start the server. In order to test from an external system, the SOAP web service WSDL URL must be determined. Open a web browser and enter the following URL, localhost colon 8880 slash AB slash WS to view local SOAP resources. Expand the document slash literal web services links until the user API resource is found. Click the user API link. Copy the WSDL URL from the browser address field. Use SOAP UI to test the new SOAP web service. Click file from the menu bar. Select new SOAP project. Type the project name. Type the URL of the initial WSDL. Click OK to save. Double click SOAP request 1. Type the GW underscore locale value. Type the GW underscore language value. Type SOAP username value. Type SOAP password value. Type user first name value. Type user last name value. Click the submit icon to submit request to specified endpoint URL. The output shows that the vacation status for Bruce Baker is at work. This ends the publishing SOAP web service demonstration. This ends the publishing SOAP web service demonstration.\n\n--- In_10_01 ---\nThis demonstration will create a plugin that retrieves exchange rate values from an external system that requires authentication. This demonstration requires that you use Training App, External App, Guidewire Studio, and a supported web browser. Begin by creating a new package for the new plugin. Right-click on the demo.ta package. Select New and then Package. Type the new package name. Goza class. Click OK to save. Create a new pre-defined plugin. Goza class. Right-click on exchange rate package. Select New and then Goza class. Type the name of the new Goza class. Click OK to save. the Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Right-click. The Goza class. Press ALT plus ENTER to import the initializable plugin interface. Note that the uses statement automatically populate for each interface imported. The methods still need to be imported for each interface. Select either interface and press ALT plus ENTER to implement methods. Select Implement methods. Note, the methods for both plugins are automatically selected. Click OK to implement selected methods. The methods for both interfaces are implemented. Enter code to implement the requirements. Examine the code. Lines 8 to 11 class variables are defined that will be used by methods. Lines 13 to 40 implement create exchange rate set method. Retrieve exchange rate values from external app API. Lines 42 to 45 retrieve plugin parameters that will be used to authenticate the method. Select the SOAP web service call to external app. Edit the iExchange Rate Set plugin registry so that the plugin points to the new demo iExchange Rate Set plugin GOSA class. Double click on the iExchange Rate Set plugin registry. Select the plugin entry and add a new plugin of the other type. Select the ellipsis icon and search for the new plugin class. In the search field, type the name of the new GOSA class plugin. Double click on the GOSA Plugin class. Add two plugin parameters that will be used by the class. Click on the add parameter icon. Type the name of the parameter. Type the value of the parameter. Click on the add parameter icon. Type the name of the second parameter. Type the value of the parameter. Restart the training app server since a new class was created and the plugin registry was updated. Click the stop server icon. Click the debug server icon to start the server. Make sure external app server is started prior to testing. To test, log in to training app. Type the username for super user. Type the password for super user. Click the login button. Click the administration link. Click the training, plugins link. Click the invoke exchange rate set plugin button. The exchange rates are retrieved from external app. There are two ways to confirm new exchange rates were retrieved. 1. The retrieved on column shows the date and time the exchange rates were retrieved. 2. The rate for each USD to non-USD currency is a decimal value that goes to at least 4 digits. The whole number part of the first two digits are always the same each time you run a plugin. The third and fourth digits vary based on the current minute. For example, the USD to EUR rate is 0.75 XX, where XX is the current minute. This ends the configuring of plugin with parameters demonstration. Filogy of theountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountount you\n\n--- In_11_01 ---\nThis demonstration will examine the functionality of the messaging administration screens found under Training Messaging. This demonstration requires that you use Training App, Guidewire Studio, and a supported web browser. Type the username for SuperUser. Type the password for SuperUser. Click the Login button. Click the Administration link. Click the Training Messaging link. Click the Message Generator link. Whenever the Message Generator screen is rendered, Training App Auto generates a name for a new instance of the Message Generator entity. The name can be modified if needed. Click the Create and Send Only button. When the Create and Send Only button is clicked, an instance of Message Generator is created and committed. The AutoAC Message field is set to False. The message is then committed to the Message Generator. The message table. Click the Message table. Click the Message table link. The message was created and sent, but is pending acknowledgement. In Studio, observe the console output. The message was created and sent but was not acknowledged. In Training App, click the Message Generator link. Click the Create, Send, and Acknowledge button. When the Create, Send, and Acknowledge button is clicked, an instance of Message Generator is created in the message. The AutoAC Message Fil Filogy. The AutoAC Message Filogy. The AutoAC Message Filogy. The AutoAC Message Filogy. The AutoAC Message Filogy. The AutoAC Message Filogy. The AutoAC Message Filogy. The AutoAC Message Filogy. The AutoAC Message Filogy. The AutoAC Message Filogy. The AutoAC Message Filogy. The AutoAC Message Filogy. The AutoAC Filogy. The AutoAC Filogy Filogy. The AutoAC Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Filogy Fil In Studio, observe the console output. The message was created, sent, and acknowledged. Note, an outstanding message, MSG Gen colon 1, is still in the message table. Navigate to the Message Acknowledgement screen to acknowledge the message. In Training App, click the Message Acknowledgement link. The Message Acknowledgement screen contains 5 fields. The first 3 fields are required. Click the Destination field. Select the destination from which the message was sent. Type the sender ref ID of the message. Click the External System Response field. There are 4 choices. Positive Acknowledgement, the message is positively acknowledged. Negative Acknowledgement, Error. The message is reported as an error. You need to specify the error category. The message will automatically be retried. The first retry will be 1 minute later. The second will be 2 minutes later, and so on. If the message has reached the maximum number of retries, then it will not be retried. The maximum number of retries is determined by the max retries for retriable message script parameter which is set to 1. Duplicate, the message is a duplicate. No response, there is no response for the message. This actually does this not do anything in terms of the external system not responding. Select Positive Acknowledgement. There are 2 additional fields that may be needed based on the choices in the first 3 fields. Error Category. If a message is reported as an error, then you must specify an error category. This gets used if the message has reached its maximum number of retries. This field is available only when reporting an error. Vendor Profile Code. If a message is a positive acknowledgement for a vendor recommendation message, then you must provide a vendor profile code, a string of up to 10 characters. This code is displayed on the vendor info card for vendors who have been recommended. This field is available only for positive acknowledgements of vendor recommendations. Click the Send Response button. The Results field displays the action taken. For errors, it will identify if the maximum number of retries have been reached. Click the Message Table link. Since the message was acknowledged, it was moved from the Message Table to the Message History Table. Click the Message History Table link. The message was acknowledged. This ends the Message Administration demonstration.\n\n--- In_12_01 ---\nThis demonstration will examine the following messaging components for bank account verification. Configuration of the bank account entity making it an event aware entity. Configuration of the destination focusing on the required fields. Triggering a message in the UI. This demonstration requires that you use Training App, External App, Guidewire Studio, and a supported web browser. To understand why the bank account entity is an event aware entity, examine the bank account.eti file. Press CTRL plus SHIFT plus N to search for the file. In the search screen, start typing the name of the file. Double-click on the file name to open. Notice that the entity implements the event aware delegate by adding the events element. The events that are implemented by default are, added, changed, and removed. Also, a custom event was configured called Bank Account Flagged. Examine the bank account entity in the data dictionary. Navigate to the bank account entity. Click the data entities link. Click the bank account link. Observe that the bank account entity delegates to event aware and other delegates. Under Messaging Events is the list of messaging events. Bank account flagged, bank account added, bank account changed, bank account removed. The next messaging component to examine is the destination. Double-click the messaging config.xml file to view all the existing destinations. Select the bank account verification destination. Examine the configuration for the required fields. ID can be a number between 0 to 63. This destination is 13. Name has to be a unique name. Transport plugin. Configured to use the bank account verification transport plugin which will be examined in detail when the transport plugin is discussed. Events. The destination can subscribe to 4 possible events, but this destination only subscribes to the bank account added and bank account changed events. The remainder relevant fields will be discussed as needed through the remaining messaging lessons. In Training App, trigger a bank account verification message by adding a bank account to a contact. Prior to triggering the message, perform the following administrative tasks. Clear the message table. Clear the message history table. Ensure the bank account verification destination is started. Type the username for super user. Type the password for super user. Click the login button. Click the administration link. Click the training, messaging link. Click the select all box. Click the skip selected messages button. Click OK. Click the message history table link. Click the select all box. Click the delete selected message histories button. Click OK. Click the message administration link. Note, the bank account verification destination is currently suspended. Select the bank account verification destination. Click the resume button. Click the search button. Search for Brandi Amante. Type the last name in the search field. Click the search button. In the search results, select the contact link. Click the details link. Click the bank accounts link. Click the edit button. Click the add button. Click the add button. Type the bank name. Type the routing number. Type the routing number. Type the account number. Type the account type. Click the account type. Type the account type. Click the update button. Click the update button. Click theountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountountount The payload was transformed by replacing the token with the actual age of the message. Also, a sender ref ID field was added to the payload. Stage 4, the message was sent. Stage 5, the message was acknowledged and the verified field was updated. This is an example of synchronous acknowledgement. In Training App, confirm the updated status of the new bank account. Note, the screen needs to be refreshed to see the updated status. Refresh the screen by clicking on the Verification Check button. Observe that the status is now verified. To determine the status of the message in Training App, navigate to the Training, Messaging screen. Click the Administration link. Click the Training, Messaging link. Why isn't the new message displayed in the message table? This is because the message has already been acknowledged and moved to the Message History table. Click the Message History table link. Note, the acknowledged message in the table. This ends the examine an event aware entity and destination demonstration.\n\n--- In_13_01 ---\nThis demonstration will examine the following messaging components for bank account verification. Configuration of the structure of event-fired rules. Configuration of the event-fired rule that creates a message. Triggering a message in the UI. This demonstration requires that you use Training App, External App, Guidewire Studio, and a supported web browser. In Studio, navigate to and open the Event-Fired rule set in Event Message rule set category. Double-click on Event Fired rule. Examine the description of the rule set. Note, these rules execute when Contact Manager fires an integration event. The root entity is Entity.MessageContext. Next, examine the structure for the bank account verification rules. Recall, best practice dictates that the rule should filter by destination. Select the BAEF 1000, Bank Account Verification rule. The condition of the rule checks if the destination ID is equal to 13. The next step of the hierarchy would be to filter by root entity. Select the BAEF 1100, Bank Account rule. The condition of the rule checks if the root field is of type Bank Account. Next, the hierarchy should filter by message event name. Select the BAEF 1110, Added Changed rule. The condition of the rule checks if the message event names are Bank Account Added or Bank Account Changed. Finally, the hierarchy should create a rule that implements the business requirement. Select the BAEF 1111, Field Changed rule. The condition of the rule checks if one of the four listed fields have changed. Examine the code. The action of the rule implements the business requirement. Line 25 The rule casts the root object to the Bank Account object. Line 28 The rule is verifying if the account is savings, and if true, it will use a GOSA template to generate the payload, otherwise, it will use XMLModeler to generate the payload. Line 29 A GOSA template is used to create the payload. Line 30 The message is created. Line 41 An XMLModeler is used to create the payload. Line 42 The message is created. Now that the Bank Account Verification event fired rules have been examined, trigger a message by changing the Brandiamonte Savings account from Savings to Checking. Based on the rule, XMLModeler will be used to generate the payload. Type the username for SuperUser. Type the password for SuperUser. Click the Login button. Search for Brandiamonte. Type Amonte in the Last Name field. Click the Search button. Select the Brandiamonte link. Click the Details link. Click the Bank Accounts link. Click the Edit button. Click the Account Type field. Select Checking as the Account Type. Click the Update button. The event is triggered and a new message is created. Notice that the Verified field indicates pending. This is because the system is waiting for an acknowledgement from the external system to update the field. Wait for the status of the bank account to change to Verified. This should take a few seconds. Refresh the screen by clicking on the Verification check button. Note, the status is now Verified. In Studio, examine the console output. Observe the payload for the message by searching for Stage 2 of the message. As expected, the message used XMLModeler to generate the payload. This ends the Examine Event Fired Rules demonstration.       Filogy of the Filogy of the                          Filogy of the  Filogy of the                                                                           \n\n--- In_14_01 ---\nThis demonstration will examine the following messaging components for bank account verification. Configuration of the bank account verification request plugin. Configuration of the bank account verification request plugin registry. Configuration of the bank account verification destination. Triggering a message in the UI. This demonstration requires that you use training app, external app, Guidewire Studio, and a supported web browser. In Studio, search for and open the bank account verification request plugin. Press Ctrl plus Shift plus N. In the search field, type the name of the file. In the search results, double click on the file. Examine the code. Line 9. The plugin implements the message request interface. Line 17. Implement the before send method to transform the payload. Line 19 to 21. The sender ref id is set if it is null. Line 23. A variable is created for the transformed payload. Lines 24 to 32. Transform the payload by adding the sender ref id and setting the late binding value age in seconds. Line 33 to 46. Transform the payload by adding the sender ref id, to the payload that was based on XML. Line 53. The method returns a string transformed payload. Next, examine the configuration of the bank account verification request plugin registry. Press Ctrl plus Shift plus N to search for the file. In the search results, double click on the file. The interface that is implemented is the message request. A GOSA plugin class is referenced. No plugin parameters are defined. Next, examine the configuration of the bank account verification destination by opening the messagingconfig.xml file. Press Ctrl plus Shift plus N to search for the file. In the search field, type the name of the file. In the search results, double click on the file. Select the bank account verification destination. The request plugin is set to bank account verification request. In training app, trigger a message by adding a bank account of type savings. Based on the request plugin configuration, the message payload should be transformed by adding a sender ref id and replacing the token. Type the username for super user. Type the password for super user. Click the login button. Search for Brandiamonte. Type the last name of the contact. Click the search button. In the search results, select the contact link. Click the details link. Click the bank accounts link. Click the edit button. Click the add button. Type the bank name. Type the routing number. Type the account number. Type the account number. Click the account type field. Select savings as the account type. Click the update button. The bank account verification message event is triggered and a new message is created. In Studio, examine the console output. Observe the payload for the message by searching for Stage 2. The payload has an age of message late binding value and the sender ref id field has not been added. In Stage 3, the payload has been transformed. The token has been replaced by the age of the message in seconds and the sender ref id field has been added to the transformed payload. This ends the examine message payload transformation demonstration. Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Thank you.\n\n--- In_15_01 ---\nThis demonstration will examine the following messaging components for bank account verification. Configuration of the bank account verification transport plugin. Triggering a message in the UI. Perform send error recovery. This demonstration requires that you use, training app, external app, Guidewire Studio, and a supported web browser. In Studio, search for and open the bank account verification transport plugin. Press Ctrl plus Shift plus N to search for a file. Type the name of the file in the search field. In the search results, double click on the file to open. Examine the code. Line 6. The plugin implements the message transport interface. Line 13. Implement the send method to send the payload to the external system. Lines 15 to 18. API object is created and API parameters. are set. Line 21. The payload is sent to the external system. Note, the synchronous response is received and the at code variable is set. This will be discussed in more detail in the acknowledging messages lesson. In training app, trigger a message by adding a bank account of type savings. Based on the transport plugin configuration, the message payload should be sent to the external system. Before continuing, make sure that you have a message. the user's email address. Our external app is not running because we want to observe a send failure and recover from that failure. Type the username for super user. Type the password for super user. Click the login button. Search for William Dan. Type the last name of the contact in the search field. Click the search button. In the search results, select the link to the contact. Click the details link. Click the bank. Click the link to the bank accounts. Click the edit button. Click the add button. Type the bank name. Type the routing number. Type the account number. Type the account number. Click on the account type field. Select savings as the account type. Click the update button. Click the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link to the link. automatically attempts to resend the message three times because the max retries field in the destination is set to three. Eventually the system suspends the destination. Note, in each attempt the sender ref id does not change. In training app, in the message administration screen, observe the system suspended the bank account verification destination. In the message table screen, observe the messages in queue with a status of pending send. To recover from the send failure perform the following steps. Make sure the external system is running. Start external app. Resume the destination, the system will automatically try sending any outstanding messages in queue. External app is started. In the message administration screen, select the bank account verification destination. Click the resume button. Click the message table link. Observe, the message is not in queue. This means the message was successfully sent and acknowledged. Click the message history table link. The message is in the history table. This ends the examine message send and send error recovery demonstration.\n\n--- In_16_01 ---\nThis demonstration will examine the following asynchronous acknowledgement scenarios. Positive acknowledgement, negative acknowledgement, duplicate acknowledgement. This demonstration requires that you use training app and a supported web browser. Type the username for super user. Type the password for super user. Click the login button. Prior to starting the demonstration, clear the message and message history table screens. Also, verify that the message generator destination is still updated. Click on the Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil select any messages in history and click Delete Selected Message Histories button. In this case, the queue is empty, so no action is required. Click on the Message Administration link. The Message Generator destination is started, so no action is required. Click on the Message Generator link. The first scenario will simulate an asynchronous positive acknowledgement. In the Message Generator screen, the system will automatically fill the name field. Click the Create, Send, and Acknowledgement button. Open the Message History Table screen since the message is created, sent, and acknowledged. Click the Message History Table link. The message has a status of Acknowledged. The next scenario will simulate an asynchronous negative acknowledgement. Click on the Message Generator link. In the Message Generator screen, the system will automatically fill the name field. Click the Create and Send Only button. Open the Message Table screen since the message is created and sent but has not been acknowledged yet. Click on the Message Table link. The message has a status of Pending Acknowledgment. Make note of the Sender Ref ID value because it will be used to acknowledge the message. Click on the Message Acknowledgment link. Click on the Destination field. Select Message Generator as the destination. Type the Message Sender Ref ID in the field. Click the External System Response field. Select Negative Acknowledgement as the External System Response. Click the Error Category field. Select Payload Format as the Error Category. Click the Send Response button. Click the Message Table link. Observe, a new message was created, see Sender Ref ID, and sent to the external system with status Pending Acknowledged. Click the Message History Table link. Observe the original message with status of Error Retried. Why wasn't the original message sent again instead of creating a new message? Since the system is simulating an asynchronous response this means the reply plugin, transaction 4, is processing the reply. The original message was already successfully sent in the transport plugin, transaction 3. If a message reply fails in transaction 4, the system will execute reply acknowledgement code which typically will send a clone of the original message and move the original message to the message history table. What would happen if the reply is processed as a synchronous acknowledgement in the transport plugin? Since the error happens in the transport plugin, transaction 3, the system will automatically try to resend the original message based on the destination parameters. The last scenario will simulate an asynchronous duplicate acknowledgement. In the Message History Table screen, make note of the Sender Ref ID of a message with a status of Acknowledged. Click on the Message Acknowledgment link. Type the value of the Sender Ref ID. Click the External System Response field. Select Duplicate as the External System Response. Click the Send Response button. Click the Message History Table link. Observe the message now has a duplicate count value of 1. Since the message was already acknowledged, the system makes note that a duplicate response was received from the external system by increasing the duplicate count field. This ends the asynchronous acknowledgement scenarios demonstration. Click the Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil                                  Bye!                      \n\n--- In_17_01 ---\nThis demonstration will illustrate user authentication flow by implementing the training app, authentication plugins and setting breakpoints. This demonstration requires that you use training app, Guidewire Studio, and a supported web browser. First, register the training app, authentication plugins. Navigate to the plugin registry located under config.plugins.registry. Double-click on authentication source creator plugin to open the plugin. Remove the OSGI plugin by clicking on the remove plugin icon. Click on the add plugin icon. Select add Gozu plugin. Click on the ellipsis icon to search for a Gozu class. Type the name of the Gozu class in the search field. Double-click on the Gozu class name to select. Double-click on authentication service plugin to open. Remove the Java plugin. Restart the plugin plugin by clicking on the plugin plugin by clicking on the remove plugin icon. Click on the add plugin icon. Select add Gozu plugin. Click on the ellipsis icon to search for a Gozu class. Type the name of the Gozu class in the search field. Double-click on the Gozu class name to select. Restart the server since the plugin registries were modified. Click the stop server icon. Click the debugger. bug server icon to start the server. Next, set some breakpoints in the plugin Gozu classes to demonstrate the progression of user authentication. Press ctrl plus shift plus n to search for a Gozu class. Type the name of the Gozu class in the search field. Double-click on the Gozu file name to open. Click at line 13 to set a breakpoint. Press ctrl plus shift plus n to search for a Gozu class. Double-click on the Gozu class. Double-click on the Gozu class name to open. Click at line 22 to set a breakpoint. Click at line 26 to set a breakpoint. Click at line 39 to set a breakpoint. Now that the breakpoints are set, log in to training app and observe the progression of user authentication. Type the user name for super user. Type the password for super user. Click the login button. The user authentication process is triggered. The system breaks at line 13 in the custom authentication source creator plugin class. The source object was of type username password since the method did not throw an exception. The user name and password are extracted from the source object. The underscore handler variable is not null. Click the resume program button. The system breaks at line 26. The public ID is not null. If the public ID were null, then the system would throw a failed login exception error. Click the resume program button. The system breaks at line 39. The method will return a string value, public ID. The user is not null. Click the resume program button. Click the resume program button. After the last breakpoint, the user is logged into the system. This ends the user authentication flow demonstration.\n\n--- In_18_01 ---\nThis demonstration will create a batch process that checks if an A-B person has either a phone number or email. If they don't, flag the contact. This demonstration requires that you use TrainingApp, Guidewire Studio, and a supported web browser. Start by adding a type code to the flag entry reason type list to represent the new flag reason. Press Ctrl plus Shift plus N to search for the file. In the search field, type the name of the file. Double-click on the file name to open. Click on the Type Code button to add a new type code. Type the code value. Type the name value. Copy the name value and paste in the description field. Next, add a new type code to the batch process type type list to represent the new batch process. Press Ctrl plus Shift plus N to search for the file. In the search field, type the file name. Double-click on the file name to open. Click on the Type Code button to add a new type code. Type the code value. Type the name value. Copy the name value. Copy the name value and paste in the description field. Categorize the new type code with batch process type usage categories of schedulable and UI runnable. Right-click on the new type code. Select Add New and then Add Categories. Select the Categories. Select the Category Type Code. Click the next button. Categorize the new type code. Click the next button. Categorize the new type code. Select the new type code. Categorize the new type code. Click the next button. Categorize the new type code. Select the new type code. Select the new type code. Categorize the new type code. Select the new type code. Click the new type code. Click the finish button to save. Next, create a new package and GOSA class for the new batch process. Right-click on the GSRC package. Select New and then Package. Type the new package name. Click OK to save. Right-click on the new batch package. Select New and then GOSU class. Type the name of the new GOSU class. Click OK to save. The new GOSU class is created. Enter the code to meet the demonstration requirements. Examine the code. Line 9. The class extends batch process base. Lines 11 to 13. Construct method must call super. Passing appropriate type code value as an argument. Lines 15 to 17. The application calls the method to determine whether to start a batch process. Do not perform long-running operations such as a query. Guidewire recommends that you do not return false from the check initial conditions method unless the condition that triggered the false return value is likely to be temporary. If your overridden check initial conditions method returns false, the application freezes any ongoing work in the batch process. Sets the last run status value in the server tools batch process info screen to running. Executes the check initial conditions method once a minute unless the return value becomes true, or you click stop in the batch process info screen for this batch process, or the repeat attempts timeout. Stops executing the check initial conditions method after 10 minutes and generates an error message in the application log. No one started batch process after 600 seconds. Lines 19 to 22. The application may want to terminate a batch process, such as when, the process is run from the UI and the user clicks stop. The process is run from the API and the stop process command is received. The application is shutting down. The terminated requested property is checked in the do work method. Line 24. Override the do work method. Lines 26 to 31. Query looking for persons with no phone or email. Line 34. Set operations expected with the number of items to be processed. Line 37. Set a reasonable page size to minimize memory usage. Line 39. Chunk up each page to keep the bundle size reasonable. Line 41. Potential fails variable tracks the number of flags in the bundle in case the bundle fails. Lines 45 to 47. Check if termination is requested prior to starting the bundle. Line 49 to 61. Flag the contact if they have not been flagged already. Specify the user to commit the bundle. Line 57. Increment an internal counter for how many operations are completed. Line 62 to 71. Increment operations failed by the number of flags in the bundle. This is the sole reason for the try slash catch. Line 73 to 75. Check if termination is requested after each bundle. Line 73 to 71. Next, modify the existing process plugin class to include the new batch process. Note, the process plugin has not been created in all products, and if it has not been previously created it is up to the implementer to do so. Press CTRL plus SHIFT plus N to search for a file. In the search field, type the name of the file. Double click on the file name to open. Line 6. Add a uses statement with the path to the new GoTo class. Lines 14 to 15. Add a case statement for the new batch process. Restart the server to deploy all code changes. Click the Stop Server button. Click the Debug Server button to start the server. To test the batch process, log in to TrainingApp and run the batch process manually. Type the username for SuperUser. Type the password for SuperUser. Click the Login button. Press Alt plus SHIFT plus T to open Internal Tools page. Click the Run button to execute the flag no email or phone batch process. In Studio, examine the console output. A list of flagged contacts is displayed. Make a note of a contact and search for them in the UI to verify that a flag was added. Click the Gear button. Select Return to Training App link. Type the name of the contact in the search field. Click the Search button. In the search results, select the Contact link. The no email or phone flag was added to the contact. This ends the Create a Custom Batch Process demonstration. Click the Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil \n\n--- In_19_01 ---\nThis demonstration will step through the process of adding and removing a document using the default out-of-the-box DMS implementation. This demonstration requires that you use ClaimCenter, Guidewire Studio, and a supported web browser. Since this is the default implementation, the iDocument metadata source is not implemented and enabled. This means that the document metadata is stored in the Application Database document table. The iDocument Content Source plugin is implemented by the AsyncDocumentContentSource class. Press Ctrl plus Shift plus N to search for and open the AsyncDocumentContentSource class. In the search field, type the name of the file. Double-click on the file name to open. To facilitate the analysis of the Add Document process, make a small change to the code at line 80 in the Add Document method. Add code to the Add Document method. Click at line 82 to submit the code to the Add Document method. Set a breakpoint. Click at line 101 to set a breakpoint. Click Run and then Reload Changed Classes to deploy changes. Next, log in to ClaimCenter as Superuser since this user can add and remove a document. Type the username for Superuser. Type the password for Superuser. Click the login button. Click the login button. Click the search link. Type Newton in the Last Name Search field. Click the Search button to search for all Newton claims. In the search results, select the link for the Ray Newton claim. Click on the Documents link. Click on the Select button. Select Create from a Template. Click on the Search icon to search for a document template. In the search results, click on the Select button for an Excel sample template. Click on the Create Document button to generate a document based on the selected template. Click on the Update button to save the new document. Click on the Select button. The system breaks at line 82. Add Document method. Notice, this method returns False since the iDocument metadata source plugin is not implemented and enabled. The method will add a new content file to the Application Server file system. The metadata will be saved in the Application Database document table. Click the Resume Program button to resume the operation. In Claim Center, note that the document was added to the claim. In Studio, write a query. Select the query in GoTo Scratchpad to verify that the metadata was saved to the document table in the Application Database. Click Run and then GoTo Scratchpad. In GoTo Scratchpad, add the query to output the metadata saved in the document table. Click the Run and Debug Process icon to execute the query. In the Console output, the metadata is displayed. The new document, Excel sample, is highlighted. In Claim Center, click the Delete Document from Claim Trash icon to remove the document from the system. Click OK to continue. The system breaks at line 101. Remove Document method. This method will remove the content file from the Application Server file system and remove the metadata from the Document Database table. Click Resume Program icon to resume the operation. To verify that the metadata was removed from the Document Database table. Execute the query in GoTo Scratchpad again. Click on the GoTo Scratchpad tab. Click the Run and Debug Process icon to execute the query. In the Console output, the Excel sample metadata is removed. In Claim Center, the Excel sample document was removed. This sends the Analyze default out of the box DMS implementation demonstration. Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil Fil                                                                          ",
  "generated_at": "2026-02-13T12:52:43.441675"
}