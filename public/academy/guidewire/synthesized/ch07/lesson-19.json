{
  "lessonId": "ch07-l19",
  "chapterId": 7,
  "chapterSlug": "ch07",
  "lessonNumber": 19,
  "title": "Introduction to Partial Page Update",
  "subtitle": "Learn to create dynamic, responsive user interfaces with partial page updates in Guidewire.",
  "synthesizedAt": "2026-02-16T18:12:15.856946+00:00",
  "estimatedMinutes": 45,
  "blocks": [
    {
      "type": "hook",
      "id": "hook-1",
      "scenario": "Imagine you're developing an insurance application. When a user selects 'Yes' for 'Inspection Required?', a new 'Inspection Date' field should immediately appear. Or, when they enter an 'Affinity Group Name,' related business details should automatically populate without a full page reload. Without this, users would face a clunky, frustrating experience.",
      "question": "How can we make our application interfaces respond dynamically to user input in real-time, without requiring a full page refresh?"
    },
    {
      "type": "objectives",
      "id": "obj-1",
      "objectives": [
        "Identify properties associated with dynamic widget behaviors",
        "Describe common ways to configure a partial page update",
        "Enable and configure targeted Post On Change for a widget"
      ],
      "estimatedMinutes": 3
    },
    {
      "type": "activate",
      "id": "act-1",
      "priorKnowledge": "You should be familiar with basic UI configuration in Guidewire Studio and how to set static properties for widgets. You might also have some exposure to Gosu expressions.",
      "warmupQuestion": "Think about a time you've used an application where a field appeared or changed based on another selection. How do you think that dynamic behavior is achieved in a web application?",
      "hint": "Consider how web pages typically update content without reloading the entire page."
    },
    {
      "type": "concept",
      "id": "concept-1",
      "heading": "Understanding Dynamic Widget Properties",
      "narrative": "In Guidewire applications, widgets can have two kinds of properties: **static** and **dynamic**. Static properties, like a widget's `id`, evaluate to a fixed, immutable value that never changes. Dynamic properties, however, are much more powerful. They evaluate an expression—often a Gosu expression—after a user navigates to a page or clicks 'Update', returning a value that can change based on business logic or data. This allows for flexible UI behavior.\n\nCommon dynamic properties include `editable`, `label`, and `value`, which can return boolean, string, or object expressions respectively. For example, the `value` property of a widget is inherently dynamic, as it evaluates an object expression to display data. Not all widgets possess every property, so it's essential to consult the PCF Format Reference (which refers to properties as 'attributes') for specific widget details.\n\nSeveral key dynamic properties control widget visibility and interaction:\n*   **Available**: A boolean expression that, if `false`, grays out the widget and its children.\n*   **Editable**: A boolean expression that, if `false`, makes the widget and its children read-only.\n*   **Required**: A boolean expression that, if `true`, mandates user input for the field.\n*   **Visible**: A boolean expression that, if `false`, completely hides the widget and its children. By default, `visible` is `true` and is typically set to an expression rather than a static `false`.\n\nLet's look at some practical examples. You can make a `State` field required only when a `License Number` has a value, as shown in the figure. Similarly, a button can be made `visible` only when there are one or more bank accounts associated with a contact, providing a cleaner UI by hiding irrelevant actions until needed.",
      "keyPoints": [
        "Static properties are immutable; dynamic properties evaluate expressions.",
        "Dynamic properties like `editable`, `required`, `visible`, and `available` control widget behavior.",
        "Gosu expressions are commonly used to define dynamic property values.",
        "The PCF Format Reference is the definitive source for widget property details."
      ],
      "figures": [
        {
          "slideNumber": 3,
          "caption": "An overview of widget properties and their configuration."
        },
        {
          "slideNumber": 4,
          "caption": "Comparison of static and dynamic widget properties, with examples."
        },
        {
          "slideNumber": 5,
          "caption": "Key dynamic properties that evaluate expressions to control UI elements."
        },
        {
          "slideNumber": 6,
          "caption": "Example of using the `required` dynamic property to enforce data entry based on another field's value."
        },
        {
          "slideNumber": 7,
          "caption": "Example of using the `visible` dynamic property to show a button only when relevant data exists."
        }
      ],
      "callouts": [
        {
          "type": "definition",
          "title": "Dynamic Property",
          "content": "A widget property that evaluates an expression (often Gosu) to determine its value, allowing for flexible UI behavior based on data or business logic."
        },
        {
          "type": "tip",
          "title": "PCF Format Reference",
          "content": "Always refer to the PCF Format Reference (les\\pcf.htm) for comprehensive details on widget properties and their expected value types. It's your go-to guide for UI configuration."
        }
      ]
    },
    {
      "type": "concept",
      "id": "concept-2",
      "heading": "Dynamic Behavior and Partial Page Updates",
      "narrative": "While dynamic properties are evaluated after a page loads or updates, **dynamic behavior** takes this a step further: it evaluates widget property expressions *while* a user is actively changing business data. This means the UI can react immediately to uncommitted data changes, providing a highly interactive experience. This real-time responsiveness is achieved through **Partial Page Updates**.\n\nA Partial Page Update allows specific parts of a page to be re-rendered or updated with new data without reloading the entire page. This significantly improves user experience by making the application feel more responsive and reducing server round-trips for minor UI changes. There are two main types of partial page updates:\n\n1.  **Layout Re-render**: This type responds to user changes by altering the layout of widgets on the screen. For instance, if a user selects 'Yes' for 'Did agent inspect vehicles?', a secondary question and a 'Date Input' widget might immediately become visible. When a layout re-render occurs, all user-editable data is sent from the client to the application server. The server processes the request and returns instructions and the updated user-editable data to the client, which then re-renders the affected layout. Crucially, no data is committed during this process. Layout re-renders apply to dynamic widget properties such as `visible`, `editable`, `available`, and `required`.\n\n2.  **DATA_ONLY**: This type also responds to user changes in real-time but focuses on updating data within existing widgets rather than changing the layout. For example, if a user changes the 'Affinity Group Name' field, values for other fields like 'Year Business Started' and 'Description of Business and Operations' might be automatically rendered with new data (often read-only in the UI). In a DATA_ONLY update, only the changed information is sent to the server. The server processes it and returns only the newly supplied data to the client, which then updates only those specific data fields. This type of update applies primarily to the `value` property of a widget and is commonly used for refreshing input groups or updating fields based on cell changes in a list view.\n\nBoth types of partial page updates require specific configuration to enable this dynamic behavior, which we will explore next.",
      "keyPoints": [
        "Dynamic behavior evaluates widget properties in real-time as users change data.",
        "Partial Page Update enables dynamic behavior without full page reloads.",
        "Layout Re-render changes widget visibility, editability, or layout.",
        "DATA_ONLY updates specific data fields without altering layout.",
        "No data is committed during either type of partial page update."
      ],
      "figures": [
        {
          "slideNumber": 8,
          "caption": "Distinguishing between dynamic properties (committed data) and dynamic behavior (uncommitted data)."
        },
        {
          "slideNumber": 9,
          "caption": "An overview of how dynamic behavior leads to partial page updates."
        },
        {
          "slideNumber": 10,
          "caption": "Example of a Layout Re-render: a field appearing based on a 'Yes/No' selection."
        },
        {
          "slideNumber": 11,
          "caption": "Details on Layout Re-render, including affected properties and client-server interaction."
        },
        {
          "slideNumber": 12,
          "caption": "Example of a DATA_ONLY update: other fields updating based on a single input change."
        },
        {
          "slideNumber": 13,
          "caption": "Details on DATA_ONLY updates, including affected properties and client-server interaction."
        }
      ],
      "callouts": [
        {
          "type": "definition",
          "title": "Partial Page Update",
          "content": "A mechanism that allows portions of a web page to be updated dynamically in response to user input, without requiring a full page reload, enhancing user experience and application responsiveness."
        },
        {
          "type": "best_practice",
          "title": "Performance Consideration",
          "content": "While powerful, be mindful of the scope of partial page updates. A full page re-render (without specifying a target) can have a high performance cost, especially on complex pages. Targeted updates are generally more efficient."
        }
      ]
    },
    {
      "type": "demo",
      "id": "demo-1",
      "videoIndex": 0,
      "context": "This demonstration illustrates how to implement business logic using Gosu enhancements to calculate values, which often serve as the foundation for dynamic UI updates. Pay attention to how new Gosu functions are created and integrated into the application's data model.",
      "transcriptSummary": "The demo showcases the implementation of business logic for calculating down payment and installment amounts. It involves creating a new Gosu enhancement for the Policy entity, defining two Gosu functions (`calculateDownPayment` and `calculateInstallment`) to perform these calculations, and then adding uneditable monetary amount input widgets to the Policy popup PCF to display the results. This process highlights how to extend entity behavior and integrate calculated values into the UI."
    },
    {
      "type": "concept",
      "id": "concept-3",
      "heading": "Configuring Targeted Post On Change",
      "narrative": "To enable dynamic behavior and partial page updates, you configure **Post On Change** properties for a widget. This tells the application to immediately send a change to the server when the widget's value is altered, rather than waiting for a full page submission.\n\nTwo primary Post On Change properties are:\n*   **onChange**: This property defines a Gosu expression to invoke when the user changes the widget's value. It causes an immediate post-back to the server, triggering the dynamic behavior. For example, an `onChange` expression might call a function like `setFieldsOnResolution()` to update other fields based on the current widget's value.\n*   **disablePostOnEnter**: If evaluated to `true` when the page is rendered, this field will not trigger a Post On Change. The widget will not announce a change in its value, preventing a round-trip to the server and any subsequent page re-rendering or data refresh. This is useful for optimizing performance by preventing unnecessary updates for certain conditions, such as when a currency is not USD.\n\nIn earlier versions of InsuranceSuite, a `target` property was also used to specify the area to be re-rendered. This `target` could be a specific widget ID or a grouping of widgets (like an Input Set). The `update` property (within `target`) would then specify whether it was a `Layout re-render` or `DATA_ONLY` update. If no `target` or `update` properties were specified, it would default to re-rendering the entire page, which had a high performance cost.\n\n**Important Note**: In current InsuranceSuite applications, targeted updates are often automatic for any widget where Targeted Post On Change is enabled. This means the `target` property is largely redundant, simplifying configuration and improving performance by default. The system intelligently determines the minimal area to update.",
      "keyPoints": [
        "Post On Change properties trigger immediate server interaction upon widget value change.",
        "`onChange` invokes a Gosu expression and causes a post-back to the server.",
        "`disablePostOnEnter` can prevent Post On Change behavior under specific conditions.",
        "In earlier versions, the `target` property specified the re-render area (widget ID, `Layout re-render`, or `DATA_ONLY`).",
        "Current InsuranceSuite versions often handle targeted updates automatically, making the `target` property redundant."
      ],
      "figures": [
        {
          "slideNumber": 16,
          "caption": "Configuration of `onChange` and `disablePostOnEnter` properties for Post On Change behavior."
        },
        {
          "slideNumber": 17,
          "caption": "The `target` property (for earlier versions) to specify the area and type of partial page update."
        },
        {
          "slideNumber": 18,
          "caption": "An example of configuring targeted Post On Change for a widget."
        }
      ],
      "callouts": [
        {
          "type": "best_practice",
          "title": "Optimize Post On Change",
          "content": "Use `disablePostOnEnter` to prevent unnecessary server round-trips when dynamic updates are not required under certain conditions, improving application performance."
        },
        {
          "type": "gotcha",
          "title": "Legacy Target Property",
          "content": "Be aware that the `target` property is mostly for backwards compatibility. In modern Guidewire versions, the system often intelligently handles which parts of the page need to be updated when Post On Change is enabled, making explicit `target` configuration less common."
        }
      ]
    },
    {
      "type": "practice",
      "id": "practice-1",
      "level": "guided",
      "scenario": "You are tasked with enhancing a policy submission form. The form includes a dropdown for 'Policy Type' and a text input for 'Special Conditions'. The 'Special Conditions' field should only appear if 'Policy Type' is set to 'Commercial'.",
      "question": "How would you configure the 'Special Conditions' widget and the 'Policy Type' dropdown to achieve this dynamic behavior?",
      "hints": [
        "Which dynamic property controls whether a widget is shown or hidden?",
        "What kind of expression does this property typically take?",
        "What needs to be enabled on the 'Policy Type' dropdown to trigger an immediate update when its value changes?"
      ],
      "expectedApproach": "Configure the `visible` property of the 'Special Conditions' widget with a boolean Gosu expression that checks if the 'Policy Type' dropdown's value is 'Commercial'. Then, enable 'Targeted Post On Change' on the 'Policy Type' dropdown to ensure the page updates immediately when the selection changes."
    },
    {
      "type": "knowledge_check",
      "id": "kc-1",
      "question": "Name two properties that evaluate expressions.",
      "referenceAnswer": "Possible answers include:\n* editable\n* required\n* visible\n* available",
      "questionKey": "slide-19"
    },
    {
      "type": "knowledge_check",
      "id": "kc-2",
      "question": "Howis a partial page update implemented?",
      "referenceAnswer": "A partial page update is implemented by configuring dynamic widget behavior by enabling targeted post on change. Often the dynamic widget behavior configuration also includes configuring an expression for a widget property.",
      "questionKey": "slide-21"
    },
    {
      "type": "knowledge_check",
      "id": "kc-3",
      "question": "Whatare the three properties that you can configure for a widget with\n¢ targeted Post On Change enabled?",
      "referenceAnswer": "disablePostOnEnter, onChange, and (with earlier InsuranceSuite versions) target.",
      "questionKey": "slide-23"
    },
    {
      "type": "summary",
      "id": "summary-1",
      "keyTakeaways": [
        "Dynamic widget properties use expressions to control UI behavior (e.g., visible, editable, required).",
        "Partial page updates enable real-time dynamic behavior without full page reloads, enhancing user experience.",
        "There are two types of partial page updates: Layout Re-render (changes UI structure) and DATA_ONLY (updates data within existing UI).",
        "Post On Change properties (`onChange`, `disablePostOnEnter`) trigger immediate server interaction for dynamic updates.",
        "While older versions used a `target` property, modern Guidewire applications often handle targeted updates automatically."
      ],
      "realWorldConnection": "Mastering partial page updates is crucial for building modern, responsive, and efficient Guidewire applications. By making forms and interfaces react dynamically to user input, you significantly improve user satisfaction, reduce data entry errors, and streamline workflows in real Guidewire projects. This leads to a more intuitive and productive experience for end-users, directly impacting operational efficiency.",
      "nextLessonPreview": "In the next lesson, we will delve deeper into advanced Gosu expressions and common pitfalls when implementing complex dynamic behaviors."
    },
    {
      "type": "assignment",
      "id": "assign-1",
      "description": "Implement a partial page update scenario in Guidewire Studio. Create a new PCF or modify an existing one to include two fields: a 'Checkbox' and a 'Text Input'. The 'Text Input' should only become visible when the 'Checkbox' is checked. Ensure the visibility change happens immediately without a full page refresh.",
      "objectives": [
        "Configure a dynamic `visible` property for a widget using a Gosu expression.",
        "Enable targeted Post On Change for a driving widget (the Checkbox).",
        "Test and observe the real-time dynamic behavior in the Guidewire application UI."
      ]
    }
  ],
  "videos": [
    {
      "index": 1,
      "filename": "IS_Fund_19.mp4",
      "path": "/academy/guidewire/videos/ch07/IS_Fund_19.mp4"
    }
  ]
}