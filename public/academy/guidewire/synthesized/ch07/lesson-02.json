{
  "lessonId": "ch07-l02",
  "chapterId": 7,
  "chapterSlug": "ch07",
  "lessonNumber": 2,
  "title": "Introduction to the Data Model",
  "subtitle": "Explore Guidewire's metadata-driven architecture, core components, and how to extend the data model.",
  "synthesizedAt": "2026-02-16T17:57:33.871652+00:00",
  "estimatedMinutes": 65,
  "blocks": [
    {
      "type": "hook",
      "id": "hook-1",
      "scenario": "Imagine a client needs to add a new field to capture specific information about their contacts, or even an entirely new type of business object. How would you, as a Guidewire developer, implement these changes without rewriting core application code?",
      "question": "What if the solution lies not in complex coding, but in simple configuration?"
    },
    {
      "type": "objectives",
      "id": "obj-1",
      "objectives": [
        "Understand the metadata-driven architecture of the Guidewire data model.",
        "Explain how XML configuration files are used to extend the data model.",
        "Identify core data model components, including entities, fields, and typelists.",
        "Describe how supertype and subtype entities are used for efficient data modeling.",
        "Differentiate between how various data model components are stored in the database.",
        "Utilize the Data Dictionary to navigate and understand the application's data structure.",
        "Apply data model extension principles to meet specific business requirements."
      ],
      "estimatedMinutes": 5
    },
    {
      "type": "activate",
      "id": "act-1",
      "priorKnowledge": "You've likely worked with databases or data structures before, where information is organized into tables and fields, and relationships link different pieces of data. Guidewire builds on these fundamental concepts but introduces a powerful metadata-driven approach.",
      "warmupQuestion": "Think about a time you needed to add a new piece of information to an existing system. What challenges did you face?",
      "hint": "Consider how changes might impact existing code or database schema."
    },
    {
      "type": "concept",
      "id": "concept-1",
      "heading": "The Extensible Guidewire Data Model",
      "narrative": "One of the most significant advantages of the Guidewire platform is its inherent extensibility. At its core, Guidewire applications use a **metadata-driven architecture** to define data objects. This means that instead of hardcoding every aspect of the data structure, Guidewire relies on XML configuration files to describe entities, fields, and their relationships. This approach drives both how data is persisted in the database and how Gosu and Java interfaces interact with these objects.\n\nThis architecture provides immense power and flexibility. As a developer, you can extend the application's capabilities by modifying existing XML files or adding entirely new ones. These modifications are known as **extensions**. For example, you might need to add a new custom field to an existing entity like `User` to capture specific business information, or even declare entirely new entities to represent unique business objects. The complete data model of your Guidewire application installation comprises the base application model and all the data model extensions you create. Understanding how to effectively manage these extensions is a critical skill, enabling you to tailor the application to meet specific organizational needs, making your implementation both flexible and robust.",
      "keyPoints": [
        "Guidewire uses a metadata-driven architecture for data objects.",
        "Data model modifications are made through XML configuration files and are called extensions.",
        "Extensions allow adding new fields to existing entities or creating entirely new entities.",
        "The data model drives database persistence and Gosu/Java interfaces."
      ],
      "figures": [
        {
          "slideNumber": 3,
          "caption": "Overview of how the Guidewire Data Model is modified through XML configuration files."
        },
        {
          "slideNumber": 4,
          "caption": "Illustrates the metadata-driven nature of the Guidewire data model, showing how XML definitions generate database tables and Gosu/Java classes."
        }
      ],
      "callouts": [
        {
          "type": "definition",
          "title": "Metadata-Driven Architecture",
          "content": "A system design where the behavior and structure of an application are defined by metadata (data about data) rather than being hardcoded. In Guidewire, this means XML files define the data model, which then drives database schema and application logic."
        }
      ]
    },
    {
      "type": "concept",
      "id": "concept-2",
      "heading": "Core Data Model Components: Entities and Fields",
      "narrative": "At the heart of any Guidewire application are **entities**, which represent high-level business objects like `ABContact`, `Policy`, or `Claim`. These entities serve as the root objects for various application components, including PCF files and Gosu rules. Guidewire provides a set of base entities, and you can extend these or define entirely new ones using XML elements in entity metadata definition files.\n\nEach entity defines a set of **fields** to store information. These fields can be categorized into several types:\n\n*   **Data Fields (Column Fields)**: These store single, primitive values that do not reference other objects or tables. They are typically defined with the `<column>` element in XML and map directly to columns in a database table. Examples include `Name` (varchar), `CreateTime` (datetime), or `Score` (integer). It's important to note that while many data fields map to database columns, not all do (e.g., virtual fields, which we'll discuss later).\n\n*   **Foreign Key Fields**: These fields establish relationships between entities by storing a reference to a related object. They define a unidirectional relationship. For instance, an `AssignedUser` field in an `ABContact` entity would be a foreign key pointing to a `User` entity, linking a contact to the user responsible for it.\n\n*   **Array Fields**: Array fields allow an entity to associate with a collection of additional entities of the same type. For example, an `ABContact` entity might have an array field for `ContactNotes`, meaning a single `ABContact` can have zero, one, or many `ContactNote` entities associated with it. This enables efficient querying of related data.\n\n*   **Typekey Fields**: These fields are associated with **typelists**, which are predefined sets of possible values. Typelists limit the acceptable values for fields, often rendered as drop-down lists in the user interface. A typekey field points to exactly one value within a specific typelist, ensuring data consistency and simplifying data management. For example, a `ContactTier` field might be a typekey referencing a typelist with values like 'Platinum', 'Gold', or 'Silver'.",
      "keyPoints": [
        "Entities are high-level business objects, serving as roots for application components.",
        "Fields define information within entities and can be data, foreign key, array, or typekey.",
        "Data fields (columns) store primitive values and often map to database columns.",
        "Foreign key fields link entities, establishing relationships.",
        "Array fields store collections of related entities.",
        "Typekey fields reference typelists, which are predefined sets of enumerated values for consistency."
      ],
      "figures": [
        {
          "slideNumber": 5,
          "caption": "Illustrates core data model entities like ABContact, Policy, and Account, and lists the types of fields that can be added."
        },
        {
          "slideNumber": 6,
          "caption": "Explains data fields, typically defined with the `<column>` element, storing single values like Name or CreateTime."
        },
        {
          "slideNumber": 7,
          "caption": "Demonstrates foreign key fields, which store references to related objects, using `AssignedUser` as an example."
        },
        {
          "slideNumber": 8,
          "caption": "Shows array fields, which associate multiple entities of the same type with a main entity, such as `ContactNotes` for `ABContact`."
        },
        {
          "slideNumber": 9,
          "caption": "Explains typelists and typekey fields, where typelists provide predefined values (e.g., 'Platinum', 'Gold') that typekey fields reference."
        }
      ],
      "callouts": [
        {
          "type": "definition",
          "title": "Entity",
          "content": "A high-level business object in Guidewire, such as `ABContact` or `Policy`, that serves as a root for data and application logic."
        },
        {
          "type": "definition",
          "title": "Typelist",
          "content": "A predefined, enumerated set of possible values that limits acceptable values for fields within the application, often rendered as a drop-down list."
        },
        {
          "type": "definition",
          "title": "Typekey Field",
          "content": "An entity field associated with a specific typelist, allowing it to point to exactly one value in that typelist."
        }
      ]
    },
    {
      "type": "concept",
      "id": "concept-3",
      "heading": "Supertype and Subtype Entities for Inheritance",
      "narrative": "Guidewire's data model supports **supertype and subtype entities**, a powerful mechanism for organizing related entities into a hierarchy and leveraging inheritance. If multiple entities share a common set of fields with the same business purpose, they can be grouped under a supertype (or parent) entity. The subtype (or child) entities then inherit all fields and methods from their supertype.\n\nFor example, `ABContact` often serves as an abstract supertype entity. An abstract entity cannot be directly instantiated, but its subtypes can. `ABPerson` and `ABCompany` are common subtypes of `ABContact`. Instead of defining fields like `TaxID` or `EmailAddress1` separately in both `ABPerson` and `ABCompany`, these common fields are defined once in `ABContact`. Both `ABPerson` and `ABCompany` then inherit these fields, eliminating redundancy and ensuring consistency across related contact types.\n\nThis design pattern is crucial for creating a clean, organized, scalable, and maintainable data model. It optimizes the data structure by centralizing common attributes and behaviors, making it easier to manage and extend the application as business requirements evolve. Understanding and effectively utilizing supertype/subtype relationships is a key aspect of advanced Guidewire data modeling.",
      "keyPoints": [
        "Supertype and subtype entities organize related data into hierarchies.",
        "Subtype entities inherit fields and methods from their supertype.",
        "This mechanism reduces data redundancy and promotes consistency.",
        "Abstract supertypes cannot be instantiated directly, only their subtypes can."
      ],
      "figures": [
        {
          "slideNumber": 10,
          "caption": "Illustrates the concept of supertype (subtyped) entities, showing how ABContact acts as a supertype for ABPerson, ABCompany, ABAttorney, and ABDoctor, enabling inheritance."
        },
        {
          "slideNumber": 11,
          "caption": "Provides an example of how ABContact as a supertype allows ABPerson and ABCompany to inherit common fields, optimizing the data model."
        }
      ],
      "callouts": [
        {
          "type": "definition",
          "title": "Supertype (Subtyped) Entity",
          "content": "A parent entity in a hierarchy from which other entities (subtypes) inherit fields and methods, promoting reusability and consistency."
        },
        {
          "type": "definition",
          "title": "Subtype Entity",
          "content": "A child entity that inherits all fields and methods from its supertype, allowing for specialized data while maintaining common attributes."
        }
      ]
    },
    {
      "type": "concept",
      "id": "concept-4",
      "heading": "Data Model Components and Database Storage",
      "narrative": "Understanding how Guidewire data model components are stored in the database is crucial for effective development and performance optimization. While most entities are **persistent**, meaning their data is stored in dedicated database tables, there are important nuances:\n\n*   **Entities**: Often, an entity stores data in a database table named after the entity (e.g., `ABContact` entity data in `ab_abcontact` table). However, **non-persistent (virtual) entities**, like `ABContactSearchCriteria`, exist only at runtime and are not saved to the database. They are constructed entirely with code and their data is lost when the application shuts down. Guidewire generally recommends against creating non-persistent entities unless absolutely necessary.\n\n*   **Subtype Entities**: A top-level supertype entity and all its child subtypes are stored in a *single database table*. This means all entities within that hierarchy share the same table. The table contains all parent fields and all subtype-specific fields. Irrelevant fields for a particular subtype instance will be `null`. A `Subtype` column in the table identifies the specific subtype of each row. For example, `FirstName` and `LastName` would be null for an `ABCompany` subtype within the `ab_abcontact` table.\n\n*   **Physical Data Fields**: These are defined as `<column>` elements and are stored as physical columns in the database table corresponding to the entity.\n\n*   **Virtual Data Fields**: Unlike physical fields, virtual fields are not stored in the database. Their values are computed at runtime, typically using Gosu code within **Entity Enhancements**. For example, a `FullName` virtual field might concatenate `FirstName`, `MiddleName`, and `LastName` fields. This provides flexibility in data presentation without altering the database schema.\n\n*   **Foreign Key Fields**: These are stored as foreign key columns in the database table, linking to the primary key (ID) of the related entity's table.\n\n*   **Array Fields**: Array fields themselves are *not* stored directly in the database. Instead, they are managed dynamically at runtime. When an array field is referenced (e.g., `ericAndy.ContactNotes`), Guidewire queries the database for all related objects (e.g., `ContactNote` objects) whose foreign key points back to the parent entity (`ericAndy`). To enable this, every array on the main entity must have a reverse foreign key pair on the associated additional entity.\n\n*   **Typelists and Typekey Fields**: Each typelist is stored in its own dedicated database table, typically prefixed with the application code and `tl_` (e.g., `ab_abcontacttl_vendortype`). These are predefined, fixed tables. A typekey field, on the other hand, is stored as a foreign key column in the entity's table, referencing a single row in the corresponding typelist table.",
      "keyPoints": [
        "Most entities are persistent and stored in database tables.",
        "Non-persistent (virtual) entities exist only at runtime and are not stored in the database.",
        "Supertype and all its subtype entities share a single database table, with a `Subtype` column identifying the specific type.",
        "Physical data fields are stored as database columns.",
        "Virtual data fields are computed at runtime via Gosu code in Entity Enhancements and are not stored in the database.",
        "Foreign key fields are stored as foreign key columns.",
        "Array fields are not stored directly but are populated at runtime by queries based on reverse foreign keys.",
        "Typelists are stored in their own dedicated database tables, while typekey fields are foreign key columns referencing these typelist tables."
      ],
      "figures": [
        {
          "slideNumber": 12,
          "caption": "An overview slide emphasizing the importance of understanding how entities and their relationships are stored in the database."
        },
        {
          "slideNumber": 13,
          "caption": "Explains how entities (persistent, virtual, and subtype) are stored in the database, showing an example of the `ab_abcontact` table."
        },
        {
          "slideNumber": 14,
          "caption": "Differentiates between physical and virtual data fields, illustrating how a `FullName` virtual field is computed from physical fields using Gosu."
        },
        {
          "slideNumber": 15,
          "caption": "Shows how foreign key fields are stored as foreign key columns, linking entities like `ABContact` to `User`."
        },
        {
          "slideNumber": 16,
          "caption": "Explains that array fields are not stored directly but are populated at runtime by queries, requiring a reverse foreign key on the associated entity."
        },
        {
          "slideNumber": 17,
          "caption": "Illustrates how typelists are stored in dedicated tables and typekey fields are foreign key columns referencing these typelist tables."
        },
        {
          "slideNumber": 18,
          "caption": "Details how subtype entities are stored within the supertype's table, with a `SUBTYPE` column and null values for irrelevant fields, and how a virtual typelist is automatically created."
        }
      ],
      "codeExamples": [
        {
          "language": "gosu",
          "title": "Virtual Field Calculation in Gosu",
          "code": "FullName = FirstName + \" \" + MiddleName + \" \" + LastName",
          "explanation": "This Gosu code snippet demonstrates how a virtual field named `FullName` is computed by concatenating the values of `FirstName`, `MiddleName`, and `LastName`. This logic would typically reside in an Entity Enhancement."
        }
      ],
      "callouts": [
        {
          "type": "definition",
          "title": "Virtual Field",
          "content": "A field whose value is computed at runtime by Gosu code (often in an Entity Enhancement) rather than being stored directly in a database column."
        }
      ]
    },
    {
      "type": "concept",
      "id": "concept-5",
      "heading": "Navigating the TrainingApp Data Model and Data Dictionary",
      "narrative": "To effectively work with Guidewire, it's essential to understand the application's specific data model. In the **TrainingApp**, the data model is centered around the `ABContact` entity, which manages contact information and is extensively subtyped for various contact types (e.g., `ABPerson`, `ABCompany`). This core entity interacts with several other entities to form a comprehensive data structure, including:\n\n*   `Address`: Stores address details, with `ABContact` having one-to-many addresses.\n*   `HistoryEntry`: Records important occurrences in a contact's life, with `ABContact` having one-to-many history entries.\n*   `FlagEntry`: Stores issues pertaining to an `ABContact` that require attention.\n*   `ContactNote`: Captures free-form text notes about an `ABContact`.\n*   `BankAccount`, `ServiceEvaluation`, `User`, and `FinancialSummary`: These entities store related information, with `ABContact` having zero-to-many or zero-to-one relationships with them.\n\nTo navigate and understand this intricate web of entities and relationships, Guidewire provides an invaluable tool: the **Data Dictionary**. This comprehensive resource documents all entities and typelists within your application. It offers three distinct views, each serving a different purpose:\n\n1.  **Standard View**: Provides a full set of entities, their columns, typekeys, arrays, foreign keys, and subtypes. This is your primary resource for understanding the application's data structure.\n2.  **Migration View**: Offers a subset of information more useful for converting data from legacy applications.\n3.  **Database View**: Shows only persistent entities and their physical database structure.\n\nThe Data Dictionary is not pre-generated upon installation; you must generate it using the `gwb genDataDictionary` command. You should also regenerate it anytime you extend the data model to validate your changes and refresh the static HTML pages. This ensures you always have an up-to-date reference for your application's data structure.",
      "keyPoints": [
        "The TrainingApp data model revolves around the `ABContact` entity and its subtypes.",
        "Key related entities include `Address`, `HistoryEntry`, `FlagEntry`, `ContactNote`, `BankAccount`, `ServiceEvaluation`, `User`, and `FinancialSummary`.",
        "The Data Dictionary documents all entities and typelists in a Guidewire application.",
        "It offers Standard, Migration, and Database views.",
        "The `gwb genDataDictionary` command is used to generate and refresh the Data Dictionary."
      ],
      "figures": [
        {
          "slideNumber": 19,
          "caption": "An overview of the TrainingApp data model, highlighting the central role of the ABContact entity and its relationships with other entities."
        },
        {
          "slideNumber": 20,
          "caption": "A detailed diagram of the TrainingApp data model, showing ABContact and its relationships with entities like Address, HistoryEntry, FlagEntry, and ContactNote."
        },
        {
          "slideNumber": 21,
          "caption": "Introduces the Guidewire Data Dictionary as a crucial resource for developers."
        },
        {
          "slideNumber": 22,
          "caption": "Explains what the Data Dictionary is, its three main views (Standard, Migration, Database), and when to use the `gwb genDataDictionary` command."
        }
      ],
      "callouts": [
        {
          "type": "best_practice",
          "title": "When to Generate the Data Dictionary",
          "content": "Execute the `gwb genDataDictionary` command immediately after a clean installation of a Guidewire application, and anytime you extend the Data Model. This validates your changes and refreshes the static HTML pages, ensuring your documentation is always current."
        }
      ]
    },
    {
      "type": "demo",
      "id": "demo-1",
      "videoIndex": 0,
      "context": "This demonstration will walk you through generating the Data Dictionary using the `gwb` command and then navigating its different views. Pay close attention to how the Data Dictionary provides detailed insights into entities, fields, and their relationships, which is crucial for understanding and extending the Guidewire data model.",
      "transcriptSummary": "The video demonstrates using the `gwb genDataDictionary` Gradle command to generate the Data Dictionary, explaining the `xcompile` flag for faster generation. It then shows how to open and navigate the Data Dictionary HTML files, highlighting the three entity views (full, database, migration) and the typelists and all fields views. The demo focuses on the `ABContact` entity, explaining its header, database table name, implemented delegates, description, and attributes."
    },
    {
      "type": "practice",
      "id": "practice-1",
      "level": "guided",
      "scenario": "A business analyst has requested a new field on the `ABContact` entity to store a 'Preferred Contact Method' (e.g., Email, Phone, Mail). This should be a controlled list of values.",
      "question": "How would you begin to extend the Guidewire data model to accommodate this new requirement? Specifically, what type of field would you add, and what XML elements would you use to define it and its associated values?",
      "hints": [
        "Consider which field type is best suited for a controlled list of values.",
        "Think about how enumerated values are defined in Guidewire.",
        "Refer to the slides on 'Typelists and Typekey Fields' for guidance on XML elements."
      ],
      "expectedApproach": "The learner should identify that a typekey field linked to a new typelist is the appropriate solution. They would then describe creating a new typelist XML file (or extending an existing one) to define the 'Preferred Contact Method' values, and adding a `<typekey>` element to the `ABContact` entity's XML definition to reference this typelist."
    },
    {
      "type": "concept",
      "id": "concept-6",
      "heading": "Reviewing Data Model Changes and Best Practices",
      "narrative": "After making data model extensions, it's crucial to review your changes to ensure they align with business requirements and Guidewire best practices. This includes verifying that new fields are correctly defined, relationships are properly established, and the overall data model remains efficient and maintainable. Reflecting on the challenges encountered during the extension process, such as ensuring data consistency or optimizing performance, helps solidify your understanding and prepares you for real-world development scenarios.\n\nWhen designing and extending the data model, always strive for clarity and simplicity. Utilize supertype/subtype hierarchies to eliminate redundancy, leverage typelists for consistent enumerated values, and define clear relationships between entities using foreign keys. Be mindful of potential pitfalls, such as improperly defined foreign keys, inefficient use of array fields, or overly complex subtype hierarchies, as these can lead to performance issues or data integrity problems. By adhering to these guidelines, you can create a robust and adaptable data model that not only meets current requirements but is also well-positioned for future changes and enhancements.",
      "keyPoints": [
        "Review data model changes to ensure alignment with requirements and best practices.",
        "Use supertype/subtype hierarchies to eliminate redundancy.",
        "Leverage typelists for data consistency.",
        "Define clear relationships between entities using foreign keys.",
        "Be aware of common pitfalls like improper foreign key definitions or overly complex hierarchies."
      ],
      "figures": [
        {
          "slideNumber": 25,
          "caption": "A slide prompting a review of data model changes made during an exercise, encouraging reflection on alignment with user stories and encountered challenges."
        }
      ],
      "callouts": [
        {
          "type": "best_practice",
          "title": "Data Model Design Principles",
          "content": "Prioritize simplicity, consistency, and scalability. Avoid over-normalization or under-normalization. Use Guidewire's built-in features like typelists and supertype/subtype relationships to their full potential to create a maintainable and performant data model."
        }
      ]
    },
    {
      "type": "knowledge_check",
      "id": "kc-1",
      "question": "For each of the following, identify if itis stored as a database table, as a\n¢ table column, or not stored in the database at all:\n\nA) Anentity (such as ABContact)\n\nB) Aphysical data field (such as ABContact.CreateTime)\nC) A virtual data field (such as ABContact.FullName)\n\nD) A foreign key field (such as ABContact.AssignedUser)",
      "referenceAnswer": "For each of the following, identify if itis stored as a database table, as a\n¢ table column, or not stored in the database at all:\n\nThe correct responses are:\nA) Atable\nB) Acolumn\n\nC) Not stored in the database (Technically, the source values are probably stored in\nthe database. But the value of a virtual field itself is not stored as a separate\nvalue.)\n\ngS\n\nAcolumn (specifically a foreign key column to the relevant entity's table)",
      "questionKey": "slide-26"
    },
    {
      "type": "knowledge_check",
      "id": "kc-2",
      "question": "For each of the following, identify if itis stored as a database table, as a\n¢ table column, or not stored in the database at all:\n\nA) Anarray key field (such as ABContact.ContactNotes)\nB) Atypelist (such as VendorType)\nC) Atypekey field (such as ABContact.VendorType)",
      "referenceAnswer": "For each of the following, identify if itis stored as a database table, as a\n¢ table column, or not stored in the database at all:\n\nA) Anarray key field (such as ABContact.ContactNotes)\nB) Atypelist (such as VendorType)\nC) Atypekey field (such as ABContact.VendorType)\n\nThe correct answers are:\nA) Not stored in the database,\nB) Atable,\n\nC) Acolumn (specifically a foreign key column to the typelist's table)",
      "questionKey": "slide-28"
    },
    {
      "type": "knowledge_check",
      "id": "kc-3",
      "question": "Name two circumstances in which you would execute the gwb\n¢ genDataDictionary command.",
      "referenceAnswer": "other aspect of access and therefore need to regenerate the Security Dictionary.\n\nPossible answers:\n\nYou would execute genDataDictionary when you install the application and whenever\nyou extend the Data Model.\n\nYou could also execute the command when you modify system permissions or some\nother aspect of access and therefore need to regenerate the Security Dictionary.",
      "questionKey": "slide-30"
    },
    {
      "type": "summary",
      "id": "summary-1",
      "keyTakeaways": [
        "Guidewire's data model is metadata-driven, allowing extensions via XML configuration.",
        "Entities are core business objects, containing various field types: data, foreign key, array, and typekey.",
        "Typelists provide consistent, enumerated values referenced by typekey fields.",
        "Supertype/subtype entities enable inheritance, reducing redundancy and organizing data hierarchies.",
        "Storage mechanisms vary: entities and typelists in tables, physical/foreign key/typekey fields in columns, virtual/array fields computed at runtime.",
        "The Data Dictionary is a vital tool for understanding the data model, generated by `gwb genDataDictionary`."
      ],
      "realWorldConnection": "In real Guidewire projects, mastering data model extensions is fundamental. It allows developers to adapt the core application to unique client requirements, whether it's adding a new policy attribute or integrating with external systems, all while maintaining the integrity and performance of the platform.",
      "nextLessonPreview": "Our next lesson will delve deeper into extending the data model, exploring advanced techniques for creating custom entities and fields, and best practices for maintaining data integrity and performance. This will build on today's foundational knowledge, equipping you with the skills to tackle more complex development challenges."
    },
    {
      "type": "assignment",
      "id": "assign-1",
      "description": "Based on the concepts learned, you will now undertake a hands-on exercise to extend the Guidewire data model. You will be given a user story and tasked with implementing the necessary data model changes, including defining new entities or fields, and then reviewing your modifications. This exercise will reinforce your understanding of how data model extensions meet specific business requirements.",
      "objectives": [
        "Define new entities or fields based on a given user story.",
        "Apply knowledge of field types (data, foreign key, array, typekey) and entity relationships.",
        "Utilize the Data Dictionary to guide and validate data model changes.",
        "Reflect on the impact and alignment of data model modifications with business needs."
      ]
    }
  ],
  "videos": [
    {
      "index": 1,
      "filename": "IS_Fund_02_01.mp4",
      "path": "/academy/guidewire/videos/ch07/IS_Fund_02_01.mp4"
    }
  ]
}