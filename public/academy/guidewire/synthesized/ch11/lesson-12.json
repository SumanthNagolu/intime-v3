{
  "lessonId": "ch11-l12",
  "chapterId": 11,
  "chapterSlug": "ch11",
  "lessonNumber": 12,
  "title": "Triggering Messages",
  "subtitle": "Learn how Guidewire applications trigger messages and manage the integration with external systems.",
  "synthesizedAt": "2026-02-16T18:58:04.243441+00:00",
  "estimatedMinutes": 60,
  "blocks": [
    {
      "type": "hook",
      "id": "hook-1",
      "scenario": "Imagine a customer updates their bank account details in your system. This critical change needs to be immediately communicated to an external bank verification service. How does your Guidewire application ensure this message is reliably sent and processed?",
      "question": "What mechanisms are at play to trigger these essential communications and manage their journey to an external system?"
    },
    {
      "type": "objectives",
      "id": "obj-1",
      "objectives": [
        "Understand when message events are triggered in Guidewire applications.",
        "Identify the key entities involved in the Guidewire messaging framework.",
        "Explain the role of messaging destinations in connecting to external systems.",
        "Configure a new messaging destination to subscribe to specific events.",
        "Describe the transaction flow for message processing in Guidewire."
      ],
      "estimatedMinutes": 5
    },
    {
      "type": "activate",
      "id": "act-1",
      "priorKnowledge": "This lesson builds on your understanding of Guidewire's data model and basic integration concepts. Recall how different parts of a system might need to react to changes in data.",
      "warmupQuestion": "Think about a time you've seen two different software systems exchange information. What challenges might arise in ensuring that information is sent, received, and processed correctly?",
      "hint": "Consider aspects like timing, reliability, and data format."
    },
    {
      "type": "concept",
      "id": "concept-1",
      "heading": "Understanding Message Triggering and Transaction Flow",
      "narrative": "In Guidewire applications, messages are often triggered by specific events within the system, such as when a bank account is added or modified. This process is crucial for integrations, allowing Guidewire to communicate changes to external systems, like a bank account verification service. The message itself is generated by 'Event Fired' rules, which respond to these system events.\n\nThe journey of a message involves several Guidewire servers and a structured transaction process. The servers involved are important because they dictate where the 'payload' – the actual information to be sent – is generated. Most payload generation should occur in Event Fired rules on the UI role server, which manages the user's session. However, if some payload data is only known immediately before sending, it can be generated on the messaging role server.\n\nEvery message goes through a series of transactions to ensure reliability and proper error handling. This can involve anywhere from two to four distinct transactions:\n\n*   **Transaction 1:** This transaction is always present. It's responsible for creating the message and generating its initial payload.\n*   **Transaction 2 (Optional):** Prior to sending, an optional transaction might transform the message payload. This is typically used when certain information is only available right before the message is dispatched.\n*   **Transaction 3:** This transaction, also always present, handles the actual sending of the message to the external system. If the external system provides a synchronous acknowledgment (meaning an immediate response), that acknowledgment is processed within this same transaction.\n*   **Transaction 4 (Optional):** If the external system acknowledges the message asynchronously (meaning the response comes later), a separate transaction is dedicated to processing that acknowledgment. This transaction is not needed for synchronously acknowledged messages.\n\nUnderstanding this transaction structure is vital because it defines what work is rolled back if an error occurs at any point, ensuring data consistency.",
      "keyPoints": [
        "Messages are triggered by system events, often related to data changes.",
        "Payload generation primarily occurs on the UI role server via Event Fired rules.",
        "Message processing involves a series of 2-4 database transactions for reliability.",
        "Transaction boundaries determine error rollback behavior."
      ],
      "figures": [
        {
          "slideNumber": 3,
          "caption": "Illustrates a use case for bank account verification, showing how a message is triggered when an account is added or modified."
        },
        {
          "slideNumber": 4,
          "caption": "Depicts the Guidewire servers and the multi-transaction process involved in messaging, from event triggering to external system acknowledgment."
        },
        {
          "slideNumber": 5,
          "caption": "A visual break or transition slide."
        }
      ],
      "callouts": [
        {
          "type": "definition",
          "title": "Payload",
          "content": "The 'payload' in messaging refers to the actual data or information that is sent to an external system in response to an event."
        }
      ]
    },
    {
      "type": "concept",
      "id": "concept-2",
      "heading": "Event-Aware Entities and Triggering Custom Events",
      "narrative": "At the heart of Guidewire's messaging are **EventAware entities**. Most entities in Guidewire are persistent, meaning they store data in the database. An `EventAware` entity, however, is special because its XML definition includes an `<events/>` element, signifying that it delegates to the `EventAware` delegate. This delegation means the entity automatically supports messaging events.\n\nFor any entity that implements the `EventAware` delegate, Guidewire automatically creates a standard set of events: `entityNameAdded`, `entityNameChanged`, and `entityNameRemoved`. You can identify an `EventAware` entity by checking its definition in Guidewire Studio's Entity Editor or by reviewing the Data Dictionary. While you cannot modify the predefined events for a base entity, you *can* add additional custom events to it through extension.\n\nA messaging event typically fires when an instance of an `EventAware` entity is created, modified, or deleted. It's important to note that bulk data import tools, such as `ImportToolsAPI` or the `import_tools` command-line tool, do *not* trigger messaging events for `EventAware` entities. When loading business data that requires messaging, these tools should be avoided.\n\nBeyond the standard `Added`, `Changed`, and `Removed` events, you can also trigger **custom message events**. These provide significant flexibility, allowing you to initiate messaging in contexts where a standard entity change hasn't occurred. For example, a user clicking a button on the UI could trigger a custom event, or you might want to group messaging logic more granularly than just `EntityChanged`. Custom events are triggered manually using the `eventAwareEntityInstance.addEvent(\"CustomEventName\")` method and are only applicable to `EventAware` entities.",
      "keyPoints": [
        "EventAware entities automatically support messaging events via the EventAware delegate.",
        "Standard events include Added, Changed, and Removed for EventAware entities.",
        "Custom events provide flexibility to trigger messages outside of standard entity lifecycle changes.",
        "Custom events are triggered using the `addEvent` method on an EventAware entity instance.",
        "Data import tools do not trigger messaging events."
      ],
      "figures": [
        {
          "slideNumber": 6,
          "caption": "Explains the concept of an EventAware entity, its delegation, and the default messaging events it supports."
        },
        {
          "slideNumber": 7,
          "caption": "Illustrates how custom message events are triggered, showing an example of a 'BankAccountFlagged' event."
        }
      ],
      "callouts": [
        {
          "type": "definition",
          "title": "Delegate",
          "content": "In Guidewire, a delegate is an entity associated with an implemented interface that multiple parent entities can reuse, promoting code reuse and consistent behavior."
        },
        {
          "type": "warning",
          "title": "Data Import Tools",
          "content": "Be cautious when using data import tools like ImportToolsAPI or import_tools, as they do not trigger messaging events. For business data requiring integration, use alternative methods."
        }
      ]
    },
    {
      "type": "concept",
      "id": "concept-3",
      "heading": "The Core Messaging Entities: Context, Message, and History",
      "narrative": "When an event is triggered, the system relies on several key entities to manage the messaging process. The first is the **MessageContext** entity. This is an internal, non-persistent, virtual entity that is exclusively used within 'Event Fired' rules. You can access it through the `messageContext` variable. It holds crucial information such as the `DestID` (identifying the subscribing destination), `EventName` (the name of the triggering event), and the `Root` object (a reference to the triggering entity). Event Fired rules leverage this `messageContext` to decide whether to generate one or more messages.\n\nNext, we have the **Message** entity. Unlike `MessageContext`, `Message` is a persistent entity that stores all the details about the message to be sent to an external system. These messages are created within Event Fired rules and are stored in the `xx_message` database table (where `xx` represents the application code, e.g., `ab_message` for AddressBook). Key fields of the `Message` entity include `DestinationID`, `EventName`, `MessageRoot` (a pointer to the `EventAware` entity instance that triggered the event), `Payload` (the actual information to communicate), `SenderRefID` (a reference number set at send time), and `Status` (indicating if the message is pending, errored, etc.). It's a best practice to keep payloads as small and simple as possible to avoid performance issues.\n\nFinally, the **MessageHistory** entity records the outcome of message processing. This is also a persistent entity, storing information in the `xx_messagehistory` database table. It tracks details like `DestinationID`, `DuplicateCount` (number of duplicate acknowledgments), and `ErrorCategory`. Once a message is successfully sent and acknowledged, its details are moved or recorded in `MessageHistory`, providing an audit trail of all communications.",
      "keyPoints": [
        "MessageContext is a virtual entity used in Event Fired rules to gather event and destination information.",
        "The Message entity is persistent, storing all details and the payload of an outbound message.",
        "MessageHistory is a persistent entity that records the history and status of processed messages.",
        "Payloads should be kept small and simple for efficiency."
      ],
      "figures": [
        {
          "slideNumber": 8,
          "caption": "Details the MessageContext entity, an internal virtual entity used in event fired rules, highlighting its important fields."
        },
        {
          "slideNumber": 9,
          "caption": "Describes the Message entity, a persistent entity that holds the details and payload for messages sent to external systems."
        },
        {
          "slideNumber": 10,
          "caption": "Outlines the MessageHistory entity, which stores historical details about message processing."
        }
      ],
      "callouts": [
        {
          "type": "best_practice",
          "title": "Payload Size",
          "content": "Avoid creating unnecessarily large or complex payloads. Keep the information to be sent to an external system concise and relevant to improve performance and reduce processing overhead."
        }
      ]
    },
    {
      "type": "practice",
      "id": "practice-1",
      "level": "guided",
      "scenario": "A new claim is created in Guidewire, triggering a `ClaimAdded` event. An external fraud detection system needs to receive details about this new claim. Assume `Claim` is an EventAware entity.",
      "question": "Describe the sequence of entities involved from the `ClaimAdded` event being triggered to the message details being stored in the database, and identify the key information each entity would hold at its stage.",
      "hints": [
        "Start with the `EventAware` entity that triggers the event.",
        "What entity is created for each destination interested in the event?",
        "What persistent entity holds the actual message data?",
        "What happens after the message is successfully sent?"
      ],
      "expectedApproach": "Trace the flow from the `ClaimAdded` event, through the `MessageContext` creation for relevant destinations, the generation and storage of the `Message` entity, and finally the recording in `MessageHistory`."
    },
    {
      "type": "concept",
      "id": "concept-4",
      "heading": "Messaging Destinations: Connecting to External Systems",
      "narrative": "A **messaging destination** serves as an abstraction of an external system that Guidewire needs to communicate with. Each Guidewire message is designed to be sent to a *single* destination. If a scenario requires the same information to be sent to multiple external systems in response to a single event, your Event Fired rules should explicitly create multiple messages, one for each intended destination. Guidewire's messaging framework does not inherently support 'multicasting' (sending the same message simultaneously to multiple receivers).\n\nCrucially, every message sent by Guidewire expects a response from the external system. This response acts as an acknowledgment, confirming that the message was successfully processed. Responses can be synchronous, arriving immediately after the message is sent, or asynchronous, arriving sometime later. Asynchronous responses can also contain additional data, such as a verification code or a report, from the external system.\n\nThe mechanism for receiving these responses depends on whether the message is synchronous or asynchronous. For synchronous replies, the message transport plugin often handles the response. For asynchronous replies, a Guidewire Application published SOAP web service or a message reply plugin is typically used.\n\nMessaging destinations are configured to subscribe to specific message events. For example, consider a `BankAccount` entity (which is `EventAware`). If `BankAccount 2637` changes, and `Destination 13` listens for `BankAccountAdded` and `BankAccountChanged` events, while `Destination 14` only listens for `BankAccountChanged`, and `Destination 15` listens for `ActivityAdded` and `ActivityChanged` – then when `BankAccount 2637` changes, a `MessageContext` object will be created for both `Destination 13` and `Destination 14`. No `MessageContext` would be created for `Destination 15` because it does not subscribe to `BankAccountChanged` events. Each created `MessageContext` is then processed by the relevant Event Fired business rules.",
      "keyPoints": [
        "A messaging destination abstracts an external system.",
        "Each message is sent to a single destination; multiple messages are needed for multiple receivers.",
        "Every message expects a response (acknowledgment) from the external system.",
        "Response mechanisms vary based on synchronous vs. asynchronous communication.",
        "Destinations subscribe to specific events, triggering MessageContext creation for relevant rules."
      ],
      "figures": [
        {
          "slideNumber": 11,
          "caption": "A visual break or transition slide."
        },
        {
          "slideNumber": 12,
          "caption": "Illustrates the concept of a messaging destination as an abstraction of an external system, showing its role in processing outbound requests and inbound replies."
        },
        {
          "slideNumber": 13,
          "caption": "Demonstrates how messaging destinations subscribe to specific events, leading to the creation of MessageContext instances for relevant destinations."
        }
      ]
    },
    {
      "type": "concept",
      "id": "concept-5",
      "heading": "Configuring and Deploying Messaging Destinations",
      "narrative": "Messaging destinations are defined and configured within the `messaging-config.xml` file, located under `configuration.config.Messaging`. To create a new destination, you define several required fields:\n\n*   **ID:** A unique integer value from 0 to 63, inclusive. Values greater than 63 are reserved by Guidewire.\n*   **Name:** A unique name that will be displayed in the application's user interface, often a display key expression.\n*   **Transport Plugin:** This is a crucial component responsible for sending your message to the external system. The specific implementation of this plugin will vary based on the external system and the communication technology (e.g., JMS queue, web service, FTP). Every destination *must* provide a message transport plugin implementation, though multiple destinations can share the same implementation.\n*   **Events:** This is a list of event names (expressed as regex patterns) that the destination is interested in. For example, a destination might listen for `BankAccountAdded` and `BankAccountChanged` events. When an event occurs that matches a pattern in this list, the Event Fired rule set for that destination is triggered. If a single user action triggers multiple events that a destination listens for, the application runs the Event Fired rules for every combination of event name and destination.\n\nIt's a **best practice** to explicitly list all the events a destination listens to, rather than using broad regex patterns like `BankAccount` (which would match `BankAccountAdded`, `BankAccountChanged`, `BankAccountRemoved`). Incorrectly spelled regex patterns in the `Events` list will prevent the destination from working as expected.\n\nIn addition to these core parameters, destinations can have **Other Messaging Destination Parameters** such as optional Request and Reply plugins (for payload transformation and asynchronous acknowledgments, respectively) and various Connectivity and Error Parameters. These advanced settings are covered in more detail in dedicated lessons.\n\nAfter defining or modifying a destination in `messaging-config.xml`, you must **deploy code changes** by restarting the Guidewire server. This ensures that the application reads the new or updated configuration. You can restart the server from Guidewire Studio by stopping the running server and then starting it again, preferably in Debug mode for development and training.",
      "keyPoints": [
        "Destinations are defined in `messaging-config.xml`.",
        "Required fields include ID, Name, Transport Plugin, and Events.",
        "The Transport Plugin is essential for sending messages to external systems.",
        "Events are specified using regex patterns, defining what the destination subscribes to.",
        "Server restart is necessary to deploy new or modified destination configurations."
      ],
      "figures": [
        {
          "slideNumber": 14,
          "caption": "Shows how to define a message destination in the `messaging-config.xml` file, highlighting key configuration fields."
        },
        {
          "slideNumber": 15,
          "caption": "Lists other optional messaging destination parameters, including various plugins and connectivity settings."
        },
        {
          "slideNumber": 16,
          "caption": "Illustrates the process of deploying code changes by restarting the Guidewire server from Studio."
        }
      ],
      "callouts": [
        {
          "type": "best_practice",
          "title": "Explicit Event Listing",
          "content": "While regex patterns allow for broad matching, it's best practice to explicitly list all specific events a destination listens to (e.g., `BankAccountAdded`, `BankAccountChanged`) to avoid unintended subscriptions and improve clarity."
        },
        {
          "type": "warning",
          "title": "Regex Spelling",
          "content": "Be extremely careful with the spelling of regex patterns in the `Events` list. A simple typo, like `BankAccountChange` instead of `BankAccountChanged`, will prevent the destination from responding to the correct message event."
        }
      ]
    },
    {
      "type": "demo",
      "id": "demo-1",
      "videoIndex": 0,
      "context": "This demonstration will walk you through examining an event-aware entity and a messaging destination within Guidewire Studio. Pay close attention to how the entity's event awareness is configured and how a destination subscribes to specific events.",
      "transcriptSummary": "The demo showcases how to identify an EventAware entity in Guidewire Studio, review its default and custom events, and then navigate to the messaging-config.xml file to inspect the definition of a messaging destination, including its subscribed events and transport plugin."
    },
    {
      "type": "practice",
      "id": "practice-2",
      "level": "independent",
      "scenario": "Your team needs to integrate with a new external system that handles 'High-Value Policy' notifications. This system should receive a message whenever a `Policy` entity is either `Bound` (a custom event you've already defined) or `Changed` in a significant way. Assume `Policy` is an EventAware entity.",
      "question": "Outline the steps to configure a new messaging destination for this 'High-Value Policy' system. Include the key parameters you would define in `messaging-config.xml` and explain your choices for each.",
      "hints": [
        "Remember the required fields for a destination: ID, Name, Transport Plugin, and Events.",
        "How would you represent the 'Bound' and 'Changed' events in the `Events` list?",
        "What kind of `Transport Plugin` might be appropriate for sending data to an external system?"
      ],
      "expectedApproach": "Create a new destination entry in `messaging-config.xml`, assign a unique ID and name, specify a suitable `Transport Plugin` (e.g., a generic HTTP or JMS plugin), and correctly list the `PolicyBound` and `PolicyChanged` events using regex patterns in the `Events` attribute."
    },
    {
      "type": "knowledge_check",
      "id": "kc-1",
      "question": "When does a message event get triggered?",
      "referenceAnswer": "Typically, a message event gets triggered when an event-aware entity is created, changed, or removed.",
      "questionKey": "slide-19"
    },
    {
      "type": "knowledge_check",
      "id": "kc-2",
      "question": "N What is the primary purpose of the MessageContext entity?",
      "referenceAnswer": "The primary purpose of the MessageContext entity is to create messages using information from the message event and the triggering entity.",
      "questionKey": "slide-21"
    },
    {
      "type": "knowledge_check",
      "id": "kc-3",
      "question": "A Guidewire application has seven destinations and an event-aware\n7’ entity called Escalation.\ny 4 A) When an Escalation is created, what is the maximum number of\nMessageContexts that might get created?\nB) What is the minimum?",
      "referenceAnswer": "A) Seven, which would occur if all seven destinations listen to EscalationAdded.\nB) Zero, which would occur if none of the destinations listen to EscalationAdded.",
      "questionKey": "slide-23"
    },
    {
      "type": "knowledge_check",
      "id": "kc-4",
      "question": "An What plugin is required for every destination? What does this plugin do?",
      "referenceAnswer": "MessageTransport, which sends the message to the external system.",
      "questionKey": "slide-25"
    },
    {
      "type": "summary",
      "id": "summary-1",
      "keyTakeaways": [
        "Guidewire messages are triggered by events, primarily from EventAware entities (Added, Changed, Removed) or custom events.",
        "The messaging process involves a multi-transaction flow across different Guidewire servers for reliability.",
        "Key entities include MessageContext (virtual, for rules), Message (persistent, for outbound data), and MessageHistory (persistent, for audit trails).",
        "Messaging destinations abstract external systems and subscribe to specific events defined in `messaging-config.xml`.",
        "Every destination requires a Transport Plugin to send messages, and configuration changes necessitate a server restart."
      ],
      "realWorldConnection": "Understanding message triggering and destination configuration is fundamental for building robust integrations in Guidewire. Correctly configuring event-aware entities and destinations ensures that critical business data changes are reliably communicated to external systems, supporting processes like fraud detection, policy issuance, and financial reporting. Misconfigurations can lead to data synchronization issues and integration failures, impacting business operations.",
      "nextLessonPreview": "In the next lesson, we will delve deeper into the Message Transport Plugin, exploring how messages are actually sent to external systems and the various technologies and configurations involved."
    },
    {
      "type": "assignment",
      "id": "assign-1",
      "description": "Your task is to configure a new event-aware entity and a messaging destination in your Guidewire environment. You will:\n\n1.  Identify an existing non-EventAware entity (or create a simple new one) and modify its XML definition to make it EventAware.\n2.  Add a custom event to this entity (e.g., `MyEntityFlagged`).\n3.  Configure a new messaging destination in `messaging-config.xml`.\n4.  Ensure this new destination subscribes to your custom event and at least one standard event (e.g., `MyEntityAdded`).\n5.  Restart your Guidewire server to apply the changes.\n6.  (Optional) Write a simple Gosu rule or script to trigger your custom event and observe if a message context is created for your new destination.",
      "objectives": [
        "Practice modifying entity definitions to enable event awareness.",
        "Implement custom event triggering.",
        "Gain hands-on experience configuring messaging destinations in `messaging-config.xml`.",
        "Understand the deployment process for messaging configurations."
      ]
    }
  ],
  "videos": [
    {
      "index": 1,
      "filename": "In_12_01.mp4",
      "path": "/academy/guidewire/videos/ch11/In_12_01.mp4"
    }
  ]
}
