#!/usr/bin/env node
/**
 * Auto-Update Documentation Script
 *
 * This script scans the project structure and updates FILE-STRUCTURE.md
 * with current file descriptions and organization.
 *
 * Run: pnpm exec tsx .claude/orchestration/scripts/update-docs.ts
 */

import fs from 'fs/promises';
import path from 'path';
import { existsSync } from 'fs';

interface FileInfo {
  path: string;
  name: string;
  lines: number;
  description: string;
  type: 'core' | 'workflow' | 'test' | 'script' | 'config' | 'cli';
}

interface DirectoryInfo {
  name: string;
  description: string;
  files: FileInfo[];
}

/**
 * Extract description from file header comments
 */
async function extractDescription(filePath: string): Promise<string> {
  try {
    const content = await fs.readFile(filePath, 'utf-8');

    // Look for /** ... */ block comment at start
    const blockCommentMatch = content.match(/^\/\*\*\n([\s\S]*?)\*\//);
    if (blockCommentMatch) {
      const lines = blockCommentMatch[1]
        .split('\n')
        .map(line => line.replace(/^\s*\*\s?/, '').trim())
        .filter(line => line && !line.startsWith('@'));

      return lines[0] || 'No description';
    }

    // Look for // comment at start
    const lineCommentMatch = content.match(/^\/\/\s*(.+)$/m);
    if (lineCommentMatch) {
      return lineCommentMatch[1].trim();
    }

    return 'No description';
  } catch (error) {
    return 'Error reading file';
  }
}

/**
 * Count lines in a file
 */
async function countLines(filePath: string): Promise<number> {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    return content.split('\n').length;
  } catch (error) {
    return 0;
  }
}

/**
 * Determine file type based on path and name
 */
function getFileType(filePath: string): FileInfo['type'] {
  if (filePath.includes('/core/')) return 'core';
  if (filePath.includes('/workflows/')) return 'workflow';
  if (filePath.includes('/scripts/')) return 'script';
  if (filePath.includes('/cli/')) return 'cli';
  if (filePath.startsWith('test-')) return 'test';
  if (filePath.endsWith('.json') || filePath.endsWith('.md')) return 'config';
  return 'core';
}

/**
 * Scan a directory for TypeScript files
 */
async function scanDirectory(dirPath: string, baseDir: string): Promise<FileInfo[]> {
  const files: FileInfo[] = [];

  try {
    const entries = await fs.readdir(dirPath, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dirPath, entry.name);
      const relativePath = path.relative(baseDir, fullPath);

      if (entry.isDirectory()) {
        // Recursively scan subdirectories
        const subFiles = await scanDirectory(fullPath, baseDir);
        files.push(...subFiles);
      } else if (entry.isFile() && entry.name.endsWith('.ts')) {
        const description = await extractDescription(fullPath);
        const lines = await countLines(fullPath);

        files.push({
          path: relativePath,
          name: entry.name,
          lines,
          description,
          type: getFileType(relativePath),
        });
      }
    }
  } catch (error) {
    console.error(`Error scanning ${dirPath}:`, error);
  }

  return files;
}

/**
 * Generate markdown documentation
 */
function generateMarkdown(directories: DirectoryInfo[]): string {
  const timestamp = new Date().toISOString().split('T')[0];

  let md = `# File Structure Documentation

**Last Updated:** ${timestamp}
**Auto-generated by:** \`.claude/orchestration/scripts/update-docs.ts\`

> This document is automatically updated. To regenerate, run:
> \`pnpm exec tsx .claude/orchestration/scripts/update-docs.ts\`

---

## Project Structure Overview

\`\`\`
.claude/orchestration/
â”œâ”€â”€ core/           # Core system components
â”œâ”€â”€ workflows/      # Workflow implementations
â”œâ”€â”€ cli/            # Command-line interface
â”œâ”€â”€ scripts/        # Utility scripts
â””â”€â”€ tests/          # Test suites
\`\`\`

---

`;

  // Group files by type
  const filesByType: Record<string, FileInfo[]> = {
    core: [],
    workflow: [],
    cli: [],
    script: [],
    test: [],
    config: [],
  };

  directories.forEach(dir => {
    dir.files.forEach(file => {
      filesByType[file.type].push(file);
    });
  });

  // Sort by type
  const typeOrder: FileInfo['type'][] = ['core', 'workflow', 'cli', 'script', 'test', 'config'];

  typeOrder.forEach(type => {
    const files = filesByType[type];
    if (files.length === 0) return;

    const typeNames = {
      core: 'Core Components',
      workflow: 'Workflows',
      cli: 'CLI Interface',
      script: 'Utility Scripts',
      test: 'Test Suites',
      config: 'Configuration',
    };

    md += `## ${typeNames[type]}\n\n`;

    // Sort files by name
    files.sort((a, b) => a.name.localeCompare(b.name));

    files.forEach(file => {
      md += `### \`${file.name}\`\n\n`;
      md += `**Path:** \`${file.path}\`  \n`;
      md += `**Lines:** ${file.lines}  \n`;
      md += `**Purpose:** ${file.description}\n\n`;

      // Add additional details based on file name
      if (file.name === 'agent-runner.ts') {
        md += `**Key Features:**\n`;
        md += `- Executes individual agents with Claude API\n`;
        md += `- Manages tool calling loop for MCP integration\n`;
        md += `- Handles prompt caching for cost optimization\n`;
        md += `- Tracks token usage and costs\n\n`;
      } else if (file.name === 'tool-manager.ts') {
        md += `**Key Features:**\n`;
        md += `- Manages 14 MCP filesystem tools\n`;
        md += `- Provides 4 custom validation tools\n`;
        md += `- Agent-specific tool selection\n`;
        md += `- Lifecycle management (init/shutdown)\n\n`;
      } else if (file.name === 'workflow-engine.ts') {
        md += `**Key Features:**\n`;
        md += `- Orchestrates multi-agent workflows\n`;
        md += `- Sequential and parallel execution\n`;
        md += `- State management and persistence\n`;
        md += `- Cost tracking across workflow\n\n`;
      }
    });

    md += `---\n\n`;
  });

  // Add statistics
  const totalFiles = Object.values(filesByType).reduce((sum, files) => sum + files.length, 0);
  const totalLines = Object.values(filesByType)
    .flat()
    .reduce((sum, file) => sum + file.lines, 0);

  md += `## Statistics\n\n`;
  md += `- **Total Files:** ${totalFiles}\n`;
  md += `- **Total Lines of Code:** ${totalLines.toLocaleString()}\n`;
  md += `- **Core Components:** ${filesByType.core.length}\n`;
  md += `- **Workflows:** ${filesByType.workflow.length}\n`;
  md += `- **Test Suites:** ${filesByType.test.length}\n`;
  md += `- **Scripts:** ${filesByType.script.length}\n\n`;

  md += `---\n\n`;
  md += `## Maintenance\n\n`;
  md += `### Updating This Documentation\n\n`;
  md += `Run the update script:\n`;
  md += `\`\`\`bash\n`;
  md += `pnpm exec tsx .claude/orchestration/scripts/update-docs.ts\n`;
  md += `\`\`\`\n\n`;
  md += `### Archiving Old Files\n\n`;
  md += `See \`.archive/README.md\` for archival policy and procedures.\n\n`;
  md += `Files are archived after 30 days of inactivity and can be restored if needed.\n\n`;
  md += `---\n\n`;
  md += `*Auto-generated on ${timestamp}*\n`;

  return md;
}

/**
 * Main execution
 */
async function main() {
  console.log('ðŸ“š Updating file structure documentation...\n');

  const baseDir = path.join(process.cwd(), '.claude/orchestration');

  // Scan directories
  console.log('ðŸ” Scanning directories...');
  const allFiles = await scanDirectory(baseDir, baseDir);

  console.log(`   Found ${allFiles.length} files\n`);

  // Group by directory
  const directories: DirectoryInfo[] = [
    {
      name: 'orchestration',
      description: 'Main orchestration system',
      files: allFiles,
    },
  ];

  // Generate markdown
  console.log('ðŸ“ Generating documentation...');
  const markdown = generateMarkdown(directories);

  // Write to file
  const outputPath = path.join(process.cwd(), '.claude/orchestration/FILE-STRUCTURE.md');
  await fs.writeFile(outputPath, markdown, 'utf-8');

  console.log(`âœ… Documentation updated: ${outputPath}\n`);

  // Print summary
  console.log('ðŸ“Š Summary:');
  console.log(`   Total files documented: ${allFiles.length}`);
  console.log(`   Total lines of code: ${allFiles.reduce((sum, f) => sum + f.lines, 0).toLocaleString()}`);
  console.log();
}

main().catch(error => {
  console.error('Error updating documentation:', error);
  process.exit(1);
});
